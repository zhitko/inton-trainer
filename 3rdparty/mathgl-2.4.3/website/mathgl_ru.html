<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Это документация для MathGL (версии 2.4.3) - библиотеки классов и функций для построения научной графики. Пожалуйста сообщайте о любых ошибках в этом руководстве на mathgl.abalakin@gmail.org.

Copyright (C) 2008-2012 Alexey A. Balakin.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled "GNU
Free Documentation License."
 -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head><link rel="stylesheet" href="styles.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>MathGL 2.4.3</title>

<meta name="description" content="MathGL 2.4.3">
<meta name="keywords" content="MathGL 2.4.3">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<link href="#Top" rel="start" title="Top">
<link href="#Index" rel="index" title="Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="ru"><div class="topnav" id="myTopnav"></div><div class="main">
<h1 class="settitle" align="center">MathGL 2.4.3</h1>




<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Obzor-MathGL" href="#Overview">1 Обзор MathGL</a>
  <ul class="no-bullet">
    <li><a name="toc-Chto-takoe-MathGL_003f" href="#What-is-MathGL_003f">1.1 Что такое MathGL?</a></li>
    <li><a name="toc-Vozmozhnosti-MathGL" href="#MathGL-features">1.2 Возможности MathGL</a></li>
    <li><a name="toc-Ustanovka-MathGL" href="#Installation">1.3 Установка MathGL</a></li>
    <li><a name="toc-Quick-guide-1" href="#Quick-guide">1.4 Quick guide</a></li>
    <li><a name="toc-Changes-from-v_002e1_002e_002a" href="#Changes-from-v_002e1">1.5 Changes from v.1.*</a></li>
    <li><a name="toc-Utilities-for-parsing-MGL" href="#Utilities">1.6 Utilities for parsing MGL</a></li>
    <li><a name="toc-Blagodarnosti" href="#Thanks">1.7 Благодарности</a></li>
  </ul></li>
  <li><a name="toc-Primery-MathGL" href="#Examples">2 Примеры MathGL</a>
  <ul class="no-bullet">
    <li><a name="toc-Osnovy-ispolxzovaniya" href="#Basic-usage">2.1 Основы использования</a>
    <ul class="no-bullet">
      <li><a name="toc-Ispolxzovanie-okon-MathGL" href="#Using-MathGL-window">2.1.1 Использование окон MathGL</a></li>
      <li><a name="toc-Drawing-to-file-1" href="#Drawing-to-file">2.1.2 Drawing to file</a></li>
      <li><a name="toc-Animation-1" href="#Animation">2.1.3 Animation</a></li>
      <li><a name="toc-Drawing-in-memory-1" href="#Drawing-in-memory">2.1.4 Drawing in memory</a></li>
      <li><a name="toc-Draw-and-calculate-1" href="#Draw-and-calculate">2.1.5 Draw and calculate</a></li>
      <li><a name="toc-Using-QMathGL-1" href="#Using-QMathGL">2.1.6 Using QMathGL</a></li>
      <li><a name="toc-OpenGL-output-1" href="#OpenGL-output">2.1.7 OpenGL output</a></li>
      <li><a name="toc-MathGL-and-PyQt-1" href="#MathGL-and-PyQt">2.1.8 MathGL and PyQt</a></li>
      <li><a name="toc-MathGL-and-MPI-1" href="#MathGL-and-MPI">2.1.9 MathGL and MPI</a></li>
    </ul></li>
    <li><a name="toc-Advanced-usage-1" href="#Advanced-usage">2.2 Advanced usage</a>
    <ul class="no-bullet">
      <li><a name="toc-Subplots-1" href="#Subplots">2.2.1 Subplots</a></li>
      <li><a name="toc-Axis-and-ticks-1" href="#Axis-and-ticks">2.2.2 Axis and ticks</a></li>
      <li><a name="toc-Curvilinear-coordinates-1" href="#Curvilinear-coordinates">2.2.3 Curvilinear coordinates</a></li>
      <li><a name="toc-Colorbars-1" href="#Colorbars">2.2.4 Colorbars</a></li>
      <li><a name="toc-Bounding-box-1" href="#Bounding-box">2.2.5 Bounding box</a></li>
      <li><a name="toc-Ternary-axis-1" href="#Ternary-axis">2.2.6 Ternary axis</a></li>
      <li><a name="toc-Text-features-1" href="#Text-features">2.2.7 Text features</a></li>
      <li><a name="toc-Legend-sample-1" href="#Legend-sample">2.2.8 Legend sample</a></li>
      <li><a name="toc-Cutting-sample-1" href="#Cutting-sample">2.2.9 Cutting sample</a></li>
    </ul></li>
    <li><a name="toc-Data-handling-1" href="#Data-handling">2.3 Data handling</a>
    <ul class="no-bullet">
      <li><a name="toc-Array-creation-1" href="#Array-creation">2.3.1 Array creation</a></li>
      <li><a name="toc-Linking-array-1" href="#Linking-array">2.3.2 Linking array</a></li>
      <li><a name="toc-Change-data-1" href="#Change-data">2.3.3 Change data</a></li>
    </ul></li>
    <li><a name="toc-Data-plotting-1" href="#Data-plotting">2.4 Data plotting</a></li>
    <li><a name="toc-Hints-1" href="#Hints">2.5 Hints</a>
    <ul class="no-bullet">
      <li><a name="toc-_0060_0060Compound_0027_0027-graphics-1" href="#g_t_0060_0060Compound_0027_0027-graphics">2.5.1 &ldquo;Compound&rdquo; graphics</a></li>
      <li><a name="toc-Transparency-and-lighting-1" href="#Transparency-and-lighting">2.5.2 Transparency and lighting</a></li>
      <li><a name="toc-Types-of-transparency-1" href="#Types-of-transparency">2.5.3 Types of transparency</a></li>
      <li><a name="toc-Axis-projection-1" href="#Axis-projection">2.5.4 Axis projection</a></li>
      <li><a name="toc-Adding-fog-1" href="#Adding-fog">2.5.5 Adding fog</a></li>
      <li><a name="toc-Lighting-sample-1" href="#Lighting-sample">2.5.6 Lighting sample</a></li>
      <li><a name="toc-Using-primitives-1" href="#Using-primitives">2.5.7 Using primitives</a></li>
      <li><a name="toc-STFA-sample-1" href="#STFA-sample">2.5.8 STFA sample</a></li>
      <li><a name="toc-Mapping-visualization-1" href="#Mapping-visualization">2.5.9 Mapping visualization</a></li>
      <li><a name="toc-Data-interpolation-1" href="#Data-interpolation">2.5.10 Data interpolation</a></li>
      <li><a name="toc-Making-regular-data-1" href="#Making-regular-data">2.5.11 Making regular data</a></li>
      <li><a name="toc-Making-histogram-1" href="#Making-histogram">2.5.12 Making histogram</a></li>
      <li><a name="toc-Nonlinear-fitting-hints-1" href="#Nonlinear-fitting-hints">2.5.13 Nonlinear fitting hints</a></li>
      <li><a name="toc-PDE-solving-hints-1" href="#PDE-solving-hints">2.5.14 PDE solving hints</a></li>
      <li><a name="toc-Drawing-phase-plain-1" href="#Drawing-phase-plain">2.5.15 Drawing phase plain</a></li>
      <li><a name="toc-Pulse-properties-1" href="#Pulse-properties">2.5.16 Pulse properties</a></li>
      <li><a name="toc-Using-MGL-parser-1" href="#Using-MGL-parser">2.5.17 Using MGL parser</a></li>
      <li><a name="toc-Using-options-1" href="#Using-options">2.5.18 Using options</a></li>
      <li><a name="toc-_0060_0060Templates_0027_0027-1" href="#g_t_0060_0060Templates_0027_0027">2.5.19 &ldquo;Templates&rdquo;</a></li>
      <li><a name="toc-Stereo-image-1" href="#Stereo-image">2.5.20 Stereo image</a></li>
      <li><a name="toc-Reduce-memory-usage-1" href="#Reduce-memory-usage">2.5.21 Reduce memory usage</a></li>
      <li><a name="toc-Scanning-file" href="#Saving-and-scanning-file">2.5.22 Scanning file</a></li>
      <li><a name="toc-Mixing-bitmap-and-vector-output-1" href="#Mixing-bitmap-and-vector-output">2.5.23 Mixing bitmap and vector output</a></li>
    </ul></li>
    <li><a name="toc-FAQ-1" href="#FAQ">2.6 FAQ</a></li>
  </ul></li>
  <li><a name="toc-Osnovnye-principy" href="#General-concepts">3 Основные принципы</a>
  <ul class="no-bullet">
    <li><a name="toc-Osi-koordinat" href="#Coordinate-axes">3.1 Оси координат</a></li>
    <li><a name="toc-Cveta" href="#Color-styles">3.2 Цвета</a></li>
    <li><a name="toc-Stilx-linii" href="#Line-styles">3.3 Стиль линий</a></li>
    <li><a name="toc-Cvetovaya-skhema" href="#Color-scheme">3.4 Цветовая схема</a></li>
    <li><a name="toc-Stilx-teksta" href="#Font-styles">3.5 Стиль текста</a></li>
    <li><a name="toc-Tekstovye-formuly" href="#Textual-formulas">3.6 Текстовые формулы</a></li>
    <li><a name="toc-Opcii-komand" href="#Command-options">3.7 Опции команд</a></li>
    <li><a name="toc-Interfeisy" href="#Interfaces">3.8 Интерфейсы</a>
    <ul class="no-bullet">
      <li><a name="toc-C_002fFortran-interfeis" href="#C-interface">3.8.1 C/Fortran интерфейс</a></li>
      <li><a name="toc-C_002b_002b_002fPython-interfeis" href="#C_002b_002b-interface">3.8.2 C++/Python интерфейс</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-YAdro-MathGL" href="#MathGL-core">4 Ядро MathGL</a>
  <ul class="no-bullet">
    <li><a name="toc-Sozdanie-i-udalenie-graficheskogo-obwekta" href="#Constructor">4.1 Создание и удаление графического объекта</a></li>
    <li><a name="toc-Nastroika-grafika" href="#Graphics-setup">4.2 Настройка графика</a>
    <ul class="no-bullet">
      <li><a name="toc-Prozrachnostx" href="#Transparency">4.2.1 Прозрачность</a></li>
      <li><a name="toc-Osveshchenie" href="#Lighting">4.2.2 Освещение</a></li>
      <li><a name="toc-Tuman" href="#Fog">4.2.3 Туман</a></li>
      <li><a name="toc-Bazovye-razmery" href="#Default-sizes">4.2.4 Базовые размеры</a></li>
      <li><a name="toc-Obrezanie" href="#Cutting">4.2.5 Обрезание</a></li>
      <li><a name="toc-Shrifty" href="#Font-settings">4.2.6 Шрифты</a></li>
      <li><a name="toc-Palitra-i-cveta" href="#Palette-and-colors">4.2.7 Палитра и цвета</a></li>
      <li><a name="toc-Maski" href="#Masks">4.2.8 Маски</a></li>
      <li><a name="toc-Obrabotka-oshibok" href="#Error-handling">4.2.9 Обработка ошибок</a></li>
      <li><a name="toc-Ostanovka-risovaniya" href="#Stop-drawing">4.2.10 Остановка рисования</a></li>
    </ul></li>
    <li><a name="toc-Nastroiki-osei-koordinat" href="#Axis-settings">4.3 Настройки осей координат</a>
    <ul class="no-bullet">
      <li><a name="toc-Masshtab-osei-koordinat" href="#Ranges-_0028bounding-box_0029">4.3.1 Масштаб осей координат</a></li>
      <li><a name="toc-Krivolineinye-koordinaty" href="#Curved-coordinates">4.3.2 Криволинейные координаты</a></li>
      <li><a name="toc-Metki-osei" href="#Ticks">4.3.3 Метки осей</a></li>
    </ul></li>
    <li><a name="toc-Matrica-preobrazovaniya" href="#Subplots-and-rotation">4.4 Матрица преобразования</a></li>
    <li><a name="toc-Eksport-risunka" href="#Export-picture">4.5 Экспорт рисунка</a>
    <ul class="no-bullet">
      <li><a name="toc-Eksport-v-fail" href="#Export-to-file">4.5.1 Экспорт в файл</a></li>
      <li><a name="toc-Kadry_002fAnimaciya" href="#Frames_002fAnimation">4.5.2 Кадры/Анимация</a></li>
      <li><a name="toc-Risovanie-v-pamyati" href="#Bitmap-in-memory">4.5.3 Рисование в памяти</a></li>
      <li><a name="toc-Rasparallelivanie" href="#Parallelization">4.5.4 Распараллеливание</a></li>
    </ul></li>
    <li><a name="toc-Fonovoe-izobrazhenie" href="#Background">4.6 Фоновое изображение</a></li>
    <li><a name="toc-Risovanie-primitivov" href="#Primitives">4.7 Рисование примитивов</a></li>
    <li><a name="toc-Vyvod-teksta" href="#Text-printing">4.8 Вывод текста</a></li>
    <li><a name="toc-Osi-i-Colorbar" href="#Axis-and-Colorbar">4.9 Оси и Colorbar</a></li>
    <li><a name="toc-Legenda" href="#Legend">4.10 Легенда</a></li>
    <li><a name="toc-1D-grafiki" href="#g_t1D-plotting">4.11 1D графики</a></li>
    <li><a name="toc-2D-grafiki" href="#g_t2D-plotting">4.12 2D графики</a></li>
    <li><a name="toc-3D-grafiki" href="#g_t3D-plotting">4.13 3D графики</a></li>
    <li><a name="toc-Parnye-grafiki" href="#Dual-plotting">4.14 Парные графики</a></li>
    <li><a name="toc-Vektornye-polya" href="#Vector-fields">4.15 Векторные поля</a></li>
    <li><a name="toc-Prochie-grafiki" href="#Other-plotting">4.16 Прочие графики</a></li>
    <li><a name="toc-Nonlinear-fitting-1" href="#Nonlinear-fitting">4.17 Nonlinear fitting</a></li>
    <li><a name="toc-Raspredelenie-dannykh" href="#Data-manipulation">4.18 Распределение данных</a></li>
  </ul></li>
  <li><a name="toc-_0060_0060Okonnye_0027_0027-klassy" href="#Widget-classes">5 &ldquo;Оконные&rdquo; классы</a>
  <ul class="no-bullet">
    <li><a name="toc-Klass-mglWnd" href="#mglWnd-class">5.1 Класс mglWnd</a></li>
    <li><a name="toc-mglDraw-class-1" href="#mglDraw-class">5.2 mglDraw class</a></li>
    <li><a name="toc-Klass-Fl_005fMathGL" href="#Fl_005fMathGL-class">5.3 Класс Fl_MathGL</a></li>
    <li><a name="toc-Klass-QMathGL" href="#QMathGL-class">5.4 Класс QMathGL</a></li>
    <li><a name="toc-Klass-wxMathGL" href="#wxMathGL-class">5.5 Класс wxMathGL</a></li>
  </ul></li>
  <li><a name="toc-Obrabotka-dannykh" href="#Data-processing">6 Обработка данных</a>
  <ul class="no-bullet">
    <li><a name="toc-Peremennye" href="#Public-variables">6.1 Переменные</a></li>
    <li><a name="toc-Sozdanie-i-udalenie-dannykh" href="#Data-constructor">6.2 Создание и удаление данных</a></li>
    <li><a name="toc-Izmenenie-razmerov-dannykh" href="#Data-resizing">6.3 Изменение размеров данных</a></li>
    <li><a name="toc-Zapolnenie-dannykh" href="#Data-filling">6.4 Заполнение данных</a></li>
    <li><a name="toc-Chtenie_002fsokhranenie-dannykh" href="#File-I_002fO">6.5 Чтение/сохранение данных</a></li>
    <li><a name="toc-Make-another-data-1" href="#Make-another-data">6.6 Make another data</a></li>
    <li><a name="toc-Izmenenie-dannykh" href="#Data-changing">6.7 Изменение данных</a></li>
    <li><a name="toc-Interpolyaciya" href="#Interpolation">6.8 Интерполяция</a></li>
    <li><a name="toc-Informacionnye-funkcii" href="#Data-information">6.9 Информационные функции</a></li>
    <li><a name="toc-Operatory" href="#Operators">6.10 Операторы</a></li>
    <li><a name="toc-Globalxnye-funkcii" href="#Global-functions">6.11 Глобальные функции</a></li>
    <li><a name="toc-Vychislenie-vyrazhenii" href="#Evaluate-expression">6.12 Вычисление выражений</a></li>
    <li><a name="toc-Special-data-classes-1" href="#Special-data-classes">6.13 Special data classes</a></li>
  </ul></li>
  <li><a name="toc-Skripty-MGL" href="#MGL-scripts">7 Скрипты MGL</a>
  <ul class="no-bullet">
    <li><a name="toc-Osnovy-MGL" href="#MGL-definition">7.1 Основы MGL</a></li>
    <li><a name="toc-Upravlenie-khodom-vypolneniya" href="#Program-flow-commands">7.2 Управление ходом выполнения</a></li>
    <li><a name="toc-Specialxnye-kommentarii" href="#Special-comments">7.3 Специальные комментарии</a></li>
    <li><a name="toc-LaTeX-package-1" href="#LaTeX-package">7.4 LaTeX package</a></li>
    <li><a name="toc-mglParse-class-1" href="#mglParse-class">7.5 mglParse class</a></li>
  </ul></li>
  <li><a name="toc-UDAV-1" href="#UDAV">8 UDAV</a>
  <ul class="no-bullet">
    <li><a name="toc-UDAV-overview-1" href="#UDAV-overview">8.1 UDAV overview</a></li>
    <li><a name="toc-UDAV-dialogs-1" href="#UDAV-dialogs">8.2 UDAV dialogs</a></li>
    <li><a name="toc-UDAV-hints-1" href="#UDAV-hints">8.3 UDAV hints</a></li>
  </ul></li>
  <li><a name="toc-Other-classes-1" href="#Other-classes">9 Other classes</a>
  <ul class="no-bullet">
    <li><a name="toc-Define-new-kind-of-plot-_0028mglBase-class_0029" href="#mglBase-class">9.1 Define new kind of plot (mglBase class)</a></li>
    <li><a name="toc-User-defined-types-_0028mglDataA-class_0029" href="#mglDataA-class">9.2 User defined types (mglDataA class)</a></li>
    <li><a name="toc-mglColor-class-1" href="#mglColor-class">9.3 mglColor class</a></li>
    <li><a name="toc-mglPoint-class-1" href="#mglPoint-class">9.4 mglPoint class</a></li>
  </ul></li>
  <li><a name="toc-All-samples-1" href="#All-samples">10 All samples</a>
  <ul class="no-bullet">
    <li><a name="toc-Functions-for-initialization" href="#initialization-sample">10.1 Functions for initialization</a></li>
    <li><a name="toc-Sample-3wave" href="#g_t3wave-sample">10.2 Sample &lsquo;<samp>3wave</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-alpha" href="#alpha-sample">10.3 Sample &lsquo;<samp>alpha</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-apde" href="#apde-sample">10.4 Sample &lsquo;<samp>apde</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-area" href="#area-sample">10.5 Sample &lsquo;<samp>area</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-aspect" href="#aspect-sample">10.6 Sample &lsquo;<samp>aspect</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-axial" href="#axial-sample">10.7 Sample &lsquo;<samp>axial</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-axis" href="#axis-sample">10.8 Sample &lsquo;<samp>axis</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-barh" href="#barh-sample">10.9 Sample &lsquo;<samp>barh</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-bars" href="#bars-sample">10.10 Sample &lsquo;<samp>bars</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-belt" href="#belt-sample">10.11 Sample &lsquo;<samp>belt</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-bifurcation" href="#bifurcation-sample">10.12 Sample &lsquo;<samp>bifurcation</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-box" href="#box-sample">10.13 Sample &lsquo;<samp>box</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-boxplot" href="#boxplot-sample">10.14 Sample &lsquo;<samp>boxplot</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-boxs" href="#boxs-sample">10.15 Sample &lsquo;<samp>boxs</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-candle" href="#candle-sample">10.16 Sample &lsquo;<samp>candle</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-chart" href="#chart-sample">10.17 Sample &lsquo;<samp>chart</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cloud" href="#cloud-sample">10.18 Sample &lsquo;<samp>cloud</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-colorbar" href="#colorbar-sample">10.19 Sample &lsquo;<samp>colorbar</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-combined" href="#combined-sample">10.20 Sample &lsquo;<samp>combined</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cones" href="#cones-sample">10.21 Sample &lsquo;<samp>cones</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cont" href="#cont-sample">10.22 Sample &lsquo;<samp>cont</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cont3" href="#cont3-sample">10.23 Sample &lsquo;<samp>cont3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cont_005fxyz" href="#cont_005fxyz-sample">10.24 Sample &lsquo;<samp>cont_xyz</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-contd" href="#contd-sample">10.25 Sample &lsquo;<samp>contd</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-contf" href="#contf-sample">10.26 Sample &lsquo;<samp>contf</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-contf3" href="#contf3-sample">10.27 Sample &lsquo;<samp>contf3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-contf_005fxyz" href="#contf_005fxyz-sample">10.28 Sample &lsquo;<samp>contf_xyz</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-contv" href="#contv-sample">10.29 Sample &lsquo;<samp>contv</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-correl" href="#correl-sample">10.30 Sample &lsquo;<samp>correl</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-curvcoor" href="#curvcoor-sample">10.31 Sample &lsquo;<samp>curvcoor</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-cut" href="#cut-sample">10.32 Sample &lsquo;<samp>cut</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dat_005fdiff" href="#dat_005fdiff-sample">10.33 Sample &lsquo;<samp>dat_diff</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dat_005fextra" href="#dat_005fextra-sample">10.34 Sample &lsquo;<samp>dat_extra</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-data1" href="#data1-sample">10.35 Sample &lsquo;<samp>data1</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-data2" href="#data2-sample">10.36 Sample &lsquo;<samp>data2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dens" href="#dens-sample">10.37 Sample &lsquo;<samp>dens</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dens3" href="#dens3-sample">10.38 Sample &lsquo;<samp>dens3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dens_005fxyz" href="#dens_005fxyz-sample">10.39 Sample &lsquo;<samp>dens_xyz</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-detect" href="#detect-sample">10.40 Sample &lsquo;<samp>detect</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dew" href="#dew-sample">10.41 Sample &lsquo;<samp>dew</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-diffract" href="#diffract-sample">10.42 Sample &lsquo;<samp>diffract</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dilate" href="#dilate-sample">10.43 Sample &lsquo;<samp>dilate</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-dots" href="#dots-sample">10.44 Sample &lsquo;<samp>dots</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-earth" href="#earth-sample">10.45 Sample &lsquo;<samp>earth</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-error" href="#error-sample">10.46 Sample &lsquo;<samp>error</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-error2" href="#error2-sample">10.47 Sample &lsquo;<samp>error2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-export" href="#export-sample">10.48 Sample &lsquo;<samp>export</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-fall" href="#fall-sample">10.49 Sample &lsquo;<samp>fall</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-fexport" href="#fexport-sample">10.50 Sample &lsquo;<samp>fexport</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-fit" href="#fit-sample">10.51 Sample &lsquo;<samp>fit</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-flame2d" href="#flame2d-sample">10.52 Sample &lsquo;<samp>flame2d</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-flow" href="#flow-sample">10.53 Sample &lsquo;<samp>flow</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-flow3" href="#flow3-sample">10.54 Sample &lsquo;<samp>flow3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-fog" href="#fog-sample">10.55 Sample &lsquo;<samp>fog</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-fonts" href="#fonts-sample">10.56 Sample &lsquo;<samp>fonts</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-grad" href="#grad-sample">10.57 Sample &lsquo;<samp>grad</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-hist" href="#hist-sample">10.58 Sample &lsquo;<samp>hist</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ifs2d" href="#ifs2d-sample">10.59 Sample &lsquo;<samp>ifs2d</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ifs3d" href="#ifs3d-sample">10.60 Sample &lsquo;<samp>ifs3d</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-indirect" href="#indirect-sample">10.61 Sample &lsquo;<samp>indirect</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-inplot" href="#inplot-sample">10.62 Sample &lsquo;<samp>inplot</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-iris" href="#iris-sample">10.63 Sample &lsquo;<samp>iris</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-label" href="#label-sample">10.64 Sample &lsquo;<samp>label</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-lamerey" href="#lamerey-sample">10.65 Sample &lsquo;<samp>lamerey</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-legend" href="#legend-sample">10.66 Sample &lsquo;<samp>legend</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-light" href="#light-sample">10.67 Sample &lsquo;<samp>light</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-loglog" href="#loglog-sample">10.68 Sample &lsquo;<samp>loglog</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-map" href="#map-sample">10.69 Sample &lsquo;<samp>map</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-mark" href="#mark-sample">10.70 Sample &lsquo;<samp>mark</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-mask" href="#mask-sample">10.71 Sample &lsquo;<samp>mask</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-mesh" href="#mesh-sample">10.72 Sample &lsquo;<samp>mesh</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-mirror" href="#mirror-sample">10.73 Sample &lsquo;<samp>mirror</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-molecule" href="#molecule-sample">10.74 Sample &lsquo;<samp>molecule</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ode" href="#ode-sample">10.75 Sample &lsquo;<samp>ode</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ohlc" href="#ohlc-sample">10.76 Sample &lsquo;<samp>ohlc</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-param1" href="#param1-sample">10.77 Sample &lsquo;<samp>param1</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-param2" href="#param2-sample">10.78 Sample &lsquo;<samp>param2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-param3" href="#param3-sample">10.79 Sample &lsquo;<samp>param3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-paramv" href="#paramv-sample">10.80 Sample &lsquo;<samp>paramv</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-parser" href="#parser-sample">10.81 Sample &lsquo;<samp>parser</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-pde" href="#pde-sample">10.82 Sample &lsquo;<samp>pde</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-pendelta" href="#pendelta-sample">10.83 Sample &lsquo;<samp>pendelta</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-pipe" href="#pipe-sample">10.84 Sample &lsquo;<samp>pipe</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-plot" href="#plot-sample">10.85 Sample &lsquo;<samp>plot</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-pmap" href="#pmap-sample">10.86 Sample &lsquo;<samp>pmap</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-primitives" href="#primitives-sample">10.87 Sample &lsquo;<samp>primitives</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-projection" href="#projection-sample">10.88 Sample &lsquo;<samp>projection</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-projection5" href="#projection5-sample">10.89 Sample &lsquo;<samp>projection5</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-pulse" href="#pulse-sample">10.90 Sample &lsquo;<samp>pulse</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-qo2d" href="#qo2d-sample">10.91 Sample &lsquo;<samp>qo2d</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality0" href="#quality0-sample">10.92 Sample &lsquo;<samp>quality0</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality1" href="#quality1-sample">10.93 Sample &lsquo;<samp>quality1</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality2" href="#quality2-sample">10.94 Sample &lsquo;<samp>quality2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality4" href="#quality4-sample">10.95 Sample &lsquo;<samp>quality4</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality5" href="#quality5-sample">10.96 Sample &lsquo;<samp>quality5</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality6" href="#quality6-sample">10.97 Sample &lsquo;<samp>quality6</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-quality8" href="#quality8-sample">10.98 Sample &lsquo;<samp>quality8</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-radar" href="#radar-sample">10.99 Sample &lsquo;<samp>radar</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-refill" href="#refill-sample">10.100 Sample &lsquo;<samp>refill</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-region" href="#region-sample">10.101 Sample &lsquo;<samp>region</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-scanfile" href="#scanfile-sample">10.102 Sample &lsquo;<samp>scanfile</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-schemes" href="#schemes-sample">10.103 Sample &lsquo;<samp>schemes</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-section" href="#section-sample">10.104 Sample &lsquo;<samp>section</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-several_005flight" href="#several_005flight-sample">10.105 Sample &lsquo;<samp>several_light</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-solve" href="#solve-sample">10.106 Sample &lsquo;<samp>solve</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-stem" href="#stem-sample">10.107 Sample &lsquo;<samp>stem</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-step" href="#step-sample">10.108 Sample &lsquo;<samp>step</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-stereo" href="#stereo-sample">10.109 Sample &lsquo;<samp>stereo</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-stfa" href="#stfa-sample">10.110 Sample &lsquo;<samp>stfa</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-style" href="#style-sample">10.111 Sample &lsquo;<samp>style</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surf" href="#surf-sample">10.112 Sample &lsquo;<samp>surf</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surf3" href="#surf3-sample">10.113 Sample &lsquo;<samp>surf3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surf3a" href="#surf3a-sample">10.114 Sample &lsquo;<samp>surf3a</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surf3c" href="#surf3c-sample">10.115 Sample &lsquo;<samp>surf3c</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surf3ca" href="#surf3ca-sample">10.116 Sample &lsquo;<samp>surf3ca</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surfa" href="#surfa-sample">10.117 Sample &lsquo;<samp>surfa</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surfc" href="#surfc-sample">10.118 Sample &lsquo;<samp>surfc</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-surfca" href="#surfca-sample">10.119 Sample &lsquo;<samp>surfca</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-table" href="#table-sample">10.120 Sample &lsquo;<samp>table</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-tape" href="#tape-sample">10.121 Sample &lsquo;<samp>tape</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-tens" href="#tens-sample">10.122 Sample &lsquo;<samp>tens</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ternary" href="#ternary-sample">10.123 Sample &lsquo;<samp>ternary</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-text" href="#text-sample">10.124 Sample &lsquo;<samp>text</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-text2" href="#text2-sample">10.125 Sample &lsquo;<samp>text2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-textmark" href="#textmark-sample">10.126 Sample &lsquo;<samp>textmark</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-ticks" href="#ticks-sample">10.127 Sample &lsquo;<samp>ticks</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-tile" href="#tile-sample">10.128 Sample &lsquo;<samp>tile</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-tiles" href="#tiles-sample">10.129 Sample &lsquo;<samp>tiles</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-torus" href="#torus-sample">10.130 Sample &lsquo;<samp>torus</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-traj" href="#traj-sample">10.131 Sample &lsquo;<samp>traj</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-triangulation" href="#triangulation-sample">10.132 Sample &lsquo;<samp>triangulation</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-triplot" href="#triplot-sample">10.133 Sample &lsquo;<samp>triplot</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-tube" href="#tube-sample">10.134 Sample &lsquo;<samp>tube</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-type0" href="#type0-sample">10.135 Sample &lsquo;<samp>type0</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-type1" href="#type1-sample">10.136 Sample &lsquo;<samp>type1</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-type2" href="#type2-sample">10.137 Sample &lsquo;<samp>type2</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-vect" href="#vect-sample">10.138 Sample &lsquo;<samp>vect</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-vect3" href="#vect3-sample">10.139 Sample &lsquo;<samp>vect3</samp>&rsquo;</a></li>
    <li><a name="toc-Sample-_0027venn_0027" href="#venn-sample">10.140 Sample &rsquo;venn&rsquo;</a></li>
  </ul></li>
  <li><a name="toc-Symbols-and-hot_002dkeys-1" href="#Symbols-and-hot_002dkeys">Appendix A Symbols and hot-keys</a>
  <ul class="no-bullet">
    <li><a name="toc-Symbols-for-styles-1" href="#Symbols-for-styles">A.1 Symbols for styles</a></li>
    <li><a name="toc-Hot_002dkeys-for-mglview-1" href="#Hot_002dkeys-for-mglview">A.2 Hot-keys for mglview</a></li>
    <li><a name="toc-Hot_002dkeys-for-UDAV-1" href="#Hot_002dkeys-for-UDAV">A.3 Hot-keys for UDAV</a></li>
  </ul></li>
  <li><a name="toc-File-formats-1" href="#File-formats">Appendix B File formats</a>
  <ul class="no-bullet">
    <li><a name="toc-Font-files-1" href="#Font-files">B.1 Font files</a></li>
    <li><a name="toc-MGLD-format-1" href="#MGLD-format">B.2 MGLD format</a></li>
    <li><a name="toc-JSON-format-1" href="#JSON-format">B.3 JSON format</a></li>
    <li><a name="toc-IFS-format-1" href="#IFS-format">B.4 IFS format</a></li>
  </ul></li>
  <li><a name="toc-Vremya-otrisovki" href="#Plotting-time">Appendix C Время отрисовки</a></li>
  <li><a name="toc-Simvoly-TeX" href="#TeX_002dlike-symbols">Appendix D Символы TeX</a></li>
  <li><a name="toc-GNU-Free-Documentation-License" href="#Copying-This-Manual">Appendix E GNU Free Documentation License</a></li>
  <li><a name="toc-Indeks" href="#Index">Индекс</a></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Overview" accesskey="n" rel="next">Overview</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MathGL"></a>
<h1 class="top">MathGL</h1>

<p>Это документация для MathGL (версии 2.4.3) &ndash; библиотеки классов и функций для построения научной графики. Пожалуйста сообщайте о любых ошибках в этом руководстве на <a href="mailto:mathgl.abalakin@gmail.org">mathgl.abalakin@gmail.org</a>. Дополнительную информацию о MathGL можно найти на домашней странице проекта <a href="http://mathgl.sourceforge.net/">http://mathgl.sourceforge.net/</a>.
</p>
<p>Copyright &copy; 2008-2012 Alexey A. Balakin.
</p>
<blockquote>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled &ldquo;GNU
Free Documentation License.&rdquo;
</p></blockquote>



<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Overview" accesskey="1">Overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Examples" accesskey="2">Examples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#General-concepts" accesskey="3">General concepts</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MathGL-core" accesskey="4">MathGL core</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Widget-classes" accesskey="5">Widget classes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-processing" accesskey="6">Data processing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MGL-scripts" accesskey="7">MGL scripts</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UDAV" accesskey="8">UDAV</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-classes" accesskey="9">Other classes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#All-samples">All samples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbols-and-hot_002dkeys">Symbols and hot-keys</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#File-formats">File formats</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TeX_002dlike-symbols">TeX-like symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Plotting-time">Plotting time</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Copying-This-Manual">Copying This Manual</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Index">Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>




<hr>
<a name="Overview"></a>
<div class="header">
<p>
Next: <a href="#Examples" accesskey="n" rel="next">Examples</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Obzor-MathGL"></a>
<h2 class="chapter">1 Обзор MathGL</h2>


<a name="index-Obzor-MathGL"></a>

<p>MathGL это ...
</p><ul>
<li> библиотека для создания высококачественной научной графики под Linux и Windows;
</li><li> библиотека для быстрого обработки и отображения больших массивов данных;
</li><li> библиотека для работы в оконном и консольном режимах;
</li><li> библиотека с большим набором базовых типов графиков.
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#What-is-MathGL_003f" accesskey="1">What is MathGL?</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MathGL-features" accesskey="2">MathGL features</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installation" accesskey="3">Installation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Quick-guide" accesskey="4">Quick guide</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Changes-from-v_002e1" accesskey="5">Changes from v.1</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Utilities" accesskey="6">Utilities</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Thanks" accesskey="7">Thanks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="What-is-MathGL_003f"></a>
<div class="header">
<p>
Next: <a href="#MathGL-features" accesskey="n" rel="next">MathGL features</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Chto-takoe-MathGL_003f"></a>
<h3 class="section">1.1 Что такое MathGL?</h3>


<p>Код для создания качественной научной графики на различных платформах. Код для быстрой обработки и отображения больших массивов данных. Код для работы в графическом и консольном режимах и легкого интегрирования в другие программы. Код с большим обновляемым набором графиков и инструментами обработки данных. Именно такого кода мне не хватало в последние годы при работе на персональных компьютерах и на кластерах. И именно такой код я постарался создать в библиотеке MathGL.
</p>
<p>На данный момент (версия 2.4.3) MathGL это более 50 основных типов графиков для одно-, двух- и трехмерных массивов, возможность экспорта в растровые и векторные (EPS или SVG) файлы, интерфейс для OpenGL и возможность запуска в консольном режиме, функции для обработки данных и даже простейший командный (интерпретируемый) язык MGL для упрощения построения графиков. Кроме того, есть несколько типов прозрачности, гладкое освещение, векторные шрифты, TeX-ие команды в надписях, произвольные криволинейные системы координат и прочие полезные мелочи (см. раздел pictures на <a href="http://mathgl.sf.net/">домашней странице</a>). Ну, и, естественно, полная переносимость библиотеки и ее свободное распространение под лицензией GPL v.2.0 или более поздней.
</p>

<hr>
<a name="MathGL-features"></a>
<div class="header">
<p>
Next: <a href="#Installation" accesskey="n" rel="next">Installation</a>, Previous: <a href="#What-is-MathGL_003f" accesskey="p" rel="prev">What is MathGL?</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Vozmozhnosti-MathGL"></a>
<h3 class="section">1.2 Возможности MathGL</h3>


<p>Библиотека MathGL позволяет строить широкий класс графиков, включая:
</p><ul>
<li> рисование одномерных массивов (Plot, Area, Bars, Step, Stem, Torus, Chart, Error, Tube, Mark, see <a href="#g_t1D-plotting">1D plotting</a>);

</li><li> рисование двумерных массивов (Mesh, Surf, Dens, Cont, ContF, Boxs, Axial, Fall, Belt, Tile, see <a href="#g_t2D-plotting">2D plotting</a>);

</li><li> рисование трехмерных массивов (Surf3, Dens3, Cont3, ContF3, Cloud-like, see <a href="#g_t3D-plotting">3D plotting</a>);

</li><li> рисование нескольких связанных массивов: векторные поля Vect, линии тока Flow, точечное отображение Map, поверхности с прозрачностью или цветом, определяемым другим массивом SurfA, SurfC, Surf3A, Surf3C (see <a href="#Dual-plotting">Dual plotting</a>);

</li><li> и другие (см. see <a href="#MathGL-core">MathGL core</a>).
</li></ul>

<p>Фактически, я постарался реализовать все известные мне типы научных графиков. Список графиков постоянно пополняется, и если Вам нужен какой-то новый вариант, пишите на <a href="mailto:mathgl.abalakin@gmail.com">e-mail</a>, и в новой версии библиотеки этот график появится.
</p>
<p>Я постарался сделать графики максимально красивыми &ndash; поверхности могут быть прозрачными и освещены произвольно расположенными источниками света (максимальное их количество 10). Большинство функций рисования имеет два варианта: простой для быстрого построения картинки и более сложный для детальной настройки отображения, включающего в том числе возможность параметрического задания всех массивов. Получившееся изображение можно сохранить в растровом формате PNG, JPEG, GIF, TGA или BMP; в векторном EPS, SVG или TeX формате, или в 3D формате OBJ, OFF, STL, или в PRC формате, который может быть конвертирован U3D.
</p>
<p>Все надписи выводятся векторным шрифтом, что обеспечивает их хорошую масштабируемость и переносимость. Текст может содержать команды для большинства ТеХ-их символов, изменения положения (верхний и нижний индексы) и стиля шрифта внутри строки текста (see <a href="#Font-styles">Font styles</a>). Текст меток поворачивается вместе с осями. На график можно вывести описание кривых (легенду) и поместить надпись в произвольную точку экрана или пустить ее вдоль кривой. Поддерживаются произвольные кодировки текста (с помощью стандартной функции <code>setlocale()</code>) и текст в кодировке UTF-16.
</p>
<p>Для представления данных используется специальный класс mglData (see <a href="#Data-processing">Data processing</a>). Помимо безопасного создания и удаления массивов, он включает функции по их обработке (дифференцированию, интегрированию, сглаживанию, интерполяции и т.д.) и чтению текстового файла с автоматическим определением размеров данных. Класс mglData позволяет работать с массивами размерности вплоть до 3 (массивы, зависящие от трех независимых индексов <em>a_{ijk}</em>). Использование массивов с большим числом размерностей нецелесообразно, поскольку я не представляю, как их можно отобразить на экране. Заполнение или изменение значений массива можно выполнить как вручную, так и по формуле, заданной текстовой строкой.
</p>
<p>Для <em>быстрого</em> вычисления значения выражения, заданного текстовой строкой (see <a href="#Textual-formulas">Textual formulas</a>). Он основан на компиляции строки в древоподобную структуру при создании экземпляра класса. На этапе вычисления происходит быстрый обход дерева с выдачей результата для конкретных значений переменных. Помимо изменения значений массива данных, текстовые формулы используются для рисования в <em>произвольной</em> криволинейной системе координат. Набор таких координат ограничивается только фантазией пользователя, а не фиксированным числом (типа полярной, параболической, цилиндрической и т.д.).
</p>

<hr>
<a name="Installation"></a>
<div class="header">
<p>
Next: <a href="#Quick-guide" accesskey="n" rel="next">Quick guide</a>, Previous: <a href="#MathGL-features" accesskey="p" rel="prev">MathGL features</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ustanovka-MathGL"></a>
<h3 class="section">1.3 Установка MathGL</h3>


<p>Установка библиотеки возможна 4-мя способами.
</p><ol>
<li> Скомпилировать библиотеку непосредственно из исходных файлов. С библиотекой поставляется файлы для системы сборки CMake. Для его запуска достаточно в командной строке выполнить 3 команды: сначала <code>cmake .</code> дважды, далее <code>make</code> и, наконец, с правами суперпользователя <code>make install</code>. Иногда после компиляции библиотеки может потребоваться обновление списка библиотека в системе &ndash; выполните команду <code>ldconfig</code> с правами суперпользователя.

<p>Есть несколько дополнительных опций, которые по умолчанию отключены. К их числу относятся: <code>enable-fltk, enable-glut, enable-qt4, enable-qt5</code> для поддержки FLTK, GLUT и/или Qt окон; <code>enable-jpeg, enable-gif, enable-hdf5</code> для поддержки соответствующих форматов; <code>enable-all</code> для включения всех возможностей. Для использования типа <code>double</code> для внутреннего хранения данных используйте опцию <code>enable-double</code>. Для создания интерфейсов к другим языкам (кроме С/Фортран/MGL) используйте опции <code>enable-python, enable-octave</code> или <code>enable-all-swig</code> для всех поддерживаемых языков. Вы можете воспользоваться WYSIWYG утилитой (<code>cmake-gui</code>) для просмотра и изменения всех опций, или выполнить <code>cmake -D enable-all=on -D enable-all-widgets=on -D enable-all-swig=on .</code> в командной строке для включения всех опций.
</p>
<p>При сборке с помощью MinGW необходимо дополнительно установить опцию сборки <code>-fopenmp</code> (т.е. <code>CMAKE_EXE_LINKER_FLAGS:STRING='-fopenmp'</code> и <code>CMAKE_SHARED_LINKER_FLAGS:STRING='-fopenmp'</code>) если включена поддержка OpenMP (<code>enable-openmp=ON</code>).
</p>

</li><li> Использовать предварительно скомпилированные файлы &ndash; с библиотекой поставляются файлы для MinGW (платформа Win32). В скомпилированной версии достаточно распаковать заголовочные файлы в папку с заголовочными файлами и библиотеку libmgl.a в папку с библиотеками. По умолчанию, скомпилированная версия включают поддержку GSL (www.gsl.org), PNG, GIF и JPEG. Соответственно, при сборке программы эти библиотеки должны быть установлены (их можно найти на <a href="http://gnuwin32.sourceforge.net/packages.html">http://gnuwin32.sourceforge.net/packages.html</a>).
</li><li> Установить из стандартных пакетов (RPM, deb, DevPak и пр.).
</li></ol>

<p>Последнюю версию (которая может быть не стабильна) можно загрузить с  sourceforge.net SVN с помощью команды
</p><pre class="verbatim">svn checkout http://svn.code.sf.net/p/mathgl/code/mathgl-2x mathgl-code
</pre>
<p><strong>ВАЖНО!</strong> MathGL использует набор defines, определяемых на этапе конфигурирования библиотеки. Это <code>MGL_SYS_NAN, MGL_HAVE_TYPEOF, MGL_HAVE_PTHREAD, MGL_HAVE_ATTRIBUTE, MGL_HAVE_C99_COMPLEX, MGL_HAVE_RVAL</code>. Они могут отличаться при использовании бинарников скомпилированных другим компилятором (например при использовании скомпилированных MinGW бинарников в VisualStudio). Я специально устанавливаю их в <code>0</code> для компиляторов Borland и Microsoft из соображений совместимости. Кроме того, настройки по умолчанию подходят для компиляторов GNU (gcc, mingw) и clang. Однако, для прочих компиляторов может потребоваться ручная установка defines в <code>0</code> в файле <code>include/mgl2/config.h</code> если вы используете предварительно скомпилированные файлы.
</p>



<hr>
<a name="Quick-guide"></a>
<div class="header">
<p>
Next: <a href="#Changes-from-v_002e1" accesskey="n" rel="next">Changes from v.1</a>, Previous: <a href="#Installation" accesskey="p" rel="prev">Installation</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Quick-guide-1"></a>
<h3 class="section">1.4 Quick guide</h3>


<p>There are 3 steps to prepare the plot in MathGL: (1) prepare data to be plotted, (2) setup plot, (3) plot data. Let me show this on the example of surface plotting.
</p>
<p>First we need the data. MathGL use its own class <code>mglData</code> to handle data arrays (see <a href="#Data-processing">Data processing</a>). This class give ability to handle data arrays by more or less format independent way. So, create it
</p><pre class="verbatim">    int main()
    {
        mglData dat(30,40);	// data to for plotting
        for(long i=0;i&lt;30;i++)   for(long j=0;j&lt;40;j++)
            dat.a[i+30*j] = 1/(1+(i-15)*(i-15)/225.+(j-20)*(j-20)/400.);
</pre><p>Here I create matrix 30*40 and initialize it by formula. Note, that I use <code>long</code> type for indexes <var>i</var>, <var>j</var> because data arrays can be really large and <code>long</code> type will automatically provide proper indexing.
</p>
<p>Next step is setup of the plot. The only setup I need is axis rotation and lighting.
</p><pre class="verbatim">        mglGraph gr;		// class for plot drawing
        gr.Rotate(50,60);	// rotate axis
        gr.Light(true);		// enable lighting
</pre>
<p>Everything is ready. And surface can be plotted.
</p><pre class="verbatim">        gr.Surf(dat);		// plot surface
</pre><p>Basically plot is done. But I decide to add yellow (&lsquo;<samp>y</samp>&rsquo; color, see <a href="#Color-styles">Color styles</a>) contour lines on the surface. To do it I can just add:
</p><pre class="verbatim">        gr.Cont(dat,&quot;y&quot;);	// plot yellow contour lines
</pre><p>This demonstrate one of base MathGL concept (see, <a href="#General-concepts">General concepts</a>) &ndash; &ldquo;new drawing never clears things drawn already&rdquo;. So, you can just consequently call different plotting functions to obtain &ldquo;combined&rdquo; plot. For example, if one need to draw axis then he can just call one more plotting function
</p><pre class="verbatim">        gr.Axis();			// draw axis
</pre>
<p>Now picture is ready and we can save it in a file.
</p><pre class="verbatim">        gr.WriteFrame(&quot;sample.png&quot;);	// save it
    }
</pre>
<p>To compile your program, you need to specify the linker option <code>-lmgl</code>.
</p>
<p>This is enough for a compilation of console program or with external (non-MathGL) window library. If you want to use FLTK or Qt windows provided by MathGL then you need to add the option <code>-lmgl-wnd</code>.
</p>
<p>При использовании фортрана необходимо также включить библиотеку <code>-lstdc++</code>. Кроме того, если библиотека была собрана с опцией <code>enable-double=ON</code> (по умолчанию в версии 2.1 и более поздних), то все вещественные числа должны быть типа real*8. Это можно включить по умолчанию опцией <code>-fdefault-real-8</code>.
</p>

<hr>
<a name="Changes-from-v_002e1"></a>
<div class="header">
<p>
Next: <a href="#Utilities" accesskey="n" rel="next">Utilities</a>, Previous: <a href="#Quick-guide" accesskey="p" rel="prev">Quick guide</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Changes-from-v_002e1_002e_002a"></a>
<h3 class="section">1.5 Changes from v.1.*</h3>


<p>There are a lot of changes for v.2. Here I denote only main of them.
</p><ul>
<li> mglGraph class is single plotter class instead of mglGraphZB, mglGraphPS and so on.
</li><li> Text style and text color positions are swapped. I.e. text style &lsquo;<samp>r:C</samp>&rsquo; give red centered text, but not roman dark cyan text as for v.1.*.
</li><li> ColumnPlot() indexing is reverted.
</li><li> Move most of arguments of plotting functions into the string parameter and/or options.
</li><li> &ldquo;Bright&rdquo; colors (like {b8}) can be used in color schemes and line styles.
</li><li> Intensively use pthread internally for parallelization of drawing and data processing.
</li><li> Add tick labels rotation and skipping. Add ticks in time/date format.
</li><li> New kinds of plots (Tape(), Label(), Cones(), ContV()). Extend existing plots. New primitives (Circle(), Ellipse(), Rhomb(), ...). New plot positioning (MultiPlot(), GridPlot())
</li><li> Improve MGL scripts. Add &rsquo;ask&rsquo; command and allow string concatenation from different lines.
</li><li> Export to LaTeX and to 3D formats (OBJ, OFF, STL).
</li><li> Add pipes support in utilities (<code>mglconv, mglview</code>).
</li></ul>


<hr>
<a name="Utilities"></a>
<div class="header">
<p>
Next: <a href="#Thanks" accesskey="n" rel="next">Thanks</a>, Previous: <a href="#Changes-from-v_002e1" accesskey="p" rel="prev">Changes from v.1</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Utilities-for-parsing-MGL"></a>
<h3 class="section">1.6 Utilities for parsing MGL</h3>


<p>MathGL library provides several tools for parsing MGL scripts. There is tools saving it to bitmap or vectorial images (<code>mglconv</code>). Tool <code>mglview</code> show MGL script and allow to rotate and setup the image. Another feature of <code>mglview</code> is loading *.mgld files (see <code>ExportMGLD()</code>) for quick viewing 3d pictures.
</p>
<p>Both tools have similar set of arguments. They can be name of script file or options. You can use &lsquo;<samp>-</samp>&rsquo; as script name for using standard input (i.e. pipes). Options are:
</p><ul>
<li> <strong>-1</strong> <var>str</var>
set <var>str</var> as argument $1 for script;
</li><li> ...
...
</li><li> <strong>-9</strong> <var>str</var>
set <var>str</var> as argument $9 for script;
</li><li> <strong>-L</strong> <var>loc</var>
set locale to <var>loc</var>;
</li><li> <strong>-s</strong> <var>fname</var>
set MGL script for setting up the plot;
</li><li> <strong>-h</strong>
print help message.
</li></ul>
<p>Additionally <code>mglconv</code> have following options:
</p><ul>
<li> <strong>-A</strong> <var>val</var>
add <var>val</var> into the list of animation parameters;
</li><li> <strong>-C</strong> <var>v1</var>:<var>v2</var>[:<var>dv</var>]
add values from <var>v1</var> ot <var>v2</var> with step <var>dv</var> (default is 1) into the list of animation parameters;
</li><li> <strong>-o</strong> <var>name</var>
set output file name;
</li><li> <strong>-n</strong>
disable default output (script should save results by itself);
</li><li> <strong>-S</strong> <var>val</var>
set set scaling factor for <a href="#setsize">setsize</a>;
</li><li> <strong>-q</strong> <var>val</var>
set <a href="#quality">quality</a> for output (val=0...9).
</li></ul>

<p>Also you can create animated GIF file or a set of JPEG files with names &lsquo;<samp>frameNNNN.jpg</samp>&rsquo; (here &lsquo;<samp>NNNN</samp>&rsquo; is frame index). Values of the parameter <code>$0</code> for making animation can be specified inside the script by comment <code>##a val</code> for each value <code>val</code> (one comment for one value) or by option(s) &lsquo;<samp>-A val</samp>&rsquo;. Also you can specify a cycle for animation by comment <code>##c v1 v2 dv</code> or by option <code>-C v1:v2:dv</code>. In the case of found/specified animation parameters, tool will execute script several times &ndash; once for each value of <code>$0</code>.
</p>

<p>MathGL also provide another simple tool <code>mgl.cgi</code> which parse MGL script from CGI request and send back produced PNG file. Usually this program should be placed in <code>/usr/lib/cgi-bin/</code>. But you need to put this program by yourself due to possible security issues and difference of Apache server settings.
</p>

<hr>
<a name="Thanks"></a>
<div class="header">
<p>
Previous: <a href="#Utilities" accesskey="p" rel="prev">Utilities</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Blagodarnosti"></a>
<h3 class="section">1.7 Благодарности</h3>



<ul>
<li> Моя специальная благодарность моей жене за терпение во время написания библиотеки.
</li><li> Я благодарен моим соавторам Д. Кулагину и М. Видассову за помощь в разработке MathGL.
</li><li> Я благодарен Diego Sejas Viscarra за разработку mgltex, вклад в генерацию фракталов и продуктивные предложения и обсуждения.
</li><li> Я благодарен D. Eftaxiopoulos, D. Haley, В. Липатову и С. Плису за создание бинарных пакетов для Linux.
</li><li> Я благодарен С. Скобелеву, К. Михайленко, М. Вейсману, A. Прохорову, A. Короткевичу, В. Онучину, С. Плису, Р. Киселеву, A. Иванову, Н. Троицкому and В. Липатову за продуктивные предложения и обсуждения.
</li><li> Я благодарен спонсорам М. Вейсману (<a href="http://www.jiht.ru/about/structure.php?set_filter_structure=Y&amp;structure_UF_DEPARTMENT=241&amp;filter=Y&amp;set_filter=Y">ОИВТ РАН</a>) и A. Прохорову (<a href="www.datadvance.net">DATADVANCE</a>).
</li></ul>

<p>Javascript интерфейс был разработан при поддержке компании <a href="www.datadvance.net">DATADVANCE</a>.
</p>



<hr>
<a name="Examples"></a>
<div class="header">
<p>
Next: <a href="#General-concepts" accesskey="n" rel="next">General concepts</a>, Previous: <a href="#Overview" accesskey="p" rel="prev">Overview</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Primery-MathGL"></a>
<h2 class="chapter">2 Примеры MathGL</h2>


<p>В данной главе рассмотрены базовые и продвинутые возможности MathGL, даны советы по использованию и примеры для всех типов графиков. Я рекомендую прочитать вначале первые 2 раздела и посмотреть на раздел <a href="#Hints">Hints</a>. Также рекомендую прочитать <a href="#General-concepts">General concepts</a> и <a href="#FAQ">FAQ</a>.
</p>
<p>Отмечу, что MathGL v.2.* имеет только пользовательских 2 интерфейса: один для языков подобных C или Fortran (не поддерживающих классы), другой для языков подобных C++/Python/Octave, которые поддерживают классы. При этом все классы являются &quot;оберткой&quot; С-ого интерфейсы, а функции-члены классов &ndash; inline вызовами функций С. Поэтому, в большинстве примеров в этой главе я буду приводить только один вариант кода, который после минимальных изменений синтаксиса может быть применен для других языков. Например, код на языке C++
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
int main()
{
  mglGraph gr;
  gr.FPlot(&quot;sin(pi*x)&quot;);
  gr.WriteFrame(&quot;test.png&quot;);
}
</pre><p>на Python будет выглядеть как
</p><pre class="verbatim">from mathgl import *
gr = mglGraph();
gr.FPlot(&quot;sin(pi*x)&quot;);
gr.WriteFrame(&quot;test.png&quot;);
</pre><p>в Octave он будет почти тем же (в новых версиях надо предварительно выполнить <code>mathgl;</code>)
</p><pre class="verbatim">gr = mglGraph();
gr.FPlot(&quot;sin(pi*x)&quot;);
gr.WriteFrame(&quot;test.png&quot;);
</pre><p>в C необходимо будет найти С-ые аналоги функций (из документации) и указать все их аргументы явно
</p><pre class="verbatim">#include &lt;mgl2/mgl_cf.h&gt;
int main()
{
  HMGL gr = mgl_create_graph(600,400);
  mgl_fplot(gr,&quot;sin(pi*x)&quot;,&quot;&quot;,&quot;&quot;);
  mgl_write_frame(gr,&quot;test.png&quot;,&quot;&quot;);
  mgl_delete_graph(gr);
}
</pre><p>в Fortran помимо этого придется определить функции возвращающие указатели на объекты как функции возвращающие целое
</p><pre class="verbatim">integer gr, mgl_create_graph
gr = mgl_create_graph(600,400);
call mgl_fplot(gr,'sin(pi*x)','','');
call mgl_write_frame(gr,'test.png','');
call mgl_delete_graph(gr);
</pre><p>и т.д.
</p>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Basic-usage" accesskey="1">Basic usage</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-usage" accesskey="2">Advanced usage</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-handling" accesskey="3">Data handling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-plotting" accesskey="4">Data plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hints" accesskey="5">Hints</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FAQ" accesskey="6">FAQ</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Basic-usage"></a>
<div class="header">
<p>
Next: <a href="#Advanced-usage" accesskey="n" rel="next">Advanced usage</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osnovy-ispolxzovaniya"></a>
<h3 class="section">2.1 Основы использования</h3>


<p>Библиотеку MathGL можно использовать несколькими способами, каждый из которых имеет свои достоинства и недостатки:
</p><ul>
<li> <em>Использовать возможности MathGL для создания графического окна (требуется FLTK, Qt или GLUT библиотеки).</em>

<p>Положительная сторона состоит в возможности сразу увидеть график и быстро его мышкой поправить (повернуть, приблизить, выключить прозрачность или освещение и т.д.). Однако, в этом случае требуется наличие графической системы (нельзя запускать на удаленной машине), и работать можно только с одним набором данных одновременно.
</p>
</li><li> <em>Прямой вывод в файл в растровом или векторном формате, без создания графического окна.</em>

<p>Достоинства такого подхода: пакетная обработка похожих данных (например, набора расчетных файлов при различных условиях), возможность запуска из консольной программы (включая запуск на удаленном компьютере/сервере/кластере), более быстрая и автоматизированная отрисовка, сохранение графиков для последующего анализа непосредственно во время расчета. К недостаткам подхода можно отнести: использование внешней программы просмотра для построенных графиков, необходимость заранее представить картинку (углы просмотра, освещение и пр.). Я рекомендую вначале использовать графическое окно для выбора оптимальных параметров графика, а потом использовать их для пакетной обработки.
</p>
</li><li> <em>Рисовать график в памяти с последующим выводом на экран другой графической программой.</em>

<p>В этом случае программист имеет максимум свободы в выборе графической библиотеки (не только FLTK, Qt или GLUT), в расположении и выборе элементов управления графиком и т.д. Я рекомендую этот вариант для &quot;самодостаточного&quot; приложения.
</p>
</li><li> <em>Использовать FLTK или Qt виджеты, предоставляемые MathGL</em>

<p>Вы также можете использовать ряд элементов управления (виджетов), которые позволяют отобразить график, сохранить его в файл в различных форматах или скопировать в буфер обмена, обработать движение/клики мышкой и пр.
</p></li></ul>

<p>Графики MathGL могут быть созданы не только с помощью объектно-ориентированных языков (например, C++ или Python), но и на C или Fortran подобных языках. Использование последних в основном идентичны использованию классов (за исключением различных имен функций). Различие состоит в обязательном предварительном создании (и удалении после использования) объектов типа HMGL (для графики) и/или HMDT (для данных). Пользователи Fortran могут считать эти переменные целочисленными с достаточной разрядностью для используемой операционной системы.
</p>
<p>Рассмотрим вышесказанное подробно.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Using-MathGL-window" accesskey="1">Using MathGL window</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Drawing-to-file" accesskey="2">Drawing to file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Animation" accesskey="3">Animation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Drawing-in-memory" accesskey="4">Drawing in memory</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Draw-and-calculate" accesskey="5">Draw and calculate</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-QMathGL" accesskey="6">Using QMathGL</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenGL-output" accesskey="7">OpenGL output</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MathGL-and-PyQt" accesskey="8">MathGL and PyQt</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MathGL-and-MPI" accesskey="9">MathGL and MPI</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<a name="Using-MathGL-window"></a>
<div class="header">
<p>
Next: <a href="#Drawing-to-file" accesskey="n" rel="next">Drawing to file</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ispolxzovanie-okon-MathGL"></a>
<h4 class="subsection">2.1.1 Использование окон MathGL</h4>

<a name="index-window"></a>
<a name="index-widgets"></a>

<p>&ldquo;Интерактивный&rdquo; способ использования MathGL состоит в создании окна с помощью классов <code>mglQT</code>, <code>mglFLTK</code> или <code>mglGLUT</code> (см. <a href="#Widget-classes">Widget classes</a>) и последующем рисовании в этом окне. Соответствующий код выглядит так:
</p><pre class="verbatim">#include &lt;mgl2/qt.h&gt;
int sample(mglGraph *gr)
{
  gr-&gt;Rotate(60,40);
  gr-&gt;Box();
  return 0;
}
//-----------------------------------------------------
int main(int argc,char **argv)
{
  mglQT gr(sample,&quot;MathGL examples&quot;);
  return gr.Run();
}
</pre><p>Здесь используется callback функция <code>sample</code>, выполняющая собственно рисование. Функция <code>main</code> &ndash; точка входа в программу &ndash; создает окно (объект <var>gr</var> типа <code>mglQT</code>) и запускает цикл обработки сообщений (вызов <code>gr.Run()</code>). Для компиляции достаточно выполнить команду
</p><pre class="verbatim">gcc test.cpp -lmgl-qt5 -lmgl
</pre><p>Вы можете использовать &quot;-lmgl-qt4&quot; вместо &quot;-lmgl-qt5&quot;, если установлен Qt4.
</p>
<p>Альтернативный способ состоит в использовании класса, производного от <code>mglDraw</code> с переопределенной функцией <code>Draw()</code>:
</p><pre class="verbatim">#include &lt;mgl2/qt.h&gt;
class Foo : public mglDraw
{
public:
  int Draw(mglGraph *gr);
};
//-----------------------------------------------------
int Foo::Draw(mglGraph *gr)
{
  gr-&gt;Rotate(60,40);
  gr-&gt;Box();
  return 0;
}
//-----------------------------------------------------
int main(int argc,char **argv)
{
  Foo foo;
  mglQT gr(&amp;foo,&quot;MathGL examples&quot;);
  return gr.Run();
}
</pre><p>Или в использовании функций С:
</p><pre class="verbatim">#include &lt;mgl2/mgl_cf.h&gt;
int sample(HMGL gr, void *)
{
  mgl_rotate(gr,60,40,0);
  mgl_box(gr);
}
int main(int argc,char **argv)
{
  HMGL gr;
  gr = mgl_create_graph_qt(sample,&quot;MathGL examples&quot;,0,0);
  return mgl_qt_run();
/* generally I should call mgl_delete_graph() here,
 * but I omit it in main() function. */
}
</pre>
<p>Похожий код получается и при использовании окон <code>mglFLTK</code>, <code>mglGLUT</code> (функция <code>sample()</code> та же):
</p><pre class="verbatim">#include &lt;mgl2/glut.h&gt;
int main(int argc,char **argv)
{
  mglGLUT gr(sample,&quot;MathGL examples&quot;);
  return 0;
}
</pre>
<p>The rotation, shift, zooming, switching on/off transparency and lighting can be done with help of tool-buttons (for <code>mglWindow</code>) or by hot-keys: &lsquo;<samp>a</samp>&rsquo;, &lsquo;<samp>d</samp>&rsquo;, &lsquo;<samp>w</samp>&rsquo;, &lsquo;<samp>s</samp>&rsquo; for plot rotation, &lsquo;<samp>r</samp>&rsquo; and &lsquo;<samp>f</samp>&rsquo; switching on/off transparency and lighting. Press &lsquo;<samp>x</samp>&rsquo; for exit (or closing the window).
</p>
<p>In this example function <code>sample</code> rotates axes (<code>Rotate()</code>, see <a href="#Subplots-and-rotation">Subplots and rotation</a>) and draws the bounding box (<code>Box()</code>). Drawing is placed in separate function since it will be used on demand when window canvas needs to be redrawn.
</p>

<hr>
<a name="Drawing-to-file"></a>
<div class="header">
<p>
Next: <a href="#Animation" accesskey="n" rel="next">Animation</a>, Previous: <a href="#Using-MathGL-window" accesskey="p" rel="prev">Using MathGL window</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Drawing-to-file-1"></a>
<h4 class="subsection">2.1.2 Drawing to file</h4>


<p>Another way of using MathGL library is the direct writing of the picture to the file. It is most usable for plot creation during long calculation or for using of small programs (like Matlab or Scilab scripts) for visualizing repetitive sets of data. But the speed of drawing is much higher in comparison with a script language.
</p>
<p>The following code produces a bitmap PNG picture:
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
int main(int ,char **)
{
  mglGraph gr;
  gr.Alpha(true);   gr.Light(true);
  sample(&amp;gr);              // The same drawing function.
  gr.WritePNG(&quot;test.png&quot;);  // Don't forget to save the result!
  return 0;
}
</pre><p>For compilation, you need only libmgl library not the one with widgets
</p><pre class="verbatim">gcc test.cpp -lmgl
</pre><p>This can be important if you create a console program in computer/cluster where X-server (and widgets) is inaccessible.
</p>
<p>The only difference from the previous variant (using windows) is manual switching on the transparency  <code>Alpha</code> and lightning <code>Light</code>, if you need it. The usage of frames (see <a href="#Animation">Animation</a>) is not advisable since the whole image is prepared each time. If function <code>sample</code> contains frames then only last one will be saved to the file. In principle, one does not need to separate drawing functions in case of direct file writing in consequence of the single calling of this function for each picture. However, one may use the same drawing procedure to create a plot with changeable parameters, to export in different file types, to emphasize the drawing code and so on. So, in future I will put the drawing in the separate function.
</p>
<p>The code for export into other formats (for example, into vector EPS file) looks the same:
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
int main(int ,char **)
{
  mglGraph gr;
  gr.Light(true);
  sample(&amp;gr);              // The same drawing function.
  gr.WriteEPS(&quot;test.eps&quot;);  // Don't forget to save the result!
  return 0;
}
</pre><p>The difference from the previous one is using other function <code>WriteEPS()</code> for EPS format instead of function <code>WritePNG()</code>. Also, there is no switching on of the plot transparency <code>Alpha</code> since EPS format does not support it.
</p>

<hr>
<a name="Animation"></a>
<div class="header">
<p>
Next: <a href="#Drawing-in-memory" accesskey="n" rel="next">Drawing in memory</a>, Previous: <a href="#Drawing-to-file" accesskey="p" rel="prev">Drawing to file</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Animation-1"></a>
<h4 class="subsection">2.1.3 Animation</h4>


<p>Widget classes (<code>mglWindow</code>, <code>mglGLUT</code>) support a delayed drawing, when all plotting functions are called once at the beginning of writing to memory lists. Further program displays the saved lists faster. Resulting redrawing will be faster but it requires sufficient memory. Several lists (frames) can be displayed one after another (by pressing &lsquo;<samp>,</samp>&rsquo;, &lsquo;<samp>.</samp>&rsquo;) or run as cinema. To switch these feature on one needs to modify function <code>sample</code>:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;NewFrame();             // the first frame
  gr-&gt;Rotate(60,40);
  gr-&gt;Box();
  gr-&gt;EndFrame();             // end of the first frame
  gr-&gt;NewFrame();             // the second frame
  gr-&gt;Box();
  gr-&gt;Axis(&quot;xy&quot;);
  gr-&gt;EndFrame();             // end of the second frame
  return gr-&gt;GetNumFrame();   // returns the frame number
}
</pre><p>First, the function creates a frame by calling <code>NewFrame()</code> for rotated axes and draws the bounding box.  The function <code>EndFrame()</code> <strong>must be</strong> called after the frame drawing! The second frame contains the bounding box and axes <code>Axis(&quot;xy&quot;)</code> in the initial (unrotated) coordinates. Function <code>sample</code> returns the number of created frames <code>GetNumFrame()</code>.
</p>
<p>Note, that animation can be also done as visualization of running calculations (see <a href="#Draw-and-calculate">Draw and calculate</a>).
</p>
<p>Pictures with <strong>animation can be saved in file(s)</strong> as well. You can: export in animated GIF, or save each frame in separate file (usually JPEG) and convert these files into the movie (for example, by help of ImageMagic). Let me show both methods.
</p>
<a name="GIF"></a><p>The simplest methods is making animated GIF. There are 3 steps: (1) open GIF file by <code>StartGIF()</code> function; (2) create the frames by calling <code>NewFrame()</code> before and <code>EndFrame()</code> after plotting; (3) close GIF by <code>CloseGIF()</code> function. So the simplest code for &ldquo;running&rdquo; sinusoid will look like this:
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
int main(int ,char **)
{
  mglGraph gr;
  mglData dat(100);
  char str[32];
  gr.StartGIF(&quot;sample.gif&quot;);
  for(int i=0;i&lt;40;i++)
  {
    gr.NewFrame();     // start frame
    gr.Box();          // some plotting
    for(int j=0;j&lt;dat.nx;j++)
      dat.a[j]=sin(M_PI*j/dat.nx+M_PI*0.05*i);
    gr.Plot(dat,&quot;b&quot;);
    gr.EndFrame();     // end frame
  }
  gr.CloseGIF();
  return 0;
}
</pre>
<a name="MPEG"></a><p>The second way is saving each frame in separate file (usually JPEG) and later make the movie from them. MathGL have special function for saving frames &ndash; it is <code>WriteFrame()</code>. This function save each frame with automatic name &lsquo;<samp>frame0001.jpg, frame0002.jpg</samp>&rsquo; and so on. Here prefix &lsquo;<samp>frame</samp>&rsquo; is defined by <var>PlotId</var> variable of <code>mglGraph</code> class. So the similar code will look like this:
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
int main(int ,char **)
{
  mglGraph gr;
  mglData dat(100);
  char str[32];
  for(int i=0;i&lt;40;i++)
  {
    gr.NewFrame();     // start frame
    gr.Box();          // some plotting
    for(int j=0;j&lt;dat.nx;j++)
      dat.a[j]=sin(M_PI*j/dat.nx+M_PI*0.05*i);
    gr.Plot(dat,&quot;b&quot;);
    gr.EndFrame();     // end frame
    gr.WriteFrame();   // save frame
  }
  return 0;
}
</pre>
<p>Created files can be converted to movie by help of a lot of programs. For example, you can use ImageMagic (command &lsquo;<samp>convert frame*.jpg movie.mpg</samp>&rsquo;), MPEG library, GIMP and so on.
</p>
<p>Finally, you can use <code>mglconv</code> tool for doing the same with MGL scripts (see <a href="#Utilities">Utilities</a>).
</p>

<hr>
<a name="Drawing-in-memory"></a>
<div class="header">
<p>
Next: <a href="#Draw-and-calculate" accesskey="n" rel="next">Draw and calculate</a>, Previous: <a href="#Animation" accesskey="p" rel="prev">Animation</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Drawing-in-memory-1"></a>
<h4 class="subsection">2.1.4 Drawing in memory</h4>


<p>The last way of MathGL using is the drawing in memory. Class <code>mglGraph</code> allows one  to create a bitmap picture in memory. Further this picture can be displayed in window by some window libraries (like wxWidgets, FLTK, Windows GDI and so on). For example, the code for drawing in wxWidget library looks like:
</p><pre class="verbatim">void MyForm::OnPaint(wxPaintEvent&amp; event)
{
  int w,h,x,y;
  GetClientSize(&amp;w,&amp;h);   // size of the picture
  mglGraph gr(w,h);

  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);
  sample(&amp;gr,NULL);

  wxImage img(w,h,gr.GetRGB(),true);
  ToolBar-&gt;GetSize(&amp;x,&amp;y);    // gets a height of the toolbar if any
  wxPaintDC dc(this);         // and draws it
  dc.DrawBitmap(wxBitmap(img),0,y);
}
</pre><p>The drawing in other libraries is most the same.
</p>
<p>For example, FLTK code will look like
</p><pre class="verbatim">void Fl_MyWidget::draw()
{
  mglGraph gr(w(),h());
  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);
  sample(&amp;gr,NULL);
  fl_draw_image(gr.GetRGB(), x(), y(), gr.GetWidth(), gr.GetHeight(), 3);
}
</pre><p>Qt code will look like
</p><pre class="verbatim">void MyWidget::paintEvent(QPaintEvent *)
{
  mglGraph gr(w(),h());

  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);         gr.Light(0,mglPoint(1,0,-1));
  sample(&amp;gr,NULL);

  // Qt don't support RGB format as is. So, let convert it to BGRN.
  long w=gr.GetWidth(), h=gr.GetHeight();
  unsigned char *buf = new uchar[4*w*h];
  gr.GetBGRN(buf, 4*w*h)
  QPixmap pic = QPixmap::fromImage(QImage(*buf, w, h, QImage::Format_RGB32));

  QPainter paint;
  paint.begin(this);  paint.drawPixmap(0,0,pic);  paint.end();
  delete []buf;
}
</pre>

<hr>
<a name="Draw-and-calculate"></a>
<div class="header">
<p>
Next: <a href="#Using-QMathGL" accesskey="n" rel="next">Using QMathGL</a>, Previous: <a href="#Drawing-in-memory" accesskey="p" rel="prev">Drawing in memory</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Draw-and-calculate-1"></a>
<h4 class="subsection">2.1.5 Draw and calculate</h4>


<p>MathGL can be used to draw plots in parallel with some external calculations. The simplest way for this is the usage of <a href="#mglDraw-class">mglDraw class</a>. At this you should enable pthread for widgets by setting <code>enable-pthr-widget=ON</code> at configure stage (it is set by default).
First, you need to inherit you class from <code>mglDraw</code> class, define virtual members <code>Draw()</code> and <code>Calc()</code> which will draw the plot and proceed calculations. You may want to add the pointer <code>mglWnd *wnd;</code> to window with plot for interacting with them. Finally, you may add any other data or member functions. The sample class is shown below
</p><pre class="verbatim">class myDraw : public mglDraw
{
	mglPoint pnt;	// some variable for changeable data
	long i;			// another variable to be shown
	mglWnd *wnd;	// external window for plotting
public:
	myDraw(mglWnd *w=0) : mglDraw()	{	wnd=w;	}
	void SetWnd(mglWnd *w)	{	wnd=w;	}
	int Draw(mglGraph *gr)
	{
		gr-&gt;Line(mglPoint(),pnt,&quot;Ar2&quot;);
		char str[16];	snprintf(str,15,&quot;i=%ld&quot;,i);
		gr-&gt;Puts(mglPoint(),str);
		return 0;
	}
	void Calc()
	{
		for(i=0;;i++)	// do calculation
		{
			long_calculations();// which can be very long
			Check();	// check if need pause
			pnt.Set(2*mgl_rnd()-1,2*mgl_rnd()-1);
			if(wnd)	wnd-&gt;Update();
		}
	}
} dr;
</pre><p>There is only one issue here. Sometimes you may want to pause calculations to view result carefully, or save state, or change something. So, you need to provide a mechanism for pausing. Class <code>mglDraw</code> provide function <code>Check();</code> which check if toolbutton with pause is pressed and wait until it will be released. This function should be called in a &quot;safety&quot; places, where you can pause the calculation (for example, at the end of time step). Also you may add call <code>exit(0);</code> at the end of <code>Calc();</code> function for closing window and exit after finishing calculations.
Finally, you need to create a window itself and run calculations.
</p><pre class="verbatim">int main(int argc,char **argv)
{
	mglFLTK gr(&amp;dr,&quot;Multi-threading test&quot;);	// create window
	dr.SetWnd(&amp;gr);	// pass window pointer to yours class
	dr.Run();	// run calculations
	gr.Run();	// run event loop for window
	return 0;
}
</pre>
<p>Note, that you can reach the similar functionality without using <code>mglDraw</code> class (i.e. even for pure C code).
</p><pre class="verbatim">mglFLTK *gr=NULL;	// pointer to window
void *calc(void *)	// function with calculations
{
	mglPoint pnt;	// some data for plot
	for(long i=0;;i++)		// do calculation
	{
		long_calculations();	// which can be very long
		pnt.Set(2*mgl_rnd()-1,2*mgl_rnd()-1);
		if(gr)
		{
			gr-&gt;Clf();			// make new drawing
			// draw something
			gr-&gt;Line(mglPoint(),pnt,&quot;Ar2&quot;);
			char str[16];	snprintf(str,15,&quot;i=%ld&quot;,i);
			gr-&gt;Puts(mglPoint(),str);
			// don't forgot to update window
			gr-&gt;Update();
		}
	}
}
int main(int argc,char **argv)
{
	static pthread_t thr;
	pthread_create(&amp;thr,0,calc,0);	// create separate thread for calculations
	pthread_detach(thr);			// and detach it
	gr = new mglFLTK;	// now create window
	gr-&gt;Run();			// and run event loop
	return 0;
}
</pre><p>This sample is exactly the same as one with <code>mglDraw</code> class, but it don&rsquo;t have functionality for pausing calculations. If you need it then you have to create global mutex (like <code>pthread_mutex_t *mutex = pthread_mutex_init(&amp;mutex,NULL);</code>), set it to window (like <code>gr-&gt;SetMutex(mutex);</code>) and periodically check it at calculations (like <code>pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock(&amp;mutex);</code>).
</p>
<p>Finally, you can put the event-handling loop in separate instead of yours code by using <code>RunThr()</code> function instead of <code>Run()</code> one. Unfortunately, such method work well only for FLTK windows and only if pthread support was enabled. Such limitation come from the Qt requirement to be run in the primary thread only. The sample code will be:
</p><pre class="verbatim">int main(int argc,char **argv)
{
	mglFLTK gr(&quot;test&quot;);
	gr.RunThr();	// &lt;-- need MathGL version which use pthread for widgets
	mglPoint pnt;	// some data
	for(int i=0;i&lt;10;i++)	// do calculation
	{
		long_calculations();// which can be very long
		pnt.Set(2*mgl_rnd()-1,2*mgl_rnd()-1);
		gr.Clf();			// make new drawing
		gr.Line(mglPoint(),pnt,&quot;Ar2&quot;);
		char str[10] = &quot;i=0&quot;;	str[3] = '0'+i;
		gr-&gt;Puts(mglPoint(),str);
		gr.Update();		// update window
	}
	return 0;	// finish calculations and close the window
}
</pre>


<hr>
<a name="Using-QMathGL"></a>
<div class="header">
<p>
Next: <a href="#OpenGL-output" accesskey="n" rel="next">OpenGL output</a>, Previous: <a href="#Draw-and-calculate" accesskey="p" rel="prev">Draw and calculate</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Using-QMathGL-1"></a>
<h4 class="subsection">2.1.6 Using QMathGL</h4>


<p>MathGL have several interface widgets for different widget libraries. There are QMathGL for Qt, Fl_MathGL for FLTK. These classes provide control which display MathGL graphics. Unfortunately there is no uniform interface for widget classes because all libraries have slightly different set of functions, features and so on. However the usage of MathGL widgets is rather simple. Let me show it on the example of QMathGL.
</p>
<p>First of all you have to define the drawing function or inherit a class from <code>mglDraw</code> class. After it just create a window and setup QMathGL instance as any other Qt widget:
</p><pre class="verbatim">#include &lt;QApplication&gt;
#include &lt;QMainWindow&gt;
#include &lt;QScrollArea&gt;
#include &lt;mgl2/qmathgl.h&gt;
int main(int argc,char **argv)
{
  QApplication a(argc,argv);
  QMainWindow *Wnd = new QMainWindow;
  Wnd-&gt;resize(810,610);  // for fill up the QMGL, menu and toolbars
  Wnd-&gt;setWindowTitle(&quot;QMathGL sample&quot;);
  // here I allow to scroll QMathGL -- the case
  // then user want to prepare huge picture
  QScrollArea *scroll = new QScrollArea(Wnd);

  // Create and setup QMathGL
  QMathGL *QMGL = new QMathGL(Wnd);
//QMGL-&gt;setPopup(popup); // if you want to setup popup menu for QMGL
  QMGL-&gt;setDraw(sample);
  // or use QMGL-&gt;setDraw(foo); for instance of class Foo:public mglDraw
  QMGL-&gt;update();

  // continue other setup (menu, toolbar and so on)
  scroll-&gt;setWidget(QMGL);
  Wnd-&gt;setCentralWidget(scroll);
  Wnd-&gt;show();
  return a.exec();
}
</pre>



<hr>
<a name="OpenGL-output"></a>
<div class="header">
<p>
Next: <a href="#MathGL-and-PyQt" accesskey="n" rel="next">MathGL and PyQt</a>, Previous: <a href="#Using-QMathGL" accesskey="p" rel="prev">Using QMathGL</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="OpenGL-output-1"></a>
<h4 class="subsection">2.1.7 OpenGL output</h4>


<p>MathGL have possibility to draw resulting plot using OpenGL. This produce resulting plot a bit faster, but with some limitations (especially at use of transparency and lighting). Generally, you need to prepare OpenGL window and call MathGL functions to draw it. There is GLUT interface (see <a href="#Widget-classes">Widget classes</a>) to do it by simple way. Below I show example of OpenGL usage basing on Qt libraries (i.e. by using <code>QGLWidget</code> widget).
</p>
<p>First, one need to define widget class derived from <code>QGLWidget</code> and implement a few methods: <code>resizeGL()</code> called after each window resize, <code>paintGL()</code> for displaying the image on the screen, and <code>initializeGL()</code> for initializing OpenGL. The header file looks as following.
</p><pre class="verbatim">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QGLWidget&gt;
#include &lt;mgl2/mgl.h&gt;

class MainWindow : public QGLWidget
{
  Q_OBJECT
protected:
  mglGraph *gr;         // pointer to MathGL core class
  void resizeGL(int nWidth, int nHeight);   // Method called after each window resize
  void paintGL();       // Method to display the image on the screen
  void initializeGL();  // Method to initialize OpenGL
public:
  MainWindow(QWidget *parent = 0);
  ~MainWindow();
};
#endif // MAINWINDOW_H
</pre>
<p>The class implementation is rather straightforward. One need to recreate the instance of mglGraph at initializing OpenGL, and ask MathGL to use OpenGL output (set argument <code>1</code> in mglGraph constructor). Of course, the mglGraph object should be deleted at destruction. The method <code>resizeGL()</code> just pass new sizes to OpenGL and update viewport sizes. All plotting functions are located in the method <code>paintGL()</code>. At this, one need to add 2 calls: <code>gr-&gt;Clf()</code> at beginning for clearing previous OpenGL primitives; and <code>swapBuffers()</code> for showing output on the screen. The source file looks as following.
</p><pre class="verbatim">#include &quot;qgl_example.h&quot;
#include &lt;QApplication&gt;
//#include &lt;QtOpenGL&gt;
//-----------------------------------------------------------------------------
MainWindow::MainWindow(QWidget *parent) : QGLWidget(parent)	{	gr=0;	}
//-----------------------------------------------------------------------------
MainWindow::~MainWindow()	{	if(gr)	delete gr;	}
//-----------------------------------------------------------------------------
void MainWindow::initializeGL()	// recreate instance of MathGL core
{
	if(gr)	delete gr;
	gr = new mglGraph(1);	// use '1' for argument to force OpenGL output in MathGL
}
//-----------------------------------------------------------------------------
void MainWindow::resizeGL(int w, int h) // standard resize replace
{
	QGLWidget::resizeGL(w, h);
	glViewport (0, 0, w, h);
}
//-----------------------------------------------------------------------------
void MainWindow::paintGL()	// main drawing function
{
	gr-&gt;Clf();	// clear previous OpenGL primitives
	gr-&gt;SubPlot(1,1,0);
	gr-&gt;Rotate(40,60);
	gr-&gt;Light(true);
	gr-&gt;AddLight(0,mglPoint(0,0,10),mglPoint(0,0,-1));
	gr-&gt;Axis();
	gr-&gt;Box();
	gr-&gt;FPlot(&quot;sin(pi*x)&quot;,&quot;i2&quot;);
	gr-&gt;FPlot(&quot;cos(pi*x)&quot;,&quot;|&quot;);
	gr-&gt;FSurf(&quot;cos(2*pi*(x^2+y^2))&quot;);
	gr-&gt;Finish();
	swapBuffers();	// show output on the screen
}
//-----------------------------------------------------------------------------
int main(int argc, char *argv[])	// create application
{
	mgl_textdomain(argv?argv[0]:NULL,&quot;&quot;);
	QApplication a(argc, argv);
	MainWindow w;
	w.show();
	return a.exec();
}
//-----------------------------------------------------------------------------
</pre>


<hr>
<a name="MathGL-and-PyQt"></a>
<div class="header">
<p>
Next: <a href="#MathGL-and-MPI" accesskey="n" rel="next">MathGL and MPI</a>, Previous: <a href="#OpenGL-output" accesskey="p" rel="prev">OpenGL output</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MathGL-and-PyQt-1"></a>
<h4 class="subsection">2.1.8 MathGL and PyQt</h4>


<p>Generally SWIG based classes (including the Python one) are the same as C++ classes. However, there are few tips for using MathGL with PyQt. Below I place a very simple python code which demonstrate how MathGL can be used with PyQt. This code is mostly written by Prof. Dr. Heino Falcke. You can just copy it to a file <code>mgl-pyqt-test.py</code> and execute it from python shell by command <code>execfile(&quot;mgl-pyqt-test.py&quot;)</code>
</p>
<pre class="verbatim">from PyQt4 import QtGui,QtCore
from mathgl import *
import sys
app = QtGui.QApplication(sys.argv)
qpointf=QtCore.QPointF()

class hfQtPlot(QtGui.QWidget):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        self.img=(QtGui.QImage())
    def setgraph(self,gr):
        self.buffer='\t'
        self.buffer=self.buffer.expandtabs(4*gr.GetWidth()*gr.GetHeight())
        gr.GetBGRN(self.buffer,len(self.buffer))
        self.img=QtGui.QImage(self.buffer, gr.GetWidth(),gr.GetHeight(),QtGui.QImage.Format_ARGB32)
        self.update()
    def paintEvent(self, event):
        paint = QtGui.QPainter()
        paint.begin(self)
        paint.drawImage(qpointf,self.img)
        paint.end()

BackgroundColor=[1.0,1.0,1.0]
size=100
gr=mglGraph()
y=mglData(size)
#y.Modify(&quot;((0.7*cos(2*pi*(x+.2)*500)+0.3)*(rnd*0.5+0.5)+362.135+10000.)&quot;)
y.Modify(&quot;(cos(2*pi*x*10)+1.1)*1000.*rnd-501&quot;)
x=mglData(size)
x.Modify(&quot;x^2&quot;);

def plotpanel(gr,x,y,n):
    gr.SubPlot(2,2,n)
    gr.SetXRange(x)
    gr.SetYRange(y)
    gr.AdjustTicks()
    gr.Axis()
    gr.Box()
    gr.Label(&quot;x&quot;,&quot;x-Axis&quot;,1)
    gr.Label(&quot;y&quot;,&quot;y-Axis&quot;,1)
    gr.ClearLegend()
    gr.AddLegend(&quot;Legend: &quot;+str(n),&quot;k&quot;)
    gr.Legend()
    gr.Plot(x,y)


gr.Clf(BackgroundColor[0],BackgroundColor[1],BackgroundColor[2])
gr.SetPlotFactor(1.5)
plotpanel(gr,x,y,0)
y.Modify(&quot;(cos(2*pi*x*10)+1.1)*1000.*rnd-501&quot;)
plotpanel(gr,x,y,1)
y.Modify(&quot;(cos(2*pi*x*10)+1.1)*1000.*rnd-501&quot;)
plotpanel(gr,x,y,2)
y.Modify(&quot;(cos(2*pi*x*10)+1.1)*1000.*rnd-501&quot;)
plotpanel(gr,x,y,3)

gr.WritePNG(&quot;test.png&quot;,&quot;Test Plot&quot;)

qw = hfQtPlot()
qw.show()
qw.setgraph(gr)
qw.raise_()
</pre>



<hr>
<a name="MathGL-and-MPI"></a>
<div class="header">
<p>
Previous: <a href="#MathGL-and-PyQt" accesskey="p" rel="prev">MathGL and PyQt</a>, Up: <a href="#Basic-usage" accesskey="u" rel="up">Basic usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MathGL-and-MPI-1"></a>
<h4 class="subsection">2.1.9 MathGL and MPI</h4>


<p>For using MathGL in MPI program you just need to: (1) plot its own part of data for each running node; (2) collect resulting graphical information in a single program (for example, at node with rank=0); (3) save it. The sample code below demonstrate this for very simple sample of surface drawing.
</p>
<p>First you need to initialize MPI
</p><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;mgl2/mpi.h&gt;
#include &lt;mpi.h&gt;

int main(int argc, char *argv[])
{
  // initialize MPI
  int rank=0, numproc=1;
  MPI_Init(&amp;argc, &amp;argv);
  MPI_Comm_size(MPI_COMM_WORLD,&amp;numproc);
  MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
  if(rank==0) printf(&quot;Use %d processes.\n&quot;, numproc);
</pre>
<p>Next step is data creation. For simplicity, I create data arrays with the same sizes for all nodes. At this, you have to create <code>mglGraph</code> object too.
</p>
<pre class="verbatim">  // initialize data similarly for all nodes
  mglData a(128,256);
  mglGraphMPI gr;
</pre>
<p>Now, data should be filled by numbers. In real case, it should be some kind of calculations. But I just fill it by formula.
</p>
<pre class="verbatim">  // do the same plot for its own range
  char buf[64];
  sprintf(buf,&quot;xrange %g %g&quot;,2.*rank/numproc-1,2.*(rank+1)/numproc-1);
  gr.Fill(a,&quot;sin(2*pi*x)&quot;,buf);
</pre>
<p>It is time to plot the data. Don&rsquo;t forget to set proper axis range(s) by using parametric form or by using options (as in the sample).
</p>
<pre class="verbatim">  // plot data in each node
  gr.Clf();   // clear image before making the image
  gr.Rotate(40,60);
  gr.Surf(a,&quot;&quot;,buf);
</pre>
<p>Finally, let send graphical information to node with rank=0.
</p>
<pre class="verbatim">  // collect information
  if(rank!=0) gr.MPI_Send(0);
  else for(int i=1;i&lt;numproc;i++)  gr.MPI_Recv(i);
</pre>
<p>Now, node with rank=0 have whole image. It is time to save the image to a file. Also, you can add a kind of annotations here &ndash; I draw axis and bounding box in the sample.
</p>
<pre class="verbatim">  if(rank==0)
  {
    gr.Box();   gr.Axis();   // some post processing
    gr.WritePNG(&quot;test.png&quot;); // save result
  }
</pre>
<p>In my case the program is done, and I finalize MPI. In real program, you can repeat the loop of data calculation and data plotting as many times as you need.
</p>
<pre class="verbatim">  MPI_Finalize();
  return 0;
}
</pre>
<p>You can type &lsquo;<samp>mpic++ test.cpp -lmgl-mpi -lmgl &amp;&amp; mpirun -np 8 ./a.out</samp>&rsquo; for compilation and running the sample program on 8 nodes. Note, that you have to set enable-mpi=ON at MathGL configure to use this feature.
</p>

<hr>
<a name="Advanced-usage"></a>
<div class="header">
<p>
Next: <a href="#Data-handling" accesskey="n" rel="next">Data handling</a>, Previous: <a href="#Basic-usage" accesskey="p" rel="prev">Basic usage</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Advanced-usage-1"></a>
<h3 class="section">2.2 Advanced usage</h3>


<p>Now I show several non-obvious features of MathGL: several subplots in a single picture, curvilinear coordinates, text printing and so on. Generally you may miss this section at first reading.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Subplots" accesskey="1">Subplots</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Axis-and-ticks" accesskey="2">Axis and ticks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Curvilinear-coordinates" accesskey="3">Curvilinear coordinates</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Colorbars" accesskey="4">Colorbars</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bounding-box" accesskey="5">Bounding box</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ternary-axis" accesskey="6">Ternary axis</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Text-features" accesskey="7">Text features</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Legend-sample" accesskey="8">Legend sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cutting-sample" accesskey="9">Cutting sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Subplots"></a>
<div class="header">
<p>
Next: <a href="#Axis-and-ticks" accesskey="n" rel="next">Axis and ticks</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Subplots-1"></a>
<h4 class="subsection">2.2.1 Subplots</h4>


<p>Let me demonstrate possibilities of plot positioning and rotation. MathGL has a set of functions: <a href="#subplot">subplot</a>, <a href="#inplot">inplot</a>, <a href="#title">title</a>, <a href="#aspect">aspect</a> and <a href="#rotate">rotate</a> and so on (see <a href="#Subplots-and-rotation">Subplots and rotation</a>). The order of their calling is strictly determined. First, one changes the position of plot in image area (functions <a href="#subplot">subplot</a>, <a href="#inplot">inplot</a> and <a href="#multiplot">multiplot</a>). Secondly, you can add the title of plot by <a href="#title">title</a> function. After that one may rotate the plot (function <a href="#rotate">rotate</a>). Finally, one may change aspects of axes (function <a href="#aspect">aspect</a>). The following code illustrates the aforesaid it:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0); gr-&gt;Box();
  gr-&gt;Puts(mglPoint(-1,1.1),&quot;Just box&quot;,&quot;:L&quot;);
  gr-&gt;InPlot(0.2,0.5,0.7,1,false);  gr-&gt;Box();
  gr-&gt;Puts(mglPoint(0,1.2),&quot;InPlot example&quot;);
  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Rotate only&quot;);
  gr-&gt;Rotate(50,60);  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;Rotate and Aspect&quot;);
  gr-&gt;Rotate(50,60);  gr-&gt;Aspect(1,1,2);  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;Shear&quot;);
  gr-&gt;Box(&quot;c&quot;); gr-&gt;Shear(0.2,0.1); gr-&gt;Box();
  return 0;
}
</pre><p>Here I used function <code>Puts</code> for printing the text in arbitrary position of picture (see <a href="#Text-printing">Text printing</a>). Text coordinates and size are connected with axes. However, text coordinates may be everywhere, including the outside the bounding box. I&rsquo;ll show its features later in <a href="#Text-features">Text features</a>.
</p>
<div align="center"><img src="png/aspect.png" alt="Example of several subplots on the single picture.">
</div>
<p>More complicated sample show how to use most of positioning functions:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(3,2,0); gr-&gt;Title(&quot;StickPlot&quot;);
  gr-&gt;StickPlot(3, 0, 20, 30);  gr-&gt;Box(&quot;r&quot;); gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
  gr-&gt;StickPlot(3, 1, 20, 30);  gr-&gt;Box(&quot;g&quot;); gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
  gr-&gt;StickPlot(3, 2, 20, 30);  gr-&gt;Box(&quot;b&quot;); gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
  gr-&gt;SubPlot(3,2,3,&quot;&quot;);  gr-&gt;Title(&quot;ColumnPlot&quot;);
  gr-&gt;ColumnPlot(3, 0); gr-&gt;Box(&quot;r&quot;); gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
  gr-&gt;ColumnPlot(3, 1); gr-&gt;Box(&quot;g&quot;); gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
  gr-&gt;ColumnPlot(3, 2); gr-&gt;Box(&quot;b&quot;); gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
  gr-&gt;SubPlot(3,2,4,&quot;&quot;);  gr-&gt;Title(&quot;GridPlot&quot;);
  gr-&gt;GridPlot(2, 2, 0);  gr-&gt;Box(&quot;r&quot;); gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
  gr-&gt;GridPlot(2, 2, 1);  gr-&gt;Box(&quot;g&quot;); gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
  gr-&gt;GridPlot(2, 2, 2);  gr-&gt;Box(&quot;b&quot;); gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
  gr-&gt;GridPlot(2, 2, 3);  gr-&gt;Box(&quot;m&quot;); gr-&gt;Puts(mglPoint(0),&quot;3&quot;,&quot;m&quot;);
  gr-&gt;SubPlot(3,2,5,&quot;&quot;);  gr-&gt;Title(&quot;InPlot&quot;);  gr-&gt;Box();
  gr-&gt;InPlot(0.4, 1, 0.6, 1, true); gr-&gt;Box(&quot;r&quot;);
  gr-&gt;MultiPlot(3,2,1, 2, 1,&quot;&quot;);  gr-&gt;Title(&quot;MultiPlot and ShearPlot&quot;); gr-&gt;Box();
  gr-&gt;ShearPlot(3, 0, 0.2, 0.1);  gr-&gt;Box(&quot;r&quot;); gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
  gr-&gt;ShearPlot(3, 1, 0.2, 0.1);  gr-&gt;Box(&quot;g&quot;); gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
  gr-&gt;ShearPlot(3, 2, 0.2, 0.1);  gr-&gt;Box(&quot;b&quot;); gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/inplot.png" alt="Example for most of positioning functions.">
</div>


<hr>
<a name="Axis-and-ticks"></a>
<div class="header">
<p>
Next: <a href="#Curvilinear-coordinates" accesskey="n" rel="next">Curvilinear coordinates</a>, Previous: <a href="#Subplots" accesskey="p" rel="prev">Subplots</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Axis-and-ticks-1"></a>
<h4 class="subsection">2.2.2 Axis and ticks</h4>


<p>MathGL library can draw not only the bounding box but also the axes, grids, labels and so on. The ranges of axes and their origin (the point of intersection) are determined by functions <code>SetRange()</code>, <code>SetRanges()</code>, <code>SetOrigin()</code> (see <a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a>). Ticks on axis are specified by function <code>SetTicks</code>, <code>SetTicksVal</code>, <code>SetTicksTime</code> (see <a href="#Ticks">Ticks</a>). But usually
</p>
<p>Function <a href="#axis">axis</a> draws axes. Its textual string shows in which directions the axis or axes will be drawn (by default <code>&quot;xyz&quot;</code>, function draws axes in all directions). Function <a href="#grid">grid</a> draws grid perpendicularly to specified directions. Example of axes and grid drawing is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Axis origin, Grid&quot;); gr-&gt;SetOrigin(0,0);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;FPlot(&quot;x^3&quot;);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;2 axis&quot;);
  gr-&gt;SetRanges(-1,1,-1,1); gr-&gt;SetOrigin(-1,-1,-1);  // first axis
  gr-&gt;Axis(); gr-&gt;Label('y',&quot;axis 1&quot;,0);  gr-&gt;FPlot(&quot;sin(pi*x)&quot;);
  gr-&gt;SetRanges(0,1,0,1);   gr-&gt;SetOrigin(1,1,1);   // second axis
  gr-&gt;Axis(); gr-&gt;Label('y',&quot;axis 2&quot;,0);  gr-&gt;FPlot(&quot;cos(pi*x)&quot;);

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;More axis&quot;);
  gr-&gt;SetOrigin(NAN,NAN); gr-&gt;SetRange('x',-1,1);
  gr-&gt;Axis(); gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y',&quot;y_1&quot;,0);
  gr-&gt;FPlot(&quot;x^2&quot;,&quot;k&quot;);
  gr-&gt;SetRanges(-1,1,-1,1); gr-&gt;SetOrigin(-1.3,-1); // second axis
  gr-&gt;Axis(&quot;y&quot;,&quot;r&quot;);  gr-&gt;Label('y',&quot;#r{y_2}&quot;,0.2);
  gr-&gt;FPlot(&quot;x^3&quot;,&quot;r&quot;);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;4 segments, inverted axis&quot;);
  gr-&gt;SetOrigin(0,0);
  gr-&gt;InPlot(0.5,1,0.5,1);  gr-&gt;SetRanges(0,10,0,2);  gr-&gt;Axis();
  gr-&gt;FPlot(&quot;sqrt(x/2)&quot;);   gr-&gt;Label('x',&quot;W&quot;,1); gr-&gt;Label('y',&quot;U&quot;,1);
  gr-&gt;InPlot(0,0.5,0.5,1);  gr-&gt;SetRanges(1,0,0,2); gr-&gt;Axis(&quot;x&quot;);
  gr-&gt;FPlot(&quot;sqrt(x)+x^3&quot;); gr-&gt;Label('x',&quot;\\tau&quot;,-1);
  gr-&gt;InPlot(0.5,1,0,0.5);  gr-&gt;SetRanges(0,10,4,0);  gr-&gt;Axis(&quot;y&quot;);
  gr-&gt;FPlot(&quot;x/4&quot;); gr-&gt;Label('y',&quot;L&quot;,-1);
  gr-&gt;InPlot(0,0.5,0,0.5);  gr-&gt;SetRanges(1,0,4,0); gr-&gt;FPlot(&quot;4*x^2&quot;);
  return 0;
}
</pre>
<p>Note, that MathGL can draw not only single axis (which is default). But also several axis on the plot (see right plots). The idea is that the change of settings does not influence on the already drawn graphics. So, for 2-axes I setup the first axis and draw everything concerning it. Then I setup the second axis and draw things for the second axis. Generally, the similar idea allows one to draw rather complicated plot of 4 axis with different ranges (see bottom left plot).
</p>
<p>At this inverted axis can be created by 2 methods. First one is used in this sample &ndash; just specify minimal axis value to be large than maximal one. This method work well for 2D axis, but can wrongly place labels in 3D case. Second method is more general and work in 3D case too &ndash; just use <a href="#aspect">aspect</a> function with negative arguments. For example, following code will produce exactly the same result for 2D case, but 2nd variant will look better in 3D.
</p><pre class="verbatim">// variant 1
gr-&gt;SetRanges(0,10,4,0);  gr-&gt;Axis();

// variant 2
gr-&gt;SetRanges(0,10,0,4);  gr-&gt;Aspect(1,-1);   gr-&gt;Axis();
</pre>
<div align="center"><img src="png/axis.png" alt="Example of axis.">
</div>
<p>Another MathGL feature is fine ticks tunning. By default (if it is not changed by <code>SetTicks</code> function), MathGL try to adjust ticks positioning, so that they looks most human readable. At this, MathGL try to extract common factor for too large or too small axis ranges, as well as for too narrow ranges. Last one is non-common notation and can be disabled by <code>SetTuneTicks</code> function.
</p>
<p>Also, one can specify its own ticks with arbitrary labels by help of <code>SetTicksVal</code> function. Or one can set ticks in time format. In last case MathGL will try to select optimal format for labels with automatic switching between years, months/days, hours/minutes/seconds or microseconds. However, you can specify its own time representation using formats described in <a href="http://www.manpagez.com/man/3/strftime/">http://www.manpagez.com/man/3/strftime/</a>. Most common variants are &lsquo;<samp>%X</samp>&rsquo; for national representation of time, &lsquo;<samp>%x</samp>&rsquo; for national representation of date, &lsquo;<samp>%Y</samp>&rsquo; for year with century.
</p>
<p>The sample code, demonstrated ticks feature is
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(3,2,0); gr-&gt;Title(&quot;Usual axis&quot;);  gr-&gt;Axis();
  gr-&gt;SubPlot(3,2,1); gr-&gt;Title(&quot;Too big/small range&quot;);
  gr-&gt;SetRanges(-1000,1000,0,0.001);  gr-&gt;Axis();
  gr-&gt;SubPlot(3,2,3); gr-&gt;Title(&quot;Too narrow range&quot;);
  gr-&gt;SetRanges(100,100.1,10,10.01);  gr-&gt;Axis();
  gr-&gt;SubPlot(3,2,4); gr-&gt;Title(&quot;Disable ticks tuning&quot;);
  gr-&gt;SetTuneTicks(0);  gr-&gt;Axis();

  gr-&gt;SubPlot(3,2,2); gr-&gt;Title(&quot;Manual ticks&quot;);  gr-&gt;SetRanges(-M_PI,M_PI, 0, 2);
  mreal val[]={-M_PI, -M_PI/2, 0, 0.886, M_PI/2, M_PI};
  gr-&gt;SetTicksVal('x', mglData(6,val), &quot;-\\pi\n-\\pi/2\n0\nx^*\n\\pi/2\n\\pi&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;FPlot(&quot;2*cos(x^2)^2&quot;, &quot;r2&quot;);

  gr-&gt;SubPlot(3,2,5); gr-&gt;Title(&quot;Time ticks&quot;);  gr-&gt;SetRange('x',0,3e5);
  gr-&gt;SetTicksTime('x',0);  gr-&gt;Axis();
  return 0;
}
</pre>
<div align="center"><img src="png/ticks.png" alt="Features of axis ticks.">
</div>
<p>The last sample I want to show in this subsection is Log-axis. From MathGL&rsquo;s point of view, the log-axis is particular case of general curvilinear coordinates. So, we need first define new coordinates (see also <a href="#Curvilinear-coordinates">Curvilinear coordinates</a>) by help of <code>SetFunc</code> or <code>SetCoor</code> functions. At this one should wary about proper axis range. So the code looks as following:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Semi-log axis&quot;);
  gr-&gt;SetRanges(0.01,100,-1,1); gr-&gt;SetFunc(&quot;lg(x)&quot;,&quot;&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(&quot;xy&quot;,&quot;g&quot;); gr-&gt;FPlot(&quot;sin(1/x)&quot;);
  gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y', &quot;y = sin 1/x&quot;,0);

  gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Log-log axis&quot;);
  gr-&gt;SetRanges(0.01,100,0.1,100);  gr-&gt;SetFunc(&quot;lg(x)&quot;,&quot;lg(y)&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(&quot;!&quot;,&quot;h=&quot;);   gr-&gt;Grid();
  gr-&gt;FPlot(&quot;sqrt(1+x^2)&quot;); gr-&gt;Label('x',&quot;x&quot;,0);
  gr-&gt;Label('y', &quot;y = \\sqrt{1+x^2}&quot;,0);

  gr-&gt;SubPlot(2,2,2,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Minus-log axis&quot;);
  gr-&gt;SetRanges(-100,-0.01,-100,-0.1);  gr-&gt;SetFunc(&quot;-lg(-x)&quot;,&quot;-lg(-y)&quot;);
  gr-&gt;Axis(); gr-&gt;FPlot(&quot;-sqrt(1+x^2)&quot;);
  gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y', &quot;y = -\\sqrt{1+x^2}&quot;,0);

  gr-&gt;SubPlot(2,2,3,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Log-ticks&quot;);
  gr-&gt;SetRanges(0.1,100,0,100); gr-&gt;SetFunc(&quot;sqrt(x)&quot;,&quot;&quot;);
  gr-&gt;Axis(); gr-&gt;FPlot(&quot;x&quot;);
  gr-&gt;Label('x',&quot;x&quot;,1); gr-&gt;Label('y', &quot;y = x&quot;,0);
  return 0;
}
</pre>
<div align="center"><img src="png/loglog.png" alt="Features of axis ticks.">
</div>
<p>You can see that MathGL automatically switch to log-ticks as we define log-axis formula (in difference from v.1.*). Moreover, it switch to log-ticks for any formula if axis range will be large enough (see right bottom plot). Another interesting feature is that you not necessary define usual log-axis (i.e. when coordinates are positive), but you can define &ldquo;minus-log&rdquo; axis when coordinate is negative (see left bottom plot).
</p>

<hr>
<a name="Curvilinear-coordinates"></a>
<div class="header">
<p>
Next: <a href="#Colorbars" accesskey="n" rel="next">Colorbars</a>, Previous: <a href="#Axis-and-ticks" accesskey="p" rel="prev">Axis and ticks</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Curvilinear-coordinates-1"></a>
<h4 class="subsection">2.2.3 Curvilinear coordinates</h4>


<p>As I noted in previous subsection, MathGL support curvilinear coordinates. In difference from other plotting programs and libraries, MathGL uses textual formulas for connection of the old (data) and new (output) coordinates. This allows one to plot in arbitrary coordinates. The following code plots the line <var>y</var>=0, <var>z</var>=0 in Cartesian, polar, parabolic and spiral coordinates:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetOrigin(-1,1,-1);

  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Cartesian&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
  gr-&gt;Axis(); gr-&gt;Grid();

  gr-&gt;SetFunc(&quot;y*sin(pi*x)&quot;,&quot;y*cos(pi*x)&quot;,0);
  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Cylindrical&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
  gr-&gt;Axis(); gr-&gt;Grid();

  gr-&gt;SetFunc(&quot;2*y*x&quot;,&quot;y*y - x*x&quot;,0);
  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;Parabolic&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
  gr-&gt;Axis(); gr-&gt;Grid();

  gr-&gt;SetFunc(&quot;y*sin(pi*x)&quot;,&quot;y*cos(pi*x)&quot;,&quot;x+z&quot;);
  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;Spiral&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
  gr-&gt;Axis(); gr-&gt;Grid();
  gr-&gt;SetFunc(0,0,0); // set to default Cartesian
  return 0;
}
</pre>
<div align="center"><img src="png/curvcoor.png" alt="Example of curvilinear coordinates">
</div>


<hr>
<a name="Colorbars"></a>
<div class="header">
<p>
Next: <a href="#Bounding-box" accesskey="n" rel="next">Bounding box</a>, Previous: <a href="#Curvilinear-coordinates" accesskey="p" rel="prev">Curvilinear coordinates</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Colorbars-1"></a>
<h4 class="subsection">2.2.4 Colorbars</h4>


<p>MathGL handle <a href="#colorbar">colorbar</a> as special kind of axis. So, most of functions for axis and ticks setup will work for colorbar too. Colorbars can be in log-scale, and generally as arbitrary function scale; common factor of colorbar labels can be separated; and so on.
</p>
<p>But of course, there are differences &ndash; colorbars usually located out of bounding box. At this, colorbars can be at subplot boundaries (by default), or at bounding box (if symbol &lsquo;<samp>I</samp>&rsquo; is specified). Colorbars can handle sharp colors. And they can be located at arbitrary position too. The sample code, which demonstrate colorbar features is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Colorbar out of box&quot;); gr-&gt;Box();
  gr-&gt;Colorbar(&quot;&lt;&quot;);  gr-&gt;Colorbar(&quot;&gt;&quot;);
  gr-&gt;Colorbar(&quot;_&quot;);  gr-&gt;Colorbar(&quot;^&quot;);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Colorbar near box&quot;);   gr-&gt;Box();
  gr-&gt;Colorbar(&quot;&lt;I&quot;); gr-&gt;Colorbar(&quot;&gt;I&quot;);
  gr-&gt;Colorbar(&quot;_I&quot;); gr-&gt;Colorbar(&quot;^I&quot;);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;manual colors&quot;);
  mglData a,v;  mgls_prepare2d(&amp;a,0,&amp;v);
  gr-&gt;Box();  gr-&gt;ContD(v,a);
  gr-&gt;Colorbar(v,&quot;&lt;&quot;);  gr-&gt;Colorbar(v,&quot;&gt;&quot;);
  gr-&gt;Colorbar(v,&quot;_&quot;);  gr-&gt;Colorbar(v,&quot;^&quot;);

  gr-&gt;SubPlot(2,2,3);   gr-&gt;Title(&quot; &quot;);
  gr-&gt;Puts(mglPoint(-0.5,1.55),&quot;Color positions&quot;,&quot;:C&quot;,-2);
  gr-&gt;Colorbar(&quot;bwr&gt;&quot;,0.25,0);  gr-&gt;Puts(mglPoint(-0.9,1.2),&quot;Default&quot;);
  gr-&gt;Colorbar(&quot;b{w,0.3}r&gt;&quot;,0.5,0); gr-&gt;Puts(mglPoint(-0.1,1.2),&quot;Manual&quot;);

  gr-&gt;Puts(mglPoint(1,1.55),&quot;log-scale&quot;,&quot;:C&quot;,-2);
  gr-&gt;SetRange('c',0.01,1e3);
  gr-&gt;Colorbar(&quot;&gt;&quot;,0.75,0);  gr-&gt;Puts(mglPoint(0.65,1.2),&quot;Normal scale&quot;);
  gr-&gt;SetFunc(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;lg(c)&quot;);
  gr-&gt;Colorbar(&quot;&gt;&quot;);    gr-&gt;Puts(mglPoint(1.35,1.2),&quot;Log scale&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/colorbar.png" alt="Example of colorbars">
</div>


<hr>
<a name="Bounding-box"></a>
<div class="header">
<p>
Next: <a href="#Ternary-axis" accesskey="n" rel="next">Ternary axis</a>, Previous: <a href="#Colorbars" accesskey="p" rel="prev">Colorbars</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Bounding-box-1"></a>
<h4 class="subsection">2.2.5 Bounding box</h4>


<p>Box around the plot is rather useful thing because it allows one to: see the plot boundaries, and better estimate points position since box contain another set of ticks. MathGL provide special function for drawing such box &ndash; <a href="#box">box</a> function. By default, it draw black or white box with ticks (color depend on transparency type, see <a href="#Types-of-transparency">Types of transparency</a>). However, you can change the color of box, or add drawing of rectangles at rear faces of box. Also you can disable ticks drawing, but I don&rsquo;t know why anybody will want it. The sample code, which demonstrate <a href="#box">box</a> features is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Box (default)&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;colored&quot;);   gr-&gt;Rotate(50,60);
  gr-&gt;Box(&quot;r&quot;);
  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;with faces&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;Box(&quot;@&quot;);
  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;both&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;Box(&quot;@cm&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/box.png" alt="Example of Box()">
</div>


<hr>
<a name="Ternary-axis"></a>
<div class="header">
<p>
Next: <a href="#Text-features" accesskey="n" rel="next">Text features</a>, Previous: <a href="#Bounding-box" accesskey="p" rel="prev">Bounding box</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ternary-axis-1"></a>
<h4 class="subsection">2.2.6 Ternary axis</h4>


<p>There are another unusual axis types which are supported by MathGL. These are ternary and quaternary axis. Ternary axis is special axis of 3 coordinates <var>a</var>, <var>b</var>, <var>c</var> which satisfy relation <var>a</var>+<var>b</var>+<var>c</var>=1. Correspondingly, quaternary axis is special axis of 4 coordinates <var>a</var>, <var>b</var>, <var>c</var>, <var>d</var> which satisfy relation <var>a</var>+<var>b</var>+<var>c</var>+<var>d</var>=1.
</p>
<p>Generally speaking, only 2 of coordinates (3 for quaternary) are independent. So, MathGL just introduce some special transformation formulas which treat <var>a</var> as &lsquo;<samp>x</samp>&rsquo;, <var>b</var> as &lsquo;<samp>y</samp>&rsquo; (and <var>c</var> as &lsquo;<samp>z</samp>&rsquo; for quaternary). As result, all plotting functions (curves, surfaces, contours and so on) work as usual, but in new axis. You should use <a href="#ternary">ternary</a> function for switching to ternary/quaternary coordinates. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetRanges(0,1,0,1,0,1);
  mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
  a.Modify(&quot;30*x*y*(1-x-y)^2*(x+y&lt;1)&quot;);
  x.Modify(&quot;0.25*(1+cos(2*pi*x))&quot;);
  y.Modify(&quot;0.25*(1+sin(2*pi*x))&quot;);
  rx.Modify(&quot;rnd&quot;); ry.Modify(&quot;(1-v)*rnd&quot;,rx);
  z.Modify(&quot;x&quot;);

  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Ordinary axis 3D&quot;);
  gr-&gt;Rotate(50,60);    gr-&gt;Light(true);
  gr-&gt;Plot(x,y,z,&quot;r2&quot;); gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;Box();
  gr-&gt;Label('x',&quot;B&quot;,1); gr-&gt;Label('y',&quot;C&quot;,1); gr-&gt;Label('z',&quot;Z&quot;,1);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Ternary axis (x+y+t=1)&quot;);
  gr-&gt;Ternary(1);
  gr-&gt;Plot(x,y,&quot;r2&quot;); gr-&gt;Plot(rx,ry,&quot;q^ &quot;);  gr-&gt;Cont(a,&quot;BbcyrR&quot;);
  gr-&gt;Line(mglPoint(0.5,0), mglPoint(0,0.75), &quot;g2&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(&quot;xyz&quot;,&quot;B;&quot;);
  gr-&gt;Label('x',&quot;B&quot;); gr-&gt;Label('y',&quot;C&quot;); gr-&gt;Label('t',&quot;A&quot;);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;Quaternary axis 3D&quot;);
  gr-&gt;Rotate(50,60);    gr-&gt;Light(true);
  gr-&gt;Ternary(2);
  gr-&gt;Plot(x,y,z,&quot;r2&quot;); gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;Box();
  gr-&gt;Label('t',&quot;A&quot;,1); gr-&gt;Label('x',&quot;B&quot;,1);
  gr-&gt;Label('y',&quot;C&quot;,1); gr-&gt;Label('z',&quot;D&quot;,1);

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;Ternary axis 3D&quot;);
  gr-&gt;Rotate(50,60);    gr-&gt;Light(true);
  gr-&gt;Ternary(1);
  gr-&gt;Plot(x,y,z,&quot;r2&quot;); gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;Box();
  gr-&gt;Label('t',&quot;A&quot;,1); gr-&gt;Label('x',&quot;B&quot;,1);
  gr-&gt;Label('y',&quot;C&quot;,1); gr-&gt;Label('z',&quot;Z&quot;,1);
  return 0;
}
</pre>
<div align="center"><img src="png/ternary.png" alt="Example of colorbars">
</div>

<hr>
<a name="Text-features"></a>
<div class="header">
<p>
Next: <a href="#Legend-sample" accesskey="n" rel="next">Legend sample</a>, Previous: <a href="#Ternary-axis" accesskey="p" rel="prev">Ternary axis</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Text-features-1"></a>
<h4 class="subsection">2.2.7 Text features</h4>


<p>MathGL prints text by vector font. There are functions for manual specifying of text position (like <code>Puts</code>) and for its automatic selection (like <code>Label</code>, <code>Legend</code> and so on). MathGL prints text always in specified position even if it lies outside the bounding box. The default size of font is specified by functions <var>SetFontSize*</var> (see <a href="#Font-settings">Font settings</a>). However, the actual size of output string depends on subplot size (depends on functions <code>SubPlot</code>, <code>InPlot</code>). The switching of the font style (italic, bold, wire and so on) can be done for the whole string (by function parameter) or inside the string. By default MathGL parses TeX-like commands for symbols and indexes (see <a href="#Font-styles">Font styles</a>).
</p>
<p>Text can be printed as usual one (from left to right), along some direction (rotated text), or along a curve. Text can be printed on several lines, divided by new line symbol &lsquo;<samp>\n</samp>&rsquo;.
</p>
<p>Example of MathGL font drawing is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0,&quot;&quot;);
  gr-&gt;Putsw(mglPoint(0,1),L&quot;Text can be in ASCII and in Unicode&quot;);
  gr-&gt;Puts(mglPoint(0,0.6),&quot;It can be \\wire{wire}, \\big{big} or #r{colored}&quot;);
  gr-&gt;Puts(mglPoint(0,0.2),&quot;One can change style in string: &quot;
  &quot;\\b{bold}, \\i{italic, \\b{both}}&quot;);
  gr-&gt;Puts(mglPoint(0,-0.2),&quot;Easy to \\a{overline} or &quot;
  &quot;\\u{underline}&quot;);
  gr-&gt;Puts(mglPoint(0,-0.6),&quot;Easy to change indexes ^{up} _{down} @{center}&quot;);
  gr-&gt;Puts(mglPoint(0,-1),&quot;It parse TeX: \\int \\alpha \\cdot &quot;
  &quot;\\sqrt3{sin(\\pi x)^2 + \\gamma_{i_k}} dx&quot;);

  gr-&gt;SubPlot(2,2,1,&quot;&quot;);
  gr-&gt;Puts(mglPoint(0,0.5), &quot;\\sqrt{\\frac{\\alpha^{\\gamma^2}+\\overset 1{\\big\\infty}}{\\sqrt3{2+b}}}&quot;, &quot;@&quot;, -4);
  gr-&gt;Puts(mglPoint(0,-0.5),&quot;Text can be printed\non several lines&quot;);

  gr-&gt;SubPlot(2,2,2,&quot;&quot;);
  mglData y;  mgls_prepare1d(&amp;y);
  gr-&gt;Box();  gr-&gt;Plot(y.SubData(-1,0));
  gr-&gt;Text(y,&quot;This is very very long string drawn along a curve&quot;,&quot;:k&quot;);
  gr-&gt;Text(y,&quot;Another string drawn under a curve&quot;,&quot;T:r&quot;);

  gr-&gt;SubPlot(2,2,3,&quot;&quot;);
  gr-&gt;Line(mglPoint(-1,-1),mglPoint(1,-1),&quot;rA&quot;);
  gr-&gt;Puts(mglPoint(0,-1),mglPoint(1,-1),&quot;Horizontal&quot;);
  gr-&gt;Line(mglPoint(-1,-1),mglPoint(1,1),&quot;rA&quot;);
  gr-&gt;Puts(mglPoint(0,0),mglPoint(1,1),&quot;At angle&quot;,&quot;@&quot;);
  gr-&gt;Line(mglPoint(-1,-1),mglPoint(-1,1),&quot;rA&quot;);
  gr-&gt;Puts(mglPoint(-1,0),mglPoint(-1,1),&quot;Vertical&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/text.png" alt="Example of text printing">
</div>
<p>You can change font faces by loading font files by function <a href="#loadfont">loadfont</a>. Note, that this is long-run procedure. Font faces can be downloaded from <a href="http://mathgl.sourceforge.net/download.html">MathGL website</a> or from <a href="http://sourceforge.net/project/showfiles.php?group_id=152187&amp;package_id=267177">here</a>. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  double h=1.1, d=0.25;
  gr-&gt;LoadFont(&quot;STIX&quot;);     gr-&gt;Puts(mglPoint(0,h), &quot;default font (STIX)&quot;);
  gr-&gt;LoadFont(&quot;adventor&quot;); gr-&gt;Puts(mglPoint(0,h-d), &quot;adventor font&quot;);
  gr-&gt;LoadFont(&quot;bonum&quot;);    gr-&gt;Puts(mglPoint(0,h-2*d), &quot;bonum font&quot;);
  gr-&gt;LoadFont(&quot;chorus&quot;);   gr-&gt;Puts(mglPoint(0,h-3*d), &quot;chorus font&quot;);
  gr-&gt;LoadFont(&quot;cursor&quot;);   gr-&gt;Puts(mglPoint(0,h-4*d), &quot;cursor font&quot;);
  gr-&gt;LoadFont(&quot;heros&quot;);    gr-&gt;Puts(mglPoint(0,h-5*d), &quot;heros font&quot;);
  gr-&gt;LoadFont(&quot;heroscn&quot;);  gr-&gt;Puts(mglPoint(0,h-6*d), &quot;heroscn font&quot;);
  gr-&gt;LoadFont(&quot;pagella&quot;);  gr-&gt;Puts(mglPoint(0,h-7*d), &quot;pagella font&quot;);
  gr-&gt;LoadFont(&quot;schola&quot;);   gr-&gt;Puts(mglPoint(0,h-8*d), &quot;schola font&quot;);
  gr-&gt;LoadFont(&quot;termes&quot;);   gr-&gt;Puts(mglPoint(0,h-9*d), &quot;termes font&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/fonts.png" alt="Example of font faces">
</div>

<hr>
<a name="Legend-sample"></a>
<div class="header">
<p>
Next: <a href="#Cutting-sample" accesskey="n" rel="next">Cutting sample</a>, Previous: <a href="#Text-features" accesskey="p" rel="prev">Text features</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Legend-sample-1"></a>
<h4 class="subsection">2.2.8 Legend sample</h4>


<p>Legend is one of standard ways to show plot annotations. Basically you need to connect the plot style (line style, marker and color) with some text. In MathGL, you can do it by 2 methods: manually using <a href="#addlegend">addlegend</a> function; or use &lsquo;<samp>legend</samp>&rsquo; option (see <a href="#Command-options">Command options</a>), which will use last plot style. In both cases, legend entries will be added into internal accumulator, which later used for legend drawing itself. <a href="#clearlegend">clearlegend</a> function allow you to remove all saved legend entries.
</p>
<p>There are 2 features. If plot style is empty then text will be printed without indent. If you want to plot the text with indent but without plot sample then you need to use space &lsquo;<samp> </samp>&rsquo; as plot style. Such style &lsquo;<samp> </samp>&rsquo; will draw a plot sample (line with marker(s)) which is invisible line (i.e. nothing) and print the text with indent as usual one.
</p>
<p>Function <a href="#legend">legend</a> draw legend on the plot. The position of the legend can be selected automatic or manually. You can change the size and style of text labels, as well as setup the plot sample. The sample code demonstrating legend features is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;AddLegend(&quot;sin(\\pi {x^2})&quot;,&quot;b&quot;);
  gr-&gt;AddLegend(&quot;sin(\\pi x)&quot;,&quot;g*&quot;);
  gr-&gt;AddLegend(&quot;sin(\\pi \\sqrt{x})&quot;,&quot;rd&quot;);
  gr-&gt;AddLegend(&quot;just text&quot;,&quot; &quot;);
  gr-&gt;AddLegend(&quot;no indent for this&quot;,&quot;&quot;);

  gr-&gt;SubPlot(2,2,0,&quot;&quot;); gr-&gt;Title(&quot;Legend (default)&quot;);
  gr-&gt;Box();  gr-&gt;Legend();

  gr-&gt;Legend(3,&quot;A#&quot;);
  gr-&gt;Puts(mglPoint(0.75,0.65),&quot;Absolute position&quot;,&quot;A&quot;);

  gr-&gt;SubPlot(2,2,2,&quot;&quot;);  gr-&gt;Title(&quot;coloring&quot;);  gr-&gt;Box();
  gr-&gt;Legend(0,&quot;r#&quot;); gr-&gt;Legend(1,&quot;Wb#&quot;);  gr-&gt;Legend(2,&quot;ygr#&quot;);

  gr-&gt;SubPlot(2,2,3,&quot;&quot;);  gr-&gt;Title(&quot;manual position&quot;); gr-&gt;Box();
  gr-&gt;Legend(0.5,1);  gr-&gt;Puts(mglPoint(0.5,0.55),&quot;at x=0.5, y=1&quot;,&quot;a&quot;);
  gr-&gt;Legend(1,&quot;#-&quot;); gr-&gt;Puts(mglPoint(0.75,0.25),&quot;Horizontal legend&quot;,&quot;a&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/legend.png" alt="Example of legend">
</div>

<hr>
<a name="Cutting-sample"></a>
<div class="header">
<p>
Previous: <a href="#Legend-sample" accesskey="p" rel="prev">Legend sample</a>, Up: <a href="#Advanced-usage" accesskey="u" rel="up">Advanced usage</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Cutting-sample-1"></a>
<h4 class="subsection">2.2.9 Cutting sample</h4>


<p>The last common thing which I want to show in this section is how one can cut off points from plot. There are 4 mechanism for that.
</p><ul>
<li> You can set one of coordinate to NAN value. All points with NAN values will be omitted.

</li><li> You can enable cutting at edges by <code>SetCut</code> function. As result all points out of bounding box will be omitted.

</li><li> You can set cutting box by <code>SetCutBox</code> function. All points inside this box will be omitted.

</li><li> You can define cutting formula by <code>SetCutOff</code> function. All points for which the value of formula is nonzero will be omitted. Note, that this is the slowest variant.
</li></ul>

<p>Below I place the code which demonstrate last 3 possibilities:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a,c,v(1); mgls_prepare2d(&amp;a); mgls_prepare3d(&amp;c); v.a[0]=0.5;
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Cut on (default)&quot;);
  gr-&gt;Rotate(50,60);  gr-&gt;Light(true);
  gr-&gt;Box();  gr-&gt;Surf(a,&quot;&quot;,&quot;zrange -1 0.5&quot;);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Cut off&quot;);   gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Surf(a,&quot;&quot;,&quot;zrange -1 0.5; cut off&quot;);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;Cut in box&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;SetCutBox(mglPoint(0,-1,-1), mglPoint(1,0,1.1));
  gr-&gt;Alpha(true);  gr-&gt;Box();  gr-&gt;Surf3(c);
  gr-&gt;SetCutBox(mglPoint(0), mglPoint(0));  // switch it off

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;Cut by formula&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;CutOff(&quot;(z&gt;(x+0.5*y-1)^2-1) &amp; (z&gt;(x-0.5*y-1)^2-1)&quot;);
  gr-&gt;Box();  gr-&gt;Surf3(c); gr-&gt;CutOff(&quot;&quot;); // switch it off
  return 0;
}
</pre>
<div align="center"><img src="png/cut.png" alt="Example of point cutting">
</div>



<hr>
<a name="Data-handling"></a>
<div class="header">
<p>
Next: <a href="#Data-plotting" accesskey="n" rel="next">Data plotting</a>, Previous: <a href="#Advanced-usage" accesskey="p" rel="prev">Advanced usage</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Data-handling-1"></a>
<h3 class="section">2.3 Data handling</h3>


<p>Class <code>mglData</code> contains all functions for the data handling in MathGL (see <a href="#Data-processing">Data processing</a>). There are several matters why I use class <code>mglData</code> but not a single array: it does not depend on type of data (mreal or double), sizes of data arrays are kept with data, memory working is simpler and safer.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Array-creation" accesskey="1">Array creation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linking-array" accesskey="2">Linking array</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Change-data" accesskey="3">Change data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Array-creation"></a>
<div class="header">
<p>
Next: <a href="#Linking-array" accesskey="n" rel="next">Linking array</a>, Up: <a href="#Data-handling" accesskey="u" rel="up">Data handling</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Array-creation-1"></a>
<h4 class="subsection">2.3.1 Array creation</h4>


<p>There are many ways in MathGL how data arrays can be created and filled.
</p>
<p>One can put the data in <code>mglData</code> instance by several ways. Let us do it for sinus function:
</p><ul>
<li> one can create external array, fill it and put to <code>mglData</code> variable
<pre class="verbatim">  double *a = new double[50];
  for(int i=0;i&lt;50;i++)   a[i] = sin(M_PI*i/49.);

  mglData y;
  y.Set(a,50);
</pre>
</li><li> another way is to create <code>mglData</code> instance of the desired size and then to work directly with data in this variable
<pre class="verbatim">  mglData y(50);
  for(int i=0;i&lt;50;i++)   y.a[i] = sin(M_PI*i/49.);
</pre>
</li><li> next way is to fill the data in <code>mglData</code> instance by textual formula with the help of <code>Modify()</code> function
<pre class="verbatim">  mglData y(50);
  y.Modify(&quot;sin(pi*x)&quot;);
</pre>
</li><li> or one may fill the array in some interval and modify it later
<pre class="verbatim">  mglData y(50);
  y.Fill(0,M_PI);
  y.Modify(&quot;sin(u)&quot;);
</pre>
</li><li> finally it can be loaded from file
<pre class="verbatim">  FILE *fp=fopen(&quot;sin.dat&quot;,&quot;wt&quot;);   // create file first
  for(int i=0;i&lt;50;i++)   fprintf(fp,&quot;%g\n&quot;,sin(M_PI*i/49.));
  fclose(fp);

  mglData y(&quot;sin.dat&quot;);             // load it
</pre><p>At this you can use textual or HDF files, as well as import values from bitmap image (PNG is supported right now).
</p>
</li><li> at this one can read only part of data
<pre class="verbatim">  FILE *fp-fopen(&quot;sin.dat&quot;,&quot;wt&quot;);   // create large file first
  for(int i=0;i&lt;70;i++)   fprintf(fp,&quot;%g\n&quot;,sin(M_PI*i/49.));
  fclose(fp);

  mglData y;
  y.Read(&quot;sin.dat&quot;,50);             // load it
</pre></li></ul>

<p>Creation of 2d- and 3d-arrays is mostly the same. But one should keep in mind that class <code>mglData</code> uses flat data representation. For example, matrix 30*40 is presented as flat (1d-) array with length 30*40=1200 (nx=30, ny=40). The element with indexes {i,j} is a[i+nx*j]. So for 2d array we have:
</p><pre class="verbatim">  mglData z(30,40);
  for(int i=0;i&lt;30;i++)   for(int j=0;j&lt;40;j++)
    z.a[i+30*j] = sin(M_PI*i/29.)*sin(M_PI*j/39.);
</pre><p>or by using <code>Modify()</code> function
</p><pre class="verbatim">  mglData z(30,40);
  z.Modify(&quot;sin(pi*x)*cos(pi*y)&quot;);
</pre>
<p>The only non-obvious thing here is using multidimensional arrays in C/C++, i.e. arrays defined like <code>mreal dat[40][30];</code>. Since, formally these elements <code>dat[i]</code> can address the memory in arbitrary place you should use the proper function to convert such arrays to <code>mglData</code> object. For C++ this is functions like <code>mglData::Set(mreal **dat, int N1, int N2);</code>. For C this is functions like <code>mgl_data_set_mreal2(HMDT d, const mreal **dat, int N1, int N2);</code>. At this, you should keep in mind that <code>nx=N2</code> and <code>ny=N1</code> after conversion.
</p>

<hr>
<a name="Linking-array"></a>
<div class="header">
<p>
Next: <a href="#Change-data" accesskey="n" rel="next">Change data</a>, Previous: <a href="#Array-creation" accesskey="p" rel="prev">Array creation</a>, Up: <a href="#Data-handling" accesskey="u" rel="up">Data handling</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Linking-array-1"></a>
<h4 class="subsection">2.3.2 Linking array</h4>


<p>Sometimes the data arrays are so large, that one couldn&rsquo;t&rsquo; copy its values to another array (i.e. into mglData). In this case, he can define its own class derived from <code>mglDataA</code> (see <a href="#mglDataA-class">mglDataA class</a>) or can use <code>Link</code> function.
</p>
<p>In last case, MathGL just save the link to an external data array, but not copy it. You should provide the existence of this data array for whole time during which MathGL can use it. Another point is that MathGL will automatically create new array if you&rsquo;ll try to modify data values by any of <code>mglData</code> functions. So, you should use only function with <code>const</code> modifier if you want still using link to the original data array.
</p>
<p>Creating the link is rather simple &ndash; just the same as using <code>Set</code> function
</p><pre class="verbatim">  double *a = new double[50];
  for(int i=0;i&lt;50;i++)   a[i] = sin(M_PI*i/49.);

  mglData y;
  y.Link(a,50);
</pre>

<hr>
<a name="Change-data"></a>
<div class="header">
<p>
Previous: <a href="#Linking-array" accesskey="p" rel="prev">Linking array</a>, Up: <a href="#Data-handling" accesskey="u" rel="up">Data handling</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Change-data-1"></a>
<h4 class="subsection">2.3.3 Change data</h4>


<p>MathGL has functions for data processing: differentiating, integrating, smoothing and so on (for more detail, see <a href="#Data-processing">Data processing</a>). Let us consider some examples. The simplest ones are integration and differentiation. The direction in which operation will be performed is specified by textual string, which may contain symbols &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo; or &lsquo;<samp>z</samp>&rsquo;. For example, the call of <code>Diff(&quot;x&quot;)</code> will differentiate data along &lsquo;<samp>x</samp>&rsquo; direction; the call of <code>Integral(&quot;xy&quot;)</code> perform the double integration of data along &lsquo;<samp>x</samp>&rsquo; and &lsquo;<samp>y</samp>&rsquo; directions; the call of <code>Diff2(&quot;xyz&quot;)</code> will apply 3d Laplace operator to data and so on. Example of this operations on 2d array a=x*y is presented in code:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetRanges(0,1,0,1,0,1);
  mglData a(30,40); a.Modify(&quot;x*y&quot;);
  gr-&gt;SubPlot(2,2,0); gr-&gt;Rotate(60,40);
  gr-&gt;Surf(a);    gr-&gt;Box();
  gr-&gt;Puts(mglPoint(0.7,1,1.2),&quot;a(x,y)&quot;);
  gr-&gt;SubPlot(2,2,1); gr-&gt;Rotate(60,40);
  a.Diff(&quot;x&quot;);    gr-&gt;Surf(a);  gr-&gt;Box();
  gr-&gt;Puts(mglPoint(0.7,1,1.2),&quot;da/dx&quot;);
  gr-&gt;SubPlot(2,2,2); gr-&gt;Rotate(60,40);
  a.Integral(&quot;xy&quot;); gr-&gt;Surf(a);  gr-&gt;Box();
  gr-&gt;Puts(mglPoint(0.7,1,1.2),&quot;\\int da/dx dxdy&quot;);
  gr-&gt;SubPlot(2,2,3); gr-&gt;Rotate(60,40);
  a.Diff2(&quot;y&quot;); gr-&gt;Surf(a);  gr-&gt;Box();
  gr-&gt;Puts(mglPoint(0.7,1,1.2),&quot;\\int {d^2}a/dxdy dx&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/dat_diff.png" alt="Example of data differentiation and integration">
</div>
<p>Data smoothing (function <a href="#smooth">smooth</a>) is more interesting and important. This function has single argument which define type of smoothing and its direction. Now 3 methods are supported: &lsquo;<samp>3</samp>&rsquo; &ndash; linear averaging by 3 points, &lsquo;<samp>5</samp>&rsquo; &ndash; linear averaging by 5 points, and default one &ndash; quadratic averaging by 5 points.
</p>
<p>MathGL also have some amazing functions which is not so important for data processing as useful for data plotting. There are functions for finding envelope (useful for plotting rapidly oscillating data), for data sewing (useful to removing jumps on the phase), for data resizing (interpolation). Let me demonstrate it:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0,&quot;&quot;);  gr-&gt;Title(&quot;Envelop sample&quot;);
  mglData d1(1000); gr-&gt;Fill(d1,&quot;exp(-8*x^2)*sin(10*pi*x)&quot;);
  gr-&gt;Axis();     gr-&gt;Plot(d1, &quot;b&quot;);
  d1.Envelop('x');  gr-&gt;Plot(d1, &quot;r&quot;);

  gr-&gt;SubPlot(2,2,1,&quot;&quot;);  gr-&gt;Title(&quot;Smooth sample&quot;);
  mglData y0(30),y1,y2,y3;
  gr-&gt;SetRanges(0,1,0,1);
  gr-&gt;Fill(y0, &quot;0.4*sin(pi*x) + 0.3*cos(1.5*pi*x) - 0.4*sin(2*pi*x)+0.5*rnd&quot;);

  y1=y0;  y1.Smooth(&quot;x3&quot;);
  y2=y0;  y2.Smooth(&quot;x5&quot;);
  y3=y0;  y3.Smooth(&quot;x&quot;);

  gr-&gt;Plot(y0,&quot;{m7}:s&quot;, &quot;legend 'none'&quot;); //gr-&gt;AddLegend(&quot;none&quot;,&quot;k&quot;);
  gr-&gt;Plot(y1,&quot;r&quot;, &quot;legend ''3' style'&quot;);
  gr-&gt;Plot(y2,&quot;g&quot;, &quot;legend ''5' style'&quot;);
  gr-&gt;Plot(y3,&quot;b&quot;, &quot;legend 'default'&quot;);
  gr-&gt;Legend();   gr-&gt;Box();

  gr-&gt;SubPlot(2,2,2);   gr-&gt;Title(&quot;Sew sample&quot;);
  mglData d2(100, 100); gr-&gt;Fill(d2, &quot;mod((y^2-(1-x)^2)/2,0.1)&quot;);
  gr-&gt;Rotate(50, 60);   gr-&gt;Light(true);  gr-&gt;Alpha(true);
  gr-&gt;Box();            gr-&gt;Surf(d2, &quot;b&quot;);
  d2.Sew(&quot;xy&quot;, 0.1);  gr-&gt;Surf(d2, &quot;r&quot;);

  gr-&gt;SubPlot(2,2,3);   gr-&gt;Title(&quot;Resize sample (interpolation)&quot;);
  mglData x0(10), v0(10), x1, v1;
  gr-&gt;Fill(x0,&quot;rnd&quot;);     gr-&gt;Fill(v0,&quot;rnd&quot;);
  x1 = x0.Resize(100);    v1 = v0.Resize(100);
  gr-&gt;Plot(x0,v0,&quot;b+ &quot;);  gr-&gt;Plot(x1,v1,&quot;r-&quot;);
  gr-&gt;Label(x0,v0,&quot;%n&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/dat_extra.png" alt="Example of data smoothing">
</div>
<p>Also one can create new data arrays on base of the existing one: extract slice, row or column of data (<a href="#subdata">subdata</a>), summarize along a direction(s) (<a href="#sum">sum</a>), find distribution of data elements (<a href="#hist">hist</a>) and so on.
</p>
<a name="Solve-sample"></a><p>Another interesting feature of MathGL is interpolation and root-finding. There are several functions for linear and cubic spline interpolation (see <a href="#Interpolation">Interpolation</a>). Also there is a function <a href="#evaluate">evaluate</a> which do interpolation of data array for values of each data element of index data. It look as indirect access to the data elements.
</p>
<p>This function have inverse function <a href="#solve">solve</a> which find array of indexes at which data array is equal to given value (i.e. work as root finding). But <a href="#solve">solve</a> function have the issue &ndash; usually multidimensional data (2d and 3d ones) have an infinite number of indexes which give some value. This is contour lines for 2d data, or isosurface(s) for 3d data. So, <a href="#solve">solve</a> function will return index only in given direction, assuming that other index(es) are the same as equidistant index(es) of original data. If data have multiple roots then second (and later) branches can be found by consecutive call(s) of <a href="#solve">solve</a> function. Let me demonstrate this on the following sample.
</p>
<pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetRange('z',0,1);
  mglData x(20,30), y(20,30), z(20,30), xx,yy,zz;
  gr-&gt;Fill(x,&quot;(x+2)/3*cos(pi*y)&quot;);
  gr-&gt;Fill(y,&quot;(x+2)/3*sin(pi*y)&quot;);
  gr-&gt;Fill(z,&quot;exp(-6*x^2-2*sin(pi*y)^2)&quot;);

  gr-&gt;SubPlot(2,1,0); gr-&gt;Title(&quot;Cartesian space&quot;);   gr-&gt;Rotate(30,-40);
  gr-&gt;Axis(&quot;xyzU&quot;);   gr-&gt;Box();  gr-&gt;Label('x',&quot;x&quot;); gr-&gt;Label('y',&quot;y&quot;);
  gr-&gt;SetOrigin(1,1); gr-&gt;Grid(&quot;xy&quot;);
  gr-&gt;Mesh(x,y,z);

  // section along 'x' direction
  mglData u = x.Solve(0.5,'x');
  mglData v(u.nx);  v.Fill(0,1);
  xx = x.Evaluate(u,v);   yy = y.Evaluate(u,v);   zz = z.Evaluate(u,v);
  gr-&gt;Plot(xx,yy,zz,&quot;k2o&quot;);

  // 1st section along 'y' direction
  mglData u1 = x.Solve(-0.5,'y');
  mglData v1(u1.nx);  v1.Fill(0,1);
  xx = x.Evaluate(v1,u1); yy = y.Evaluate(v1,u1); zz = z.Evaluate(v1,u1);
  gr-&gt;Plot(xx,yy,zz,&quot;b2^&quot;);

  // 2nd section along 'y' direction
  mglData u2 = x.Solve(-0.5,'y',u1);
  xx = x.Evaluate(v1,u2); yy = y.Evaluate(v1,u2); zz = z.Evaluate(v1,u2);
  gr-&gt;Plot(xx,yy,zz,&quot;r2v&quot;);

  gr-&gt;SubPlot(2,1,1); gr-&gt;Title(&quot;Accompanied space&quot;);
  gr-&gt;SetRanges(0,1,0,1); gr-&gt;SetOrigin(0,0);
  gr-&gt;Axis(); gr-&gt;Box();  gr-&gt;Label('x',&quot;i&quot;); gr-&gt;Label('y',&quot;j&quot;);
  gr-&gt;Grid(z,&quot;h&quot;);

  gr-&gt;Plot(u,v,&quot;k2o&quot;);    gr-&gt;Line(mglPoint(0.4,0.5),mglPoint(0.8,0.5),&quot;kA&quot;);
  gr-&gt;Plot(v1,u1,&quot;b2^&quot;);  gr-&gt;Line(mglPoint(0.5,0.15),mglPoint(0.5,0.3),&quot;bA&quot;);
  gr-&gt;Plot(v1,u2,&quot;r2v&quot;);  gr-&gt;Line(mglPoint(0.5,0.7),mglPoint(0.5,0.85),&quot;rA&quot;);
}
</pre>
<div align="center"><img src="png/solve.png" alt="Example of data interpolation and root finding">
</div>

<hr>
<a name="Data-plotting"></a>
<div class="header">
<p>
Next: <a href="#Hints" accesskey="n" rel="next">Hints</a>, Previous: <a href="#Data-handling" accesskey="p" rel="prev">Data handling</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Data-plotting-1"></a>
<h3 class="section">2.4 Data plotting</h3>


<p>Let me now show how to plot the data. Next section will give much more examples for all plotting functions. Here I just show some basics. MathGL generally has 2 types of plotting functions. Simple variant requires a single data array for plotting, other data (coordinates) are considered uniformly distributed in axis range. Second variant requires data arrays for all coordinates. It allows one to plot rather complex multivalent curves and surfaces (in case of parametric dependencies). Usually each function have one textual argument for plot style and another textual argument for options (see <a href="#Command-options">Command options</a>).
</p>
<p>Note, that the call of drawing function adds something to picture but does not clear the previous plots (as it does in Matlab). Another difference from Matlab is that all setup (like transparency, lightning, axis borders and so on) must be specified <strong>before</strong> plotting functions.
</p>
<p>Let start for plots for 1D data. Term &ldquo;1D data&rdquo; means that data depend on single index (parameter) like curve in parametric form {x(i),y(i),z(i)}, i=1...n. The textual argument allow you specify styles of line and marks (see <a href="#Line-styles">Line styles</a>). If this parameter is <code>NULL</code> or empty then solid line with color from palette is used (see <a href="#Palette-and-colors">Palette and colors</a>).
</p>
<p>Below I shall show the features of 1D plotting on base of <a href="#plot">plot</a> function. Let us start from sinus plot:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData y0(50); 	y0.Modify(&quot;sin(pi*(2*x-1))&quot;);
  gr-&gt;SubPlot(2,2,0);
  gr-&gt;Plot(y0);   	gr-&gt;Box();
</pre><p>Style of line is not specified in <a href="#plot">plot</a> function. So MathGL uses the solid line with first color of palette (this is blue). Next subplot shows array <var>y1</var> with 2 rows:
</p><pre class="verbatim">  gr-&gt;SubPlot(2,2,1);
  mglData y1(50,2);
  y1.Modify(&quot;sin(pi*2*x-pi)&quot;);
  y1.Modify(&quot;cos(pi*2*x-pi)/2&quot;,1);
  gr-&gt;Plot(y1);   	gr-&gt;Box();
</pre><p>As previously I did not specify the style of lines. As a result, MathGL again uses solid line with next colors in palette (there are green and red). Now let us plot a circle on the same subplot. The circle is parametric curve <em>x=cos(\pi t), y=sin(\pi t)</em>. I will set the color of the circle (dark yellow, &lsquo;<samp>Y</samp>&rsquo;) and put marks &lsquo;<samp>+</samp>&rsquo; at point position:
</p><pre class="verbatim">  mglData x(50);  	x.Modify(&quot;cos(pi*2*x-pi)&quot;);
  gr-&gt;Plot(x,y0,&quot;Y+&quot;);
</pre><p>Note that solid line is used because I did not specify the type of line. The same picture can be achieved by <a href="#plot">plot</a> and <a href="#subdata">subdata</a> functions. Let us draw ellipse by orange dash line:
</p><pre class="verbatim">  gr-&gt;Plot(y1.SubData(-1,0),y1.SubData(-1,1),&quot;q|&quot;);
</pre>
<p>Drawing in 3D space is mostly the same. Let us draw spiral with default line style. Now its color is 4-th color from palette (this is cyan):
</p><pre class="verbatim">  gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(60,40);
  mglData z(50);  	z.Modify(&quot;2*x-1&quot;);
  gr-&gt;Plot(x,y0,z);	gr-&gt;Box();
</pre><p>Functions <a href="#plot">plot</a> and <a href="#subdata">subdata</a> make 3D curve plot but for single array. Use it to put circle marks on the previous plot:
</p><pre class="verbatim">  mglData y2(10,3);	y2.Modify(&quot;cos(pi*(2*x-1+y))&quot;);
  y2.Modify(&quot;2*x-1&quot;,2);
  gr-&gt;Plot(y2.SubData(-1,0),y2.SubData(-1,1),y2.SubData(-1,2),&quot;bo &quot;);
</pre><p>Note that line style is empty &lsquo;<samp> </samp>&rsquo; here. Usage of other 1D plotting functions looks similar:
</p><pre class="verbatim">  gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(60,40);
  gr-&gt;Bars(x,y0,z,&quot;r&quot;);	gr-&gt;Box();
  return 0;
}
</pre>
<p>Surfaces <a href="#surf">surf</a> and other 2D plots (see <a href="#g_t2D-plotting">2D plotting</a>) are drown the same simpler as 1D one. The difference is that the string parameter specifies not the line style but the color scheme of the plot (see <a href="#Color-scheme">Color scheme</a>). Here I draw attention on 4 most interesting color schemes. There is gray scheme where color is changed from black to white (string &lsquo;<samp>kw</samp>&rsquo;) or from white to black (string &lsquo;<samp>wk</samp>&rsquo;). Another scheme is useful for accentuation of negative (by blue color) and positive (by red color) regions on plot (string &lsquo;<samp>&quot;BbwrR&quot;</samp>&rsquo;). Last one is the popular &ldquo;jet&rdquo; scheme (string &lsquo;<samp>&quot;BbcyrR&quot;</samp>&rsquo;).
</p>
<p>Now I shall show the example of a surface drawing. At first let us switch lightning on
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Light(true);	gr-&gt;Light(0,mglPoint(0,0,1));
</pre><p>and draw the surface, considering coordinates x,y to be uniformly distributed in axis range
</p><pre class="verbatim">  mglData a0(50,40);
  a0.Modify(&quot;0.6*sin(2*pi*x)*sin(3*pi*y)+0.4*cos(3*pi*(x*y))&quot;);
  gr-&gt;SubPlot(2,2,0);	gr-&gt;Rotate(60,40);
  gr-&gt;Surf(a0);		gr-&gt;Box();
</pre><p>Color scheme was not specified. So previous color scheme is used. In this case it is default color scheme (&ldquo;jet&rdquo;) for the first plot. Next example is a sphere. The sphere is parametrically specified surface:
</p><pre class="verbatim">  mglData x(50,40),y(50,40),z(50,40);
  x.Modify(&quot;0.8*sin(2*pi*x)*sin(pi*y)&quot;);
  y.Modify(&quot;0.8*cos(2*pi*x)*sin(pi*y)&quot;);
  z.Modify(&quot;0.8*cos(pi*y)&quot;);
  gr-&gt;SubPlot(2,2,1);	gr-&gt;Rotate(60,40);
  gr-&gt;Surf(x,y,z,&quot;BbwrR&quot;);gr-&gt;Box();
</pre><p>I set color scheme to <code>&quot;BbwrR&quot;</code> that corresponds to red top and blue bottom of the sphere.
</p>
<p>Surfaces will be plotted for each of slice of the data if <var>nz</var>&gt;1. Next example draws surfaces for data arrays with <var>nz</var>=3:
</p><pre class="verbatim">  mglData a1(50,40,3);
  a1.Modify(&quot;0.6*sin(2*pi*x)*sin(3*pi*y)+0.4*cos(3*pi*(x*y))&quot;);
  a1.Modify(&quot;0.6*cos(2*pi*x)*cos(3*pi*y)+0.4*sin(3*pi*(x*y))&quot;,1);
  a1.Modify(&quot;0.6*cos(2*pi*x)*cos(3*pi*y)+0.4*cos(3*pi*(x*y))&quot;,2);
  gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(60,40);
  gr-&gt;Alpha(true);
  gr-&gt;Surf(a1);		gr-&gt;Box();
</pre><p>Note, that it may entail a confusion. However, if one will use density plot then the picture will look better:
</p><pre class="verbatim">  gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(60,40);
  gr-&gt;Dens(a1);		gr-&gt;Box();
  return 0;
}
</pre>
<p>Drawing of other 2D plots is analogous. The only peculiarity is the usage of flag &lsquo;<samp>#</samp>&rsquo;. By default this flag switches on the drawing of a grid on plot (<a href="#grid">grid</a> or <a href="#mesh">mesh</a> for plots in plain or in volume). However, for isosurfaces (including surfaces of rotation <a href="#axial">axial</a>) this flag switches the  face drawing off. Figure becomes wired. The following code gives example of flag &lsquo;<samp>#</samp>&rsquo; using (compare with normal function drawing as in its description):
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Alpha(true);	gr-&gt;Light(true);	gr-&gt;Light(0,mglPoint(0,0,1));
  mglData a(30,20);
  a.Modify(&quot;0.6*sin(2*pi*x)*sin(3*pi*y) + 0.4*cos(3*pi*(x*y))&quot;);

  gr-&gt;SubPlot(2,2,0);	gr-&gt;Rotate(40,60);
  gr-&gt;Surf(a,&quot;BbcyrR#&quot;);		gr-&gt;Box();
  gr-&gt;SubPlot(2,2,1);	gr-&gt;Rotate(40,60);
  gr-&gt;Dens(a,&quot;BbcyrR#&quot;);		gr-&gt;Box();
  gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(40,60);
  gr-&gt;Cont(a,&quot;BbcyrR#&quot;);		gr-&gt;Box();
  gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(40,60);
  gr-&gt;Axial(a,&quot;BbcyrR#&quot;);		gr-&gt;Box();
  return 0;
}
</pre>

<hr>
<a name="Hints"></a>
<div class="header">
<p>
Next: <a href="#FAQ" accesskey="n" rel="next">FAQ</a>, Previous: <a href="#Data-plotting" accesskey="p" rel="prev">Data plotting</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Hints-1"></a>
<h3 class="section">2.5 Hints</h3>


<p>In this section I&rsquo;ve included some small hints and advices for the improving of the quality of plots and for the demonstration of some non-trivial features of MathGL library. In contrast to previous examples I showed mostly the idea but not the whole drawing function.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#g_t_0060_0060Compound_0027_0027-graphics" accesskey="1">``Compound'' graphics</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Transparency-and-lighting" accesskey="2">Transparency and lighting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Types-of-transparency" accesskey="3">Types of transparency</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Axis-projection" accesskey="4">Axis projection</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Adding-fog" accesskey="5">Adding fog</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Lighting-sample" accesskey="6">Lighting sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-primitives" accesskey="7">Using primitives</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#STFA-sample" accesskey="8">STFA sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mapping-visualization" accesskey="9">Mapping visualization</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-interpolation">Data interpolation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Making-regular-data">Making regular data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Making-histogram">Making histogram</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nonlinear-fitting-hints">Nonlinear fitting hints</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PDE-solving-hints">PDE solving hints</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Drawing-phase-plain">Drawing phase plain</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-MGL-parser">Using MGL parser</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Pulse-properties">Pulse properties</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-options">Using options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0060_0060Templates_0027_0027">``Templates''</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Stereo-image">Stereo image</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reduce-memory-usage">Reduce memory usage</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Saving-and-scanning-file">Saving and scanning file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mixing-bitmap-and-vector-output">Mixing bitmap and vector output</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="g_t_0060_0060Compound_0027_0027-graphics"></a>
<div class="header">
<p>
Next: <a href="#Transparency-and-lighting" accesskey="n" rel="next">Transparency and lighting</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="g_t_0060_0060Compound_0027_0027-graphics-1"></a>
<h4 class="subsection">2.5.1 &ldquo;Compound&rdquo; graphics</h4>


<p>As I noted above, MathGL functions (except the special one, like Clf()) do  not erase the previous plotting but just add the new one. It allows one to draw &ldquo;compound&rdquo; plots easily. For example, popular Matlab command <code>surfc</code> can be emulated in MathGL by 2 calls:
</p><pre class="verbatim">  Surf(a);
  Cont(a, &quot;_&quot;);     // draw contours at bottom
</pre><p>Here <var>a</var> is 2-dimensional data for the plotting, <code>-1</code> is the value of z-coordinate at which the contour should be plotted (at the bottom in this example). Analogously, one can draw density plot instead of contour lines and so on.
</p>
<p>Another nice plot is contour lines plotted directly on the surface:
</p><pre class="verbatim">  Light(true);       // switch on light for the surface
  Surf(a, &quot;BbcyrR&quot;); // select 'jet' colormap for the surface
  Cont(a, &quot;y&quot;);      // and yellow color for contours
</pre><p>The possible difficulties arise in black&amp;white case, when the color of the surface can be close to the color of a contour line. In that case I may suggest the following code:
</p><pre class="verbatim">  Light(true);   // switch on light for the surface
  Surf(a, &quot;kw&quot;); // select 'gray' colormap for the surface
  CAxis(-1,0);   // first draw for darker surface colors
  Cont(a, &quot;w&quot;);  // white contours
  CAxis(0,1);    // now draw for brighter surface colors
  Cont(a, &quot;k&quot;);  // black contours
  CAxis(-1,1);   // return color range to original state
</pre><p>The idea is to divide the color range on 2 parts (dark and bright) and to select the contrasting color for contour lines for each of part.
</p>
<p>Similarly, one can plot flow thread over density plot of vector field amplitude (this is another amusing plot from Matlab) and so on. The list of compound graphics can be prolonged but I hope that the general idea is clear.
</p>
<p>Just for illustration I put here following sample code:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a,b,d;  mgls_prepare2v(&amp;a,&amp;b);  d = a;
  for(int i=0;i&lt;a.nx*a.ny;i++)  d.a[i] = hypot(a.a[i],b.a[i]);
  mglData c;  mgls_prepare3d(&amp;c);
  mglData v(10);  v.Fill(-0.5,1);

  gr-&gt;SubPlot(2,2,1,&quot;&quot;);  gr-&gt;Title(&quot;Flow + Dens&quot;);
  gr-&gt;Flow(a,b,&quot;br&quot;); gr-&gt;Dens(d,&quot;BbcyrR&quot;); gr-&gt;Box();

  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Surf + Cont&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;Light(true);  gr-&gt;Surf(a);  gr-&gt;Cont(a,&quot;y&quot;);  gr-&gt;Box();

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;Mesh + Cont&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Mesh(a);  gr-&gt;Cont(a,&quot;_&quot;);

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;Surf3 + ContF3&quot;);gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;ContF3(v,c,&quot;z&quot;,0);  gr-&gt;ContF3(v,c,&quot;x&quot;);  gr-&gt;ContF3(v,c);
  gr-&gt;SetCutBox(mglPoint(0,-1,-1), mglPoint(1,0,1.1));
  gr-&gt;ContF3(v,c,&quot;z&quot;,c.nz-1); gr-&gt;Surf3(-0.5,c);
  return 0;
}
</pre>
<div align="center"><img src="png/combined.png" alt="Example of &ldquo;combined&rdquo; plots">
</div>

<hr>
<a name="Transparency-and-lighting"></a>
<div class="header">
<p>
Next: <a href="#Types-of-transparency" accesskey="n" rel="next">Types of transparency</a>, Previous: <a href="#g_t_0060_0060Compound_0027_0027-graphics" accesskey="p" rel="prev">``Compound'' graphics</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Transparency-and-lighting-1"></a>
<h4 class="subsection">2.5.2 Transparency and lighting</h4>


<p>Here I want to show how transparency and lighting both and separately change the look of a surface. So, there is code and picture for that:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&amp;a);
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;default&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;light on&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Light(true);  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;alpha on; light on&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Alpha(true);  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;alpha on&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;Box();  gr-&gt;Light(false); gr-&gt;Surf(a);
  return 0;
}
</pre>
<div align="center"><img src="png/alpha.png" alt="Example of transparency and lightings">
</div>

<hr>
<a name="Types-of-transparency"></a>
<div class="header">
<p>
Next: <a href="#Axis-projection" accesskey="n" rel="next">Axis projection</a>, Previous: <a href="#Transparency-and-lighting" accesskey="p" rel="prev">Transparency and lighting</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Types-of-transparency-1"></a>
<h4 class="subsection">2.5.3 Types of transparency</h4>


<p>MathGL library has advanced features for setting and handling the surface transparency. The simplest way to add transparency is the using of function <a href="#alpha">alpha</a>. As a result, all further surfaces (and isosurfaces, density plots and so on) become transparent. However, their  look can be additionally improved.
</p>
<p>The value of transparency can be different from surface to surface. To do it just use <code>SetAlphaDef</code> before the drawing of the surface, or use option <code>alpha</code> (see <a href="#Command-options">Command options</a>). If its value is close to 0 then the surface becomes more and more transparent. Contrary, if its value is close to 1 then the surface becomes practically non-transparent.
</p>
<p>Also you can change the way how the light goes through overlapped surfaces. The function <code>SetTranspType</code> defines it. By default the usual transparency is used (&lsquo;<samp>0</samp>&rsquo;) &ndash; surfaces below is less visible than the upper ones. A &ldquo;glass-like&rdquo; transparency (&lsquo;<samp>1</samp>&rsquo;) has a different look &ndash; each surface just decreases the background light (the surfaces are commutable in this case).
</p>
<p>A &ldquo;neon-like&rdquo; transparency (&lsquo;<samp>2</samp>&rsquo;) has more interesting look. In this case a surface is the light source (like a lamp on the dark background) and just adds some intensity to the color. At this, the library sets automatically the black color for the background and changes the default line color to white.
</p>
<p>As example I shall show several plots for different types of transparency. The code is the same except the values of <code>SetTranspType</code> function:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Alpha(true);  gr-&gt;Light(true);
  mglData a;  mgls_prepare2d(&amp;a);
  gr-&gt;SetTranspType(0); gr-&gt;Clf();
  gr-&gt;SubPlot(2,2,0); gr-&gt;Rotate(50,60);  gr-&gt;Surf(a);  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,1); gr-&gt;Rotate(50,60);  gr-&gt;Dens(a);  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,2); gr-&gt;Rotate(50,60);  gr-&gt;Cont(a);  gr-&gt;Box();
  gr-&gt;SubPlot(2,2,3); gr-&gt;Rotate(50,60);  gr-&gt;Axial(a); gr-&gt;Box();
  return 0;
}
</pre>
<div align="center"><img src="png/type0.png" alt="Example of SetTranspType(0).">
</div><div align="center"><img src="png/type1.png" alt="Example of SetTranspType(1).">
</div><div align="center"><img src="png/type2.png" alt="Example of SetTranspType(2).">
</div>


<hr>
<a name="Axis-projection"></a>
<div class="header">
<p>
Next: <a href="#Adding-fog" accesskey="n" rel="next">Adding fog</a>, Previous: <a href="#Types-of-transparency" accesskey="p" rel="prev">Types of transparency</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Axis-projection-1"></a>
<h4 class="subsection">2.5.4 Axis projection</h4>


<p>You can easily make 3D plot and draw its x-,y-,z-projections (like in CAD) by using <a href="#ternary">ternary</a> function with arguments: 4 for Cartesian, 5 for Ternary and 6 for Quaternary coordinates. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetRanges(0,1,0,1,0,1);
  mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
  a.Modify(&quot;30*x*y*(1-x-y)^2*(x+y&lt;1)&quot;);
  x.Modify(&quot;0.25*(1+cos(2*pi*x))&quot;);
  y.Modify(&quot;0.25*(1+sin(2*pi*x))&quot;);
  rx.Modify(&quot;rnd&quot;); ry.Modify(&quot;(1-v)*rnd&quot;,rx);
  z.Modify(&quot;x&quot;);

  gr-&gt;Title(&quot;Projection sample&quot;);
  gr-&gt;Ternary(4);
  gr-&gt;Rotate(50,60);      gr-&gt;Light(true);
  gr-&gt;Plot(x,y,z,&quot;r2&quot;);   gr-&gt;Surf(a,&quot;#&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(); gr-&gt;Box();
  gr-&gt;Label('x',&quot;X&quot;,1);   gr-&gt;Label('y',&quot;Y&quot;,1);   gr-&gt;Label('z',&quot;Z&quot;,1);
}
</pre>
<div align="center"><img src="png/projection.png" alt="Example of axis projections">
</div><div align="center"><img src="png/projection5.png" alt="Example of ternary axis projections">
</div>

<hr>
<a name="Adding-fog"></a>
<div class="header">
<p>
Next: <a href="#Lighting-sample" accesskey="n" rel="next">Lighting sample</a>, Previous: <a href="#Axis-projection" accesskey="p" rel="prev">Axis projection</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Adding-fog-1"></a>
<h4 class="subsection">2.5.5 Adding fog</h4>


<p>MathGL can add a fog to the image. Its switching on is rather simple &ndash; just use <a href="#fog">fog</a> function. There is the only feature &ndash; fog is applied for whole image. Not to particular subplot. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&amp;a);
  gr-&gt;Title(&quot;Fog sample&quot;);
  gr-&gt;Light(true);  gr-&gt;Rotate(50,60);  gr-&gt;Fog(1); gr-&gt;Box();
  gr-&gt;Surf(a);  gr-&gt;Cont(a,&quot;y&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/fog.png" alt="Example of Fog().">
</div>

<hr>
<a name="Lighting-sample"></a>
<div class="header">
<p>
Next: <a href="#Using-primitives" accesskey="n" rel="next">Using primitives</a>, Previous: <a href="#Adding-fog" accesskey="p" rel="prev">Adding fog</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Lighting-sample-1"></a>
<h4 class="subsection">2.5.6 Lighting sample</h4>


<p>In contrast to the most of other programs, MathGL supports several (up to 10) light sources. Moreover, the color each of them can be different: white (this is usual), yellow, red, cyan, green and so on. The use of several light sources may be interesting for the highlighting of some peculiarities of the plot or just to make an amusing picture. Note, each light source can be switched on/off individually. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&amp;a);
  gr-&gt;Title(&quot;Several light sources&quot;);
  gr-&gt;Rotate(50,60);  gr-&gt;Light(true);
  gr-&gt;AddLight(1,mglPoint(0,1,0),'c');
  gr-&gt;AddLight(2,mglPoint(1,0,0),'y');
  gr-&gt;AddLight(3,mglPoint(0,-1,0),'m');
  gr-&gt;Box();  gr-&gt;Surf(a,&quot;h&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/several_light.png" alt="Example of several light sources.">
</div>
<p>Additionally, you can use local light sources and set to use <a href="#diffuse">diffuse</a> reflection instead of specular one (by default) or both kinds. Note, I use <a href="#attachlight">attachlight</a> command to keep light settings relative to subplot.
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Light(true);  gr-&gt;AttachLight(true);
  gr-&gt;SubPlot(2,2,0); gr-&gt;Title(&quot;Default&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;Line(mglPoint(-1,-0.7,1.7),mglPoint(-1,-0.7,0.7),&quot;BA&quot;); gr-&gt;Box();  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,1); gr-&gt;Title(&quot;Local&quot;);   gr-&gt;Rotate(50,60);
  gr-&gt;AddLight(0,mglPoint(1,0,1),mglPoint(-2,-1,-1));
  gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);  gr-&gt;Box();  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;no diffuse&quot;); gr-&gt;Rotate(50,60);
  gr-&gt;SetDiffuse(0);
  gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);  gr-&gt;Box();  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;diffusive only&quot;);  gr-&gt;Rotate(50,60);
  gr-&gt;SetDiffuse(0.5);
  gr-&gt;AddLight(0,mglPoint(1,0,1),mglPoint(-2,-1,-1),'w',0);
  gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);  gr-&gt;Box();  gr-&gt;Surf(a);
}
</pre>
<div align="center"><img src="png/light.png" alt="Example of different types of lighting.">
</div>

<hr>
<a name="Using-primitives"></a>
<div class="header">
<p>
Next: <a href="#STFA-sample" accesskey="n" rel="next">STFA sample</a>, Previous: <a href="#Lighting-sample" accesskey="p" rel="prev">Lighting sample</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Using-primitives-1"></a>
<h4 class="subsection">2.5.7 Using primitives</h4>


<p>MathGL provide a set of functions for drawing primitives (see <a href="#Primitives">Primitives</a>). Primitives are low level object, which used by most of plotting functions. Picture below demonstrate some of commonly used primitives.
</p>
<div align="center"><img src="png/primitives.png" alt="Primitives in MathGL.">
</div>
<p>Generally, you can create arbitrary new kind of plot using primitives. For example, MathGL don&rsquo;t provide any special functions for drawing molecules. However, you can do it using only one type of primitives <a href="#drop">drop</a>. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Alpha(true);  gr-&gt;Light(true);

  gr-&gt;SubPlot(2,2,0,&quot;&quot;);  gr-&gt;Title(&quot;Methane, CH_4&quot;);
  gr-&gt;StartGroup(&quot;Methane&quot;);
  gr-&gt;Rotate(60,120);
  gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;k&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0,0,1),0.35,&quot;h&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0,0,0.7),0.25,&quot;g&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(-0.94,0,-0.33),0.35,&quot;h&quot;,1,2);
  gr-&gt;Sphere(mglPoint(-0.66,0,-0.23),0.25,&quot;g&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.47,0.82,-0.33),0.35,&quot;h&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0.33,0.57,-0.23),0.25,&quot;g&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.47,-0.82,-0.33),0.35,&quot;h&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0.33,-0.57,-0.23),0.25,&quot;g&quot;);
  gr-&gt;EndGroup();

  gr-&gt;SubPlot(2,2,1,&quot;&quot;);  gr-&gt;Title(&quot;Water, H_{2}O&quot;);
  gr-&gt;StartGroup(&quot;Water&quot;);
  gr-&gt;Rotate(60,100);
  gr-&gt;StartGroup(&quot;Water_O&quot;);
  gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;r&quot;);
  gr-&gt;EndGroup();
  gr-&gt;StartGroup(&quot;Water_Bond_1&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.3,0.5,0),0.3,&quot;m&quot;,1,2);
  gr-&gt;EndGroup();
  gr-&gt;StartGroup(&quot;Water_H_1&quot;);
  gr-&gt;Sphere(mglPoint(0.3,0.5,0),0.25,&quot;g&quot;);
  gr-&gt;EndGroup();
  gr-&gt;StartGroup(&quot;Water_Bond_2&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.3,-0.5,0),0.3,&quot;m&quot;,1,2);
  gr-&gt;EndGroup();
  gr-&gt;StartGroup(&quot;Water_H_2&quot;);
  gr-&gt;Sphere(mglPoint(0.3,-0.5,0),0.25,&quot;g&quot;);
  gr-&gt;EndGroup();
  gr-&gt;EndGroup();

  gr-&gt;SubPlot(2,2,2,&quot;&quot;);  gr-&gt;Title(&quot;Oxygen, O_2&quot;);
  gr-&gt;StartGroup(&quot;Oxygen&quot;);
  gr-&gt;Rotate(60,120);
  gr-&gt;Drop(mglPoint(0,0.5,0),mglPoint(0,-0.3,0),0.3,&quot;m&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0,0.5,0),0.25,&quot;r&quot;);
  gr-&gt;Drop(mglPoint(0,-0.5,0),mglPoint(0,0.3,0),0.3,&quot;m&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0,-0.5,0),0.25,&quot;r&quot;);
  gr-&gt;EndGroup();

  gr-&gt;SubPlot(2,2,3,&quot;&quot;);  gr-&gt;Title(&quot;Ammonia, NH_3&quot;);
  gr-&gt;StartGroup(&quot;Ammonia&quot;);
  gr-&gt;Rotate(60,120);
  gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;b&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.33,0.57,0),0.32,&quot;n&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0.33,0.57,0),0.25,&quot;g&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.33,-0.57,0),0.32,&quot;n&quot;,1,2);
  gr-&gt;Sphere(mglPoint(0.33,-0.57,0),0.25,&quot;g&quot;);
  gr-&gt;Drop(mglPoint(0,0,0),mglPoint(-0.65,0,0),0.32,&quot;n&quot;,1,2);
  gr-&gt;Sphere(mglPoint(-0.65,0,0),0.25,&quot;g&quot;);
  gr-&gt;EndGroup();
  return 0;
}
</pre>
<div align="center"><img src="png/molecule.png" alt="Example of molecules drawing.">
</div>
<p>Moreover, some of special plots can be more easily produced by primitives rather than by specialized function. For example, Venn diagram can be produced by <code>Error</code> plot:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  double xx[3]={-0.3,0,0.3}, yy[3]={0.3,-0.3,0.3}, ee[3]={0.7,0.7,0.7};
  mglData x(3,xx), y(3,yy), e(3,ee);
  gr-&gt;Title(&quot;Venn-like diagram&quot;); gr-&gt;Alpha(true);
  gr-&gt;Error(x,y,e,e,&quot;!rgb@#o&quot;);
  return 0;
}
</pre><p>You see that you have to specify and fill 3 data arrays. The same picture can be produced by just 3 calls of <a href="#circle">circle</a> function:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Title(&quot;Venn-like diagram&quot;); gr-&gt;Alpha(true);
  gr-&gt;Circle(mglPoint(-0.3,0.3),0.7,&quot;rr@&quot;);
  gr-&gt;Circle(mglPoint(0,-0.3),0.7,&quot;gg@&quot;);
  gr-&gt;Circle(mglPoint( 0.3,0.3),0.7,&quot;bb@&quot;);
  return 0;
}
</pre><p>Of course, the first variant is more suitable if you need to plot a lot of circles. But for few ones the usage of primitives looks easy.
</p>
<div align="center"><img src="png/venn.png" alt="Example of Venn diagram.">
</div>

<hr>
<a name="STFA-sample"></a>
<div class="header">
<p>
Next: <a href="#Mapping-visualization" accesskey="n" rel="next">Mapping visualization</a>, Previous: <a href="#Using-primitives" accesskey="p" rel="prev">Using primitives</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="STFA-sample-1"></a>
<h4 class="subsection">2.5.8 STFA sample</h4>


<p>Short-time Fourier Analysis (<a href="#stfa">stfa</a>) is one of informative method for analyzing long rapidly oscillating 1D data arrays. It is used to determine the sinusoidal frequency and phase content of local sections of a signal as it changes over time.
</p>
<p>MathGL can find and draw STFA result. Just to show this feature I give following sample. Initial data arrays is 1D arrays with step-like frequency. Exactly this you can see at bottom on the STFA plot. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a(2000), b(2000);
  gr-&gt;Fill(a,&quot;cos(50*pi*x)*(x&lt;-.5)+cos(100*pi*x)*(x&lt;0)*(x&gt;-.5)+\
  cos(200*pi*x)*(x&lt;.5)*(x&gt;0)+cos(400*pi*x)*(x&gt;.5)&quot;);
  gr-&gt;SubPlot(1, 2, 0,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Initial signal&quot;);
  gr-&gt;Plot(a);
  gr-&gt;Axis();
  gr-&gt;Label('x', &quot;\\i t&quot;);

  gr-&gt;SubPlot(1, 2, 1,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;STFA plot&quot;);
  gr-&gt;STFA(a, b, 64);
  gr-&gt;Axis();
  gr-&gt;Label('x', &quot;\\i t&quot;);
  gr-&gt;Label('y', &quot;\\omega&quot;, 0);
  return 0;
}
</pre>
<div align="center"><img src="png/stfa.png" alt="Example of STFA().">
</div>

<hr>
<a name="Mapping-visualization"></a>
<div class="header">
<p>
Next: <a href="#Data-interpolation" accesskey="n" rel="next">Data interpolation</a>, Previous: <a href="#STFA-sample" accesskey="p" rel="prev">STFA sample</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Mapping-visualization-1"></a>
<h4 class="subsection">2.5.9 Mapping visualization</h4>


<p>Sometime ago I worked with mapping and have a question about its visualization. Let me remember you that mapping is some transformation rule for one set of number to another one. The 1d mapping is just an ordinary function &ndash; it takes a number and transforms it to another one. The 2d mapping (which I used) is a pair of functions which take 2 numbers and transform them to another 2 ones. Except general plots (like <a href="#surfc">surfc</a>, <a href="#surfa">surfa</a>) there is a special plot &ndash; Arnold diagram. It shows the area which is the result of mapping of some initial area (usually square).
</p>
<p>I tried to make such plot in <a href="#map">map</a>. It shows the set of points or set of faces, which final position is the result of mapping. At this, the color gives information about their initial position and the height describes Jacobian value of the transformation. Unfortunately, it looks good only for the simplest mapping but for the  real multivalent quasi-chaotic mapping it produces a confusion. So, use it if you like :).
</p>
<p>The sample code for mapping visualization is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a(50, 40), b(50, 40);
  gr-&gt;Puts(mglPoint(0, 0), &quot;\\to&quot;, &quot;:C&quot;, -1.4);
  gr-&gt;SetRanges(-1,1,-1,1,-2,2);

  gr-&gt;SubPlot(2, 1, 0);
  gr-&gt;Fill(a,&quot;x&quot;);  gr-&gt;Fill(b,&quot;y&quot;);
  gr-&gt;Puts(mglPoint(0, 1.1), &quot;\\{x, y\\}&quot;, &quot;:C&quot;, -2);   gr-&gt;Box();
  gr-&gt;Map(a, b, &quot;brgk&quot;);

  gr-&gt;SubPlot(2, 1, 1);
  gr-&gt;Fill(a,&quot;(x^3+y^3)/2&quot;);  gr-&gt;Fill(b,&quot;(x-y)/2&quot;);
  gr-&gt;Puts(mglPoint(0, 1.1), &quot;\\{\\frac{x^3+y^3}{2}, \\frac{x-y}{2}\\}&quot;, &quot;:C&quot;, -2);
  gr-&gt;Box();
  gr-&gt;Map(a, b, &quot;brgk&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/map.png" alt="Example of Map().">
</div>

<hr>
<a name="Data-interpolation"></a>
<div class="header">
<p>
Next: <a href="#Making-regular-data" accesskey="n" rel="next">Making regular data</a>, Previous: <a href="#Mapping-visualization" accesskey="p" rel="prev">Mapping visualization</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Data-interpolation-1"></a>
<h4 class="subsection">2.5.10 Data interpolation</h4>


<p>There are many functions to get interpolated values of a data array. Basically all of them can be divided by 3 categories:
</p><ol>
<li> functions which return single value at given point (see <a href="#Interpolation">Interpolation</a> and <code>mglGSpline()</code> in <a href="#Global-functions">Global functions</a>);
</li><li> functions <a href="#subdata">subdata</a> and <a href="#evaluate">evaluate</a> for indirect access to data elements;
</li><li> functions <a href="#refill">refill</a>, <a href="#gspline">gspline</a> and <a href="#datagrid">datagrid</a> which fill regular (rectangular) data array by interpolated values.
</li></ol>

<p>The usage of first category is rather straightforward and don&rsquo;t need any special comments.
</p>
<p>There is difference in indirect access functions. Function <a href="#subdata">subdata</a> use use step-like interpolation to handle correctly single <code>nan</code> values in the data array. Contrary, function <a href="#evaluate">evaluate</a> use local spline interpolation, which give smoother output but spread <code>nan</code> values. So, <a href="#subdata">subdata</a> should be used for specific data elements (for example, for given column), and <a href="#evaluate">evaluate</a> should be used for distributed elements (i.e. consider data array as some field). Following sample illustrates this difference:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(1,1,0,&quot;&quot;);  gr-&gt;Title(&quot;SubData vs Evaluate&quot;);
  mglData in(9), arg(99), e, s;
  gr-&gt;Fill(in,&quot;x^3/1.1&quot;); gr-&gt;Fill(arg,&quot;4*x+4&quot;);
  gr-&gt;Plot(in,&quot;ko &quot;);     gr-&gt;Box();
  e = in.Evaluate(arg,false); gr-&gt;Plot(e,&quot;b.&quot;,&quot;legend 'Evaluate'&quot;);
  s = in.SubData(arg);    gr-&gt;Plot(s,&quot;r.&quot;,&quot;legend 'SubData'&quot;);
  gr-&gt;Legend(2);
}
</pre>
<div align="center"><img src="png/indirect.png" alt="Example of indirect data access.">
</div>
<p>Example of <a href="#datagrid">datagrid</a> usage is done in <a href="#Making-regular-data">Making regular data</a>. Here I want to show the peculiarities of <a href="#refill">refill</a> and <a href="#gspline">gspline</a> functions. Both functions require argument(s) which provide coordinates of the data values, and return rectangular data array which equidistantly distributed in axis range. So, in opposite to <a href="#evaluate">evaluate</a> function, <a href="#refill">refill</a> and <a href="#gspline">gspline</a> can interpolate non-equidistantly distributed data. At this both functions <a href="#refill">refill</a> and <a href="#gspline">gspline</a> provide continuity of 2nd derivatives along coordinate(s). However, <a href="#refill">refill</a> is slower but give better (from human point of view) result than global spline <a href="#gspline">gspline</a> due to more advanced algorithm. Following sample illustrates this difference:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData x(10), y(10), r(100);
  x.Modify(&quot;0.5+rnd&quot;);  x.CumSum(&quot;x&quot;);  x.Norm(-1,1);
  y.Modify(&quot;sin(pi*v)/1.5&quot;,x);
  gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Refill sample&quot;);
  gr-&gt;Axis();  gr-&gt;Box(); gr-&gt;Plot(x,y,&quot;o &quot;);
  gr-&gt;Refill(r,x,y);  // or you can use r.Refill(x,y,-1,1);
  gr-&gt;Plot(r,&quot;r&quot;);  gr-&gt;FPlot(&quot;sin(pi*x)/1.5&quot;,&quot;B:&quot;);
  gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);gr-&gt;Title(&quot;Global spline&quot;);
  gr-&gt;Axis();  gr-&gt;Box(); gr-&gt;Plot(x,y,&quot;o &quot;);
  r.RefillGS(x,y,-1,1);   gr-&gt;Plot(r,&quot;r&quot;);
  gr-&gt;FPlot(&quot;sin(pi*x)/1.5&quot;,&quot;B:&quot;);

  gr-&gt;Alpha(true);  gr-&gt;Light(true);
  mglData z(10,10), xx(10,10), yy(10,10), rr(100,100);
  y.Modify(&quot;0.5+rnd&quot;);  y.CumSum(&quot;x&quot;);  y.Norm(-1,1);
  for(int i=0;i&lt;10;i++) for(int j=0;j&lt;10;j++)
    z.a[i+10*j] = sin(M_PI*x.a[i]*y.a[j])/1.5;
  gr-&gt;SubPlot(2,2,2); gr-&gt;Title(&quot;2d regular&quot;);  gr-&gt;Rotate(40,60);
  gr-&gt;Axis();  gr-&gt;Box(); gr-&gt;Mesh(x,y,z,&quot;k&quot;);
  gr-&gt;Refill(rr,x,y,z); gr-&gt;Surf(rr);

  gr-&gt;Fill(xx,&quot;(x+1)/2*cos(y*pi/2-1)&quot;);
  gr-&gt;Fill(yy,&quot;(x+1)/2*sin(y*pi/2-1)&quot;);
  for(int i=0;i&lt;10*10;i++)
    z.a[i] = sin(M_PI*xx.a[i]*yy.a[i])/1.5;
  gr-&gt;SubPlot(2,2,3); gr-&gt;Title(&quot;2d non-regular&quot;);  gr-&gt;Rotate(40,60);
  gr-&gt;Axis();  gr-&gt;Box();  gr-&gt;Plot(xx,yy,z,&quot;ko &quot;);
  gr-&gt;Refill(rr,xx,yy,z);  gr-&gt;Surf(rr);
}
</pre>
<div align="center"><img src="png/refill.png" alt="Example of non-equidistant data interpolation.">
</div>


<hr>
<a name="Making-regular-data"></a>
<div class="header">
<p>
Next: <a href="#Making-histogram" accesskey="n" rel="next">Making histogram</a>, Previous: <a href="#Data-interpolation" accesskey="p" rel="prev">Data interpolation</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Making-regular-data-1"></a>
<h4 class="subsection">2.5.11 Making regular data</h4>


<p>Sometimes, one have only unregular data, like as data on triangular grids, or experimental results and so on. Such kind of data cannot be used as simple as regular data (like matrices). Only few functions, like <a href="#dots">dots</a>, can handle unregular data as is.
</p>
<p>However, one can use built in triangulation functions for interpolating unregular data points to a regular data grids. There are 2 ways. First way, one can use <a href="#triangulation">triangulation</a> function to obtain list of vertexes for triangles. Later this list can be used in functions like <a href="#triplot">triplot</a> or <a href="#tricont">tricont</a>. Second way consist in usage of <a href="#datagrid">datagrid</a> function, which fill regular data grid by interpolated values, assuming that coordinates of the data grid is equidistantly distributed in axis range. Note, you can use options (see <a href="#Command-options">Command options</a>) to change default axis range as well as in other plotting functions.
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData x(100), y(100), z(100);
  gr-&gt;Fill(x,&quot;2*rnd-1&quot;); gr-&gt;Fill(y,&quot;2*rnd-1&quot;); gr-&gt;Fill(z,&quot;v^2-w^2&quot;,x,y);
  // first way - plot triangular surface for points
  mglData d = mglTriangulation(x,y);
  gr-&gt;Title(&quot;Triangulation&quot;);
  gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Light(true);
  gr-&gt;TriPlot(d,x,y,z);	gr-&gt;TriPlot(d,x,y,z,&quot;#k&quot;);
  // second way - make regular data and plot it
  mglData g(30,30);
  gr-&gt;DataGrid(g,x,y,z);	gr-&gt;Mesh(g,&quot;m&quot;);
}
</pre>
<div align="center"><img src="png/triangulation.png" alt="Example of triangulation.">
</div>

<hr>
<a name="Making-histogram"></a>
<div class="header">
<p>
Next: <a href="#Nonlinear-fitting-hints" accesskey="n" rel="next">Nonlinear fitting hints</a>, Previous: <a href="#Making-regular-data" accesskey="p" rel="prev">Making regular data</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Making-histogram-1"></a>
<h4 class="subsection">2.5.12 Making histogram</h4>


<p>Using the <a href="#hist">hist</a> function(s) for making regular distributions is one of useful fast methods to process and plot irregular data. <code>Hist</code> can be used to find some momentum of set of points by specifying weight function. It is possible to create not only 1D distributions but also 2D and 3D ones. Below I place the simplest sample code which demonstrate <a href="#hist">hist</a> usage:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData x(10000), y(10000), z(10000);  gr-&gt;Fill(x,&quot;2*rnd-1&quot;);
  gr-&gt;Fill(y,&quot;2*rnd-1&quot;); gr-&gt;Fill(z,&quot;exp(-6*(v^2+w^2))&quot;,x,y);
  mglData xx=gr-&gt;Hist(x,z), yy=gr-&gt;Hist(y,z);	xx.Norm(0,1);
  yy.Norm(0,1);
  gr-&gt;MultiPlot(3,3,3,2,2,&quot;&quot;);   gr-&gt;SetRanges(-1,1,-1,1,0,1);
  gr-&gt;Box();  gr-&gt;Dots(x,y,z,&quot;wyrRk&quot;);
  gr-&gt;MultiPlot(3,3,0,2,1,&quot;&quot;);   gr-&gt;SetRanges(-1,1,0,1);
  gr-&gt;Box();  gr-&gt;Bars(xx);
  gr-&gt;MultiPlot(3,3,5,1,2,&quot;&quot;);   gr-&gt;SetRanges(0,1,-1,1);
  gr-&gt;Box();  gr-&gt;Barh(yy);
  gr-&gt;SubPlot(3,3,2);
  gr-&gt;Puts(mglPoint(0.5,0.5),&quot;Hist and\nMultiPlot\nsample&quot;,&quot;a&quot;,-6);
  return 0;
}
</pre>
<div align="center"><img src="png/hist.png" alt="Example of Hist().">
</div>


<hr>
<a name="Nonlinear-fitting-hints"></a>
<div class="header">
<p>
Next: <a href="#PDE-solving-hints" accesskey="n" rel="next">PDE solving hints</a>, Previous: <a href="#Making-histogram" accesskey="p" rel="prev">Making histogram</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nonlinear-fitting-hints-1"></a>
<h4 class="subsection">2.5.13 Nonlinear fitting hints</h4>


<p>Nonlinear fitting is rather simple. All that you need is the data to fit, the approximation formula and the list of coefficients to fit (better with its initial guess values). Let me demonstrate it on the following simple example. First, let us use sin function with some random noise:
</p><pre class="verbatim">  mglData dat(100), in(100); //data to be fitted and ideal data
  gr-&gt;Fill(dat,&quot;0.4*rnd+0.1+sin(2*pi*x)&quot;);
  gr-&gt;Fill(in,&quot;0.3+sin(2*pi*x)&quot;);
</pre><p>and plot it to see that data we will fit
</p><pre class="verbatim">  gr-&gt;Title(&quot;Fitting sample&quot;);
  gr-&gt;SetRange('y',-2,2); gr-&gt;Box();  gr-&gt;Plot(dat, &quot;k. &quot;);
  gr-&gt;Axis(); gr-&gt;Plot(in, &quot;b&quot;);
  gr-&gt;Puts(mglPoint(0, 2.2), &quot;initial: y = 0.3+sin(2\\pi x)&quot;, &quot;b&quot;);
</pre>
<p>The next step is the fitting itself. For that let me specify an initial values <var>ini</var> for coefficients &lsquo;<samp>abc</samp>&rsquo; and do the fitting for approximation formula &lsquo;<samp>a+b*sin(c*x)</samp>&rsquo;
</p><pre class="verbatim">  mreal ini[3] = {1,1,3};
  mglData Ini(3,ini);
  mglData res = gr-&gt;Fit(dat, &quot;a+b*sin(c*x)&quot;, &quot;abc&quot;, Ini);
</pre><p>Now display it
</p><pre class="verbatim">  gr-&gt;Plot(res, &quot;r&quot;);
  gr-&gt;Puts(mglPoint(-0.9, -1.3), &quot;fitted:&quot;, &quot;r:L&quot;);
  gr-&gt;PutsFit(mglPoint(0, -1.8), &quot;y = &quot;, &quot;r&quot;);
</pre>
<p>NOTE! the fitting results may have strong dependence on initial values for coefficients due to algorithm features. The problem is that in general case there are several local &quot;optimums&quot; for coefficients and the program returns only first found one! There are no guaranties that it will be the best. Try for example to set <code>ini[3] = {0, 0, 0}</code> in the code above.
</p>
<p>The full sample code for nonlinear fitting is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData dat(100), in(100);
  gr-&gt;Fill(dat,&quot;0.4*rnd+0.1+sin(2*pi*x)&quot;);
  gr-&gt;Fill(in,&quot;0.3+sin(2*pi*x)&quot;);
  mreal ini[3] = {1,1,3};
  mglData Ini(3,ini);

  mglData res = gr-&gt;Fit(dat, &quot;a+b*sin(c*x)&quot;, &quot;abc&quot;, Ini);

  gr-&gt;Title(&quot;Fitting sample&quot;);
  gr-&gt;SetRange('y',-2,2); gr-&gt;Box();  gr-&gt;Plot(dat, &quot;k. &quot;);
  gr-&gt;Axis();   gr-&gt;Plot(res, &quot;r&quot;); gr-&gt;Plot(in, &quot;b&quot;);
  gr-&gt;Puts(mglPoint(-0.9, -1.3), &quot;fitted:&quot;, &quot;r:L&quot;);
  gr-&gt;PutsFit(mglPoint(0, -1.8), &quot;y = &quot;, &quot;r&quot;);
  gr-&gt;Puts(mglPoint(0, 2.2), &quot;initial: y = 0.3+sin(2\\pi x)&quot;, &quot;b&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/fit.png" alt="Example of nonlinear fitting.">
</div>

<hr>
<a name="PDE-solving-hints"></a>
<div class="header">
<p>
Next: <a href="#Drawing-phase-plain" accesskey="n" rel="next">Drawing phase plain</a>, Previous: <a href="#Nonlinear-fitting-hints" accesskey="p" rel="prev">Nonlinear fitting hints</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="PDE-solving-hints-1"></a>
<h4 class="subsection">2.5.14 PDE solving hints</h4>


<p>Solving of Partial Differential Equations (PDE, including beam tracing) and ray tracing (or finding particle trajectory) are more or less common task. So, MathGL have several functions for that. There are <a href="#ray">ray</a> for ray tracing, <a href="#pde">pde</a> for PDE solving, <a href="#qo2d">qo2d</a> for beam tracing in 2D case (see <a href="#Global-functions">Global functions</a>). Note, that these functions take &ldquo;Hamiltonian&rdquo; or equations as string values. And I don&rsquo;t plan now to allow one to use user-defined functions. There are 2 reasons: the complexity of corresponding interface; and the basic nature of used methods which are good for samples but may not good for serious scientific calculations.
</p>
<p>The ray tracing can be done by <a href="#ray">ray</a> function. Really ray tracing equation is Hamiltonian equation for 3D space. So, the function can be also used for finding a particle trajectory (i.e. solve Hamiltonian ODE) for 1D, 2D or 3D cases. The function have a set of arguments. First of all, it is Hamiltonian which defined the media (or the equation) you are planning to use. The Hamiltonian is defined by string which may depend on coordinates &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;, time &lsquo;<samp>t</samp>&rsquo; (for particle dynamics) and momentums &lsquo;<samp>p</samp>&rsquo;=<em>p_x</em>, &lsquo;<samp>q</samp>&rsquo;=<em>p_y</em>, &lsquo;<samp>v</samp>&rsquo;=<em>p_z</em>. Next, you have to define the initial conditions for coordinates and momentums at &lsquo;<samp>t</samp>&rsquo;=0 and set the integrations step (default is 0.1) and its duration (default is 10). The Runge-Kutta method of 4-th order is used for integration.
</p><pre class="verbatim">  const char *ham = &quot;p^2+q^2-x-1+i*0.5*(y+x)*(y&gt;-x)&quot;;
  mglData r = mglRay(ham, mglPoint(-0.7, -1), mglPoint(0, 0.5), 0.02, 2);
</pre><p>This example calculate the reflection from linear layer (media with Hamiltonian &lsquo;<samp>p^2+q^2-x-1</samp>&rsquo;=<em>p_x^2+p_y^2-x-1</em>). This is parabolic curve. The resulting array have 7 columns which contain data for {x,y,z,p,q,v,t}.
</p>
<p>The solution of PDE is a bit more complicated. As previous you have to specify the equation as pseudo-differential operator <em>\hat H(x, \nabla)</em> which is called sometime as &ldquo;Hamiltonian&rdquo; (for example, in beam tracing). As previously, it is defined by string which may depend on coordinates &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; (but not time!), momentums &lsquo;<samp>p</samp>&rsquo;=<em>(d/dx)/i k_0</em>, &lsquo;<samp>q</samp>&rsquo;=<em>(d/dy)/i k_0</em> and field amplitude &lsquo;<samp>u</samp>&rsquo;=<em>|u|</em>. The evolutionary coordinate is &lsquo;<samp>z</samp>&rsquo; in all cases. So that, the equation look like <em>du/dz = ik_0 H(x,y,\hat p, \hat q, |u|)[u]</em>. Dependence on field amplitude &lsquo;<samp>u</samp>&rsquo;=<em>|u|</em> allows one to solve nonlinear problems too. For example, for nonlinear Shrodinger equation you may set <code>ham=&quot;p^2 + q^2 - u^2&quot;</code>. Also you may specify imaginary part for wave absorption, like <code>ham = &quot;p^2 + i*x*(x&gt;0)&quot;</code> or <code>ham = &quot;p^2 + i1*x*(x&gt;0)&quot;</code>.
</p>
<p>Next step is specifying the initial conditions at &lsquo;<samp>z</samp>&rsquo; equal to minimal z-axis value. The function need 2 arrays for real and for imaginary part. Note, that coordinates x,y,z are supposed to be in specified axis range. So, the data arrays should have corresponding scales. Finally, you may set the integration step and parameter k0=<em>k_0</em>. Also keep in mind, that internally the 2 times large box is used (for suppressing numerical reflection from boundaries) and the equation should well defined even in this extended range.
</p>
<p>Final comment is concerning the possible form of pseudo-differential operator <em>H</em>. At this moment, simplified form of operator <em>H</em> is supported &ndash; all &ldquo;mixed&rdquo; terms (like &lsquo;<samp>x*p</samp>&rsquo;-&gt;x*d/dx) are excluded. For example, in 2D case this operator is effectively <em>H = f(p,z) + g(x,z,u)</em>. However commutable combinations (like &lsquo;<samp>x*q</samp>&rsquo;-&gt;x*d/dy) are allowed for 3D case.
</p>
<p>So, for example let solve the equation for beam deflected from linear layer and absorbed later. The operator will have the form &lsquo;<samp>&quot;p^2+q^2-x-1+i*0.5*(z+x)*(z&gt;-x)&quot;</samp>&rsquo; that correspond to equation <em>1/ik_0 * du/dz + d^2 u/dx^2 + d^2 u/dy^2 + x * u + i (x+z)/2 * u = 0</em>. This is typical equation for Electron Cyclotron (EC) absorption in magnetized plasmas. For initial conditions let me select the beam with plane phase front <em>exp(-48*(x+0.7)^2)</em>. The corresponding code looks like this:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a,re(128),im(128);
  gr-&gt;Fill(re,&quot;exp(-48*(x+0.7)^2)&quot;);
  a = gr-&gt;PDE(&quot;p^2+q^2-x-1+i*0.5*(z+x)*(z&gt;-x)&quot;, re, im, 0.01, 30);
  a.Transpose(&quot;yxz&quot;);
  gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;); gr-&gt;Title(&quot;PDE solver&quot;);
  gr-&gt;SetRange('c',0,1);  gr-&gt;Dens(a,&quot;wyrRk&quot;);
  gr-&gt;Axis(); gr-&gt;Label('x', &quot;\\i x&quot;);  gr-&gt;Label('y', &quot;\\i z&quot;);
  gr-&gt;FPlot(&quot;-x&quot;, &quot;k|&quot;);
  gr-&gt;Puts(mglPoint(0, 0.85), &quot;absorption: (x+z)/2 for x+z&gt;0&quot;);
  gr-&gt;Puts(mglPoint(0,1.1),&quot;Equation: ik_0\\partial_zu + \\Delta u + x\\cdot u + i \\frac{x+z}{2}\\cdot u = 0&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/pde.png" alt="Example of PDE solving.">
</div>
<p>The next example is example of beam tracing. Beam tracing equation is special kind of PDE equation written in coordinates accompanied to a ray. Generally this is the same parameters and limitation as for PDE solving but the coordinates are defined by the ray and by parameter of grid width <var>w</var> in direction transverse the ray. So, you don&rsquo;t need to specify the range of coordinates. <strong>BUT</strong> there is limitation. The accompanied coordinates are well defined only for smooth enough rays, i.e. then the ray curvature <em>K</em> (which is defined as <em>1/K^2 = (|r''|^2 |r'|^2 - (r'', r'')^2)/|r'|^6</em>) is much large then the grid width: <em>K&gt;&gt;w</em>. So, you may receive incorrect results if this condition will be broken.
</p>
<p>You may use following code for obtaining the same solution as in previous example:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData r, xx, yy, a, im(128), re(128);
  const char *ham = &quot;p^2+q^2-x-1+i*0.5*(y+x)*(y&gt;-x)&quot;;
  r = mglRay(ham, mglPoint(-0.7, -1), mglPoint(0, 0.5), 0.02, 2);
  gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;); gr-&gt;Title(&quot;Beam and ray tracing&quot;);
  gr-&gt;Plot(r.SubData(0), r.SubData(1), &quot;k&quot;);
  gr-&gt;Axis(); gr-&gt;Label('x', &quot;\\i x&quot;);  gr-&gt;Label('y', &quot;\\i z&quot;);

  // now start beam tracing
  gr-&gt;Fill(re,&quot;exp(-48*x^2)&quot;);
  a = mglQO2d(ham, re, im, r, xx, yy, 1, 30);
  gr-&gt;SetRange('c',0, 1);
  gr-&gt;Dens(xx, yy, a, &quot;wyrRk&quot;);
  gr-&gt;FPlot(&quot;-x&quot;, &quot;k|&quot;);
  gr-&gt;Puts(mglPoint(0, 0.85), &quot;absorption: (x+y)/2 for x+y&gt;0&quot;);
  gr-&gt;Puts(mglPoint(0.7, -0.05), &quot;central ray&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/qo2d.png" alt="Example of beam tracing.">
</div>
<p>Note, the <a href="#pde">pde</a> is fast enough and suitable for many cases routine. However, there is situations then media have both together: strong spatial dispersion and spatial inhomogeneity. In this, case the <a href="#pde">pde</a> will produce incorrect result and you need to use advanced PDE solver <a href="#apde">apde</a>. For example, a wave beam, propagated in plasma, described by Hamiltonian <em>exp(-x^2-p^2)</em>, will have different solution for using of simplification and advanced PDE solver:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetRanges(-1,1,0,2,0,2);
  mglData ar(256), ai(256);	gr-&gt;Fill(ar,&quot;exp(-2*x^2)&quot;);

  mglData res1(gr-&gt;APDE(&quot;exp(-x^2-p^2)&quot;,ar,ai,0.01));	res1.Transpose();
  gr-&gt;SubPlot(1,2,0,&quot;_&quot;);	gr-&gt;Title(&quot;Advanced PDE solver&quot;);
  gr-&gt;SetRanges(0,2,-1,1);	gr-&gt;SetRange('c',res1);
  gr-&gt;Dens(res1);	gr-&gt;Axis();	gr-&gt;Box();
  gr-&gt;Label('x',&quot;\\i z&quot;);	gr-&gt;Label('y',&quot;\\i x&quot;);
  gr-&gt;Puts(mglPoint(-0.5,0.2),&quot;i\\partial_z\\i u = exp(-\\i x^2+\\partial_x^2)[\\i u]&quot;,&quot;y&quot;);

  mglData res2(gr-&gt;PDE(&quot;exp(-x^2-p^2)&quot;,ar,ai,0.01));
  gr-&gt;SubPlot(1,2,1,&quot;_&quot;);	gr-&gt;Title(&quot;Simplified PDE solver&quot;);
  gr-&gt;Dens(res2);	gr-&gt;Axis();	gr-&gt;Box();
  gr-&gt;Label('x',&quot;\\i z&quot;);	gr-&gt;Label('y',&quot;\\i x&quot;);
  gr-&gt;Puts(mglPoint(-0.5,0.2),&quot;i\\partial_z\\i u \\approx\\ exp(-\\i x^2)\\i u+exp(\\partial_x^2)[\\i u]&quot;,&quot;y&quot;);
  return 0;
}
</pre>
<div align="center"><img src="png/apde.png" alt="Comparison of simplified and advanced PDE solvers.">
</div>


<hr>
<a name="Drawing-phase-plain"></a>
<div class="header">
<p>
Next: <a href="#Pulse-properties" accesskey="n" rel="next">Pulse properties</a>, Previous: <a href="#PDE-solving-hints" accesskey="p" rel="prev">PDE solving hints</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Drawing-phase-plain-1"></a>
<h4 class="subsection">2.5.15 Drawing phase plain</h4>


<p>Here I want say a few words of plotting phase plains. Phase plain is name for system of coordinates <em>x</em>, <em>x'</em>, i.e. a variable and its time derivative. Plot in phase plain is very useful for qualitative analysis of an ODE, because such plot is rude (it topologically the same for a range of ODE parameters). Most often the phase plain {<em>x</em>, <em>x'</em>} is used (due to its simplicity), that allows to analyze up to the 2nd order ODE (i.e. <em>x''+f(x,x')=0</em>).
</p>
<p>The simplest way to draw phase plain in MathGL is using <a href="#flow">flow</a> function(s), which automatically select several points and draw flow threads. If the ODE have an integral of motion (like Hamiltonian <em>H(x,x')=const</em> for dissipation-free case) then you can use <a href="#cont">cont</a> function for plotting isolines (contours). In fact. isolines are the same as flow threads, but without arrows on it. Finally, you can directly solve ODE using <a href="#ode">ode</a> function and plot its numerical solution.
</p>
<p>Let demonstrate this for ODE equation <em>x''-x+3*x^2=0</em>. This is nonlinear oscillator with square nonlinearity. It has integral <em>H=y^2+2*x^3-x^2=Const</em>. Also it have 2 typical stationary points: saddle at {x=0, y=0} and center at {x=1/3, y=0}. Motion at vicinity of center is just simple oscillations, and is stable to small variation of parameters. In opposite, motion around saddle point is non-stable to small variation of parameters, and is very slow. So, calculation around saddle points are more difficult, but more important. Saddle points are responsible for solitons, stochasticity and so on.
</p>
<p>So, let draw this phase plain by 3 different methods. First, draw isolines for <em>H=y^2+2*x^3-x^2=Const</em> &ndash; this is simplest for ODE without dissipation. Next, draw flow threads &ndash; this is straightforward way, but the automatic choice of starting points is not always optimal. Finally, use <a href="#ode">ode</a> to check the above plots. At this we need to run <a href="#ode">ode</a> in both direction of time (in future and in the past) to draw whole plain. Alternatively, one can put starting points far from (or at the bounding box as done in <a href="#flow">flow</a>) the plot, but this is a more complicated. The sample code is:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Cont&quot;);  gr-&gt;Box();
  gr-&gt;Axis();  gr-&gt;Label('x',&quot;x&quot;);  gr-&gt;Label('y',&quot;\\dot{x}&quot;);
  mglData f(100,100);   gr-&gt;Fill(f,&quot;y^2+2*x^3-x^2-0.5&quot;);
  gr-&gt;Cont(f);
  gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Flow&quot;);  gr-&gt;Box();
  gr-&gt;Axis();  gr-&gt;Label('x',&quot;x&quot;);  gr-&gt;Label('y',&quot;\\dot{x}&quot;);
  mglData fx(100,100), fy(100,100);
  gr-&gt;Fill(fx,&quot;x-3*x^2&quot;);  gr-&gt;Fill(fy,&quot;y&quot;);
  gr-&gt;Flow(fy,fx,&quot;v&quot;,&quot;value 7&quot;);
  gr-&gt;SubPlot(2,2,2,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;ODE&quot;);   gr-&gt;Box();
  gr-&gt;Axis();  gr-&gt;Label('x',&quot;x&quot;);  gr-&gt;Label('y',&quot;\\dot{x}&quot;);
  for(double x=-1;x&lt;1;x+=0.1)
  {
    mglData in(2), r;   in.a[0]=x;
    r = mglODE(&quot;y;x-3*x^2&quot;,&quot;xy&quot;,in);
    gr-&gt;Plot(r.SubData(0), r.SubData(1));
    r = mglODE(&quot;-y;-x+3*x^2&quot;,&quot;xy&quot;,in);
    gr-&gt;Plot(r.SubData(0), r.SubData(1));
  }
}
</pre>
<div align="center"><img src="png/ode.png" alt="Example of ODE solving and phase plain drawing.">
</div>


<hr>
<a name="Pulse-properties"></a>
<div class="header">
<p>
Next: <a href="#Using-MGL-parser" accesskey="n" rel="next">Using MGL parser</a>, Previous: <a href="#Drawing-phase-plain" accesskey="p" rel="prev">Drawing phase plain</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Pulse-properties-1"></a>
<h4 class="subsection">2.5.16 Pulse properties</h4>


<p>There is common task in optics to determine properties of wave pulses or wave beams. MathGL provide special function <a href="#pulse">pulse</a> which return the pulse properties (maximal value, center of mass, width and so on). Its usage is rather simple. Here I just illustrate it on the example of Gaussian pulse, where all parameters are obvious.
</p><pre class="verbatim">void sample(mglGraph *gr)
{
  gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Pulse sample&quot;);
  // first prepare pulse itself
  mglData a(100); gr-&gt;Fill(a,&quot;exp(-6*x^2)&quot;);
  // get pulse parameters
  mglData b(a.Pulse('x'));
  // positions and widths are normalized on the number of points. So, set proper axis scale.
  gr-&gt;SetRanges(0, a.nx-1, 0, 1);
  gr-&gt;Axis(); gr-&gt;Plot(a);  // draw pulse and axis
  // now visualize found pulse properties
  double m = b[0];  // maximal amplitude
  // approximate position of maximum
  gr-&gt;Line(mglPoint(b[1],0), mglPoint(b[1],m),&quot;r=&quot;);
  // width at half-maximum (so called FWHM)
  gr-&gt;Line(mglPoint(b[1]-b[3]/2,0), mglPoint(b[1]-b[3]/2,m),&quot;m|&quot;);
  gr-&gt;Line(mglPoint(b[1]+b[3]/2,0), mglPoint(b[1]+b[3]/2,m),&quot;m|&quot;);
  gr-&gt;Line(mglPoint(0,m/2), mglPoint(a.nx-1,m/2),&quot;h&quot;);
  // parabolic approximation near maximum
  char func[128];	sprintf(func,&quot;%g*(1-((x-%g)/%g)^2)&quot;,b[0],b[1],b[2]);
  gr-&gt;FPlot(func,&quot;g&quot;);
}
</pre>
<div align="center"><img src="png/pulse.png" alt="Example of determining of pulse properties.">
</div>

<hr>
<a name="Using-MGL-parser"></a>
<div class="header">
<p>
Next: <a href="#Using-options" accesskey="n" rel="next">Using options</a>, Previous: <a href="#Pulse-properties" accesskey="p" rel="prev">Pulse properties</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Using-MGL-parser-1"></a>
<h4 class="subsection">2.5.17 Using MGL parser</h4>


<p>Sometimes you may prefer to use MGL scripts in yours code. It is simpler (especially in comparison with C/Fortran interfaces) and provide faster way to plot the data with annotations, labels and so on. Class <code>mglParse</code> (see <a href="#mglParse-class">mglParse class</a> parse MGL scripts in C++. It have also the corresponding interface for C/Fortran.
</p>
<p>The key function here is <code>mglParse::Parse()</code> (or <code>mgl_parse()</code> for C/Fortran) which execute one command per string. At this the detailed information about the possible errors or warnings is passed as function value. Or you may execute the whole script as long string with lines separated by &lsquo;<samp>\n</samp>&rsquo;. Functions <code>mglParse::Execute()</code> and <code>mgl_parse_text()</code> perform it. Also you may set the values of parameters &lsquo;<samp>$0</samp>&rsquo;...&lsquo;<samp>$9</samp>&rsquo; for the script by functions <code>mglParse::AddParam()</code> or <code>mgl_add_param()</code>, allow/disable picture resizing, check &ldquo;once&rdquo; status and so on. The usage is rather straight-forward.
</p>
<p>The only non-obvious thing is data transition between script and yours program. There are 2 stages: add or find variable; and set data to variable. In C++ you may use functions <code>mglParse::AddVar()</code> and <code>mglParse::FindVar()</code> which return pointer to <code>mglData</code>. In C/Fortran the corresponding functions are <code>mgl_add_var()</code>, <code>mgl_find_var()</code>. This data pointer is valid until next <code>Parse()</code> or <code>Execute()</code> call. Note, you <strong>must not delete or free</strong> the data obtained from these functions!
</p>
<p>So, some simple example at the end. Here I define a data array, create variable, put data into it and plot it. The C++ code looks like this:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;Title(&quot;MGL parser sample&quot;);
  mreal a[100];   // let a_i = sin(4*pi*x), x=0...1
  for(int i=0;i&lt;100;i++)a[i]=sin(4*M_PI*i/99);
  mglParse *parser = new mglParse;
  mglData *d = parser-&gt;AddVar(&quot;dat&quot;);
  d-&gt;Set(a,100); // set data to variable
  parser-&gt;Execute(gr, &quot;plot dat; xrange 0 1\nbox\naxis&quot;);
  // you may break script at any line do something
  // and continue after that
  parser-&gt;Execute(gr, &quot;xlabel 'x'\nylabel 'y'\nbox&quot;);
  // also you may use cycles or conditions in script
  parser-&gt;Execute(gr, &quot;for $0 -1 1 0.1\nline 0 0 -1 $0 'r'\nnext&quot;);
  delete parser;
  return 0;
}
</pre><p>The code in C/Fortran looks practically the same:
</p><pre class="verbatim">int sample(HMGL gr)
{
  mgl_title(gr, &quot;MGL parser sample&quot;, &quot;&quot;, -2);
  double a[100];   // let a_i = sin(4*pi*x), x=0...1
  int i;
  for(i=0;i&lt;100;i++)  a[i]=sin(4*M_PI*i/99);
  HMPR parser = mgl_create_parser();
  HMDT d = mgl_parser_add_var(parser, &quot;dat&quot;);
  mgl_data_set_double(d,a,100,1,1);    // set data to variable
  mgl_parse_text(gr, parser, &quot;plot dat; xrange 0 1\nbox\naxis&quot;);
  // you may break script at any line do something
  // and continue after that
  mgl_parse_text(gr, parser, &quot;xlabel 'x'\nylabel 'y'&quot;);
  // also you may use cycles or conditions in script
  mgl_parse_text(gr, parser, &quot;for $0 -1 1 0.1\nif $0&lt;0\n&quot;
    &quot;line 0 0 -1 $0 'r':else:line 0 0 -1 $0 'g'\n&quot;
    &quot;endif\nnext&quot;);
  mgl_write_png(gr, &quot;test.png&quot;, &quot;&quot;);  // don't forgot to save picture
  return 0;
}
</pre>
<div align="center"><img src="png/parser.png" alt="Example of MGL script parsing.">
</div>

<hr>
<a name="Using-options"></a>
<div class="header">
<p>
Next: <a href="#g_t_0060_0060Templates_0027_0027" accesskey="n" rel="next">``Templates''</a>, Previous: <a href="#Using-MGL-parser" accesskey="p" rel="prev">Using MGL parser</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Using-options-1"></a>
<h4 class="subsection">2.5.18 Using options</h4>


<p><a href="#Command-options">Command options</a> allow the easy setup of the selected plot by changing global settings only for this plot. Often, options are used for specifying the range of automatic variables (coordinates). However, options allows easily change plot transparency, numbers of line or faces to be drawn, or add legend entries. The sample function for options usage is:
</p><pre class="verbatim">void template(mglGraph *gr)
{
  mglData a(31,41);
  gr-&gt;Fill(a,&quot;-pi*x*exp(-(y+1)^2-4*x^2)&quot;);

  gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Options for coordinates&quot;);
  gr-&gt;Alpha(true);	gr-&gt;Light(true);
  gr-&gt;Rotate(40,60);    gr-&gt;Box();
  gr-&gt;Surf(a,&quot;r&quot;,&quot;yrange 0 1&quot;); gr-&gt;Surf(a,&quot;b&quot;,&quot;yrange 0 -1&quot;);
  if(mini)	return;
  gr-&gt;SubPlot(2,2,1);   gr-&gt;Title(&quot;Option 'meshnum'&quot;);
  gr-&gt;Rotate(40,60);    gr-&gt;Box();
  gr-&gt;Mesh(a,&quot;r&quot;,&quot;yrange 0 1&quot;); gr-&gt;Mesh(a,&quot;b&quot;,&quot;yrange 0 -1; meshnum 5&quot;);
  gr-&gt;SubPlot(2,2,2);   gr-&gt;Title(&quot;Option 'alpha'&quot;);
  gr-&gt;Rotate(40,60);    gr-&gt;Box();
  gr-&gt;Surf(a,&quot;r&quot;,&quot;yrange 0 1; alpha 0.7&quot;);
  gr-&gt;Surf(a,&quot;b&quot;,&quot;yrange 0 -1; alpha 0.3&quot;);
  gr-&gt;SubPlot(2,2,3,&quot;&lt;_&quot;);  gr-&gt;Title(&quot;Option 'legend'&quot;);
  gr-&gt;FPlot(&quot;x^3&quot;,&quot;r&quot;,&quot;legend 'y = x^3'&quot;);
  gr-&gt;FPlot(&quot;cos(pi*x)&quot;,&quot;b&quot;,&quot;legend 'y = cos \\pi x'&quot;);
  gr-&gt;Box();    gr-&gt;Axis(); gr-&gt;Legend(2,&quot;&quot;);
}
</pre>
<div align="center"><img src="png/mirror.png" alt="Example of options usage.">
</div>

<hr>
<a name="g_t_0060_0060Templates_0027_0027"></a>
<div class="header">
<p>
Next: <a href="#Stereo-image" accesskey="n" rel="next">Stereo image</a>, Previous: <a href="#Using-options" accesskey="p" rel="prev">Using options</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="g_t_0060_0060Templates_0027_0027-1"></a>
<h4 class="subsection">2.5.19 &ldquo;Templates&rdquo;</h4>


<p>As I have noted before, the change of settings will influence only for the further plotting commands. This allows one to create &ldquo;template&rdquo; function which will contain settings and primitive drawing for often used plots. Correspondingly one may call this template-function for drawing simplification.
</p>
<p>For example, let one has a set of points (experimental or numerical) and wants to compare it with theoretical law (for example, with exponent law <em>\exp(-x/2), x \in [0, 20]</em>). The template-function for this task is:
</p><pre class="verbatim">void template(mglGraph *gr)
{
  mglData  law(100);      // create the law
  law.Modify(&quot;exp(-10*x)&quot;);
  gr-&gt;SetRanges(0,20, 0.0001,1);
  gr-&gt;SetFunc(0,&quot;lg(y)&quot;,0);
  gr-&gt;Plot(law,&quot;r2&quot;);
  gr-&gt;Puts(mglPoint(10,0.2),&quot;Theoretical law: e^x&quot;,&quot;r:L&quot;);
  gr-&gt;Label('x',&quot;x val.&quot;); gr-&gt;Label('y',&quot;y val.&quot;);
  gr-&gt;Axis(); gr-&gt;Grid(&quot;xy&quot;,&quot;g;&quot;); gr-&gt;Box();
}
</pre><p>At this, one will only write a few lines for data drawing:
</p><pre class="verbatim">  template(gr);     // apply settings and default drawing from template
  mglData dat(&quot;fname.dat&quot;); // load the data
  // and draw it (suppose that data file have 2 columns)
  gr-&gt;Plot(dat.SubData(0),dat.SubData(1),&quot;bx &quot;);
</pre><p>A template-function can also contain settings for font, transparency, lightning, color scheme and so on.
</p>
<p>I understand that this is obvious thing for any professional programmer, but I several times receive suggestion about &ldquo;templates&rdquo; ... So, I decide to point out it here.
</p>

<hr>
<a name="Stereo-image"></a>
<div class="header">
<p>
Next: <a href="#Reduce-memory-usage" accesskey="n" rel="next">Reduce memory usage</a>, Previous: <a href="#g_t_0060_0060Templates_0027_0027" accesskey="p" rel="prev">``Templates''</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Stereo-image-1"></a>
<h4 class="subsection">2.5.20 Stereo image</h4>


<p>One can easily create stereo image in MathGL. Stereo image can be produced by making two subplots with slightly different rotation angles. The corresponding code looks like this:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&amp;a);
  gr-&gt;Light(true);

  gr-&gt;SubPlot(2,1,0); gr-&gt;Rotate(50,60+1);
  gr-&gt;Box();  gr-&gt;Surf(a);

  gr-&gt;SubPlot(2,1,1); gr-&gt;Rotate(50,60-1);
  gr-&gt;Box();  gr-&gt;Surf(a);
  return 0;
}
</pre>
<div align="center"><img src="png/stereo.png" alt="Example of stereo image.">
</div>

<hr>
<a name="Reduce-memory-usage"></a>
<div class="header">
<p>
Next: <a href="#Saving-and-scanning-file" accesskey="n" rel="next">Saving and scanning file</a>, Previous: <a href="#Stereo-image" accesskey="p" rel="prev">Stereo image</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reduce-memory-usage-1"></a>
<h4 class="subsection">2.5.21 Reduce memory usage</h4>


<p>By default MathGL save all primitives in memory, rearrange it and only later draw them on bitmaps. Usually, this speed up drawing, but may require a lot of memory for plots which contain a lot of faces (like <a href="#cloud">cloud</a>, <a href="#dew">dew</a>). You can use <a href="#quality">quality</a> function for setting to use direct drawing on bitmap and bypassing keeping any primitives in memory. This function also allow you to decrease the quality of the resulting image but increase the speed of the drawing.
</p>
<p>The code for lowest memory usage looks like this:
</p><pre class="verbatim">int sample(mglGraph *gr)
{
  gr-&gt;SetQuality(6);   // firstly, set to draw directly on bitmap
  for(i=0;i&lt;1000;i++)
    gr-&gt;Sphere(mglPoint(mgl_rnd()*2-1,mgl_rnd()*2-1),0.05);
  return 0;
}
</pre>

<hr>
<a name="Saving-and-scanning-file"></a>
<div class="header">
<p>
Next: <a href="#Mixing-bitmap-and-vector-output" accesskey="n" rel="next">Mixing bitmap and vector output</a>, Previous: <a href="#Reduce-memory-usage" accesskey="p" rel="prev">Reduce memory usage</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Scanning-file"></a>
<h4 class="subsection">2.5.22 Scanning file</h4>


<p>MathGL have possibilities to write textual information into file with variable values. In MGL script you can use <a href="#save">save</a> command for that. However, the usual <code>printf();</code> is simple in C/C++ code. For example, lets create some textual file
</p><pre class="verbatim">FILE *fp=fopen(&quot;test.txt&quot;,&quot;w&quot;);
fprintf(fp,&quot;This is test: 0 -&gt; 1 q\n&quot;);
fprintf(fp,&quot;This is test: 1 -&gt; -1 q\n&quot;);
fprintf(fp,&quot;This is test: 2 -&gt; 0 q\n&quot;);
fclose(fp);
</pre><p>It contents look like
</p><pre class="verbatim">This is test: 0 -&gt; 1 q
This is test: 1 -&gt; -1 q
This is test: 2 -&gt; 0 q
</pre>
<p>Let assume now that you want to read this values (i.e. [[0,1],[1,-1],[2,0]]) from the file. You can use <a href="#scanfile">scanfile</a> for that. The desired values was written using template &quot;This is test: %g -&gt; %g q\n&quot;. So, just use
</p><pre class="verbatim">mglData a;
a.ScanFile(&quot;test.txt&quot;,&quot;This is test: %g -&gt; %g&quot;);
</pre><p>and plot it to for assurance
</p><pre class="verbatim">gr-&gt;SetRanges(a.SubData(0), a.SubData(1));
gr-&gt;Axis();	gr-&gt;Plot(a.SubData(0),a.SubData(1),&quot;o&quot;);
</pre>
<p>Note, I keep only the leading part of template (i.e. &quot;This is test: %g -&gt; %g&quot; instead of &quot;This is test: %g -&gt; %g q\n&quot;), because there is no important for us information after the second number in the line.
</p>


<hr>
<a name="Mixing-bitmap-and-vector-output"></a>
<div class="header">
<p>
Previous: <a href="#Saving-and-scanning-file" accesskey="p" rel="prev">Saving and scanning file</a>, Up: <a href="#Hints" accesskey="u" rel="up">Hints</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Mixing-bitmap-and-vector-output-1"></a>
<h4 class="subsection">2.5.23 Mixing bitmap and vector output</h4>


<p>Sometimes output plots contain surfaces with a lot of points, and some vector primitives (like axis, text, curves, etc.). Using vector output formats (like EPS or SVG) will produce huge files with possible loss of smoothed lighting. Contrary, the bitmap output may cause the roughness of text and curves. Hopefully, MathGL have a possibility to combine bitmap output for surfaces and vector one for other primitives in the same EPS file, by using <a href="#rasterize">rasterize</a> command. 
</p>
<p>The idea is to prepare part of picture with surfaces or other &quot;heavy&quot; plots and produce the background image from them by help of <a href="#rasterize">rasterize</a> command. Next, we draw everything to be saved in vector form (text, curves, axis and etc.). Note, that you need to clear primitives (use <a href="#clf">clf</a> command) after <a href="#rasterize">rasterize</a> if you want to disable duplication of surfaces in output files (like EPS). Note, that some of output formats (like 3D ones, and TeX) don&rsquo;t support the background bitmap, and use <a href="#clf">clf</a> for them will cause the loss of part of picture.
</p>
<p>The sample code is:
</p><pre class="verbatim">// first draw everything to be in bitmap output
gr-&gt;FSurf(&quot;x^2+y^2&quot;, &quot;#&quot;, &quot;value 10&quot;);

gr-&gt;Rasterize();  // set above plots as bitmap background
gr-&gt;Clf();        // clear primitives, to exclude them from file

// now draw everything to be in vector output
gr-&gt;Axis(); gr-&gt;Box();

// and save file
gr-&gt;WriteFrame(&quot;fname.eps&quot;);
</pre>

<hr>
<a name="FAQ"></a>
<div class="header">
<p>
Previous: <a href="#Hints" accesskey="p" rel="prev">Hints</a>, Up: <a href="#Examples" accesskey="u" rel="up">Examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="FAQ-1"></a>
<h3 class="section">2.6 FAQ</h3>


<dl compact="compact">
<dt><strong>График не рисуется?!</strong></dt>
<dd><p>Проверьте, что точки графика находятся внутри ограничивающего параллелепипеда, при необходимости увеличьте его с помощью функции <code>Axis()</code>. Проверьте, что размерность массива правильная для выбранного типа графика. Убедитесь, что функция  <code>Finish()</code> была вызвана после построения графика (или график был сохранен в файл). Иногда отражение света от плоских поверхностей (типа, <code>Dens()</code>) может выглядеть как отсутствие графика.
</p>
</dd>
<dt><strong>Не нашел нужного графика?!</strong></dt>
<dd><p>Многие &ldquo;новые&rdquo; графики можно строить, используя уже существующие функции. Например, поверхность вращения кривой относительно оси можно построить, используя специальную функцию <code>Torus()</code>, а можно построить как параметрически заданную поверхность <code>Surf()</code>. См. также <a href="#Hints">Hints</a> и <a href="#Examples">Examples</a> MathGL. Если же нужного типа графика все равно нет, то пишите мне <a href="mailto:mathgl.abalakin@gmail.com">e-mail</a> и в следующей версии этот график появится.
</p>
</dd>
<dt><strong>Требуется ли знание сторонних библиотек (например, OpenGL) для использования библиотеки MathGL?</strong></dt>
<dd><p>Нет. Библиотека MathGL самодостаточна и не требует знания сторонних библиотек.
</p>
</dd>
<dt><strong>На каком языке написана библиотека? Для каких языков у нее есть интерфейсы?</strong></dt>
<dd><p>Ядро библиотеки написано на С++. Кроме него, есть интерфейсы для чистого С, фортрана, паскаля, форта и собственный командный язык MGL. Также есть поддержка большого числа интерпретируемых языков (Python, Java,  ALLEGROCL, CHICKEN, Lisp, CFFI, C#, Guile, Lua, Modula 3, Mzscheme, Ocaml, Octave, Perl, PHP, Pike, R, Ruby, Tcl). Эти интерфейсы написаны с помощью SWIG (и функции чистого С и классы). Однако на данный момент только интерфейсы для Python и Octave включены в скрипты сборки. Причина в том, что я не знаю других языков, чтобы проверить качество интерфейса :(. Замечу, что большинство прочих языков могут использовать С функции напрямую.
</p>
</dd>
<dt><strong>Как мне использовать MathGL с Фортраном?</strong></dt>
<dd><p>Библиотеку MathGL можно использовать как есть с компилятором <code>gfortran</code> поскольку он использует по умолчанию AT&amp;T нотацию для внешних функций. Для других компиляторов (например, Visual Fortran) необходимо включить использование AT&amp;T нотации вручную. AT&amp;T нотация требует, чтобы имя функции завершалось символом &lsquo;<samp>_</samp>&rsquo;, аргументы функции передавались по указателю и длины строк передавались в конце списка аргументов. Например:
</p>
<p><em>C функция</em> &ndash; <code>void mgl_fplot(HMGL graph, const char *fy, const char *stl, int n);</code>
</p>
<p><em>AT&amp;T функция</em> &ndash; <code>void mgl_fplot_(uintptr_t *graph, const char *fy, const char *stl, int *n, int ly, int ls);</code>
</p>
<p>При использовании фортрана необходимо также включить библиотеку <code>-lstdc++</code>. Кроме того, если библиотека была собрана с опцией <code>enable-double=ON</code> (по умолчанию в версии 2.1 и более поздних), то все вещественные числа должны быть типа <code>real*8</code>. Это можно включить по умолчанию опцией <code>-fdefault-real-8</code>.
</p>
</dd>
<dt><strong>У меня есть класс Foo и в нем метод рисования Foo::draw(mglGraph *gr). Как мне нарисовать что-то в окне FLTK, GLUT или Qt?</strong></dt>
<dd><p>Функции-члены класса в С++ имеют &ldquo;скрытый&rdquo; параметр &ndash; указатель на экземпляр класса и их прямое использование невозможно. Решением будет определение интерфейсной функции:
</p><div class="example">
<pre class="example">int foo_draw(mglGraph *gr, void *par)
{   ((Foo *)foo)-&gt;draw(gr);    }
</pre></div>
<p>и подстановка именно ее в вызов функции <code>Window()</code>:
</p><div class="example">
<pre class="example">gr-&gt;Window(argc,argv,foo_draw,&quot;Title&quot;,this);
</pre></div>

<p>Можно также наследовать Ваш класс от класса <code>mglDraw</code> и использовать функцию типа <code>gr-&gt;Window(argc, argv, foo, &quot;Title&quot;);</code>.
</p>
</dd>
<dt><strong>Как мне вывести текст на русском/испанском/арабском/японском и т.д.?</strong></dt>
<dd><p>Стандартный путь состоит в использовании кодировки UTF-8 для вывода текста. Кроме того, все функции вывода текста имеют интерфейс для 8-битных (char *) строк. Однако в последнем случае Вам может потребоваться установить используемую в исходном тексте локаль. Например, для русского языка в кодировке CP1251 можно использовать <code>setlocale(LC_CTYPE, &quot;ru_RU.cp1251&quot;);</code> (под MS Windows имена локали другие &ndash;  <code>setlocale(LC_CTYPE, &quot;russian_russia.1251&quot;)</code>). Настоятельно не рекомендую использовать константу <code>LC_ALL</code>, поскольку при этом меняется и формат чисел (в частности, десятичная точка), что может, например, вызвать сложности (неудобство) при написании формул и чтении текстовых файлов. Например, программа ожидает &lsquo;<samp>,</samp>&rsquo; в качестве разделителя целой и дробной части, а пользователь вводит &lsquo;<samp>.</samp>&rsquo;.
</p>
</dd>
<dt><strong>Как мне вырезать (исключить из рисования) точку или область на графике?</strong></dt>
<dd><p>Есть три основных способа. Во-первых, можно вырезать точку, задав одну из ее координат равной <code>NAN</code>. Во-вторых, можно воспользоваться функцией <code>SetCutBox()</code> или <code>CutOff()</code> для удаления точек из некоторой области (see <a href="#Cutting">Cutting</a>). Наконец, можно сделать эти точки прозрачными (невидимыми) с помощью функций <code>SurfA()</code>, <code>Surf3A()</code> (see <a href="#Dual-plotting">Dual plotting</a>). В последнем случае обеспечивается еще и плавность включения прозрачности.
</p>
</dd>
<dt><strong>Я использую VisualStudio, CBuilder или другой компилятор (не MinGW/gcc). Как мне подключить библиотеку MathGL?</strong></dt>
<dd><p>Начиная с версии 2.0, рекомендуемый к использованию класс mglGraph (заголовочный файл <code>#include &lt;mgl2/mgl.h&gt;</code>) содержbn только с <code>inline</code> функции и может использоваться с любым компилятором без перекомпиляции бинарной версии библиотеки. Однако, если Вы планируете использовать низкоуровневые возможности (т.е. классы mglBase, mglCanvas и т.д.), то Вам следует перекомпилировать библиотеку MathGL с использованием Вашего компилятора.
</p>
<p>Отмечу, что использование предоставляемых динамических библиотек *.dll требует создания библиотек импорта (import library *.lib). Эта процедура зависит от используемого компилятора &ndash; обратитесь к документации по Вашему компилятору. Например для VisualStudio это можно сделать командой <code>lib.exe /DEF:libmgl.def /OUT:libmgl.lib</code>.
</p>
</dd>
<dt><strong>Как мне собрать MathGL под Windows?</strong></dt>
<dd><p>Простейший путь &ndash; использование комбинации CMake и MinGW. Также Вам может потребоваться дополнительные библиотеки, такие как GSL, PNG, JPEG и пр. Все они могут быть найдены на <a href="http://gnuwin32.sourceforge.net/packages.html">http://gnuwin32.sourceforge.net/packages.html</a>. После установки всех компонент, просто запустите конфигуратор CMake и соберите MathGL командой make.
</p>
</dd>
<dt><strong>Как создать окно FLTK/GLUT/Qt с текущими результатами параллельно с выполнением основных вычислений?</strong></dt>
<dd><p>Следует создать отдельный поток для обработки сообщений в окно. Обновление данных в окне можно выполнить вызовом функции <code>Update()</code>. Подробнее см. <a href="#Animation">Animation</a>.
</p>
</dd>
<dt><strong>Сколько человек участвовало в создании библиотеки?</strong></dt>
<dd><p>Большую часть библиотеки написал один человек. Это результат примерно года работы на написание ядра библиотеки и базовых функций (в основном вечерами и по выходным). Процесс усовершенствования продолжается и теперь :). Скрипты сборки в основном написаны Д.Кулагиным, а экспорт в PRC/PDF написан М.Видассовым.
</p>
</dd>
<dt><strong>Как мне показать растровую картинку на рисунке?</strong></dt>
<dd><p>Можно импортировать ее в экземпляр <code>mglData</code> и построить с помощью функции <code>Dens()</code>. Например, для черно-белого рисунка можно использовать код: <code>mglData bmp; bmp.Import(&quot;fname.png&quot;,&quot;wk&quot;); gr-&gt;Dens(bmp,&quot;wk&quot;);</code>.
</p>
</dd>
<dt><strong>Как использовать MathGL в Qt, FLTK, wxWidgets ...?</strong></dt>
<dd><p>Есть специальные классы (виджеты) для этих библиотек: QMathGL для Qt, Fl_MathGL для FLTK и т.д. Если Вы не нашли подходящий класс, то можете создать свой собственный виджет, рисующий растровое изображение из mglCanvas::GetBits().
</p>
</dd>
<dt><strong>Как мне создать 3D в PDF?</strong></dt>
<dd><p>Используйте функцию <code>WritePRC</code>(), которая создаст PDF файл если MathGL был собран с enable-pdf=ON.
</p>
</dd>
<dt><strong>Как мне создать TeX рисунок?</strong></dt>
<dd><p>Используйте функцию <code>WriteTEX</code>(), которая создаст LaTeX файлы с собственно рисунком &lsquo;<samp><var>fname</var>.tex</samp>&rsquo;, с цветами MathGL &lsquo;<samp>mglcolors.tex</samp>&rsquo; и основной файл &lsquo;<samp>mglmain.tex</samp>&rsquo;, который может использоваться для просмотра изображения и/или генерации PDF с помощью команды типа <code>pdflatex mglmain.tex</code>.
</p>
</dd>
<dt><strong>Можно ли использовать MathGL в JavaScript?</strong></dt>
<dd><p>Да, пример JavaScript файла находится в папке texinfo/ исходных текстов. Для его работы необходимо предоставить JSON данные с 3d изображением (можно создать с помощью <code>WriteJSON</code>() функции). Скрипт позволяет выполнять базовые операции: приближение/удаление, вращение и сдвиг. Примеры использования JavaScript можно найти в <a href="http://mathgl.sf.net/json.html">http://mathgl.sf.net/json.html</a>.
</p>


</dd>
<dt><strong>Как сменить шрифт (семейство шрифтов)?</strong></dt>
<dd><p>Во-первых, надо загрузить файлы <a href="http://mathgl.sourceforge.net/download.html">отсюда</a> или <a href="http://sourceforge.net/project/showfiles.php?group_id=152187&amp;package_id=267177">отсюда</a>. Далее, в экземпляре mglGraph загружаем шрифты: <code>gr-&gt;LoadFont(fontname,path);</code>. Здесь <var>fontname</var> &ndash; базовое имя шрифта, например &lsquo;<samp>STIX</samp>&rsquo;, и <var>path</var> &ndash; путь к папке с файлами шрифтов. Вызовите <code>gr-&gt;RestoreFont();</code> для использования шрифта по умолчанию.
</p>
</dd>
<dt><strong>Как нарисовать метки оси снаружи от графика?</strong></dt>
<dd><p>Просто используйте отрицательные значения длины меток, например <code>gr-&gt;SetTickLen(-0.1);</code>.
</p>
</dd>
<dt><strong>Как нарисовать одинаковые оси координат для прямоугольного (не квадратного) рисунка?</strong></dt>
<dd><p>Просто используйте <code>Aspect(NAN,NAN)</code> для каждого подграфика, или в начале рисования.
</p>
</dd>
<dt><strong>Как задать полупрозрачный фон?</strong></dt>
<dd><p>Просто используйте код типа <code>Clf(&quot;r{A5}&quot;);</code> или подготовьте PNG файл и задайте его в качестве фона рисунка <code>LoadBackground(&quot;fname.png&quot;);</code>.
</p>
</dd>
<dt><strong>Как уменьшить поля вокруг графика?</strong></dt>
<dd><p>Простейший путь состоит в использовании стилей <a href="#subplot">subplot</a>. Однако, вы должны быть осторожны в изменении стиля <a href="#subplot">subplot</a> если вы планируете добавлять <a href="#colorbar">colorbar</a> или вращать график &ndash; часть графика может стать невидимой.
</p>
</dd>
<dt><strong>Can I combine bitmap and vector output in EPS?</strong></dt>
<dd><p>Yes. Sometimes you may have huge surface and a small set of curves and/or text on the plot. You can use function <a href="#rasterize">rasterize</a> just after making surface plot. This will put all plot to bitmap background. At this later plotting will be in vector format. For example, you can do something like following:
</p><pre class="verbatim">gr-&gt;Surf(x, y, z);
gr-&gt;Rasterize(); // make surface as bitmap
gr-&gt;Axis();
gr-&gt;WriteFrame(&quot;fname.eps&quot;);
</pre>
</dd>
<dt><strong>Почему у меня не получается использовать имя &lsquo;<samp>I</samp>&rsquo; для переменной?</strong></dt>
<dd><p>MathGL поддерживает стандарт C99, в котором имя &lsquo;<samp>I</samp>&rsquo; зарезервированно для мнимой единицы. Если Вам все таки нужно это имя для переменной, то поместите
</p><pre class="verbatim">#undef I
</pre><p>сразу после включения заголовочных файлов MathGL.
</p>
</dd>
<dt><strong>Как мне создать MPEG видео по графикам?</strong></dt>
<dd><p>Вам следует сохранить каждый кадр в файл JPEG с именем типа &lsquo;<samp>frame0001.jpg</samp>&rsquo;, &lsquo;<samp>frame0002.jpg</samp>&rsquo;, ... Далее используйте ImageMagic для конвертации этих файлов в видео формата MPEG с помощью команды <code>convert frame*.jpg movie.mpg</code>. См. также <a href="#MPEG">MPEG</a>.
</p>
</dd>
</dl>



<hr>
<a name="General-concepts"></a>
<div class="header">
<p>
Next: <a href="#MathGL-core" accesskey="n" rel="next">MathGL core</a>, Previous: <a href="#Examples" accesskey="p" rel="prev">Examples</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osnovnye-principy"></a>
<h2 class="chapter">3 Основные принципы</h2>


<p>Возможности библиотеки MathGL довольно богаты &ndash; число только основных типов графиков превышает 50 видов. Кроме того, есть функции для обработки данных, настройки вида графика и пр. и пр. Тем не менее, я старался придерживаться единого стиля в порядке аргументов функций и способе их &ldquo;настройки&rdquo;. В основном все ниже сказанное относится к функциям рисования различных графиков.
</p>
<p>Всего основных концепций (базисных идей) шесть:
</p><ol>
<li> <strong>Все рисунки создаются в памяти.</strong> Это могут быть как растровые картинки (для <code>SetQuality(MGL_DRAW_LMEM)</code> или <code><a href="#quality">quality</a> 6</code>), так и векторные списки примитивов (по умолчанию). Дальнейшая судьба рисунков определяется пользователем: можно сохранить в файл, вывести на экран, создать анимацию/кино, дополнительно отредактировать и т.д. Такой подход обеспечивает высокую переносимость библиотеки &ndash; один и тот же программный код создаст в точности одинаковый рисунок на <em>любой</em> операционной системе. Кроме того, при таком подходе рисунки можно создавать непосредственно в консольной программе &ndash; графическое окно не нужно!
</li><li> <strong>Все настройки графиков (стиль линий, цветовые схемы поверхностей, стиль и цвет текста) задаются строками.</strong> Это обеспечивает: удобство для пользователя &ndash; короткую строку легче читать и здесь тяжелее ошибиться, чем в большом списке параметров; переносимость &ndash; строки выглядят одинаково на всех платформах и не надо заботиться о типе и числе аргументов.
</li><li> <strong>Все функции имеют &ldquo;упрощенный&rdquo; и &ldquo;продвинутый&rdquo; варианты.</strong> Сделано опять из-за удобства. В &ldquo;упрощенном&rdquo; варианте для построения графика нужны только один-два массив(а) данных, которые автоматически равнораспределяются в заданном диапазоне осей координат. В &ldquo;продвинутой&rdquo; версии можно не только указать явно диапазон построения графика, но и задать его параметрически. Последнее позволяет легко строить довольно сложные кривые и поверхности. В обоих вариантах функций порядок аргументов стандартен: сначала идут массивы данных, потом необязательный строковый параметр стиля графика, а далее строка опций для более точной настройки графика.
</li><li> <strong>Все данные передаются через экземпляры класса mglData(A).</strong> Такой подход позволяет избежать ошибок при работе с памятью и единообразно передавать данные разных типов (float, double, данные из файла, заполненных пользователем и пр.) в функции рисования.
</li><li> <strong>Все элементы рисунков векторные.</strong> Изначально библиотека MathGL была ориентированна на работу с научными данными, которые по своей природе векторные (линии, грани, матрицы и т.д.). Поэтому векторность используется во всех рисунках! Причем иногда даже в ущерб производительности (например, при выводе шрифтов). Помимо всего прочего, векторность позволяет легко масштабировать рисунок &ndash; измените размер картинки в 2 раза, и рисунок пропорционально растянется.
</li><li> <strong>Новые графики не удаляют уже нарисованное.</strong> Этот, в чем-то неожиданный, подход позволяет создавать огромное количество &ldquo;комбинированных&rdquo; графиков. Например, поверхность с наложенными линиями уровня строится двумя последовательными вызовами функций рисования поверхности и линий уровня (в любом порядке). И совершенно не надо писать специальную функцию (как в Matlab и некоторых других программах) для рисования этого графика.
</li></ol>

<p>Кроме основных концепций я хотел бы остановиться на нескольких, как оказалось, нетривиальных моментах &ndash; способе указания положения графика, осей координат и строковых параметров линий, поверхностей, текста.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Coordinate-axes" accesskey="1">Coordinate axes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Color-styles" accesskey="2">Color styles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Line-styles" accesskey="3">Line styles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Color-scheme" accesskey="4">Color scheme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Font-styles" accesskey="5">Font styles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Textual-formulas" accesskey="6">Textual formulas</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Command-options" accesskey="7">Command options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Interfaces" accesskey="8">Interfaces</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Coordinate-axes"></a>
<div class="header">
<p>
Next: <a href="#Color-styles" accesskey="n" rel="next">Color styles</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osi-koordinat"></a>
<h3 class="section">3.1 Оси координат</h3>


<p>Представление системы координат в MathGL состоит из двух частей. Вначале координаты нормируются в диапазон изменения осей координат (see <a href="#Axis-settings">Axis settings</a>). Если флаг <code>SetCut()</code> установлен, то точки вне интервала отбрасываются, в противном случае, они проецируются на ограничивающий параллелепипед (см. <a href="#Cutting">Cutting</a>). Кроме того, отбрасываются точки внутри границ, определенных переменными <var>CutMin</var>x<var>CutMax</var> и точки, для которых значение функции <code>CutOff</code>() не равно нулю. После этого формулы перехода в криволинейную систему координат <code>SetFunc()</code>применяются к каждой точке. Наконец, точка данных отображается с помощью одной из графических функций.
</p>
<p>Диапазон изменения <em>x, y, z</em>-координат задается функциями <code>SetRange()</code> или <a href="#ranges">ranges</a>. Точка пересечения осей координат задается функцией <code>SetOrigin()</code>. При этом можно использовать NAN значения для автоматического выбора положения оси.
</p>
<p>Кроме привычных осей <em>x, y, z</em> есть еще одна ось &ndash; цветовая шкала &ndash; ось <em>c</em>. Она используется при окрашивании поверхностей и задает границы изменения функции при окрашивании. Ее границы автоматически устанавливаются равными диапазону z-оси при вызове <a href="#ranges">ranges</a>. Возможно и ручное изменение границ цветового интервала посредством вызова <code>SetRange('c', ...)</code>. Используйте <a href="#colorbar">colorbar</a> для отображения цветовой шкалы.
</p>
<p>Вид меток по осям определяется функцией <code>SetTicks()</code> (see <a href="#Ticks">Ticks</a>). Функция <var>SetTuneTicks</var> включает/выключает выделение общего множителя (большого или малого факторов в диапазоне) для меток осей координат. Наконец, если стандартный вид меток не устраивает пользователя, то их шаблон можно задать явно (можно использовать и ТеХ символы), воспользовавшись функцией  <code>SetTickTempl()</code>. Кроме того, в качестве меток можно вывести произвольный текст использовав функцию <code>SetTicksVal()</code>.
</p>

<hr>
<a name="Color-styles"></a>
<div class="header">
<p>
Next: <a href="#Line-styles" accesskey="n" rel="next">Line styles</a>, Previous: <a href="#Coordinate-axes" accesskey="p" rel="prev">Coordinate axes</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Cveta"></a>
<h3 class="section">3.2 Цвета</h3>


<p>Base colors are defined by one of symbol &lsquo;<samp>wkrgbcymhRGBCYMHWlenupqLENUPQ</samp>&rsquo;.
<p>Символы цвета: &lsquo;<samp>k</samp>&rsquo; &ndash; черный, &lsquo;<samp>r</samp>&rsquo; &ndash; <span style="color: rgb(255, 0, 0);">красный</span>, &lsquo;<samp>R</samp>&rsquo; &ndash; <span style="color: rgb(127, 0, 0);">темно красный</span>, &lsquo;<samp>g</samp>&rsquo; &ndash; <span style="color: rgb(0, 255, 0);">зеленый</span>, &lsquo;<samp>G</samp>&rsquo; &ndash; <span style="color: rgb(0, 127, 0);">темно зеленый</span>, &lsquo;<samp>b</samp>&rsquo; &ndash; <span style="color: rgb(0, 0, 255);">синий</span>, &lsquo;<samp>B</samp>&rsquo; &ndash; <span style="color: rgb(0, 0, 127);">темно синий</span>, &lsquo;<samp>c</samp>&rsquo; &ndash; <span style="color: rgb(0, 255, 255);">голубой</span>, &lsquo;<samp>C</samp>&rsquo; &ndash; <span style="color: rgb(0, 127, 127);">темно голубой</span>, &lsquo;<samp>m</samp>&rsquo; &ndash; <span style="color: rgb(255, 0, 255);">пурпурный</span>, &lsquo;<samp>M</samp>&rsquo; &ndash; <span style="color: rgb(127, 0, 127);">темно пурпурный</span>, &lsquo;<samp>y</samp>&rsquo; &ndash; <span style="color: rgb(255, 255, 0);">желтый</span>, &lsquo;<samp>Y</samp>&rsquo; &ndash; <span style="color: rgb(127, 127, 0);">темно желтый (золотой)</span>, &lsquo;<samp>h</samp>&rsquo; &ndash; <span style="color: rgb(127, 127, 127);">серый</span>, &lsquo;<samp>H</samp>&rsquo; &ndash; <span style="color: rgb(76, 76, 76);">темно серый</span>, &lsquo;<samp>w</samp>&rsquo; &ndash; белый, &lsquo;<samp>W</samp>&rsquo; &ndash; <span style="color: rgb(178, 178, 178);">светло серый</span>, &lsquo;<samp>l</samp>&rsquo; &ndash; <span style="color: rgb(0, 255, 127);">сине-зеленый</span>, &lsquo;<samp>L</samp>&rsquo; &ndash; <span style="color: rgb(0, 127, 63);">темно сине-зеленый</span>, &lsquo;<samp>e</samp>&rsquo; &ndash; <span style="color: rgb(127, 255, 0);">желто-зеленый</span>, &lsquo;<samp>E</samp>&rsquo; &ndash; <span style="color: rgb(63, 127, 0);">темно желто-зеленый</span>, &lsquo;<samp>n</samp>&rsquo; &ndash; <span style="color: rgb(0, 127, 255);">небесно-синий</span>, &lsquo;<samp>N</samp>&rsquo; &ndash; <span style="color: rgb(0, 63, 127);">темно небесно-синий</span>, &lsquo;<samp>u</samp>&rsquo; &ndash; <span style="color: rgb(127, 0, 255);">сине-фиолетовый</span>, &lsquo;<samp>U</samp>&rsquo; &ndash; <span style="color: rgb(63, 0, 127);">темно сине-фиолетовый</span>, &lsquo;<samp>p</samp>&rsquo; &ndash; <span style="color: rgb(255, 0, 127);">фиолетовый</span>, &lsquo;<samp>P</samp>&rsquo; &ndash; <span style="color: rgb(127, 0, 63);">темно фиолетовый</span>, &lsquo;<samp>q</samp>&rsquo; &ndash; <span style="color: rgb(255, 127, 0);">оранжевый</span>, &lsquo;<samp>Q</samp>&rsquo; &ndash; <span style="color: rgb(127, 63, 0);">темно оранжевый (коричневый)</span>.</p>
</p>
<p>В цветовой схеме можно использовать тональные (&ldquo;подсвеченные&rdquo;) цвета. Тональный цвет задается двумя символами в фигурных скобках &lsquo;<samp>{cN}</samp>&rsquo;: первый &ndash; обычный цвет, второй &ndash; его яркость цифрой. Цифра может быть в диапазоне &lsquo;<samp>1</samp>&rsquo;...&lsquo;<samp>9</samp>&rsquo;. При этом &lsquo;<samp>5</samp>&rsquo; соответствует нормальному цвету, &lsquo;<samp>1</samp>&rsquo; &ndash; очень темная версия цвета (почти черный), &lsquo;<samp>9</samp>&rsquo; &ndash; очень светлая версия цвета (почти белый). Например, цвета могут быть &lsquo;<samp>{b2}</samp>&rsquo; &lsquo;<samp>{b7}</samp>&rsquo; &lsquo;<samp>{r7}</samp>&rsquo; и т.д.
</p>
<p>Наконец, можно указать явно RGB или RGBA значения цвета, используя формат &lsquo;<samp>{xRRGGBB}</samp>&rsquo; или &lsquo;<samp>{xRRGGBBAA}</samp>&rsquo; соответственно. Например, &lsquo;<samp>{xFF9966}</samp>&rsquo; даст цвет
<span style="color: rgb(255, 153, 102);">дыни</span>.
</p>

<hr>
<a name="Line-styles"></a>
<div class="header">
<p>
Next: <a href="#Color-scheme" accesskey="n" rel="next">Color scheme</a>, Previous: <a href="#Color-styles" accesskey="p" rel="prev">Color styles</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Stilx-linii"></a>
<h3 class="section">3.3 Стиль линий</h3>


<a name="index-Stilx-linii"></a>
<a name="index-Stilx-markerov"></a>
<a name="index-Stilx-strelok"></a>

<p>Стиль линии задается строкой, которая может содержать символ цвета (&lsquo;<samp>wkrgbcymhRGBCYMHWlenupqLENUPQ</samp>&rsquo;), тип пунктира (&lsquo;<samp>-|;:ji</samp>&rsquo; или пробел), ширину линии (&lsquo;<samp>0123456789</samp>&rsquo;) и тип маркера (&lsquo;<samp>o+xsd.^v</samp>&rsquo; и модификатор &lsquo;<samp>#</samp>&rsquo;). Если пропущен цвет или тип пунктира, то используется значение по умолчанию с последним указанным цветом или значение из палитры (для see <a href="#g_t1D-plotting">1D plotting</a>).
По умолчанию палитры содержит следующие цвета: <span style="color: rgb(76, 76, 76);">темно серый</span> &lsquo;<samp>H</samp>&rsquo;, <span style="color: rgb(0, 0, 255);">синий</span> &lsquo;<samp>b</samp>&rsquo;, <span style="color: rgb(0, 255, 0);">зеленый</span> &lsquo;<samp>g</samp>&rsquo;, <span style="color: rgb(255, 0, 0);">красный</span> &lsquo;<samp>r</samp>&rsquo;, <span style="color: rgb(0, 255, 255);">голубой</span> &lsquo;<samp>c</samp>&rsquo;, <span style="color: rgb(255, 0, 255);">пурпурный</span> &lsquo;<samp>m</samp>&rsquo;, <span style="color: rgb(255, 255, 0);">yellow</span> &lsquo;<samp>y</samp>&rsquo;, <span style="color: rgb(127, 127, 127);">серый</span> &lsquo;<samp>h</samp>&rsquo;, <span style="color: rgb(0, 255, 127);">сине-зеленый</span> &lsquo;<samp>l</samp>&rsquo;, <span style="color: rgb(0, 127, 255);">небесно-синий</span> &lsquo;<samp>n</samp>&rsquo;, <span style="color: rgb(255, 127, 0);">оранжевый</span> &lsquo;<samp>q</samp>&rsquo;, <span style="color: rgb(127, 255, 0);">желто-зеленый</span> &lsquo;<samp>e</samp>&rsquo;, <span style="color: rgb(127, 0, 255);">сине-фиолетовый</span> &lsquo;<samp>u</samp>&rsquo;, <span style="color: rgb(255, 0, 127);">фиолетовый</span> &lsquo;<samp>p</samp>&rsquo;.

<p>Тип пунктира: пробел &ndash; нет линии (для рисования только маркеров), &lsquo;<samp>-</samp>&rsquo; &ndash; сплошная линия (&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;), &lsquo;<samp>|</samp>&rsquo; &ndash; длинный пунктир (&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9633;&#9633;&#9633;&#9633;&#9633;&#9633;&#9633;&#9633;), &lsquo;<samp>;</samp>&rsquo; &ndash; пунктир (&#9632;&#9632;&#9632;&#9632;&#9633;&#9633;&#9633;&#9633;&#9632;&#9632;&#9632;&#9632;&#9633;&#9633;&#9633;&#9633;), &lsquo;<samp>=</samp>&rsquo; &ndash; короткий пунктир (&#9632;&#9632;&#9633;&#9633;&#9632;&#9632;&#9633;&#9633;&#9632;&#9632;&#9633;&#9633;&#9632;&#9632;&#9633;&#9633;), &lsquo;<samp>:</samp>&rsquo; &ndash; точки (&#9632;&#9633;&#9633;&#9633;&#9632;&#9633;&#9633;&#9633;&#9632;&#9633;&#9633;&#9633;&#9632;&#9633;&#9633;&#9633;), &lsquo;<samp>j</samp>&rsquo; &ndash; пунктир с точками  (&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9632;&#9633;&#9633;&#9633;&#9633;&#9632;&#9633;&#9633;&#9633;&#9633;), &lsquo;<samp>i</samp>&rsquo; &ndash; мелкий пунктир с точками (&#9632;&#9632;&#9632;&#9633;&#9633;&#9632;&#9633;&#9633;&#9632;&#9632;&#9632;&#9633;&#9633;&#9632;&#9633;&#9633;), &lsquo;<samp>{dNNNN}</samp>&rsquo; &ndash; Ð·Ð°Ð´Ð°Ð½Ð½ÑÐ¹ Ð²ÑÑÑÐ½ÑÑ ÑÑÐ¸Ð»Ñ (Ð´Ð»Ñ v.2.3 Ð¸ Ð¿Ð¾Ð·Ð´Ð½Ð¸Ñ, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ &lsquo;<samp>{df090}</samp>&rsquo; Ð´Ð»Ñ (&#9632;&#9632;&#9632;&#9632;&#9633;&#9633;&#9633;&#9633;&#9632;&#9633;&#9633;&#9632;&#9633;&#9633;&#9633;&#9633;)).</p>
</p>
<p>Типы маркеров: &lsquo;<samp>o</samp>&rsquo; &ndash; окружность, &lsquo;<samp>+</samp>&rsquo; &ndash; крест, &lsquo;<samp>x</samp>&rsquo; &ndash; косой крест, &lsquo;<samp>s</samp>&rsquo; &ndash; квадрат, &lsquo;<samp>d</samp>&rsquo; - ромб, &lsquo;<samp>.</samp>&rsquo; &ndash; точка, &lsquo;<samp>^</samp>&rsquo; &ndash; треугольник вверх, &lsquo;<samp>v</samp>&rsquo; &ndash; треугольник вниз, &lsquo;<samp>&lt;</samp>&rsquo; &ndash; треугольник влево, &lsquo;<samp>&gt;</samp>&rsquo; &ndash; треугольник вправо, &lsquo;<samp>#*</samp>&rsquo; &ndash; знак Y, &lsquo;<samp>#+</samp>&rsquo; &ndash; крест в квадрате, &lsquo;<samp>#x</samp>&rsquo; &ndash; косой крест в квадрате, &lsquo;<samp>#.</samp>&rsquo; &ndash; точка в окружности. Если в строке присутствует символ &lsquo;<samp>#</samp>&rsquo;, то используются символы с заполнением.
</p>
<p>Вы можете определить собственные символы (см. <a href="#addsymbol">addsymbol</a>) для рисования маркеров при использовании стиля &lsquo;<samp>&amp;</samp>&rsquo;. В частности, &lsquo;<samp>&amp;*</samp>&rsquo;, &lsquo;<samp>&amp;o</samp>&rsquo;, &lsquo;<samp>&amp;+</samp>&rsquo;, &lsquo;<samp>&amp;x</samp>&rsquo;, &lsquo;<samp>&amp;s</samp>&rsquo;, &lsquo;<samp>&amp;d</samp>&rsquo;, &lsquo;<samp>&amp;.</samp>&rsquo;, &lsquo;<samp>&amp;^</samp>&rsquo;, &lsquo;<samp>&amp;v</samp>&rsquo;, &lsquo;<samp>&amp;&lt;</samp>&rsquo;, &lsquo;<samp>&amp;&gt;</samp>&rsquo; нарисует определенный пользователем символ с именем &lsquo;<samp>*o+xsd.^v&lt;&gt;</samp>&rsquo; соответственно; и
&lsquo;<samp>&amp;#o</samp>&rsquo;, &lsquo;<samp>&amp;#+</samp>&rsquo;, &lsquo;<samp>&amp;#x</samp>&rsquo;, &lsquo;<samp>&amp;#s</samp>&rsquo;, &lsquo;<samp>&amp;#d</samp>&rsquo;, &lsquo;<samp>&amp;#.</samp>&rsquo;, &lsquo;<samp>&amp;#^</samp>&rsquo;, &lsquo;<samp>&amp;#v</samp>&rsquo;, &lsquo;<samp>&amp;#&lt;</samp>&rsquo;, &lsquo;<samp>&amp;#&gt;</samp>&rsquo; нарисует определенный пользователем символ с именем &lsquo;<samp>YOPXSDCTVLR</samp>&rsquo; соответственно. Замечу, что будет нарисован только контур определенного пользователем символа если задан отрицательный размер маркера (см. <a href="#marksize">marksize</a> или опцию <code>size</code> в <a href="#Command-options">Command options</a>).
</p>
<p>На конце и в начале линии можно выводить специальный символ (стрелку), если в строке указать один из символов: &lsquo;<samp>A</samp>&rsquo; &ndash; стрелка наружу, &lsquo;<samp>V</samp>&rsquo; &ndash; стрелка внутрь, &lsquo;<samp>I</samp>&rsquo; &ndash; поперечная черта, &lsquo;<samp>K</samp>&rsquo; &ndash; стрелка с чертой, &lsquo;<samp>T</samp>&rsquo; &ndash; треугольник, &lsquo;<samp>S</samp>&rsquo; &ndash; квадрат, &lsquo;<samp>D</samp>&rsquo; &ndash; ромб, &lsquo;<samp>O</samp>&rsquo; &ndash; круг, &lsquo;<samp>X</samp>&rsquo; &ndash; косой крест, &lsquo;<samp>_</samp>&rsquo; &ndash; нет стрелки (по умолчанию). При этом действует следующее правило: первый символ определяет стрелку на конце линии, второй символ &ndash; стрелку в начале линии. Например, &lsquo;<samp>r-A</samp>&rsquo; &ndash; красная сплошная линия со стрелкой на конце, &lsquo;<samp>b|AI</samp>&rsquo; &ndash; синий пунктир со стрелкой на конце и чертой вначале, &lsquo;<samp>_O</samp>&rsquo; &ndash; линия с текущим стилем и кружком вначале. Эти стили действуют и при построении графиков (например, <a href="#g_t1D-plotting">1D plotting</a>).
</p>
<div align="center"><img src="png/style.png" alt="Color and line styles.">
</div>

<hr>
<a name="Color-scheme"></a>
<div class="header">
<p>
Next: <a href="#Font-styles" accesskey="n" rel="next">Font styles</a>, Previous: <a href="#Line-styles" accesskey="p" rel="prev">Line styles</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Cvetovaya-skhema"></a>
<h3 class="section">3.4 Цветовая схема</h3>


<a name="index-Cvetovaya-skhema"></a>

<p>Цветовая схема используется для определения цвета поверхностей, линий уровня и пр. Цветовая схема задается строкой <em>s</em>, которая содержит символы цвета (see <a href="#Line-styles">Line styles</a>) или символы &lsquo;<samp>#:|</samp>&rsquo;. Символ &lsquo;<samp>#</samp>&rsquo; переключает рисование поверхности на сетчатое (для трехмерных поверхностей) или включает рисование сетки на поверхности. Символ &lsquo;<samp>|</samp>&rsquo; отключает интерполяцию цвета в цветовой схеме. Это может быть полезно для &ldquo;резких&rdquo; цветов, например, при рисовании матриц. Если в строке встречается символ &lsquo;<samp>:</samp>&rsquo;, то он принудительно заканчивает разбор строки для стиля поверхности. После этого символа могут идти описание стиля текста или оси вращения кривой/линий уровня. Цветовая схема может содержать до 32 значений цвета.
</p>
<p>При определении цвета по <em>амплитуде</em> (наиболее часто используется) окончательный цвет определяется путем линейной интерполяции массива цветов. Массив цветов формируется из цветов, указанных в строке спецификации. Аргумент &ndash; амплитуда, нормированная на диапазон изменения цвета (см. <a href="#Axis-settings">Axis settings</a>). Например, строка из 4 символов &lsquo;<samp>bcyr</samp>&rsquo; соответствует изменению цвета от синего (минимальное значение) через голубой и желтый (промежуточные значения) к красному (максимальное значение). Строка &lsquo;<samp>kw</samp>&rsquo; соответствует изменению цвета от черного (минимальное значение) к белому (максимальное значение). Строка из одного символа (например, &lsquo;<samp>g</samp>&rsquo;) соответствует однотонному цвету (в данному случае зеленому).
</p>
<p>Специальная двуосная цветовая схема (как в графике <a href="#map">map</a>) задается символом &lsquo;<samp>%</samp>&rsquo;. В ней второе направление (прозрачность) используется как вторая координата для цвета. При этом можно указать до 4 цветов для углов: {c1,a1}, {c2,a1}, {c1,a2}, {c2,a2}. Здесь диапазоны цвета и прозрачности равны {c1,c2} и {a1,a2}. Если указано меньше 4 цветов, то черный используется для угла {c1,a1}. Если задано только 2 цвета, то их сумма используется для угла {c2,a2}.
</p>
<p>Есть несколько полезных цветовых схем. Строка &lsquo;<samp>kw</samp>&rsquo; дает обычную серую (черно-белую) схему, когда большие значения светлее. Строка &lsquo;<samp>wk</samp>&rsquo; представляет обратную серую схему, когда большие значения темнее. Строки &lsquo;<samp>kRryw</samp>&rsquo;, &lsquo;<samp>kGgw</samp>&rsquo;, &lsquo;<samp>kBbcw</samp>&rsquo; представляют собой хорошо известные схемы <em>hot</em>, <em>summer</em> и <em>winter</em>. Строки &lsquo;<samp>BbwrR</samp>&rsquo; и &lsquo;<samp>bBkRr</samp>&rsquo; позволяют рисовать двухцветные фигуры на белом или черном фоне, когда отрицательные значения показаны синим цветом, а положительные &ndash; красным. Строка &lsquo;<samp>BbcyrR</samp>&rsquo; дает цветовую схему, близкую к хорошо известной схеме <em>jet</em>.
</p>
<p>Для более точно раскрашивания поверхностей можно изменить равномерное (по умолчанию) положение цветов в цветовой схеме. Формат следующий: &lsquo;<samp>{CN,pos}</samp>&rsquo;, &lsquo;<samp>{CN,pos}</samp>&rsquo; или &lsquo;<samp>{xRRGGBB,pos}</samp>&rsquo;. Здесь значение <var>pos</var> положения цвета должно быть в диапазоне [0, 1]. Отмечу, что альтернативным механизмом тонкой настройки цветовой схемы может служить использование формул для цветовой координаты (см. <a href="#Curved-coordinates">Curved coordinates</a>).
</p>
<div align="center"><img src="png/schemes.png" alt="Most popular color schemes.">
</div>
<p>При определении цвета по <em>положению точки в пространстве</em> (используется в <a href="#map">map</a>) окончательный цвет определяется по формуле c=x*c[1] + y*c[2]. Здесь c[1], c[2] &ndash; первые три цвета в цветовом массиве; x, y &ndash; координаты точки, нормированные в диапазон изменения осей координат.
</p>

<p>Дополнительно, MathGL может наложить маску при закраске граней для создания растрового изображения. Тип маски задается одним из символов &lsquo;<samp>-+=;oOsS~&lt;&gt;jdD*^</samp>&rsquo; в цветовой схеме. Маску можно повернуть на произвольный угол командой <a href="#mask">mask</a> или на один из улов +45, -45 или 90 градусов, используя символы &lsquo;<samp>\/I</samp>&rsquo; соответственно. Примеры масок по умолчанию показаны на рисунке ниже.
</p>
<div align="center"><img src="png/mask.png" alt="Example of masks for face coloring.">
</div>
<p>Однако, вы можете задать собственную маску (как матрицу 8*8) для любого из этих символов, используя второй аргумент команды <a href="#mask">mask</a>. Например, маска на правом нижнем подрисунке получается кодом<br>
<code>gr-&gt;SetMask('+', &quot;ff00182424f80000&quot;);	gr-&gt;Dens(a,&quot;3+&quot;);</code><br>
или использовать явное задание маски (для v.2.3 и более поздних)<br>
<code>gr-&gt;Dens(a,&quot;3{s00ff00182424f800}&quot;);</code>
</p>

<hr>
<a name="Font-styles"></a>
<div class="header">
<p>
Next: <a href="#Textual-formulas" accesskey="n" rel="next">Textual formulas</a>, Previous: <a href="#Color-scheme" accesskey="p" rel="prev">Color scheme</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Stilx-teksta"></a>
<h3 class="section">3.5 Стиль текста</h3>


<a name="index-Stilx-teksta"></a>

<p>Стиль текста задается строкой, которая может содержать цвет текста &lsquo;<samp>wkrgbcymhRGBCYMHW</samp>&rsquo; (см. <a href="#Color-styles">Color styles</a>), а также тип шрифта (&lsquo;<samp>ribwou</samp>&rsquo;) и/или выравнивания (&lsquo;<samp>LRC</samp>&rsquo;) после символа &lsquo;<samp>:</samp>&rsquo;. Например, &lsquo;<samp>r:iCb</samp>&rsquo; соответствует жирному (&lsquo;<samp>b</samp>&rsquo;) курсиву (&lsquo;<samp>i</samp>&rsquo;) с выравниванием по центру (&lsquo;<samp>C</samp>&rsquo; красного цвета (&lsquo;<samp>r</samp>&rsquo;). Начиная с MathGL версии 2.3, вы можете использовать не только один цвет для всего текста, но и задать цветовой градиент для выводимой строки (см. <a href="#Color-scheme">Color scheme</a>).
</p>
<p>Начертания шрифта: &lsquo;<samp>r</samp>&rsquo; &ndash; прямой шрифт, &lsquo;<samp>i</samp>&rsquo; &ndash; курсив, &lsquo;<samp>b</samp>&rsquo; &ndash; жирный. По умолчанию используется прямой шрифт. Типы выравнивания текста: &lsquo;<samp>L</samp>&rsquo; &ndash; по левому краю (по умолчанию), &lsquo;<samp>C</samp>&rsquo; &ndash; по центру, &lsquo;<samp>R</samp>&rsquo; &ndash; по правому краю, &lsquo;<samp>T</samp>&rsquo; &ndash; под текстом, &lsquo;<samp>V</samp>&rsquo; &ndash; по центру вертикально. Дополнительные эффекты шрифта: &lsquo;<samp>w</samp>&rsquo; &ndash; контурный, &lsquo;<samp>o</samp>&rsquo; &ndash; надчеркнутый, &lsquo;<samp>u</samp>&rsquo; &ndash; подчеркнутый.
</p>
<p>Синтаксический разбор LaTeX-их команд по умолчанию включен. Это команды смены стиля текста (например, \b для жирного текста): \a или \overline &ndash; надчеркивание, \b или \textbf &ndash; жирный, \i или \textit &ndash; курсив, \r или \textrm &ndash; прямой (отменяет стили жирного и курсива), \u или \underline &ndash; подчеркнутый, \w или \wire &ndash; контурный, \big &ndash; большего размера, @ &ndash; меньшего размера. Нижний и верхний индексы задаются символами &lsquo;<samp>_</samp>&rsquo; и &lsquo;<samp>^</samp>&rsquo;. При этом изменение стиля применяется только к следующему символу или к символам в фигурных скобках {}, которые понимаются как единый блок. Например, сравните строки &lsquo;<samp>sin (x^{2^3})</samp>&rsquo; и &lsquo;<samp>sin (x^2^3)</samp>&rsquo;. Можно также менять цвет текста внутри строки с помощью команд #? или \color?, где &lsquo;<samp>?</samp>&rsquo; &ndash; символ цвета (see <a href="#Line-styles">Line styles</a>). Например, слова &lsquo;<samp>Blue</samp>&rsquo; и &lsquo;<samp>red</samp>&rsquo; будут окрашены в соответствующий цвет в строке &lsquo;<samp>#b{Blue} and \colorr{red} text</samp>&rsquo;. Большинство функций понимает символ новой строки &lsquo;<samp>\n</samp>&rsquo; и позволяет выводить много строчный текст. Наконец, можно использовать символы с произвольным UTF кодом с помощью команды <code>\utf0x????</code>. Например, <code>\utf0x3b1</code> даст символ
&alpha;.
</p>
<p>Распознаются также большинство символов TeX и AMSTeX, команды смены стиля текста (\textrm, \textbf, \textit, \textsc, \overline, \underline), акценты (\hat, \tilde, \dot, \ddot, \acute, \check, \grave, \bar, \breve) и корни (\sqrt, \sqrt3, \sqrt4). Полный список содержит около 2000 символов. Отмечу, что первый пробел (пробел, табуляция и пр.) после команды игнорируется, а все остальные пробелы печатаются обычным образом. Например, следующие строки дают одинаковый результат <em>\tilde a</em>: &lsquo;<samp>\tilde{a}</samp>&rsquo;; &lsquo;<samp>\tilde a</samp>&rsquo;; &lsquo;<samp>\tilde{}a</samp>&rsquo;.
</p>
В частности, распознаются греческие буквы: &alpha; &ndash; \alpha, &beta; &ndash; \beta, &gamma; &ndash; \gamma, &delta; &ndash; \delta, &epsilon; &ndash; \epsilon, &eta; &ndash; \eta, &iota; &ndash; \iota, &chi; &ndash; \chi, &kappa; &ndash; \kappa, &lambda; &ndash; \lambda, &mu; &ndash; \mu, &nu; &ndash; \nu, o &ndash; \o, &omega; &ndash; \omega, &#981; &ndash; \phi, &pi; &ndash; \pi, &psi; &ndash; \psi, &rho; &ndash; \rho, &sigma; &ndash; \sigma, &theta; &ndash; \theta, &tau; &ndash; \tau, &upsilon; &ndash; \upsilon, &xi; &ndash; \xi, &zeta; &ndash; \zeta, &sigmaf; &ndash; \varsigma, &#603; &ndash; \varepsilon, &thetasym; &ndash; \vartheta, &phi; &ndash; \varphi, &#1008; &ndash; \varkappa; A &ndash; \Alpha, B &ndash; \Beta, &Gamma; &ndash; \Gamma, &Delta; &ndash; \Delta, E &ndash; \Epsilon, H &ndash; \Eta, I &ndash; \Iota, C &ndash; \Chi, K &ndash; \Kappa, &Lambda; &ndash; \Lambda, M &ndash; \Mu, N &ndash; \Nu, O &ndash; \O, &Omega; &ndash; \Omega, &Phi; &ndash; \Phi, &Pi; &ndash; \Pi, &Psi; &ndash; \Psi, R &ndash; \Rho, &Sigma; &ndash; \Sigma, &Theta; &ndash; \Theta, T &ndash; \Tau, &Upsilon; &ndash; \Upsilon, &Xi; &ndash; \Xi, Z &ndash; \Zeta.

<p>Еще примеры наиболее общеупотребительных TeX-их символов: &ang; &ndash; \angle, &sdot; &ndash; \cdot, &clubs; &ndash; \clubsuit, &#10003; &ndash; \checkmark, &cup; &ndash; \cup, &cap; &ndash; \cap, &#9826; &ndash; \diamondsuit, &#9671; &ndash; \diamond, &divide;
 &ndash; \div,
&darr; &ndash; \downarrow, &dagger; &ndash; \dag, &Dagger; &ndash; \ddag, &equiv; &ndash; \equiv, &exist; &ndash; \exists, &#8994; &ndash; \frown, &#9837; &ndash; \flat, &ge; &ndash; \ge, &ge; &ndash; \geq, &#8807; &ndash; \geqq, &larr; &ndash; \gets, &#9825; &ndash; \heartsuit, &infin; &ndash; \infty, &int; &ndash; \int, \Int, &image;  &ndash; \Im, &#9826; &ndash; \lozenge, &#10216; &ndash; \langle, &le; &ndash; \le, &le; &ndash; \leq, &#8806; &ndash; \leqq, &larr; &ndash; \leftarrow, &#8723; &ndash; \mp, &nabla; &ndash; \nabla, &ne; &ndash; \ne, &ne; &ndash; \neq, &#9838; &ndash; \natural, &#8750; &ndash; \oint, &#8857; &ndash; \odot, &oplus; &ndash; \oplus, &part; &ndash; \partial, &#8741; &ndash; \parallel, &perp; &ndash;\perp, &plusmn; &ndash; \pm, &prop; &ndash; \propto, &prod; &ndash; \prod, &real; &ndash; \Re, &rarr; &ndash; \rightarrow, &#10217; &ndash; \rangle, &spades; &ndash; \spadesuit, ~ &ndash; \sim, &#8995; &ndash; \smile, &sub;  &ndash; \subset, &sup; &ndash; \supset, &radic; &ndash; \sqrt or \surd, &sect; &ndash; \S, &#9839; &ndash; \sharp, &sum; &ndash; \sum, &times; &ndash; \times, &rarr; &ndash; \to, &there4; &ndash; \therefore, &uarr; &ndash; \uparrow, &weierp; &ndash; \wp. </p>

<p>Размер текста может быть задан явно (если <var>size</var>&gt;0) или относительно базового размера шрифта для рисунка |<var>size</var>|*<var>FontSize</var> при <var>size</var>&lt;0. Значение <var>size</var>=0 указывает, что соответствующая строка выводиться не будет. Базовый размер шрифта измеряется во внутренних единицах. Специальные функции <code>SetFontSizePT(), SetFontSizeCM(), SetFontSizeIN()</code> позволяют задавать его в более &ldquo;привычных&rdquo; единицах.
</p>

<hr>
<a name="Textual-formulas"></a>
<div class="header">
<p>
Next: <a href="#Command-options" accesskey="n" rel="next">Command options</a>, Previous: <a href="#Font-styles" accesskey="p" rel="prev">Font styles</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tekstovye-formuly"></a>
<h3 class="section">3.6 Текстовые формулы</h3>

<a name="index-Tekstovye-formuly"></a>

<p>MathGL имеет быстрый парсер текстовых формул
(see <a href="#Evaluate-expression">Evaluate expression</a>)
, понимающий большое число функций и операций. Базовые операции: &lsquo;<samp>+</samp>&rsquo; &ndash; сложение, &lsquo;<samp>-</samp>&rsquo; &ndash; вычитание, &lsquo;<samp>*</samp>&rsquo; &ndash; умножение, &lsquo;<samp>/</samp>&rsquo; &ndash; деление, &lsquo;<samp>%</samp>&rsquo; &ndash; остаток от деления, &lsquo;<samp>^</samp>&rsquo; &ndash; возведение в целосичленную степень. Также есть логические операции: &lsquo;<samp>&lt;</samp>&rsquo; &ndash; истина если if x&lt;y, &lsquo;<samp>&gt;</samp>&rsquo; &ndash; истина если x&gt;y, &lsquo;<samp>=</samp>&rsquo; &ndash; истина если x=y, &lsquo;<samp>&amp;</samp>&rsquo; &ndash; истина если x и y оба не равны нулю, &lsquo;<samp>|</samp>&rsquo; &ndash; истина если x или y не нуль. Логические операции имеют наинизший приоритет и возвращают 1 если истина или 0 если ложно.
</p>
<p>Базовые функции: &lsquo;<samp>sqrt(x)</samp>&rsquo; &ndash; квадратный корень из <var>x</var>, &lsquo;<samp>pow(x,y)</samp>&rsquo; &ndash; <var>x</var> в степени <var>y</var>, &lsquo;<samp>ln(x)</samp>&rsquo; &ndash; натуральный логарифм <var>x</var>, &lsquo;<samp>lg(x)</samp>&rsquo; &ndash; десятичный логарифм <var>x</var>, &lsquo;<samp>log(a,x)</samp>&rsquo; &ndash; логарифм по основанию <var>a</var> от <var>x</var>, &lsquo;<samp>abs(x)</samp>&rsquo; &ndash; модуль <var>x</var>, &lsquo;<samp>sign(x)</samp>&rsquo; &ndash; знак <var>x</var>, &lsquo;<samp>mod(x,y)</samp>&rsquo; &ndash; остаток от деления <var>x</var> на <var>y</var>, &lsquo;<samp>step(x)</samp>&rsquo; &ndash; ступенчатая функция, &lsquo;<samp>int(x)</samp>&rsquo; &ndash; целая часть <var>x</var>, &lsquo;<samp>rnd</samp>&rsquo; &ndash; случайное число, &lsquo;<samp>random(x)</samp>&rsquo; &ndash; матрица случайный чисел размером как <var>x</var>, &lsquo;<samp>hypot(x,y)</samp>&rsquo;=sqrt(x^2+y^2) &ndash; гипотенуза, &lsquo;<samp>cmplx(x,y)</samp>&rsquo;=x+i*y &ndash; комплексное число, &lsquo;<samp>pi</samp>&rsquo; &ndash; число
&pi; = 3.1415926&hellip;, inf=&infin;
</p>
<p>Функции для работы с комплексными числами &lsquo;<samp>real(x)</samp>&rsquo;, &lsquo;<samp>imag(x)</samp>&rsquo;, &lsquo;<samp>abs(x)</samp>&rsquo;, &lsquo;<samp>arg(x)</samp>&rsquo;, &lsquo;<samp>conj(x)</samp>&rsquo;.
</p>
<p>Тригонометрические функции: &lsquo;<samp>sin(x)</samp>&rsquo;, &lsquo;<samp>cos(x)</samp>&rsquo;, &lsquo;<samp>tan(x)</samp>&rsquo; (или &lsquo;<samp>tg(x)</samp>&rsquo;). Обратные тригонометрические функции: &lsquo;<samp>asin(x)</samp>&rsquo;, &lsquo;<samp>acos(x)</samp>&rsquo;, &lsquo;<samp>atan(x)</samp>&rsquo;. Гиперболические функции: &lsquo;<samp>sinh(x)</samp>&rsquo; (или &lsquo;<samp>sh(x)</samp>&rsquo;), &lsquo;<samp>cosh(x)</samp>&rsquo; (или &lsquo;<samp>ch(x)</samp>&rsquo;), &lsquo;<samp>tanh(x)</samp>&rsquo; (или &lsquo;<samp>th(x)</samp>&rsquo;). Обратные гиперболические функции: &lsquo;<samp>asinh(x)</samp>&rsquo;, &lsquo;<samp>acosh(x)</samp>&rsquo;, &lsquo;<samp>atanh(x)</samp>&rsquo;.
</p>
<p>Специальные функции: &lsquo;<samp>gamma(x)</samp>&rsquo; &ndash; гамма функция &Gamma;(x) = &int;<sub>0</sub><sup>&infin;</sup> t<sup>x-1</sup> exp(-t) dt, &lsquo;<samp>gamma_inc(x,y)</samp>&rsquo; &ndash; неполная гамма функция &Gamma;(x,y) = &int;<sub>y</sub><sup>&infin;</sup> t<sup>x-1</sup> exp(-t) dt, &lsquo;<samp>psi(x)</samp>&rsquo; &ndash; дигамма функция &psi;(x) = &Gamma;&prime;(x)/&Gamma;(x) для x&ne;0, &lsquo;<samp>ai(x)</samp>&rsquo; &ndash; Эйри функция Ai(x), &lsquo;<samp>bi(x)</samp>&rsquo; &ndash; Эйри функция Bi(x), &lsquo;<samp>cl(x)</samp>&rsquo; &ndash; функция Клаузена, &lsquo;<samp>li2(x)</samp>&rsquo; (или &lsquo;<samp>dilog(x)</samp>&rsquo;) &ndash; дилогарифм Li<sub>2</sub>(x) = -&real;&int;<sub>0</sub><sup>x</sup>ds log(1-s)/s, &lsquo;<samp>sinc(x)</samp>&rsquo; &ndash; функция sinc(x) = sin(&pi;x)/(&pi;x) для любых x, &lsquo;<samp>zeta(x)</samp>&rsquo; &ndash; зета функция Римана &zeta;(s) = &sum;<sub>k=1</sub><sup>&infin;</sup>k<sup>-s</sup> для s&ne;1, &lsquo;<samp>eta(x)</samp>&rsquo; &ndash; эта функция &eta;(s) = (1 - 2<sup>1-s</sup>)&zeta;(s) для произвольного s, &lsquo;<samp>lp(l,x)</samp>&rsquo; &ndash; полином Лежандра P<sub>l</sub>(x), (|x|&le;1, l&ge;0), &lsquo;<samp>w0(x)</samp>&rsquo;, &lsquo;<samp>w1(x)</samp>&rsquo; &ndash; функции Ламберта W. Функции W(x) определены как решение уравнения: W exp(W) = x. </p>

<p>Экспоненциальные интегралы: &lsquo;<samp>ci(x)</samp>&rsquo; &ndash; cos-интеграл Ci(x) = &int;<sub>0</sub><sup>x</sup>dt cos(t)/t, &lsquo;<samp>si(x)</samp>&rsquo; &ndash; sin-интеграл Si(x) = &int;<sub>0</sub><sup>x</sup>dt sin(t)/t, &lsquo;<samp>erf(x)</samp>&rsquo; &ndash; функция ошибки erf(x) = (2/&radic;&pi;) &int;<sub>0</sub><sup>x</sup>dt exp(-t<sup>2</sup>) , &lsquo;<samp>ei(x)</samp>&rsquo; &ndash; интеграл Ei(x) = -PV(&int;<sub>-x</sub><sup>&infin;</sup>dt exp(-t)/t) (где PV обозначает главное значение), &lsquo;<samp>e1(x)</samp>&rsquo; &ndash; интеграл E<sub>1</sub>(x) = &real;&int;<sub>1</sub><sup>&infin;</sup>dt exp(-xt)/t, &lsquo;<samp>e2(x)</samp>&rsquo; &ndash; интеграл E<sub>2</sub>(x) = &real;&int;<sub>1</sub>&infin;</sup>dt exp(-xt)/t<sup>2</sup>, &lsquo;<samp>ei3(x)</samp>&rsquo; &ndash; интеграл Ei<sub>3</sub>(x) = &int;<sub>0</sub><sup>x</sup>dt exp(-t<sup>3</sup>) для x&ge;0. </p>

<p>Функции Бесселя: &lsquo;<samp>j(nu,x)</samp>&rsquo; &ndash; функция Бесселя первого рода, &lsquo;<samp>y(nu,x)</samp>&rsquo; &ndash; функция Бесселя второго рода, &lsquo;<samp>i(nu,x)</samp>&rsquo; &ndash; модифицированная функция Бесселя первого рода, &lsquo;<samp>k(nu,x)</samp>&rsquo; &ndash; модифицированная функция Бесселя второго рода. </p>

<p>Эллиптические интегралы: &lsquo;<samp>ee(k)</samp>&rsquo; &ndash; полный эллиптический интеграл E(k) = E(&pi;/2,k), &lsquo;<samp>ek(k)</samp>&rsquo; &ndash; полный эллиптический интеграл K(k) = F(&pi;/2,k), &lsquo;<samp>e(phi,k)</samp>&rsquo; &ndash; эллиптический интеграл E(&phi;,k) = &int;<sub>0</sub><sup>&phi;</sup>dt &radic;(1 - k<sup>2</sup>sin<sup>2</sup>(t)), &lsquo;<samp>f(phi,k)</samp>&rsquo; &ndash; эллиптический интеграл F(&phi;,k) = &int;<sub>0</sub><sup>&phi;</sup>dt 1/&radic;(1 - k<sup>2</sup>sin<sup>2</sup>(t))</p>

<p>Функции Якоби: &lsquo;<samp>sn(u,m)</samp>&rsquo;, &lsquo;<samp>cn(u,m)</samp>&rsquo;, &lsquo;<samp>dn(u,m)</samp>&rsquo;, &lsquo;<samp>sc(u,m)</samp>&rsquo;, &lsquo;<samp>sd(u,m)</samp>&rsquo;, &lsquo;<samp>ns(u,m)</samp>&rsquo;, &lsquo;<samp>cs(u,m)</samp>&rsquo;, &lsquo;<samp>cd(u,m)</samp>&rsquo;, &lsquo;<samp>nc(u,m)</samp>&rsquo;, &lsquo;<samp>ds(u,m)</samp>&rsquo;, &lsquo;<samp>dc(u,m)</samp>&rsquo;, &lsquo;<samp>nd(u,m)</samp>&rsquo;.
</p>
<p>Некоторые из функций могут быть недоступны если не была включена поддержка GSL при компиляции библиотеки MathGL.
</p>
<p>При разборе формул нет различия между верхним и нижним регистром. Если аргумент лежит вне области определения функции, то возвращается NaN.
</p>

<hr>
<a name="Command-options"></a>
<div class="header">
<p>
Next: <a href="#Interfaces" accesskey="n" rel="next">Interfaces</a>, Previous: <a href="#Textual-formulas" accesskey="p" rel="prev">Textual formulas</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Opcii-komand"></a>
<h3 class="section">3.7 Опции команд</h3>


<p>Опции команд позволяют легко настроить вид отдельного графика не меняя глобальных настроек для все рисунка. Каждая опция отделяется от предыдущей символом &lsquo;<samp>;</samp>&rsquo;. Опции работают так, что запоминают текущие настройки рисунка, применяют собственные настройки, выполняют команду и возвращают глобальные настройки обратно. Поэтому использование опций для команд обработки данных или настройки графика бесполезно.
</p>
<p>Наиболее часто используемые опции &ndash; <code>xrange, yrange, zrange</code>, устанавливают границы изменения осей координат (и тем самым автоматических массивов). Например, команда <code>Plot(y,&quot;&quot;,&quot;xrange 0.1 0.9&quot;);</code> или <code>plot y; xrange 0.1 0.9</code> построит кривую с x-координатой равно распределенной в интервале 0.1 ... 0.9, а не вдоль текущей оси x. См. раздел <a href="#Using-options">Using options</a>, для примеров кода и графика.
</p>
<p>Полный список опций:
<a name="index-alpha"></a>
<a name="index-alphadef"></a>
</p><dl>
<dt><a name="index-alpha-1"></a>Опция MGL: <strong>alpha</strong> <em><code>val</code></em></dt>
<dd><p>Задает величину прозрачности поверхности. Значение должно быть в диапазоне [0, 1]. См. также <a href="#alphadef">alphadef</a>
</p></dd></dl>

<a name="index-xrange"></a>
<dl>
<dt><a name="index-xrange-1"></a>Опция MGL: <strong>xrange</strong> <em><code>val1 val2</code></em></dt>
<dd><p>Задает границы изменения координаты x. См. также <a href="#xrange">xrange</a>
</p></dd></dl>
<a name="index-yrange"></a>
<dl>
<dt><a name="index-yrange-1"></a>Опция MGL: <strong>yrange</strong> <em><code>val1 val2</code></em></dt>
<dd><p>Задает границы изменения координаты y. См. также <a href="#yrange">yrange</a>
</p></dd></dl>
<a name="index-zrange"></a>
<dl>
<dt><a name="index-zrange-1"></a>Опция MGL: <strong>zrange</strong> <em><code>val1 val2</code></em></dt>
<dd><p>Задает границы изменения координаты z. См. также <a href="#zrange">zrange</a>
</p></dd></dl>

<a name="index-cut"></a>
<dl>
<dt><a name="index-cut-1"></a>Опция MGL: <strong>cut</strong> <em><code>val</code></em></dt>
<dd><p>Задает обрезание точек за пределами осей координат. См. также <a href="#cut">cut</a>.
</p></dd></dl>
<a name="index-fontsize"></a>
<dl>
<dt><a name="index-size"></a>Опция MGL: <strong>size</strong> <em><code>val</code></em></dt>
<dd><p>Задает размер текста, маркеров и стрелок. См. также <a href="#font">font</a>, <a href="#marksize">marksize</a>, <a href="#arrowsize">arrowsize</a>.
</p></dd></dl>
<a name="index-meshnum"></a>
<dl>
<dt><a name="index-meshnum-1"></a>Опция MGL: <strong>meshnum</strong> <em><code>val</code></em></dt>
<dd><p>Задает ориентировочное число линий, стрелок, ячеек и пр. См. также <a href="#meshnum">meshnum</a>
</p></dd></dl>

<a name="index-legend"></a>
<dl>
<dt><a name="index-legend-1"></a>Опция MGL: <strong>legend</strong> <em>'txt'</em></dt>
<dd><p>Добавляет строку &rsquo;txt&rsquo; во внутренний массив записей легенды. Стиль линии и маркера аргумента последней вызванной команды построения <a href="#g_t1D-plotting">1D plotting</a>. См. также <a href="#legend">legend</a>
</p></dd></dl>
<a name="index-value"></a>
<dl>
<dt><a name="index-value-1"></a>MGL option: <strong>value</strong> <em><code>val</code></em></dt>
<dd><p>Задает значение, которое будет использовано как дополнительный числовой параметр при построении графика.
</p></dd></dl>




<hr>
<a name="Interfaces"></a>
<div class="header">
<p>
Previous: <a href="#Command-options" accesskey="p" rel="prev">Command options</a>, Up: <a href="#General-concepts" accesskey="u" rel="up">General concepts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Interfeisy"></a>
<h3 class="section">3.8 Интерфейсы</h3>




<p>Библиотека MathGL имеет интерфейсы к ряду языков программирования. Большинство из них основано на С интерфейсе с использованием SWIG. Это Python, Java, Octave, Lisp, C#, Guile, Lua, Modula 3, Ocaml, Perl, PHP, Pike, R, Ruby, и Tcl интерфейсы. Также есть Fortran интерфейс, который имеет схожий набор функций, но слегка различающиеся типы аргументов (целые вместо указателей). Эти функции отмечены как [C function].
</p>
<p>Некоторые языки поддерживают классы (подобно C++ или Python). Имена функций для них такие же как в С++ (см. <a href="#MathGL-core">MathGL core</a> и <a href="#Data-processing">Data processing</a>) и отмечены, например, так [Method on mglGraph].
</p>
<p>Наконец, специальный командный язык MGL (см. <a href="#MGL-scripts">MGL scripts</a>) был создан для быстрого доступа к функциям рисования. Соответствующие скрипты могут быть выполнены самостоятельно (с помощью UDAV, mglconv, mglview и т.д.) или из программы на языке C/C++/Python/... (см. <a href="#mglParse-class">mglParse class</a>).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#C-interface" accesskey="1">C interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#C_002b_002b-interface" accesskey="2">C++ interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="C-interface"></a>
<div class="header">
<p>
Next: <a href="#C_002b_002b-interface" accesskey="n" rel="next">C++ interface</a>, Up: <a href="#Interfaces" accesskey="u" rel="up">Interfaces</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="C_002fFortran-interfeis"></a>
<h4 class="subsection">3.8.1 C/Fortran интерфейс</h4>


<p>C интерфейс &ndash; основа для многих других интерфейсов. Он содержит функции С для всех методов MathGL. В отличие от C++ классов, C функции содержат обязательный(ые) аргумент(ы) типа HMGL (для графики) и/или HCDT/HMDT/HADT (для массивов данных), который указывают на объект для рисования или изменения. Поэтому перед использованием их необходимо создать с помощью функции <code>mgl_create_*()</code>, и удалить после использования (или в конце программы) с помощью функции <code>mgl_delete_*()</code>.
</p>
<p>Все C функции описаны в заголовочном файле <code>#include &lt;mgl2/mgl_cf.h&gt;</code> и используют переменные следующих типов:
</p><ul>
<li> <code>HMGL</code> &mdash; Указатель на класс <code>mglGraph</code> (см. <a href="#MathGL-core">MathGL core</a>).
</li><li> <code>HCDT</code> &mdash; Указатель на класс <code>const mglDataA</code> (см. <a href="#Data-processing">Data processing</a>) &mdash; неизменяемые массивы данных.
</li><li> <code>HMDT</code> &mdash; Указатель на класс <code>mglData</code> (см. <a href="#Data-processing">Data processing</a>) &mdash; массивы данных с действительными числами.
</li><li> <code>HADT</code> &mdash; Указатель на класс <code>mglDataC</code> (см. <a href="#Data-processing">Data processing</a>) &mdash; массивы данных с комплексными числами.
</li><li> <code>HMPR</code> &mdash; Указатель на класс <code>mglParse</code> (см. <a href="#mglParse-class">mglParse class</a>) &mdash; выполнение MGL скриптов.
</li><li> <code>HMEX</code> &mdash; Указатель на класс <code>mglExpr</code> (см. <a href="#Evaluate-expression">Evaluate expression</a>) &mdash; текстовые формулы для действительных чисел.
</li><li> <code>HMAX</code> &mdash; Указатель на класс <code>mglExprC</code> (см. <a href="#Evaluate-expression">Evaluate expression</a>) &mdash; текстовые формулы для комплексных чисел.
</li></ul>

<p>Фортрановские функции и подпрограммы имеют такие же имена как функции С. Однако есть отличие. Переменные типов <code>HMGL, HCDT, HMDT, ...</code> должны быть целыми с достаточной разрядностью (<code>integer*4</code> для 32-битной операционной системы или <code>integer*8</code> для 64-битной). Все C функции типа <code>void</code> &mdash; подпрограммы на Фортране и должны вызываться оператором <code>call</code>. Прочие функции, возвращающие тип <code>HMGL</code> или <code>HMDT</code> и т.п. должны быть объявлены в Фортране как возвращающие целое нужной разрядности. Также необходимо иметь в виду, что строки в Фортране отделяются символом <code>'</code>, а не <code>&quot;</code>.
</p>

<hr>
<a name="C_002b_002b-interface"></a>
<div class="header">
<p>
Previous: <a href="#C-interface" accesskey="p" rel="prev">C interface</a>, Up: <a href="#Interfaces" accesskey="u" rel="up">Interfaces</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="C_002b_002b_002fPython-interfeis"></a>
<h4 class="subsection">3.8.2 C++/Python интерфейс</h4>


<p>MathGL имеет интерфейс на основе классов (объектов с членами-функциями) с использованием библиотеки SWIG. Типичный пример &ndash; Python, имя которого использовано в заголовке раздела. В точности те же классы используются и в C++ API. Отмечу, что С++ классы содержат только inline члены-функции, что делает С++ API независимым от компилятора даже для бинарной версии.
</p>
<p>Есть 3 основных класса:
</p><ul>
<li> <code>mglGraph</code>
&ndash; обеспечивает вывод графики (см. <a href="#MathGL-core">MathGL core</a>).
</li><li> <code>mglData</code>
&ndash; обеспечивает обработку данных (см. <a href="#Data-processing">Data processing</a>). Класс имеет возможность прямого доступа к данным с помощью конструкции вида: <code>dat[i]=sth;</code> или <code>sth=dat[i]</code>, где используется &quot;плоское&quot; представление данных (т.е., <var>i</var> может быть в диапазоне 0...nx*nx*nz-1). Также можно импортировать массивы NumPy в Python: <code>mgl_dat = mglData(numpy_dat);</code>.
</li><li> <code>mglParse</code>
&ndash; обеспечивает выполнение скриптов MGL (см. <a href="#MGL-scripts">MGL scripts</a>).
</li></ul>


<p>Для использования в Python достаточно выполнить &lsquo;<samp>import mathgl</samp>&rsquo;. Простейший пример имеет вид:
</p><pre class="verbatim">import mathgl
a=mathgl.mglGraph()
a.Box()
a.WritePNG(&quot;test.png&quot;)
</pre><p>Также можно импортировать все классы из модуля <code>mathgl</code> и обеспечить более легкий доступ к MathGL:
</p><pre class="verbatim">from mathgl import *
a=mglGraph()
a.Box()
a.WritePNG(&quot;test.png&quot;)
</pre><p>Это становится более полезным если, например, вы создаете много объектов данных <code>mglData</code>.
</p>



<hr>
<a name="MathGL-core"></a>
<div class="header">
<p>
Next: <a href="#Widget-classes" accesskey="n" rel="next">Widget classes</a>, Previous: <a href="#General-concepts" accesskey="p" rel="prev">General concepts</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="YAdro-MathGL"></a>
<h2 class="chapter">4 Ядро MathGL</h2>

<a name="index-mglGraph"></a>


<p>Основным классом MathGL является класс <strong>mglGraph</strong>, определённый в <code>#include &lt;mgl2/mgl.h&gt;</code>. Он включает в себя множество функций для построения графиков от 1D, 2D и 3D массивов. Он также содержит функции вывода текста и построения осей координат. Есть возможность построения в произвольной системе координат, которая  задается строковыми формулами. Все графические функции используют класс mglData (см. <a href="#Data-processing">Data processing</a>) для хранения массивов данных. Это позволяет легко контролировать размеры, работу с памятью и производить обработку данных. Дополнительная информация о цветах, шрифтах, вычисления формул может быть найдена в <a href="#General-concepts">General concepts</a> и <a href="#Other-classes">Other classes</a>.
</p>
<p>Некоторые возможности MathGL доступны только в новых версиях библиотеки. Для проверки текущей версии MathGL можно использовать следующую функцию.
<a name="version"></a></p><dl>
<dt><a name="index-version"></a>Команда MGL: <em></em> <strong>version</strong> <em>'ver'</em></dt>
<dt><a name="index-CheckVersion"></a>Метод класса <code>mglGraph</code>: <em><code>bool</code></em> <strong>CheckVersion</strong> <em>(<code>const char *</code>ver) static</em></dt>
<dt><a name="index-mgl_005fcheck_005fversion"></a>Функция С: <em><code>int</code></em> <strong>mgl_check_version</strong> <em>(<code>const char *</code>ver)</em></dt>
<dd><p>Возвращает нулевое значение если версия MathGL подходит для требуемой в <var>ver</var>, т.е. если номер основной версии совпадает и &quot;подверсия&quot; больше или равна указанной в <var>ver</var>.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Constructor" accesskey="1">Constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Graphics-setup" accesskey="2">Graphics setup</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Axis-settings" accesskey="3">Axis settings</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Subplots-and-rotation" accesskey="4">Subplots and rotation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Export-picture" accesskey="5">Export picture</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Background" accesskey="6">Background</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Primitives" accesskey="7">Primitives</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Text-printing" accesskey="8">Text printing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Axis-and-Colorbar" accesskey="9">Axis and Colorbar</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Legend">Legend</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t1D-plotting">1D plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t2D-plotting">2D plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t3D-plotting">3D plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dual-plotting">Dual plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Vector-fields">Vector fields</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-plotting">Other plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nonlinear-fitting">Nonlinear fitting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-manipulation">Data manipulation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Constructor"></a>
<div class="header">
<p>
Next: <a href="#Graphics-setup" accesskey="n" rel="next">Graphics setup</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sozdanie-i-udalenie-graficheskogo-obwekta"></a>
<h3 class="section">4.1 Создание и удаление графического объекта</h3>


<dl>
<dt><a name="index-mglGraph-1"></a>Конструктор класса <code>mglGraph</code>: <em></em> <strong>mglGraph</strong> <em>(<code>int</code> kind=<code>0</code>, <code>int</code> width=<code>600</code>, <code>int</code> height=<code>400</code>)</em></dt>
<dt><a name="index-mglGraph-2"></a>Конструктор класса <code>mglGraph</code>: <em></em> <strong>mglGraph</strong> <em>(<code>const mglGraph &amp;</code>gr)</em></dt>
<dt><a name="index-mglGraph-3"></a>Конструктор класса <code>mglGraph</code>: <em></em> <strong>mglGraph</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fcreate_005fgraph"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_create_graph</strong> <em>(<code>int</code> width, <code>int</code> height)</em></dt>
<dt><a name="index-mgl_005fcreate_005fgraph_005fgl"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_create_graph_gl</strong> <em>()</em></dt>
<dd><p>Создает (или использует созданный) экземпляр класса, производного от <code>mglGraph</code> (тип <code>HMGL</code>) с указанными размерами <var>width</var> и <var>height</var>. Параметр <var>kind</var> может иметь следующие значения: &lsquo;<samp>0</samp>&rsquo; &ndash; использовать рисование по умолчанию, &lsquo;<samp>1</samp>&rsquo; &ndash; использовать рисование в OpenGL.
</p></dd></dl>

<dl>
<dt><a name="index-_007emglGraph"></a>Destructor on <code>mglGraph</code>: <em></em> <strong>~mglGraph</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdelete_005fgraph"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_delete_graph</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Удаляет экземпляр класса mglGraph.
</p></dd></dl>

<dl>
<dt><a name="index-Self"></a>Метод класса <code>mglGraph</code>: <em><code>HMGL</code></em> <strong>Self</strong> <em>()</em></dt>
<dd><p>Возвращает указатель на используемый объект типа <code>HMGL</code>.
</p></dd></dl>



<hr>
<a name="Graphics-setup"></a>
<div class="header">
<p>
Next: <a href="#Axis-settings" accesskey="n" rel="next">Axis settings</a>, Previous: <a href="#Constructor" accesskey="p" rel="prev">Constructor</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nastroika-grafika"></a>
<h3 class="section">4.2 Настройка графика</h3>

<a name="index-Nastroika-MathGL"></a>

<p>Функции и переменные в этой группе влияют на вид всего рисунка. Соответственно они должны располагаться <em>перед</em> вызовом функций непосредственно рисующих графики.
</p>
<a name="reset"></a><dl>
<dt><a name="index-reset"></a>Команда MGL: <em></em> <strong>reset</strong></dt>
<dt><a name="index-DefaultPlotParam"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DefaultPlotParam</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fset_005fdef_005fparam"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_def_param</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Устанавливает все настройки по умолчанию и очищает рисунок.
</p></dd></dl>

<a name="setup"></a><dl>
<dt><a name="index-setup"></a>Команда MGL: <em></em> <strong>setup</strong> <em><code>val flag</code></em></dt>
<dt><a name="index-SetFlagAdv"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFlagAdv</strong> <em>(<code>int</code> val, <code>uint32_t</code> flag)</em></dt>
<dt><a name="index-mgl_005fset_005fflag"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_flag</strong> <em>(<code>HMGL</code> gr, <code>int</code> val, <code>uint32_t</code> flag)</em></dt>
<dd><p>Устанавливает значение бинарного флага <var>flag</var> в <var>val</var>. Список флагов можно найти в <a href="https://sourceforge.net/p/mathgl/code/HEAD/tree/mathgl-2x/include/mgl2/define.h#l267">define.h</a>. Текущий список флагов: 
</p><pre class="verbatim">#define MGL_ENABLE_CUT		0x00000004 	///&lt; Определяет способ рисования точек вне диапазона осей координат
#define MGL_ENABLE_RTEXT 	0x00000008 	///&lt; Использовать вращение текста
#define MGL_AUTO_FACTOR		0x00000010 	///&lt; Разрешить автоматическое масштабирование графика
#define MGL_ENABLE_ALPHA 	0x00000020 	///&lt; Использовать прозрачность
#define MGL_ENABLE_LIGHT 	0x00000040 	///&lt; Использовать освещение
#define MGL_TICKS_ROTATE 	0x00000080 	///&lt; Разрешить вращение меток осей
#define MGL_TICKS_SKIP		0x00000100 	///&lt; Разрешить пропуск меток осей
#define MGL_DISABLE_SCALE	0x00000200 	///&lt; Временный флаг, запрещающий изменение размеров
#define MGL_FINISHED 		0x00000400 	///&lt; Флаг готовности окончательной картинки (т.е. mglCanvas::G)
#define MGL_USE_GMTIME		0x00000800 	///&lt; Использовать gmtime вместо localtime
#define MGL_SHOW_POS		0x00001000 	///&lt; Включить показ координат щелчка мыши
#define MGL_CLF_ON_UPD		0x00002000 	///&lt; Очищать график перед Update()
#define MGL_NOSUBTICKS		0x00004000 	///&lt; Запретить рисование subticks для bounding box
#define MGL_LOCAL_LIGHT		0x00008000 	///&lt; Сохранять источники освещения в каждом inplot
#define MGL_VECT_FRAME		0x00010000 	///&lt; Использовать DrwDat для сохранения всех данных в кадрах
#define MGL_REDUCEACC		0x00020000 	///&lt; Сокращать точность вывода точек (для уменьшения размера выходных файлов)
#define MGL_PREFERVC 		0x00040000 	///&lt; Предпочитать цвета вершин вместо текстур если выходной формат поддерживает
#define MGL_ONESIDED 		0x00080000 	///&lt; Выводить только переднюю сторону поверхностей если выходной формат поддерживает
#define MGL_NO_ORIGIN 		0x00100000 	///&lt; Не рисовать метки в точке пересечения осей
#define MGL_GRAY_MODE 		0x00200000 	///&lt; Преобразовать все цвета в оттенки серого
#define MGL_FULL_CURV 		0x00400000 	///&lt; Запретить пропуск точек на прямолинейных участках
#define MGL_NO_SCALE_REL 	0x00800000 	///&lt; Запретить изменение размера текста в относительных inplots
</pre></dd></dl>

<dl>
<dt><a name="index-mgl_005fbsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_bsize</strong> <em>(<code>unsigned</code> bsize)</em></dt>
<dd><p>Задает размер буфера под примитивы как (1&lt;&lt;bsize)^2. Т.е. как 10^12 для bsize=20 или 4*10^9 для bsize=16 (по умолчанию). ВАЖНО: можно устанавливать только один раз вначале, до построения графиков. Возвращает текущее значение.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Transparency" accesskey="1">Transparency</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Lighting" accesskey="2">Lighting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Fog" accesskey="3">Fog</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Default-sizes" accesskey="4">Default sizes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cutting" accesskey="5">Cutting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Font-settings" accesskey="6">Font settings</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Palette-and-colors" accesskey="7">Palette and colors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Masks" accesskey="8">Masks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-handling" accesskey="9">Error handling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Stop-drawing">Stop drawing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Transparency"></a>
<div class="header">
<p>
Next: <a href="#Lighting" accesskey="n" rel="next">Lighting</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Prozrachnostx"></a>
<h4 class="subsection">4.2.1 Прозрачность</h4>

<a name="index-Alpha"></a>
<a name="index-SetAlphaDef"></a>
<a name="index-SetTranspType"></a>
<a name="index-AlphaDef"></a>
<a name="index-TranspType"></a>

<p>Эти функции и переменные настраивают тип и степень прозрачности поверхностей. Главной является функция <a href="#alpha">alpha</a>, которая включает/выключает прозрачность для всего графика. Функция <a href="#alphadef">alphadef</a> устанавливает величину alpha-канала по умолчанию. Наконец, функция <a href="#transptype">transptype</a> задает тип прозрачности. См. раздел <a href="#Transparency-and-lighting">Transparency and lighting</a>, для примеров кода и графика.
</p>
<a name="alpha"></a><dl>
<dt><a name="index-alpha-2"></a>Команда MGL: <em></em> <strong>alpha</strong> <em><code>[val=on]</code></em></dt>
<dt><a name="index-Alpha-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Alpha</strong> <em>(<code>bool</code> enable)</em></dt>
<dt><a name="index-mgl_005fset_005falpha"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_alpha</strong> <em>(<code>HMGL</code> gr, <code>int</code> enable)</em></dt>
<dd><p>Включает/выключает прозрачность и возвращает свое предыдущее состояние. По умолчанию прозрачность выключена. Функция включает прозрачность для <em>всего</em> рисунка.
</p></dd></dl>

<a name="alphadef"></a><dl>
<dt><a name="index-alphadef-1"></a>Команда MGL: <em></em> <strong>alphadef</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetAlphaDef-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetAlphaDef</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005falpha_005fdefault"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_alpha_default</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> alpha)</em></dt>
<dd><p>Задает значение прозрачности по умолчанию для всех графиков. Значение по умолчанию 0.5.
</p></dd></dl>

<a name="transptype"></a><dl>
<dt><a name="index-transptype"></a>Команда MGL: <em></em> <strong>transptype</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetTranspType-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTranspType</strong> <em>(<code>int</code> type)</em></dt>
<dt><a name="index-mgl_005fset_005ftransp_005ftype"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_transp_type</strong> <em>(<code>HMGL</code> gr, <code>int</code> type)</em></dt>
<dd><p>Задает тип прозрачности. Допустимые значения:
</p><ul>
<li> Обычная прозрачность (&lsquo;<samp>0</samp>&rsquo;) &ndash; &quot;закрытые&quot; объекты видны меньше чем закрывающие. Этот режим некорректно отображается в OpenGL (mglGraphGL) для нескольких перекрывающихся поверхностей.
</li><li> &quot;Стеклянная&quot; прозрачность (&lsquo;<samp>1</samp>&rsquo;) &ndash; закрытые и закрывающие объекты единообразно ослабляют интенсивность света (по RGB каналам).
</li><li> &quot;Ламповая&quot; прозрачность (&lsquo;<samp>2</samp>&rsquo;) &ndash; закрытые и закрывающие объекты являются источниками дополнительного освещения (рекомендую установить <code>SetAlphaDef(0.3)</code> или меньше в этом случае).
</li></ul>
<p>См. раздел <a href="#Types-of-transparency">Types of transparency</a>, для примеров кода и графика.
</p></dd></dl>


<hr>
<a name="Lighting"></a>
<div class="header">
<p>
Next: <a href="#Fog" accesskey="n" rel="next">Fog</a>, Previous: <a href="#Transparency" accesskey="p" rel="prev">Transparency</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osveshchenie"></a>
<h4 class="subsection">4.2.2 Освещение</h4>

<a name="index-SetAmbient"></a>
<a name="index-AddLight"></a>
<a name="index-Light"></a>
<a name="index-Ambient"></a>

<p>Эти функции настраивают освещение графика. Главная функция <a href="#light">light</a> включает/выключает освещение графиков построенных после ее вызова (в OpenGL работает сразу для всего рисунка). MathGL  поддерживает до 10 независимых источников света. Но в режиме OpenGL можно использовать только первые 8 из них. Положение, цвет, яркость каждого источника света можно задавать по отдельности. По умолчанию включен только первый (с порядковым номером <code>0</code>) источник света белого цвета, расположенный сверху. См. раздел <a href="#Lighting-sample">Lighting sample</a>, для примеров кода и графика.
</p>
<a name="light"></a><dl>
<dt><a name="index-light"></a>Команда MGL: <em></em> <strong>light</strong> <em><code>[val=on]</code></em></dt>
<dt><a name="index-Light-1"></a>Метод класса <code>mglGraph</code>: <em><code>bool</code></em> <strong>Light</strong> <em>(<code>bool</code> enable)</em></dt>
<dt><a name="index-mgl_005fset_005flight"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_light</strong> <em>(<code>HMGL</code> gr, <code>int</code> enable)</em></dt>
<dd><p>Включает/выключает освещение графика и возвращает предыдущее состояние. По умолчанию освещение выключено.
</p></dd></dl>

<dl>
<dt><a name="index-light-1"></a>Команда MGL: <em></em> <strong>light</strong> <em><code>num</code> <code>val</code></em></dt>
<dt><a name="index-Light-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Light</strong> <em>(<code>int</code> n, <code>bool</code> enable)</em></dt>
<dt><a name="index-mgl_005fset_005flight_005fn"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_light_n</strong> <em>(<code>HMGL</code> gr, <code>int</code> n, <code>int</code> enable)</em></dt>
<dd><p>Включает/выключает <var>n</var>-ый источник света.
</p></dd></dl>

<dl>
<dt><a name="index-light-2"></a>Команда MGL: <em></em> <strong>light</strong> <em><code>num xdir ydir zdir</code> ['col'='w' <code>br=0.5 ap=0</code>]</em></dt>
<dt><a name="index-light-3"></a>Команда MGL: <em></em> <strong>light</strong> <em><code>num xdir ydir zdir xpos ypos zpos</code> ['col'='w' <code>br=0.5</code>]</em></dt>
<dt><a name="index-AddLight-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddLight</strong> <em>(<code>int</code> n, <code>mglPoint</code> d, <code>char</code> c=<code>'w'</code>, <code>mreal</code> bright=<code>0.5</code>, <code>mreal</code> ap=<code>0</code>)</em></dt>
<dt><a name="index-AddLight-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddLight</strong> <em>(<code>int</code> n, <code>mglPoint</code> r, <code>mglPoint</code> d, <code>char</code> c=<code>'w'</code>, <code>mreal</code> bright=<code>0.5</code>, <code>mreal</code> ap=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fadd_005flight"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_light</strong> <em>(<code>HMGL</code> gr, <code>int</code> n, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz)</em></dt>
<dt><a name="index-mgl_005fadd_005flight_005fext"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_light_ext</strong> <em>(<code>HMGL</code> gr, <code>int</code> n, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>char</code> c, <code>mreal</code> bright, <code>mreal</code> ap)</em></dt>
<dt><a name="index-mgl_005fadd_005flight_005floc"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_light_loc</strong> <em>(<code>HMGL</code> gr, <code>int</code> n, <code>mreal</code> rx, <code>mreal</code> ry, <code>mreal</code> rz, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>char</code> c, <code>mreal</code> bright, <code>mreal</code> ap)</em></dt>
<dd><p>Добавляет источник света с номером <var>n</var> в положение <var>p</var> с цветом <var>c</var> и яркостью <var>bright</var>, которая должна быть в диапазоне [0,1]. Если указано положение источника <var>r</var> и оно не NAN, то источник считается локальным, иначе источник полагается бесконечно удалённым (для более быстрого рисования).
</p></dd></dl>

<a name="diffuse"></a><dl>
<dt><a name="index-diffuse"></a>Команда MGL: <em></em> <strong>diffuse</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetDifLight"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetDifLight</strong> <em>(<code>mreal</code> bright)</em></dt>
<dt><a name="index-mgl_005fset_005fdifbr"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_difbr</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> bright)</em></dt>
<dd><p>Задает яркость диффузного освещения (только для локальных источников света).
</p></dd></dl>

<a name="ambient"></a><dl>
<dt><a name="index-ambient"></a>Команда MGL: <em></em> <strong>ambient</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetAmbient-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetAmbient</strong> <em>(<code>mreal</code> bright=<code>0.5</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fambbr"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ambbr</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> bright)</em></dt>
<dd><p>Задает яркость рассеянного освещения. Значение должно быть в диапазоне [0,1].
</p></dd></dl>

<a name="attachlight"></a><dl>
<dt><a name="index-attachlight"></a>Команда MGL: <em></em> <strong>attachlight</strong> <em><code>val</code></em></dt>
<dt><a name="index-AttachLight"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AttachLight</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fattach_005flight"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_attach_light</strong> <em>(<code>HMGL</code> gr, <code>int</code> val)</em></dt>
<dd><p>Задает привязку настроек освещения к <a href="#inplot">inplot</a>/<a href="#subplot">subplot</a>. Отмечу, что OpenGL и некоторые выходные форматы не поддерживают эту возможность.
</p></dd></dl>



<hr>
<a name="Fog"></a>
<div class="header">
<p>
Next: <a href="#Default-sizes" accesskey="n" rel="next">Default sizes</a>, Previous: <a href="#Lighting" accesskey="p" rel="prev">Lighting</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tuman"></a>
<h4 class="subsection">4.2.3 Туман</h4>

<a name="index-Fog"></a>

<a name="fog"></a><dl>
<dt><a name="index-fog"></a>Команда MGL: <em></em> <strong>fog</strong> <em><code>val [dz=0.25]</code></em></dt>
<dt><a name="index-Fog-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fog</strong> <em>(<code>mreal</code> d, <code>mreal</code> dz=<code>0.25</code>)</em></dt>
<dt><a name="index-mgl_005fset_005ffog"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_fog</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> d, <code>mreal</code> dz)</em></dt>
<dd><p>Имитирует туман на графике. Туман начинается на относительном расстоянии <var>dz</var> от точки обзора и его плотность растет экспоненциально вглубь по закону ~ 1-exp(-<em>d*z</em>). Здесь <em>z</em> &ndash; нормализованная на 1 глубина графика. Если <var>d</var>=<code>0</code> то туман отсутствует. См. раздел <a href="#Adding-fog">Adding fog</a>, для примеров кода и графика.
</p></dd></dl>


<hr>
<a name="Default-sizes"></a>
<div class="header">
<p>
Next: <a href="#Cutting" accesskey="n" rel="next">Cutting</a>, Previous: <a href="#Fog" accesskey="p" rel="prev">Fog</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Bazovye-razmery"></a>
<h4 class="subsection">4.2.4 Базовые размеры</h4>

<a name="index-SetBarWidth"></a>
<a name="index-SetMarkSize"></a>
<a name="index-SetArrowSize"></a>
<a name="index-SetMeshNum"></a>
<a name="index-SetPlotId"></a>
<a name="index-BarWidth"></a>
<a name="index-MarkSize"></a>
<a name="index-ArrowSize"></a>
<a name="index-MeshNum"></a>

<p>Эти функции задают величины большинства параметров графика, включая размеры маркеров, стрелок, толщину линий и т.д. Как и любые другие настройки, они подействуют только на графики созданные после изменения настроек.
</p>
<a name="barwidth"></a><dl>
<dt><a name="index-barwidth"></a>Команда MGL: <em></em> <strong>barwidth</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetBarWidth-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetBarWidth</strong> <em>( <code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fbar_005fwidth"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_bar_width</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val)</em></dt>
<dd><p>Задает относительный размер прямоугольников в <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#boxplot">boxplot</a>, <a href="#candle">candle</a>. Значение по умолчанию <code>0.7</code>.
</p></dd></dl>

<a name="marksize"></a><dl>
<dt><a name="index-marksize"></a>Команда MGL: <em></em> <strong>marksize</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetMarkSize-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetMarkSize</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fmark_005fsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_mark_size</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val)</em></dt>
<dd><p>Задает размер маркеров для <a href="#g_t1D-plotting">1D plotting</a>. Значение по умолчанию <code>1</code>.
</p></dd></dl>

<a name="arrowsize"></a><dl>
<dt><a name="index-arrowsize"></a>Команда MGL: <em></em> <strong>arrowsize</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetArrowSize-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetArrowSize</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005farrow_005fsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_arrow_size</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val)</em></dt>
<dd><p>Задает размер стрелок для <a href="#g_t1D-plotting">1D plotting</a>, линий и кривых (см. <a href="#Primitives">Primitives</a>). Значение по умолчанию <code>1</code>.
</p></dd></dl>

<a name="meshnum"></a><a name="MeshNum"></a><dl>
<dt><a name="index-meshnum-2"></a>Команда MGL: <em></em> <strong>meshnum</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetMeshNum-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetMeshNum</strong> <em>(<code>int</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fmeshnum"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_meshnum</strong> <em>(<code>HMGL</code> gr, <code>int</code> num)</em></dt>
<dd><p>Задает ориентировочное число линий в <a href="#mesh">mesh</a>, <a href="#fall">fall</a>, и число стрелок (штрихов) в <a href="#vect">vect</a>, <a href="#dew">dew</a>, и число ячеек в <a href="#cloud">cloud</a>, и число маркеров в <a href="#plot">plot</a>, <a href="#tens">tens</a>, <a href="#step">step</a>, <a href="#mark">mark</a>, <a href="#textmark">textmark</a>. По умолчанию (=0) рисуются все линии, стрелки, ячейки и т.д.
</p></dd></dl>

<a name="facenum"></a><dl>
<dt><a name="index-facenum"></a>Команда MGL: <em></em> <strong>facenum</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetFaceNum"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFaceNum</strong> <em>(<code>int</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005ffacenum"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_facenum</strong> <em>(<code>HMGL</code> gr, <code>int</code> num)</em></dt>
<dd><p>Задает ориентировочное число видимых граней. Может быть использована для ускорения рисования за счет более грубого рисунка. По умолчанию (=0) рисуются все грани.
</p></dd></dl>

<a name="plotid"></a><dl>
<dt><a name="index-plotid"></a>Команда MGL: <em></em> <strong>plotid</strong> <em>'id'</em></dt>
<dt><a name="index-SetPlotId-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetPlotId</strong> <em>(<code>const char *</code>id)</em></dt>
<dt><a name="index-mgl_005fset_005fplotid"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_plotid</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>id)</em></dt>
<dd><p>Задает имя графика для сохранения в файл (например, в окне FLTK).
</p></dd></dl>

<dl>
<dt><a name="index-GetPlotId"></a>Метод класса <code>mglGraph</code>: <em><code>const char *</code></em> <strong>GetPlotId</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005fplotid"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_get_plotid</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fget_005fplotid-1"></a>Fortran процедура: <em><code></code></em> <strong>mgl_get_plotid</strong> <em>(<code>long</code> gr, <code>char *</code>out, <code>int</code> len)</em></dt>
<dd><p>Возвращает имя графика для сохранения в файл (например, в окне FLTK).
</p></dd></dl>

<a name="pendelta"></a><dl>
<dt><a name="index-pendelta"></a>Команда MGL: <em></em> <strong>pendelta</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetPenDelta"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetPenDelta</strong> <em>(<code>double</code> val)</em></dt>
<dt><a name="index-mgl_005fpen_005fdelta"></a>Функция С: <em><code>void</code></em> <strong>mgl_pen_delta</strong> <em>(<code>HMGL</code> gr, <code>double</code> val)</em></dt>
<dd><p>Изменяет размытие около линий и текста (по умолчанию 1). Для <var>val</var>&gt;1 текст и линии более резкие. Для <var>val</var>&lt;1 текст и линии более размытые.
</p></dd></dl>


<hr>
<a name="Cutting"></a>
<div class="header">
<p>
Next: <a href="#Font-settings" accesskey="n" rel="next">Font settings</a>, Previous: <a href="#Default-sizes" accesskey="p" rel="prev">Default sizes</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Obrezanie"></a>
<h4 class="subsection">4.2.5 Обрезание</h4>

<a name="index-SetCut"></a>
<a name="index-SetCutBox"></a>
<a name="index-CutOff"></a>
<a name="index-Cut"></a>

<p>Эти функции задают условия когда точка будет исключена (вырезана) из рисования. Замечу, что все точки со значением(-ями) NAN по одной из координат или амплитуде автоматически исключаются из рисования. См. раздел <a href="#Cutting-sample">Cutting sample</a>, для примеров кода и графика.
</p>
<a name="cut"></a><dl>
<dt><a name="index-cut-2"></a>Команда MGL: <em></em> <strong>cut</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetCut-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetCut</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fcut"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_cut</strong> <em>(<code>HMGL</code> gr, <code>int</code> val)</em></dt>
<dd><p>Задает обрезание точек за пределами осей координат. Если <code>true</code> то такие точки исключаются из рисования (это по умолчанию) иначе они проецируются на ограничивающий прямоугольник.
</p></dd></dl>

<dl>
<dt><a name="index-cut-3"></a>Команда MGL: <em></em> <strong>cut</strong> <em><code>x1 y1 z1 x2 y2 z2</code></em></dt>
<dt><a name="index-SetCutBox-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetCutBox</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p1)</em></dt>
<dt><a name="index-mgl_005fset_005fcut_005fbox"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_cut_box</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2)</em></dt>
<dd><p>Задает границы параллелепипеда внутри которого точки не рисуются. Если границы одинаковы (переменные равны), то параллелепипеда считается пустым.
</p></dd></dl>

<dl>
<dt><a name="index-cut-4"></a>Команда MGL: <em></em> <strong>cut</strong> <em>'cond'</em></dt>
<dt><a name="index-CutOff-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>CutOff</strong> <em>(<code>const char *</code>cond)</em></dt>
<dt><a name="index-mgl_005fset_005fcutoff"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_cutoff</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>cond)</em></dt>
<dd><p>Задает условие обрезания по формуле <var>cond</var>. Это условие исключает точки из рисования если результат вычисления формулы не равен нулю. Установите аргумент <code>&quot;&quot;</code> для выключения условия обрезания.
</p></dd></dl>


<hr>
<a name="Font-settings"></a>
<div class="header">
<p>
Next: <a href="#Palette-and-colors" accesskey="n" rel="next">Palette and colors</a>, Previous: <a href="#Cutting" accesskey="p" rel="prev">Cutting</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Shrifty"></a>
<h4 class="subsection">4.2.6 Шрифты</h4>

<a name="index-SetFontSize"></a>
<a name="index-SetFontDef"></a>
<a name="index-SetRotatedText"></a>
<a name="index-SetFontSizePT"></a>
<a name="index-SetFontSizeCM"></a>
<a name="index-SetFontSizeIN"></a>
<a name="index-LoadFont"></a>
<a name="index-CopyFont"></a>
<a name="index-RestoreFont"></a>
<a name="index-Font"></a>
<a name="index-RotateText"></a>

<a name="font"></a><dl>
<dt><a name="index-font"></a>Команда MGL: <em></em> <strong>font</strong> <em>'fnt' [<code>val=6</code>]</em></dt>
<dd><p>Задает стиль и размер шрифта. Вначале используется &lsquo;<samp>:rC</samp>&rsquo; &ndash; прямой шрифт с выравниванием по центру. По умолчанию размер подписей оси координат в 1.4 раза больше. См. также см. <a href="#Font-styles">Font styles</a>.
</p></dd></dl>

<a name="rotatetext"></a><dl>
<dt><a name="index-rotatetext"></a>Команда MGL: <em></em> <strong>rotatetext</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetRotatedText-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRotatedText</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005frotated_005ftext"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_rotated_text</strong> <em>(<code>HMGL</code> gr, <code>int</code> val)</em></dt>
<dd><p>Включает/выключает вращение меток и подписей осей координат вдоль оси.
</p></dd></dl>

<a name="scaletext"></a><dl>
<dt><a name="index-scaletext"></a>Команда MGL: <em></em> <strong>scaletext</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetScaleText"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetScaleText</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fscale_005ftext"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_scale_text</strong> <em>(<code>HMGL</code> gr, <code>int</code> val)</em></dt>
<dd><p>Включает/выключает масштабирование текста в относительных <a href="#inplot">inplot</a>-ах (в том числе <a href="#columnplot">columnplot</a>, <a href="#gridplot">gridplot</a>, <a href="#stickplot">stickplot</a>, <a href="#shearplot">shearplot</a>).
</p></dd></dl>

<a name="loadfont"></a><dl>
<dt><a name="index-loadfont"></a>Команда MGL: <em></em> <strong>loadfont</strong> <em>['name'='']</em></dt>
<dt><a name="index-LoadFont-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>LoadFont</strong> <em>(<code>const char *</code>name, <code>const char *</code>path=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fload_005ffont"></a>Функция С: <em><code>void</code></em> <strong>mgl_load_font</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>name, <code>const char *</code>path)</em></dt>
<dd><p>Загружает начертание шрифта из файла <var>path</var>/<var>name</var>. Пустая строка загрузит шрифт по умолчанию.
</p></dd></dl>

<dl>
<dt><a name="index-SetFontDef-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFontDef</strong> <em>(<code>const char *</code>fnt)</em></dt>
<dt><a name="index-mgl_005fset_005ffont_005fdef"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_font_def</strong> <em>(<code>HMGL</code> gr, <code>const char *</code> val)</em></dt>
<dd><p>Задает стиль шрифта (см. <a href="#Text-printing">Text printing</a>). По умолчанию используется &lsquo;<samp>rC</samp>&rsquo; &ndash; прямой шрифт с выравниванием по центру.
</p></dd></dl>

<dl>
<dt><a name="index-SetFontSize-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFontSize</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005ffont_005fsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_font_size</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val)</em></dt>
<dd><p>Задает базовый размер шрифта. По умолчанию размер подписей оси координат в 1.4 раза больше.
</p></dd></dl>

<dl>
<dt><a name="index-SetFontSizePT-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFontSizePT</strong> <em>(<code>mreal</code> cm, <code>int</code> dpi=<code>72</code>)</em></dt>
<dd><p>Задает размер шрифта в пунктах для заданного DPI (по умолчанию 16 pt для dpi=72).
</p></dd></dl>
<dl>
<dt><a name="index-SetFontSizeCM-1"></a>Метод класса <code>mglGraph</code>: <em><code>inline void</code></em> <strong>SetFontSizeCM</strong> <em>(<code>mreal</code> cm, <code>int</code> dpi=<code>72</code>)</em></dt>
<dd><p>Задает размер шрифта в сантиметрах для заданного DPI (по умолчанию 0.56 см = 16 pt).
</p></dd></dl>
<dl>
<dt><a name="index-SetFontSizeIN-1"></a>Метод класса <code>mglGraph</code>: <em><code>inline void</code></em> <strong>SetFontSizeIN</strong> <em>(<code>mreal</code> cm, <code>int</code> dpi=<code>72</code>)</em></dt>
<dd><p>Задает размер шрифта в дюймах для заданного DPI (по умолчанию 0.22 in = 16 pt).
</p></dd></dl>

<dl>
<dt><a name="index-CopyFont-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>CopyFont</strong> <em>(<code>mglGraph *</code> from)</em></dt>
<dt><a name="index-mgl_005fcopy_005ffont"></a>Функция С: <em><code>void</code></em> <strong>mgl_copy_font</strong> <em>(<code>HMGL</code> gr, <code>HMGL</code> gr_from)</em></dt>
<dd><p>Копирует начертание шрифта из другого объекта <code>mglGraph</code>.
</p></dd></dl>

<dl>
<dt><a name="index-RestoreFont-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>RestoreFont</strong> <em>()</em></dt>
<dt><a name="index-mgl_005frestore_005ffont"></a>Функция С: <em><code>void</code></em> <strong>mgl_restore_font</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Восстанавливает начертание шрифта по умолчанию.
</p></dd></dl>

<dl>
<dt><a name="index-SetDefFont"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetDefFont</strong> <em>(<code>const char *</code>name, <code>const char *</code>path=<code>&quot;&quot;</code>) static</em></dt>
<dt><a name="index-mgl_005fdef_005ffont"></a>Функция С: <em><code>void</code></em> <strong>mgl_def_font</strong> <em>(<code>const char *</code>name, <code>const char *</code>path)</em></dt>
<dd><p>Загружает начертание шрифта по умолчанию (для всех вновь создаваемых HMGL/mglGraph объектов) из файла <var>path</var>/<var>name</var>.
</p></dd></dl>



<hr>
<a name="Palette-and-colors"></a>
<div class="header">
<p>
Next: <a href="#Masks" accesskey="n" rel="next">Masks</a>, Previous: <a href="#Font-settings" accesskey="p" rel="prev">Font settings</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Palitra-i-cveta"></a>
<h4 class="subsection">4.2.7 Палитра и цвета</h4>

<a name="index-SetPalette"></a>
<a name="index-Palette"></a>

<a name="palette"></a><dl>
<dt><a name="index-palette"></a>Команда MGL: <em></em> <strong>palette</strong> <em>'colors'</em></dt>
<dt><a name="index-SetPalette-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetPalette</strong> <em>(<code>const char *</code>colors)</em></dt>
<dt><a name="index-mgl_005fset_005fpalette"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_palette</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>colors)</em></dt>
<dd><p>Задает палитру как последовательность цветов. Значение по умолчанию <code>&quot;Hbgrcmyhlnqeup&quot;</code>, что соответствует цветам: темно серый &lsquo;<samp>H</samp>&rsquo;, синий &lsquo;<samp>b</samp>&rsquo;, зелёный &lsquo;<samp>g</samp>&rsquo;, красный &lsquo;<samp>r</samp>&rsquo;, голубой &lsquo;<samp>c</samp>&rsquo;, малиновый &lsquo;<samp>m</samp>&rsquo;, жёлтый &lsquo;<samp>y</samp>&rsquo;, серый &lsquo;<samp>h</samp>&rsquo;, сине-зелёный  &lsquo;<samp>l</samp>&rsquo;, небесно-голубой &lsquo;<samp>n</samp>&rsquo;, оранжевый &lsquo;<samp>q</samp>&rsquo;, желто-зелёный &lsquo;<samp>e</samp>&rsquo;, сине-фиолетовый &lsquo;<samp>u</samp>&rsquo;, фиолетовый &lsquo;<samp>p</samp>&rsquo;. Палитра в основном используется в 1D графиках (см. <a href="#g_t1D-plotting">1D plotting</a>) для кривых с неопределённым стилем линии. Внутренний счетчик цвета будет сброшен при любом изменении палитры, включая скрытые (например, функциями <a href="#box">box</a> или <a href="#axis">axis</a>).
</p></dd></dl>

<dl>
<dt><a name="index-SetDefScheme"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetDefScheme</strong> <em>(<code>const char *</code>sch)</em></dt>
<dt><a name="index-mgl_005fset_005fdef_005fsch"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_def_sch</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>sch)</em></dt>
<dd><p>Устанавливает <var>sch</var> в качестве цветовой схемы по умолчанию. Начальное значение <code>&quot;BbcyrR&quot;</code>.
</p></dd></dl>

<dl>
<dt><a name="index-SetColor"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetColor</strong> <em>(<code>char</code> id, <code>mreal</code> r, <code>mreal</code> g, <code>mreal</code> b) static</em></dt>
<dt><a name="index-mgl_005fset_005fcolor"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_color</strong> <em>(<code>char</code> id, <code>mreal</code> r, <code>mreal</code> g, <code>mreal</code> b)</em></dt>
<dd><p>Задает RGB значения для цвета с заданным <var>id</var>. Изменения действуют глобально для всех последующих использований данного <var>id</var>.
</p></dd></dl>

<a name="gray"></a><dl>
<dt><a name="index-gray"></a>Команда MGL: <em></em> <strong>gray</strong> <em>[<code>val=on</code>]</em></dt>
<dt><a name="index-Gray"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Gray</strong> <em>(<code>bool</code> enable)</em></dt>
<dt><a name="index-mgl_005fset_005fgray"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_gray</strong> <em>(<code>HMGL</code> gr, <code>int</code> enable)</em></dt>
<dd><p>Включает/выключает вывод графика в оттенках серого.
</p></dd></dl>


<hr>
<a name="Masks"></a>
<div class="header">
<p>
Next: <a href="#Error-handling" accesskey="n" rel="next">Error handling</a>, Previous: <a href="#Palette-and-colors" accesskey="p" rel="prev">Palette and colors</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Maski"></a>
<h4 class="subsection">4.2.8 Маски</h4>

<a name="index-SetMask"></a>
<a name="index-SetMaskAngle"></a>

<a name="mask"></a><dl>
<dt><a name="index-mask"></a>Команда MGL: <em></em> <strong>mask</strong> <em>'id' 'hex' [angle]</em></dt>
<dt><a name="index-mask-1"></a>Команда MGL: <em></em> <strong>mask</strong> <em>'id' hex [angle]</em></dt>
<dt><a name="index-SetMask-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetMask</strong> <em>(<code>char</code> id, <code>const char *</code>hex)</em></dt>
<dt><a name="index-SetMask-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetMask</strong> <em>(<code>char</code> id, <code>uint64_t</code> hex)</em></dt>
<dt><a name="index-mgl_005fset_005fmask"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_mask</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>hex)</em></dt>
<dt><a name="index-mgl_005fset_005fmask_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_mask_val</strong> <em>(<code>HMGL</code> gr, <code>uint64_t</code> hex)</em></dt>
<dd><p>Задает новую матрицу <var>hex</var> размером 8*8 для маски с заданным <var>id</var>. Изменения действуют глобально для всех последующих использований данного <var>id</var>. Значения по умолчанию (см. <a href="#Color-scheme">Color scheme</a>): &lsquo;<samp>-</samp>&rsquo; &ndash; 000000FF00000000, &lsquo;<samp>+</samp>&rsquo; &ndash; 080808FF08080808,	&lsquo;<samp>=</samp>&rsquo; &ndash; 0000FF00FF000000,	&lsquo;<samp>;</samp>&rsquo; &ndash; 0000007700000000, &lsquo;<samp>o</samp>&rsquo; &ndash; 0000182424180000,	&lsquo;<samp>O</samp>&rsquo; &ndash; 0000183C3C180000,	&lsquo;<samp>s</samp>&rsquo; &ndash; 00003C24243C0000,	&lsquo;<samp>S</samp>&rsquo; &ndash; 00003C3C3C3C0000, &lsquo;<samp>~</samp>&rsquo; &ndash; 0000060990600000,	&lsquo;<samp>&lt;</samp>&rsquo; &ndash; 0060584658600000,	&lsquo;<samp>&gt;</samp>&rsquo; &ndash; 00061A621A060000,	&lsquo;<samp>j</samp>&rsquo; &ndash; 0000005F00000000, &lsquo;<samp>d</samp>&rsquo; &ndash; 0008142214080000,	&lsquo;<samp>D</samp>&rsquo; &ndash; 00081C3E1C080000,	&lsquo;<samp>*</samp>&rsquo; &ndash; 8142241818244281,	&lsquo;<samp>^</samp>&rsquo; &ndash; 0000001824420000. Параметр <var>angle</var> позволяет сразу задать и угол поворота маски. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.
</p>
<p>Задает новую матрицу <var>hex</var> размером 8*8 для маски с заданным <var>id</var>. Изменения действуют глобально для всех последующих использований данного <var>id</var>. Значения по умолчанию (см. <a href="#Color-scheme">Color scheme</a>): &lsquo;<samp>-</samp>&rsquo; &ndash; линии (<code>0x000000FF00000000</code>), &lsquo;<samp>+</samp>&rsquo; &ndash; клетки (<code>080808FF08080808</code>),	&lsquo;<samp>=</samp>&rsquo; &ndash; двойные линии (<code>0000FF00FF000000</code>),	&lsquo;<samp>;</samp>&rsquo; &ndash; пунктир (<code>0x0000000F00000000</code>), &lsquo;<samp>o</samp>&rsquo; &ndash; окружкости (<code>0000182424180000</code>),	&lsquo;<samp>O</samp>&rsquo; &ndash; круги (<code>0000183C3C180000</code>),	&lsquo;<samp>s</samp>&rsquo; &ndash; квадраты (<code>00003C24243C0000</code>),	&lsquo;<samp>S</samp>&rsquo; &ndash; закрашенные квадраты (<code>00003C3C3C3C0000</code>), &lsquo;<samp>~</samp>&rsquo; &ndash; волны (<code>0000060990600000</code>),	&lsquo;<samp>&lt;</samp>&rsquo; &ndash; треугольники влево (<code>0060584658600000</code>),	&lsquo;<samp>&gt;</samp>&rsquo; &ndash; треугольники вправо (<code>00061A621A060000</code>),	&lsquo;<samp>j</samp>&rsquo; пунктир с точками (<code>0000002700000000</code>), &lsquo;<samp>d</samp>&rsquo; плюсы (<code>0x0008083E08080000</code>),	&lsquo;<samp>D</samp>&rsquo; &ndash; стежки (<code>0x0139010010931000</code>),	&lsquo;<samp>*</samp>&rsquo; &ndash; точки (<code>0x0000001818000000</code>),	&lsquo;<samp>^</samp>&rsquo; &ndash; кирпичи (<code>0x101010FF010101FF</code>). Параметр <var>angle</var> позволяет сразу задать и угол поворота маски. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.
</p></dd></dl>

<dl>
<dt><a name="index-mask-2"></a>Команда MGL: <em></em> <strong>mask</strong> <em>angle</em></dt>
<dt><a name="index-SetMaskAngle-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetMaskAngle</strong> <em>(<code>int</code> angle)</em></dt>
<dt><a name="index-mgl_005fset_005fmask_005fangle"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_mask_angle</strong> <em>(<code>HMGL</code> gr, <code>int</code> angle)</em></dt>
<dd><p>Задает угол поворота маски в градусах. Отмечу, что символы &lsquo;<samp>\</samp>&rsquo;, &lsquo;<samp>/</samp>&rsquo;, &lsquo;<samp>I</samp>&rsquo; в цветовой схеме задают угол поворота в 45, -45 и 90 градусов соответственно. ВАЖНО: при экспорте в EPS угол поворота будет приведен к ближайшему кратному 45 градусам.
</p></dd></dl>


<hr>
<a name="Error-handling"></a>
<div class="header">
<p>
Next: <a href="#Stop-drawing" accesskey="n" rel="next">Stop drawing</a>, Previous: <a href="#Masks" accesskey="p" rel="prev">Masks</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Obrabotka-oshibok"></a>
<h4 class="subsection">4.2.9 Обработка ошибок</h4>

<a name="index-Message"></a>
<a name="index-SetWarn"></a>
<a name="index-GetWarn"></a>

<p>Обычно вы должны сбросить признак ошибки с помощью <code>SetWarn(0);</code> перед построением и проверить <code>GetWarnCode()</code> или <code>Message()</code> на наличие ошибок после построения. Только последнее предупреждение сохраняется. Замечу, что все предупреждения/ошибки в MathGL не являются критичными &ndash; в худшем из вариантов соответствующий график просто не будет построен. По умолчанию, все предупреждения выводятся в <code>stderr</code>. Этот вывод можно выключить вызовом <code>mgl_suppress_warn(true);</code>.
</p>
<dl>
<dt><a name="index-SetWarn-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetWarn</strong> <em>(<code>int</code> code, <code>const char *</code>info=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fwarn"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_warn</strong> <em>(<code>HMGL</code> gr, <code>int</code> code, <code>const char *</code>info)</em></dt>
<dd><p>Задает код предупреждения. Обычно вызывается только для очистки предупреждений (<code>SetWarn(0);</code>) или внутри библиотеки. Текст <var>info</var> будет добавлен к предупреждениям как есть при <var>code</var>&lt;0.
</p></dd></dl>

<dl>
<dt><a name="index-_0028_0029"></a>Метод класса <code>mglGraph</code>: <em><code>const char *</code>Message</em> <strong>()</strong></dt>
<dt><a name="index-_0028HMGL"></a>Функция С: <em><code>const char *</code>mgl_get_mess</em> <strong>(<code>HMGL</code></strong> <em>gr)</em></dt>
<dt><a name="index-mgl_005fget_005fmess"></a>Fortran процедура: <em><code></code></em> <strong>mgl_get_mess</strong> <em>(<code>long</code> gr, <code>char *</code>out, <code>int</code> len)</em></dt>
<dd><p>Возвращает текст предупреждений о причине отсутствия графика. Если возвращаемая строка пустая, то сообщений нет.
</p></dd></dl>

<dl>
<dt><a name="index-GetWarn-1"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetWarn</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005fwarn"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_warn</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает код сообщения о причине отсутствия графика. Возможные значения:
</p><dl compact="compact">
<dt><code>mglWarnNone=0</code></dt>
<dd><p>Предупреждений нет
</p></dd>
<dt><code>mglWarnDim</code></dt>
<dd><p>Неправильные или несовместимые размеры данных
</p></dd>
<dt><code>mglWarnLow</code></dt>
<dd><p>Размеры данных слишком малы
</p></dd>
<dt><code>mglWarnNeg</code></dt>
<dd><p>Минимальное значение отрицательно
</p></dd>
<dt><code>mglWarnFile</code></dt>
<dd><p>Файл не найден или указаны неправильные размерности
</p></dd>
<dt><code>mglWarnMem</code></dt>
<dd><p>Не достаточно памяти
</p></dd>
<dt><code>mglWarnZero</code></dt>
<dd><p>Значение данных равно нулю
</p></dd>
<dt><code>mglWarnLeg</code></dt>
<dd><p>Нет записей в легенде
</p></dd>
<dt><code>mglWarnSlc</code></dt>
<dd><p>Индекс среза вне данных
</p></dd>
<dt><code>mglWarnCnt</code></dt>
<dd><p>Число линий уровня меньше или равно нулю
</p></dd>
<dt><code>mglWarnOpen</code></dt>
<dd><p>Не могу открыть файл
</p></dd>
<dt><code>mglWarnLId</code></dt>
<dd><p>Light: ID вне допустимых значений
</p></dd>
<dt><code>mglWarnSize</code></dt>
<dd><p>Setsize: размер(ы) равны нулю или отрицательны
</p></dd>
<dt><code>mglWarnFmt</code></dt>
<dd><p>Формат не поддерживается
</p></dd>
<dt><code>mglWarnTern</code></dt>
<dd><p>Диапазоны осей несовместимые
</p></dd>
<dt><code>mglWarnNull</code></dt>
<dd><p>Указатель равен NULL
</p></dd>
<dt><code>mglWarnSpc</code></dt>
<dd><p>Не хватает места для графика
</p></dd>
<dt><code>mglScrArg</code></dt>
<dd><p>Неправильные аргументы команды скрипта MGL
</p></dd>
<dt><code>mglScrCmd</code></dt>
<dd><p>Неправильная команда в скрипте MGL
</p></dd>
<dt><code>mglScrLong</code></dt>
<dd><p>Слишком длинная строка в скрипте MGL
</p></dd>
<dt><code>mglScrStr</code></dt>
<dd><p>Одиночная &rsquo; в скрипте MGL
</p></dd>
<dt><code>mglScrTemp</code></dt>
<dd><p>Изменяется временная переменная в MGL скрипте
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><a name="index-SuppressWarn"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SuppressWarn</strong> <em>(<code>bool</code> state) static</em></dt>
<dt><a name="index-mgl_005fsuppress_005fwarn"></a>Функция С: <em><code>void</code></em> <strong>mgl_suppress_warn</strong> <em>(<code>int</code> state)</em></dt>
<dd><p>Выключает вывод предупреждений в <code>stderr</code> если <var>state</var> не ноль.
</p></dd></dl>

<dl>
<dt><a name="index-SetGlobalWarn"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetGlobalWarn</strong> <em>(<code>const char *</code>info) static</em></dt>
<dt><a name="index-mgl_005fset_005fglobal_005fwarn"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_global_warn</strong> <em>(<code>const char *</code>info)</em></dt>
<dd><p>Задает предупреждение <var>info</var>, не привязанное к конкретному объекту рисования.
</p></dd></dl>

<dl>
<dt><a name="index-GlobalWarn"></a>Метод класса <code>mglGraph</code>: <em><code>const char *</code></em> <strong>GlobalWarn</strong> <em>() static</em></dt>
<dt><a name="index-mgl_005fget_005fglobal_005fwarn"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_get_global_warn</strong> <em>()</em></dt>
<dd><p>Возвращает предупреждения, не привязанные к конкретному объекту рисования.
</p></dd></dl>




<hr>
<a name="Stop-drawing"></a>
<div class="header">
<p>
Previous: <a href="#Error-handling" accesskey="p" rel="prev">Error handling</a>, Up: <a href="#Graphics-setup" accesskey="u" rel="up">Graphics setup</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ostanovka-risovaniya"></a>
<h4 class="subsection">4.2.10 Остановка рисования</h4>

<a name="index-Stop"></a>
<a name="index-NeedStop"></a>
<a name="index-SetEventFunc"></a>

<dl>
<dt><a name="index-Stop-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Stop</strong> <em>(<code>bool</code> stop=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fask_005fstop"></a>Функция С only: <em><code>void</code></em> <strong>mgl_ask_stop</strong> <em>(<code>HMGL</code> gr, <code>int</code> stop)</em></dt>
<dd><p>Просит остановить рисование если <var>stop</var> не ноль, иначе сбрасывает флаг остановки.
</p></dd></dl>

<dl>
<dt><a name="index-NeedStop-1"></a>Метод класса <code>mglGraph</code>: <em><code>bool</code></em> <strong>NeedStop</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fneed_005fstop"></a>Функция С only: <em><code>void</code></em> <strong>mgl_need_stop</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает <code>true</code> если рисование должно быть остановлено. Также запускает обработку всех отложенных событий в GUI. Пользователь должен вызывать эту функцию время от времени внутри долгих вычислений для плавности отклика GUI.
</p></dd></dl>

<dl>
<dt><a name="index-SetEventFunc-1"></a>Метод класса <code>mglGraph</code>: <em><code>bool</code></em> <strong>SetEventFunc</strong> <em>(<code>void (*</code>func<code>)(void *)</code>, <code>void *</code>par=<code>NULL</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fevent_005ffunc"></a>Функция С only: <em><code>void</code></em> <strong>mgl_set_event_func</strong> <em>(<code>HMGL</code> gr, <code>void (*</code>func<code>)(void *)</code>, <code>void *</code>par)</em></dt>
<dd><p>Задает функцию, которая будет вызвана для обработки событий в GUI библиотеке.
</p></dd></dl>




<hr>
<a name="Axis-settings"></a>
<div class="header">
<p>
Next: <a href="#Subplots-and-rotation" accesskey="n" rel="next">Subplots and rotation</a>, Previous: <a href="#Graphics-setup" accesskey="p" rel="prev">Graphics setup</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nastroiki-osei-koordinat"></a>
<h3 class="section">4.3 Настройки осей координат</h3>


<p>Эти функции управляет видом и масштабом осей координат. Перед построением для каждой точки выполняются 3 преобразования: сначала определяется возможность рисования точки (см. <a href="#Cutting">Cutting</a>), далее применяются формулы перехода к криволинейным координатам и наконец точка отображается. Отмечу, что MathGL выдает предупреждение если масштабы осей координат лежат вне области определения формул преобразования координат.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Ranges-_0028bounding-box_0029" accesskey="1">Ranges (bounding box)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Curved-coordinates" accesskey="2">Curved coordinates</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ticks" accesskey="3">Ticks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Ranges-_0028bounding-box_0029"></a>
<div class="header">
<p>
Next: <a href="#Curved-coordinates" accesskey="n" rel="next">Curved coordinates</a>, Up: <a href="#Axis-settings" accesskey="u" rel="up">Axis settings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Masshtab-osei-koordinat"></a>
<h4 class="subsection">4.3.1 Масштаб осей координат</h4>

<a name="index-CRange"></a>
<a name="index-XRange"></a>
<a name="index-YRange"></a>
<a name="index-ZRange"></a>
<a name="index-Ranges"></a>
<a name="index-Origin"></a>
<a name="index-SetRange"></a>
<a name="index-SetRanges"></a>
<a name="index-SetOrigin"></a>

<a name="xrange"></a><a name="yrange"></a><a name="zrange"></a><a name="crange"></a><dl>
<dt><a name="index-xrange-2"></a>Команда MGL: <em></em> <strong>xrange</strong> <em><code>v1 v2</code> [<code>add=off</code>]</em></dt>
<dt><a name="index-yrange-2"></a>Команда MGL: <em></em> <strong>yrange</strong> <em><code>v1 v2</code> [<code>add=off</code>]</em></dt>
<dt><a name="index-zrange-2"></a>Команда MGL: <em></em> <strong>zrange</strong> <em><code>v1 v2</code> [<code>add=off</code>]</em></dt>
<dt><a name="index-crange"></a>Команда MGL: <em></em> <strong>crange</strong> <em><code>v1 v2</code> [<code>add=off</code>]</em></dt>
<dt><a name="index-SetRange-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRange</strong> <em>(<code>char</code> dir, <code>mreal</code> v1, <code>mreal</code> v2)</em></dt>
<dt><a name="index-AddRange"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddRange</strong> <em>(<code>char</code> dir, <code>mreal</code> v1, <code>mreal</code> v2)</em></dt>
<dt><a name="index-mgl_005fset_005frange_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_range_val</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>mreal</code> v1, <code>mreal</code> v2)</em></dt>
<dt><a name="index-mgl_005fadd_005frange_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_range_val</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>mreal</code> v1, <code>mreal</code> v2)</em></dt>
<dd><p>Задает диапазон изменения &lsquo;<samp>x</samp>&rsquo;-,&lsquo;<samp>y</samp>&rsquo;-,&lsquo;<samp>z</samp>&rsquo;-,&lsquo;<samp>c</samp>&rsquo;-координат. Если одно из значений равно <code>NAN</code>, то оно игнорируется. Параметр <code>add=on</code> указывает добавлять новый диапазон к существующему (не заменять его). См. также <a href="#ranges">ranges</a>.
</p></dd></dl>

<dl>
<dt><a name="index-xrange-3"></a>Команда MGL: <em></em> <strong>xrange</strong> <em>dat [<code>add=off</code>]</em></dt>
<dt><a name="index-yrange-3"></a>Команда MGL: <em></em> <strong>yrange</strong> <em>dat [<code>add=off</code>]</em></dt>
<dt><a name="index-zrange-3"></a>Команда MGL: <em></em> <strong>zrange</strong> <em>dat [<code>add=off</code>]</em></dt>
<dt><a name="index-crange-1"></a>Команда MGL: <em></em> <strong>crange</strong> <em>dat [<code>add=off</code>]</em></dt>
<dt><a name="index-SetRange-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRange</strong> <em>(<code>char</code> dir, <code>const mglDataA &amp;</code>dat, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fset_005frange_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_range_dat</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>const HCDT</code> a, <code>int</code> add)</em></dt>
<dd><p>Задает диапазон изменения &lsquo;<samp>x</samp>&rsquo;-,&lsquo;<samp>y</samp>&rsquo;-,&lsquo;<samp>z</samp>&rsquo;-,&lsquo;<samp>c</samp>&rsquo;-координат как минимальное и максимальное значение массива <var>dat</var>. Параметр <code>add=on</code> указывает добавлять новый диапазон к существующему (не заменять его).
</p></dd></dl>

<a name="ranges"></a><dl>
<dt><a name="index-ranges"></a>Команда MGL: <em></em> <strong>ranges</strong> <em><code>x1 x2 y1 y2 [z1=0 z2=0]</code></em></dt>
<dt><a name="index-SetRanges-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dt><a name="index-SetRanges-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>mreal</code> z1=<code>0</code>, <code>mreal</code> z2=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fset_005franges"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ranges</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>mreal</code> z1, <code>mreal</code> z2)</em></dt>
<dd><p>Задает диапазон изменения координат. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению. Также устанавливает размер цветовой шкалы, аналогично команде  <code>crange z1 z2</code>. Начальные диапазоны равны [-1, 1].
</p></dd></dl>

<dl>
<dt><a name="index-ranges-1"></a>Команда MGL: <em></em> <strong>ranges</strong> <em><code>xx yy [zz cc=zz]</code></em></dt>
<dt><a name="index-SetRanges-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>const mglDataA &amp;</code>xx, <code>const mglDataA &amp;</code>yy)</em></dt>
<dt><a name="index-SetRanges-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>const mglDataA &amp;</code>xx, <code>const mglDataA &amp;</code>yy, <code>const mglDataA &amp;</code>zz)</em></dt>
<dt><a name="index-SetRanges-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>const mglDataA &amp;</code>xx, <code>const mglDataA &amp;</code>yy, <code>const mglDataA &amp;</code>zz, <code>const mglDataA &amp;</code>cc)</em></dt>
<dd><p>Задает диапазон изменения &lsquo;<samp>x</samp>&rsquo;-,&lsquo;<samp>y</samp>&rsquo;-,&lsquo;<samp>z</samp>&rsquo;-,&lsquo;<samp>c</samp>&rsquo;-координат как минимальное и максимальное значение массивов <var>xx</var>, <var>yy</var>, <var>zz</var>, <var>cc</var> соответственно.
</p></dd></dl>

<dl>
<dt><a name="index-SetAutoRanges"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetAutoRanges</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dt><a name="index-SetAutoRanges-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetAutoRanges</strong> <em>(<code>double</code> x1, <code>double</code> x2, <code>double</code> y1, <code>double</code> y2, <code>double</code> z1=<code>0</code>, <code>double</code> z2=<code>0</code>, <code>double</code> c1=<code>0</code>, <code>double</code> c2=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fauto_005franges"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_auto_ranges</strong> <em>(<code>HMGL</code> gr, <code>double</code> x1, <code>double</code> x2, <code>double</code> y1, <code>double</code> y2, <code>double</code> z1, <code>double</code> z2, <code>double</code> z1, <code>double</code> z2)</em></dt>
<dd><p>Задает диапазон изменения координат для автоматических переменных. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению.
</p></dd></dl>

<a name="origin"></a><dl>
<dt><a name="index-origin"></a>Команда MGL: <em></em> <strong>origin</strong> <em><code>x0 y0 [z0=nan]</code></em></dt>
<dt><a name="index-SetOrigin-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetOrigin</strong> <em>(<code>mglPoint</code> p0)</em></dt>
<dt><a name="index-SetOrigin-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetOrigin</strong> <em>(<code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0=<code>NAN</code>)</em></dt>
<dt><a name="index-mgl_005fset_005forigin"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_origin</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0)</em></dt>
<dd><p>Задает центр пересечения осей координат. Если одно из значений равно NAN, то MathGL попытается выбрать оптимальное положение осей координат по этому направлению.
</p></dd></dl>

<a name="zoomaxis"></a><dl>
<dt><a name="index-zoomaxis"></a>Команда MGL: <em></em> <strong>zoomaxis</strong> <em><code>x1 x2</code></em></dt>
<dt><a name="index-zoomaxis-1"></a>Команда MGL: <em></em> <strong>zoomaxis</strong> <em><code>x1 y1 x2 y2</code></em></dt>
<dt><a name="index-zoomaxis-2"></a>Команда MGL: <em></em> <strong>zoomaxis</strong> <em><code>x1 y1 z1 x2 y2 z2</code></em></dt>
<dt><a name="index-zoomaxis-3"></a>Команда MGL: <em></em> <strong>zoomaxis</strong> <em><code>x1 y1 z1 c1 x2 y2 z2 c2</code></em></dt>
<dt><a name="index-ZoomAxis"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ZoomAxis</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dt><a name="index-mgl_005fzoom_005faxis"></a>Функция С: <em><code>void</code></em> <strong>mgl_zoom_axis</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> c1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> c2)</em></dt>
<dd><p>Дополнительно расширяет диапазон осей координат, задаваемый функциями <code>SetRange</code> или <code>SetRanges</code>, в соответствии с формулами <em>min += (max-min)*p1</em> и <em>max += (max-min)*p1</em> (или <em>min *= (max/min)^p1</em> и <em>max *= (max/min)^p1</em> для &quot;логарифмических&quot; диапазонов, когда <em>inf&gt;max/min&gt;100</em> или <em>0&lt;max/min&lt;0.01</em>). Начальные значения [0, 1]. Внимание! эти настройки не могут быть переписаны никакими другими функциями, включая  <code>DefaultPlotParam()</code>.
</p></dd></dl>



<hr>
<a name="Curved-coordinates"></a>
<div class="header">
<p>
Next: <a href="#Ticks" accesskey="n" rel="next">Ticks</a>, Previous: <a href="#Ranges-_0028bounding-box_0029" accesskey="p" rel="prev">Ranges (bounding box)</a>, Up: <a href="#Axis-settings" accesskey="u" rel="up">Axis settings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Krivolineinye-koordinaty"></a>
<h4 class="subsection">4.3.2 Криволинейные координаты</h4>

<a name="index-Axis"></a>
<a name="index-SetFunc"></a>
<a name="index-SetCoor"></a>
<a name="index-Ternary"></a>

<dl>
<dt><a name="index-axis"></a>Команда MGL: <em></em> <strong>axis</strong> <em>'fx' 'fy' 'fz' ['fa'='']</em></dt>
<dt><a name="index-SetFunc-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetFunc</strong> <em>(<code>const char *</code>EqX, <code>const char *</code>EqY, <code>const char *</code>EqZ=<code>&quot;&quot;</code>, <code>const char *</code>EqA=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fset_005ffunc"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_func</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>EqX, <code>const char *</code>EqY, <code>const char *</code>EqZ, <code>const char *</code>EqA)</em></dt>
<dd><p>Задает формулы перехода к криволинейным координатам. Каждая строка является математическим выражением, зависящим от старых координат &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; и &lsquo;<samp>a</samp>&rsquo; или &lsquo;<samp>c</samp>&rsquo; для цветовой шкалы. Например, для цилиндрических координат будет <code>SetFunc(&quot;x*cos(y)&quot;, &quot;x*sin(y)&quot;, &quot;z&quot;);</code>. Для удаления формул соответствующий параметр должен быть пустым или <code>NULL</code>. Использование формул преобразования слегка замедляет программу. Параметр <var>EqA</var> задает аналогичную формулу для цветовой шкалы. See <a href="#Textual-formulas">Textual formulas</a>.
</p></dd></dl>

<dl>
<dt><a name="index-axis-1"></a>Команда MGL: <em></em> <strong>axis</strong> <em><code>how</code></em></dt>
<dt><a name="index-SetCoor-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetCoor</strong> <em>(<code>int</code> how)</em></dt>
<dt><a name="index-mgl_005fset_005fcoor"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_coor</strong> <em>(<code>HMGL</code> gr, <code>int</code> how)</em></dt>
<dd><p>Устанавливает одну из предопределенных систем криволинейных координат в зависимости от параметра <var>how</var>:
</p><dl compact="compact">
<dt><code>mglCartesian=0</code></dt>
<dd><p>декартова система (нет преобразования координат, {x,y,z});
</p></dd>
<dt><code>mglPolar=1</code></dt>
<dd><p>полярные координаты: {x*cos(y),x*sin(y), z};
</p></dd>
<dt><code>mglSpherical=2</code></dt>
<dd><p>сферические координаты: {x*sin(y)*cos(z), x*sin(y)*sin(z), x*cos(y)};
</p></dd>
<dt><code>mglParabolic=3</code></dt>
<dd><p>параболические координаты: {x*y, (x*x-y*y)/2, z};
</p></dd>
<dt><code>mglParaboloidal=4</code></dt>
<dd><p>Paraboloidal coordinates: {(x*x-y*y)*cos(z)/2, (x*x-y*y)*sin(z)/2, x*y};
</p></dd>
<dt><code>mglOblate=5</code></dt>
<dd><p>Oblate coordinates: {cosh(x)*cos(y)*cos(z), cosh(x)*cos(y)*sin(z), sinh(x)*sin(y)};
</p></dd>
<dt><code>mglProlate=6</code></dt>
<dd><p>Prolate coordinates: {sinh(x)*sin(y)*cos(z), sinh(x)*sin(y)*sin(z), cosh(x)*cos(y)};
</p></dd>
<dt><code>mglElliptic=7</code></dt>
<dd><p>эллиптические координаты: {cosh(x)*cos(y), sinh(x)*sin(y), z};
</p></dd>
<dt><code>mglToroidal=8</code></dt>
<dd><p>тороидальные координаты: {sinh(x)*cos(z)/(cosh(x)-cos(y)), sinh(x)*sin(z)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y))};
</p></dd>
<dt><code>mglBispherical=9</code></dt>
<dd><p>бисферические координаты: {sin(y)*cos(z)/(cosh(x)-cos(y)), sin(y)*sin(z)/(cosh(x)-cos(y)), sinh(x)/(cosh(x)-cos(y))};
</p></dd>
<dt><code>mglBipolar=10</code></dt>
<dd><p>биполярные координаты: {sinh(x)/(cosh(x)-cos(y)), sin(y)/(cosh(x)-cos(y)), z};
</p></dd>
<dt><code>mglLogLog=11</code></dt>
<dd><p>Log-log координаты: {lg(x), lg(y), lg(z)};
</p></dd>
<dt><code>mglLogX=12</code></dt>
<dd><p>Log-x координаты: {lg(x), y, z};
</p></dd>
<dt><code>mglLogY=13</code></dt>
<dd><p>Log-y координаты: {x, lg(y), z}.
</p></dd>
</dl>
</dd></dl>

<a name="ternary"></a><dl>
<dt><a name="index-ternary"></a>Команда MGL: <em></em> <strong>ternary</strong> <em><code>val</code></em></dt>
<dt><a name="index-Ternary-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Ternary</strong> <em>(<code>int</code> tern)</em></dt>
<dt><a name="index-mgl_005fset_005fternary"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ternary</strong> <em>(<code>HMGL</code> gr, <code>int</code> tern)</em></dt>
<dd><p>Задает рисование треугольных (Ternary, <var>tern</var>=<code>1</code>), пирамидальных (Quaternary, <var>tern</var>=<code>2</code>) осей координат и проекций осей координат (<var>tern</var>=<code>4,5,6</code>).
</p>
<p>Ternary &ndash; специальный тип графика для 3 зависимых координат (компонент) <var>a</var>, <var>b</var>, <var>c</var> таких, что <var>a</var>+<var>b</var>+<var>c</var>=1. MathGL использует только 2 независимые координаты <var>a</var>=x и <var>b</var>=y поскольку их достаточно для построения всех графиков. При этом третья координата z является независимым параметром для построения линий уровня, поверхностей и т.д.
</p>
<p>Соответственно Quaternary координаты &ndash; 4 зависимые координаты <var>a</var>, <var>b</var>, <var>c</var> и <var>d</var>, такие что <var>a</var>+<var>b</var>+<var>c</var>+<var>d</var>=1. MathGL использует только 2 независимые координаты <var>a</var>=x, <var>b</var>=y и <var>d</var>=z поскольку их достаточно для построения всех графиков.
</p>
<p>Проекции строятся если к переменной <var>tern</var> добавить число <code>4</code>. Так что <var>tern</var>=<code>4</code> нарисует проекции в декартовых координатах, <var>tern</var>=<code>5</code> нарисует проекции в треугольных координатах, <var>tern</var>=<code>6</code> нарисует проекции в пирамидальных координатах. Если добавить <code>8</code> вместо <code>4</code>, то текст не будет выводиться на проекциях.
</p>
<p>Используйте <code>Ternary(0)</code> для возвращения к привычным координатам. См. раздел <a href="#Ternary-axis">Ternary axis</a>, для примеров кода и графика. См. раздел <a href="#Axis-projection">Axis projection</a>, для примеров кода и графика.
</p></dd></dl>


<hr>
<a name="Ticks"></a>
<div class="header">
<p>
Previous: <a href="#Curved-coordinates" accesskey="p" rel="prev">Curved coordinates</a>, Up: <a href="#Axis-settings" accesskey="u" rel="up">Axis settings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Metki-osei"></a>
<h4 class="subsection">4.3.3 Метки осей</h4>

<a name="index-AxisStl"></a>
<a name="index-TickLen"></a>
<a name="index-Adjust"></a>
<a name="index-XTick"></a>
<a name="index-YTick"></a>
<a name="index-ZTick"></a>
<a name="index-CTick"></a>
<a name="index-SetAxisStl"></a>
<a name="index-SetTickLen"></a>
<a name="index-SetTicks"></a>
<a name="index-SetTicksVal"></a>
<a name="index-SetTuneTicks"></a>
<a name="index-SetTickTime"></a>
<a name="index-SetTickTempl"></a>
<a name="index-SetTickRotate"></a>
<a name="index-SetTickSkip"></a>
<a name="index-SetOriginTick"></a>
<a name="index-AddTick"></a>

<a name="adjust"></a><dl>
<dt><a name="index-adjust"></a>Команда MGL: <em></em> <strong>adjust</strong> <em>['dir'='xyzc']</em></dt>
<dt><a name="index-Adjust-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Adjust</strong> <em>(<code>const char *</code>dir=<code>&quot;xyzc&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fadjust_005fticks"></a>Функция С: <em><code>void</code></em> <strong>mgl_adjust_ticks</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>dir)</em></dt>
<dd><p>Автоматически задает шаг меток осей, число подметок и начальное положение меток для осей координат <var>dir</var> в виде наиболее удобном для человека. Также задает <code>SetTuneTicks(true)</code>. Обычно не требуется вызывать эту функцию кроме случая возвращения настроек по умолчанию.
</p></dd></dl>

<a name="xtick"></a><a name="ytick"></a><a name="ztick"></a><a name="ctick"></a><dl>
<dt><a name="index-xtick"></a>Команда MGL: <em></em> <strong>xtick</strong> <em><code>val [sub=0 org=nan 'fact'='']</code></em></dt>
<dt><a name="index-ytick"></a>Команда MGL: <em></em> <strong>ytick</strong> <em><code>val [sub=0 org=nan 'fact'='']</code></em></dt>
<dt><a name="index-ztick"></a>Команда MGL: <em></em> <strong>ztick</strong> <em><code>val [sub=0 org=nan 'fact'='']</code></em></dt>
<dt><a name="index-xtick-1"></a>Команда MGL: <em></em> <strong>xtick</strong> <em><code>val sub ['fact'='']</code></em></dt>
<dt><a name="index-ytick-1"></a>Команда MGL: <em></em> <strong>ytick</strong> <em><code>val sub ['fact'='']</code></em></dt>
<dt><a name="index-ztick-1"></a>Команда MGL: <em></em> <strong>ztick</strong> <em><code>val sub ['fact'='']</code></em></dt>
<dt><a name="index-ctick"></a>Команда MGL: <em></em> <strong>ctick</strong> <em><code>val ['fact'='']</code></em></dt>
<dt><a name="index-SetTicks-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicks</strong> <em>(<code>char</code> dir, <code>mreal</code> d=<code>0</code>, <code>int</code> ns=<code>0</code>, <code>mreal</code> org=<code>NAN</code>, <code>const char *</code>fact=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-SetTicks-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicks</strong> <em>(<code>char</code> dir, <code>mreal</code> d=<code>0</code>, <code>int</code> ns=<code>0</code>, <code>mreal</code> org=<code>NAN</code>, <code>const wchar_t *</code>fact)</em></dt>
<dt><a name="index-mgl_005fset_005fticks"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>mreal</code> d, <code>int</code> ns, <code>mreal</code> org)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005ffact"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_fact</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>mreal</code> d, <code>int</code> ns, <code>mreal</code> org, <code>const char *</code>fact)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005ffactw"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_factw</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>mreal</code> d, <code>int</code> ns, <code>mreal</code> org, <code>const wchar_t *</code> fact)</em></dt>
<dd><p>Задает шаг меток осей <var>d</var>, число подметок <var>ns</var> и начальное положение меток <var>org</var> для оси вдоль направления <var>dir</var> (используйте &rsquo;c&rsquo; для меток colorbar). Переменная <var>d</var> задает шаг меток (если положительна) или их число на оси (если отрицательна). Нулевое значение задает автоматическую расстановку меток. Если <var>org</var>=<code>NAN</code>, то используется значение из переменной <var>Org</var>. Параметр <var>fact</var> задает текст, которые будет напечатан после метки оси (например, &quot;\pi&quot; для <var>d</var>=M_PI).
</p></dd></dl>

<dl>
<dt><a name="index-xtick-2"></a>Команда MGL: <em></em> <strong>xtick</strong> <em><code>val1</code> 'lbl1' [<code>val2</code> 'lbl2' ...]</em></dt>
<dt><a name="index-ytick-2"></a>Команда MGL: <em></em> <strong>ytick</strong> <em><code>val1</code> 'lbl1' [<code>val2</code> 'lbl2' ...]</em></dt>
<dt><a name="index-ztick-2"></a>Команда MGL: <em></em> <strong>ztick</strong> <em><code>val1</code> 'lbl1' [<code>val2</code> 'lbl2' ...]</em></dt>
<dt><a name="index-ctick-1"></a>Команда MGL: <em></em> <strong>ctick</strong> <em><code>val1</code> 'lbl1' [<code>val2</code> 'lbl2' ...]</em></dt>
<dt><a name="index-xtick-3"></a>Команда MGL: <em></em> <strong>xtick</strong> <em>vdat 'lbls' [<code>add=off</code>]</em></dt>
<dt><a name="index-ytick-3"></a>Команда MGL: <em></em> <strong>ytick</strong> <em>vdat 'lbls' [<code>add=off</code>]</em></dt>
<dt><a name="index-ztick-3"></a>Команда MGL: <em></em> <strong>ztick</strong> <em>vdat 'lbls' [<code>add=off</code>]</em></dt>
<dt><a name="index-ctick-2"></a>Команда MGL: <em></em> <strong>ctick</strong> <em>vdat 'lbls' [<code>add=off</code>]</em></dt>
<dt><a name="index-SetTicksVal-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicksVal</strong> <em>(<code>char</code> dir, <code>const char *</code>lbl, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-SetTicksVal-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicksVal</strong> <em>(<code>char</code> dir, <code>const wchar_t *</code>lbl, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-SetTicksVal-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicksVal</strong> <em>(<code>char</code> dir, <code>const mglDataA &amp;</code>val, <code>const char *</code>lbl, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-SetTicksVal-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicksVal</strong> <em>(<code>char</code> dir, <code>const mglDataA &amp;</code>val, <code>const wchar_t *</code>lbl, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005fstr"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_str</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>const char *</code>lbl, <code>bool</code> add)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005fwcs"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_wcs</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>const wchar_t *</code>lbl, <code>bool</code> add)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_val</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>HCDT</code> val, <code>const char *</code>lbl, <code>bool</code> add)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005fvalw"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_valw</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>HCDT</code> val, <code>const wchar_t *</code>lbl, <code>bool</code> add)</em></dt>
<dd><p>Задает явное положение <var>val</var> и подписи <var>lbl</var> для меток вдоль оси <var>dir</var>. Если массив <var>val</var> не указан, то используются значения равно распределённые в диапазоне осей координат. Метки разделяются символом &lsquo;<samp>\n</samp>&rsquo;. Если в команде MGL задано только одно значение, то метка будет <em>добавлена</em> к существующим меткам. Используйте <code>SetTicks()</code> для восстановления автоматических меток.
</p></dd></dl>

<dl>
<dt><a name="index-AddTick-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddTick</strong> <em>(<code>char</code> dir, <code>double</code> val, <code>const char *</code>lbl)</em></dt>
<dt><a name="index-AddTick-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddTick</strong> <em>(<code>char</code> dir, <code>double</code> val, <code>const wchar_t *</code>lbl)</em></dt>
<dt><a name="index-mgl_005fadd_005ftick"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_tick</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>double</code> val, <code>const char *</code>lbl)</em></dt>
<dt><a name="index-mgl_005fset_005ftickw"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tickw</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>double</code> val, <code>const wchar_t *</code>lbl)</em></dt>
<dd><p>Аналогично предыдущему, но добавляет одну метку оси к списку существующих меток.
</p></dd></dl>

<dl>
<dt><a name="index-xtick-4"></a>Команда MGL: <em></em> <strong>xtick</strong> <em>'templ'</em></dt>
<dt><a name="index-ytick-4"></a>Команда MGL: <em></em> <strong>ytick</strong> <em>'templ'</em></dt>
<dt><a name="index-ztick-4"></a>Команда MGL: <em></em> <strong>ztick</strong> <em>'templ'</em></dt>
<dt><a name="index-ctick-3"></a>Команда MGL: <em></em> <strong>ctick</strong> <em>'templ'</em></dt>
<dt><a name="index-SetTickTempl-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickTempl</strong> <em>(<code>char</code> dir, <code>const char *</code>templ)</em></dt>
<dt><a name="index-SetTickTempl-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickTempl</strong> <em>(<code>char</code> dir, <code>const wchar_t *</code>templ)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005ftempl"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_templ</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>templ)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005ftemplw"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_templw</strong> <em>(<code>HMGL</code> gr, <code>const wchar_t *</code>templ)</em></dt>
<dd><p>Задает шаблон <var>templ</var> для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Если <var>templ</var>=<code>&quot;&quot;</code>, то используется шаблон по умолчанию (в простейшем случае &lsquo;<samp>%.2g</samp>&rsquo;). Если шаблон начинается с символа &lsquo;<samp>&amp;</samp>&rsquo;, то будет использовано целое <code>long</code> вместо типа <code>double</code>. Установка шаблона выключает автоматическое улучшение вида меток.
</p></dd></dl>

<a name="ticktime"></a><dl>
<dt><a name="index-ticktime"></a>Команда MGL: <em></em> <strong>ticktime</strong> <em>'dir' [<code>dv=0</code> 'tmpl'='']</em></dt>
<dt><a name="index-SetTicksTime"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTicksTime</strong> <em>(<code>char</code> dir, <code>mreal</code> val, <code>const char *</code>templ)</em></dt>
<dt><a name="index-mgl_005fset_005fticks_005ftime"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_ticks_time</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>const char *</code>templ)</em></dt>
<dd><p>Задает метки времени с шагом <var>val</var> и шаблоном <var>templ</var> для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Формат шаблона <var>templ</var> такой же как <a href="http://www.manpagez.com/man/3/strftime/">http://www.manpagez.com/man/3/strftime/</a>. Наиболее употребительные варианты: &lsquo;<samp>%X</samp>&rsquo; для национального представления времени, &lsquo;<samp>%x</samp>&rsquo; для национального представления даты, &lsquo;<samp>%Y</samp>&rsquo; для года с цифрами столетия. Если <var>val</var>=0 и/или <var>templ</var>=&quot;&quot;, то используется автоматическая расстановка меток и/или выбор шаблона. Вы можете использовать функцию <code>mgl_get_time</code>() для получения числа секунд с 1970 года до указанной даты/времени. Отмечу, что MS Visual Studio не может обрабатывать даты до 1970.
</p></dd></dl>

<dl>
<dt><a name="index-mgl_005fget_005ftime"></a>Функция С: <em><code>double</code></em> <strong>mgl_get_time</strong> <em>(<code>const char*</code>str, <code>const char *</code>templ)</em></dt>
<dd><p>Возвращает число секунд с 1970 года до даты/времени, указанной в строке <var>str</var>. Формат строки задается <var>templ</var>, такой же как <a href="http://www.manpagez.com/man/3/strftime/">http://www.manpagez.com/man/3/strftime/</a>. Наиболее употребительные варианты: &lsquo;<samp>%X</samp>&rsquo; для национального представления времени, &lsquo;<samp>%x</samp>&rsquo; для национального представления даты, &lsquo;<samp>%Y</samp>&rsquo; для года с цифрами столетия. Отмечу, что MS Visual Studio не может обрабатывать даты до 1970.
</p></dd></dl>

<a name="tuneticks"></a><dl>
<dt><a name="index-tuneticks"></a>Команда MGL: <em></em> <strong>tuneticks</strong> <em><code>val</code> [<code>pos=1.15</code>]</em></dt>
<dt><a name="index-SetTuneTicks-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTuneTicks</strong> <em>(<code>int</code> tune, <code>mreal</code> pos=<code>1.15</code>)</em></dt>
<dt><a name="index-mgl_005ftune_005fticks"></a>Функция С: <em><code>void</code></em> <strong>mgl_tune_ticks</strong> <em>(<code>HMGL</code> gr, <code>int</code> tune, <code>mreal</code> pos)</em></dt>
<dd><p>Включает/выключает улучшение вида меток осей путем вынесения общего множителя (для маленьких, типа 0.001...0.002, или больших, типа 1000...2000, значений координат) или общей компоненты (для узкого диапазона, типа 0.999...1.000). Также задает положение <var>pos</var> общего множителя на оси: =0 около минимального значения, =1 около максимального значения.
</p></dd></dl>

<a name="tickshift"></a><dl>
<dt><a name="index-tickshift"></a>Команда MGL: <em></em> <strong>tickshift</strong> <em><code>dx [dy=0 dz=0 dc=0]</code></em></dt>
<dt><a name="index-SetTickShift"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickShift</strong> <em>(<code>mglPoint</code> d)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005fshift"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_shift</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>mreal</code> dc)</em></dt>
<dd><p>Задает значение дополнительного сдвига меток осей координат.
</p></dd></dl>


<dl>
<dt><a name="index-SetTickRotate-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickRotate</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005frotate"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_rotate</strong> <em>(<code>HMGL</code> gr, <code>bool</code> val)</em></dt>
<dd><p>Включает/выключает поворот меток если их число или длина меток слишком велики.
</p></dd></dl>

<dl>
<dt><a name="index-SetTickSkip-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickSkip</strong> <em>(<code>bool</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005fskip"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_skip</strong> <em>(<code>HMGL</code> gr, <code>bool</code> val)</em></dt>
<dd><p>Включает/выключает пропуск меток если их число или длина меток слишком велики.
</p></dd></dl>

<dl>
<dt><a name="index-SetTimeUTC"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTimeUTC</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Разрешает/запрещает использование UTC времени в метках осей координат. В C/Fortran следует использовать <code>mgl_set_flag(gr,val, MGL_USE_GMTIME);</code>.
</p></dd></dl>


<a name="origintick"></a><dl>
<dt><a name="index-origintick"></a>Команда MGL: <em></em> <strong>origintick</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetOriginTick-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetOriginTick</strong> <em>(<code>bool</code> val=<code>true</code>)</em></dt>
<dd><p>Разрешает/запрещает рисование меток в точке пересечения осей координат. В C/Fortran следует использовать <code>mgl_set_flag(gr,val, MGL_NO_ORIGIN);</code>.
</p></dd></dl>

<a name="ticklen"></a><dl>
<dt><a name="index-ticklen"></a>Команда MGL: <em></em> <strong>ticklen</strong> <em><code>val</code> [<code>stt=1</code>]</em></dt>
<dt><a name="index-SetTickLen-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetTickLen</strong> <em>(<code>mreal</code> val, <code>mreal</code> stt=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fset_005ftick_005flen"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_tick_len</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>mreal</code> stt)</em></dt>
<dd><p>Задает относительную длину меток осей координат. Значение по умолчанию <code>0.1</code>. Параметр <var>stt</var>&gt;0 задает относительную длину подметок, которые в <code>sqrt(1+stt)</code> раз меньше.
</p></dd></dl>

<dl>
<dt><a name="index-axisstl"></a>Команда MGL: <em></em> <strong>axisstl</strong> <em>'stl' ['tck'='' 'sub'='']</em></dt>
<dt><a name="index-SetAxisStl-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetAxisStl</strong> <em>(<code>const char *</code>stl=<code>&quot;k&quot;</code>, <code>const char *</code>tck=<code>0</code>, <code>const char *</code>sub=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fset_005faxis_005fstl"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_axis_stl</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>stl, <code>const char *</code>tck, <code>const char *</code>sub)</em></dt>
<dd><p>Задает стиль осей (<var>stl</var>), меток (<var>tck</var>) и подметок (<var>sub</var>) осей координат. Если <var>stl</var> пустая или ноль, то используется стиль по умолчанию (&lsquo;<samp>k</samp>&rsquo; или &lsquo;<samp>w</samp>&rsquo; в зависимости от типа прозрачности). Если  <var>tck</var>, <var>sub</var> пустая или ноль, то используется стиль осей (т.е. <var>stl</var>).
</p></dd></dl>


<hr>
<a name="Subplots-and-rotation"></a>
<div class="header">
<p>
Next: <a href="#Export-picture" accesskey="n" rel="next">Export picture</a>, Previous: <a href="#Axis-settings" accesskey="p" rel="prev">Axis settings</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Matrica-preobrazovaniya"></a>
<h3 class="section">4.4 Матрица преобразования</h3>

<a name="index-Aspect"></a>
<a name="index-Rotate"></a>
<a name="index-RotateN"></a>
<a name="index-SubPlot"></a>
<a name="index-MultiPlot"></a>
<a name="index-StickPlot"></a>
<a name="index-ColumnPlot"></a>
<a name="index-InPlot"></a>
<a name="index-Title"></a>
<a name="index-Perspective"></a>
<a name="index-View"></a>
<a name="index-Push"></a>
<a name="index-Pop"></a>

<p>Эти функции контролируют где и как график будет расположен. Существует определенный порядок вызова этих функций для лучшего вида графика. Вначале должны вызываться функции <a href="#subplot">subplot</a>, <a href="#multiplot">multiplot</a> или <a href="#inplot">inplot</a> для указания местоположения вывода. После них &ndash; функции вращения <a href="#rotate">rotate</a>, <a href="#shear">shear</a> и <a href="#aspect">aspect</a>. И наконец любые другие функции для рисования графика. Вместо вращения графика можно вызвать функцию <a href="#columnplot">columnplot</a>, <a href="#gridplot">gridplot</a>, <a href="#stickplot">stickplot</a>, <a href="#shearplot">shearplot</a> или относительную <a href="#inplot">inplot</a> для расположения графиков в столбец одного над другим без зазора между осями. См. раздел <a href="#Subplots">Subplots</a>, для примеров кода и графика.
</p>
<a name="subplot"></a><dl>
<dt><a name="index-subplot"></a>Команда MGL: <em></em> <strong>subplot</strong> <em><code>nx ny m</code> ['stl'='&lt;&gt;_^' <code>dx=0 dy=0</code>]</em></dt>
<dt><a name="index-SubPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SubPlot</strong> <em>(<code>int</code> nx, <code>int</code> ny, <code>int</code> m, <code>const char *</code>stl=<code>&quot;&lt;&gt;_^&quot;</code>, <code>mreal</code> dx=<code>0</code>, <code>mreal</code> dy=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fsubplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_subplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> m, <code>const char *</code>stl)</em></dt>
<dt><a name="index-mgl_005fsubplot_005fd"></a>Функция С: <em><code>void</code></em> <strong>mgl_subplot_d</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> m, <code>const char *</code>stl, <code>mreal</code> dx, <code>mreal</code> dy)</em></dt>
<dd><p>Помещает последующий вывод в <var>m</var>-ую ячейку сетки размером <var>nx</var>*<var>ny</var> от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания &quot;подграфика&quot;. С эстетической точки зрения не рекомендуется вызывать эту функцию с различными (или не кратными) размерами сетки. Дополнительное место для осей/colorbar резервируется только если строка <var>stl</var> содержит: 
</p><ul>
<li> &lsquo;<samp>L</samp>&rsquo; или &lsquo;<samp>&lt;</samp>&rsquo; &ndash; с левого края,
</li><li> &lsquo;<samp>R</samp>&rsquo; или &lsquo;<samp>&gt;</samp>&rsquo; &ndash; с правого края,
</li><li> &lsquo;<samp>A</samp>&rsquo; или &lsquo;<samp>^</samp>&rsquo; &ndash; с верхнего края,
</li><li> &lsquo;<samp>U</samp>&rsquo; или &lsquo;<samp>_</samp>&rsquo; &ndash; с нижнего края,
</li><li> &lsquo;<samp>#</samp>&rsquo; &ndash; место резервироваться не будет &ndash; оси координат будут занимать все доступное пространство.
</li></ul>
<p>Ячейка может быть дополнительно сдвинута относительно своего обычного положения на относительный размер <var>dx</var>, <var>dy</var>. Отмечу, что colorbar может находиться за пределами рисунка если выбран пустой стиль &lsquo;<samp></samp>&rsquo;.
</p></dd></dl>

<a name="multiplot"></a><dl>
<dt><a name="index-multiplot"></a>Команда MGL: <em></em> <strong>multiplot</strong> <em><code>nx ny m dx dy</code> ['style'='&lt;&gt;_^' sx sy]</em></dt>
<dt><a name="index-MultiPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>MultiPlot</strong> <em>(<code>int</code> nx, <code>int</code> ny, <code>int</code> m, <code>int</code> dx, <code>int</code> dy, <code>const char *</code>stl=<code>&quot;&lt;&gt;_^&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fmultiplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_multiplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> m, <code>int</code> dx, <code>int</code> dy, <code>const char *</code>stl)</em></dt>
<dd><p>Помещает последующий вывод в прямоугольник из <var>dx</var>*<var>dy</var> ячеек, начиная с <var>m</var>-ой ячейки, сетки размером <var>nx</var>*<var>ny</var> от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания &quot;подграфика&quot;. Дополнительное место для осей/colorbar резервируется если строка <var>stl</var> содержит:
</p><ul>
<li> &lsquo;<samp>L</samp>&rsquo; или &lsquo;<samp>&lt;</samp>&rsquo; &ndash; с левого края,
</li><li> &lsquo;<samp>R</samp>&rsquo; или &lsquo;<samp>&gt;</samp>&rsquo; &ndash; с правого края,
</li><li> &lsquo;<samp>A</samp>&rsquo; или &lsquo;<samp>^</samp>&rsquo; &ndash; с верхнего края,
</li><li> &lsquo;<samp>U</samp>&rsquo; или &lsquo;<samp>_</samp>&rsquo; &ndash; с нижнего края,
</li><li> &lsquo;<samp>#</samp>&rsquo; &ndash; место резервироваться не будет &ndash; оси координат будут занимать все доступное пространство.
</li></ul>
<p>Область вывода может быть дополнительно сдвинута относительно своего обычного положения на относительный размер <var>sx</var>, <var>sy</var>.
</p></dd></dl>

<a name="inplot"></a><dl>
<dt><a name="index-inplot"></a>Команда MGL: <em></em> <strong>inplot</strong> <em><code>x1 x2 y1 y2 [rel=on]</code></em></dt>
<dt><a name="index-InPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>InPlot</strong> <em>(<code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>bool</code> rel=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005finplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_inplot</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2)</em></dt>
<dt><a name="index-mgl_005frelplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_relplot</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2)</em></dt>
<dd><p>Помещает последующий вывод в прямоугольную область [<var>x1</var>, <var>x2</var>]*[<var>y1</var>, <var>y2</var>] (исходный размер [0,1]*[0,1]). Эта функция позволяет поместить график в произвольную область рисунка. Если параметр <var>rel</var>=<code>true</code>, то используется позиция относительно текущего <a href="#subplot">subplot</a> (или <a href="#inplot">inplot</a> с <var>rel</var>=<code>false</code>). Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания &quot;подграфика&quot;.
</p></dd></dl>

<a name="columnplot"></a><dl>
<dt><a name="index-columnplot"></a>Команда MGL: <em></em> <strong>columnplot</strong> <em><code>num ind [d=0]</code></em></dt>
<dt><a name="index-ColumnPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ColumnPlot</strong> <em>(<code>int</code> num, <code>int</code> ind, <code>mreal</code> d=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fcolumnplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_columnplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> num, <code>int</code> ind)</em></dt>
<dt><a name="index-mgl_005fcolumnplot_005fd"></a>Функция С: <em><code>void</code></em> <strong>mgl_columnplot_d</strong> <em>(<code>HMGL</code> gr, <code>int</code> num, <code>int</code> ind, <code>mreal</code> d)</em></dt>
<dd><p>Помещает последующий вывод в <var>ind</var>-ую строку столбца из <var>num</var> строк. Положение столбца выбирается относительно последнего вызова <a href="#subplot">subplot</a> (или <a href="#inplot">inplot</a> с <var>rel</var>=<code>false</code>). Параметр <var>d</var> задает дополнительный зазор между строк.
</p></dd></dl>

<a name="gridplot"></a><dl>
<dt><a name="index-gridplot"></a>Команда MGL: <em></em> <strong>gridplot</strong> <em><code>nx ny ind [d=0]</code></em></dt>
<dt><a name="index-GridPlot"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GridPlot</strong> <em>(<code>int</code> nx, <code>int</code> ny, <code>int</code> ind, <code>mreal</code> d=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fgridplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_gridplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> ind)</em></dt>
<dt><a name="index-mgl_005fgridplot_005fd"></a>Функция С: <em><code>void</code></em> <strong>mgl_gridplot_d</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> ind, <code>mreal</code> d)</em></dt>
<dd><p>Помещает последующий вывод в <var>ind</var>-ую ячейку таблицы <var>nx</var>*<var>ny</var>. Положение ячейки выбирается относительно последнего вызова <a href="#subplot">subplot</a> (или <a href="#inplot">inplot</a> с <var>rel</var>=<code>false</code>). Параметр <var>d</var> задает дополнительный зазор между ячеек.
</p></dd></dl>

<a name="stickplot"></a><dl>
<dt><a name="index-stickplot"></a>Команда MGL: <em></em> <strong>stickplot</strong> <em><code>num ind tet phi</code></em></dt>
<dt><a name="index-StickPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>StickPlot</strong> <em>(<code>int</code> num, <code>int</code> ind, <code>mreal</code> tet, <code>mreal</code> phi)</em></dt>
<dt><a name="index-mgl_005fstickplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_stickplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> num, <code>int</code> ind, <code>mreal</code> tet, <code>mreal</code> phi)</em></dt>
<dd><p>Помещает последующий вывод в <var>ind</var>-ую ячейку &quot;бруска&quot; из <var>num</var> ячеек. При этом сам брусок повернут на углы <var>tet</var>, <var>phi</var>. Положение выбирается относительно последнего вызова  <a href="#subplot">subplot</a> (или <a href="#inplot">inplot</a> с <var>rel</var>=<code>false</code>).
</p></dd></dl>

<a name="shearplot"></a><dl>
<dt><a name="index-shearplot"></a>Команда MGL: <em></em> <strong>shearplot</strong> <em><code>num ind sx sy [xd yd]</code></em></dt>
<dt><a name="index-ShearPlot"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ShearPlot</strong> <em>(<code>int</code> num, <code>int</code> ind, <code>mreal</code> sx, <code>mreal</code> sy, <code>mreal</code> xd=<code>1</code>, <code>mreal</code> yd=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fshearplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_shearplot</strong> <em>(<code>HMGL</code> gr, <code>int</code> num, <code>int</code> ind, <code>mreal</code> sx, <code>mreal</code> sy, <code>mreal</code> xd, <code>mreal</code> yd)</em></dt>
<dd><p>Помещает последующий вывод в <var>ind</var>-ую ячейку &quot;бруска&quot; из <var>num</var> ячеек. При этом сама ячейка скошена на <var>sx</var>, <var>sy</var>. Направление бруска задается переменными <var>xd</var> и <var>yd</var>. Положение выбирается относительно последнего вызова  <a href="#subplot">subplot</a> (или <a href="#inplot">inplot</a> с <var>rel</var>=<code>false</code>).
</p></dd></dl>

<a name="title"></a><dl>
<dt><a name="index-title"></a>Команда MGL: <em></em> <strong>title</strong> <em>'title' ['stl'='' <code>size=-2</code>]</em></dt>
<dt><a name="index-Title-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Title</strong> <em>(<code>const char *</code>txt, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> size=<code>-2</code>)</em></dt>
<dt><a name="index-Title-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Title</strong> <em>(<code>const wchar_t *</code>txt, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> size=<code>-2</code>)</em></dt>
<dt><a name="index-mgl_005ftitle"></a>Функция С: <em><code>void</code></em> <strong>mgl_title</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>txt, <code>const char *</code>stl, <code>mreal</code> size)</em></dt>
<dt><a name="index-mgl_005ftitlew"></a>Функция С: <em><code>void</code></em> <strong>mgl_titlew</strong> <em>(<code>HMGL</code> gr, <code>const wchar_t *</code>txt, <code>const char *</code>stl, <code>mreal</code> size)</em></dt>
<dd><p>Выводит заголовок <var>title</var> для текущего &quot;подграфика&quot; шрифтом <var>stl</var> с размером <var>size</var>. Если строка <var>stl</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется обрамляющий прямоугольник. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться сразу после создания &quot;подграфика&quot;.
</p></dd></dl>

<a name="rotate"></a><dl>
<dt><a name="index-rotate"></a>Команда MGL: <em></em> <strong>rotate</strong> <em><code>tetx tetz [tety=0]</code></em></dt>
<dt><a name="index-Rotate-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Rotate</strong> <em>(<code>mreal</code> TetX, <code>mreal</code> TetZ, <code>mreal</code> TetY=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005frotate"></a>Функция С: <em><code>void</code></em> <strong>mgl_rotate</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> TetX, <code>mreal</code> TetZ, <code>mreal</code> TetY)</em></dt>
<dd><p>Вращает систему координат относительно осей {x, z, y} последовательно на углы <var>TetX</var>, <var>TetZ</var>, <var>TetY</var>.
</p></dd></dl>

<dl>
<dt><a name="index-rotate-1"></a>Команда MGL: <em></em> <strong>rotate</strong> <em><code>tet x y z</code></em></dt>
<dt><a name="index-RotateN-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>RotateN</strong> <em>(<code>mreal</code> Tet, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-mgl_005frotate_005fvector"></a>Функция С: <em><code>void</code></em> <strong>mgl_rotate_vector</strong> <em>(<code>HMGL</code> gr, <code>mreal Tet</code>, <code>mreal x</code>, <code>mreal y</code>, <code>mreal z</code>)</em></dt>
<dd><p>Вращает систему координат относительно вектора {<var>x</var>, <var>y</var>, <var>z</var>} на угол <var>Tet</var>.
</p></dd></dl>


<a name="shear"></a><dl>
<dt><a name="index-shear"></a>Команда MGL: <em></em> <strong>shear</strong> <em><code>sx sy</code></em></dt>
<dt><a name="index-Shear"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Shear</strong> <em>(<code>mreal</code> sx, <code>mreal</code> sy)</em></dt>
<dt><a name="index-mgl_005fshear"></a>Функция С: <em><code>void</code></em> <strong>mgl_shear</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> sx, <code>mreal</code> sy)</em></dt>
<dd><p>Сдвигает (скашивает) систему координат на значения <var>sx</var>, <var>sy</var>.
</p></dd></dl>


<a name="aspect"></a><dl>
<dt><a name="index-aspect"></a>Команда MGL: <em></em> <strong>aspect</strong> <em><code>ax ay [az=1]</code></em></dt>
<dt><a name="index-Aspect-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Aspect</strong> <em>(<code>mreal</code> Ax, <code>mreal</code> Ay, <code>mreal</code> Az=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005faspect"></a>Функция С: <em><code>void</code></em> <strong>mgl_aspect</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> Ax, <code>mreal</code> Ay, <code>mreal</code> Az)</em></dt>
<dd><p>Устанавливает соотношение размеров осей в отношении <var>Ax:Ay:Az</var>. Для лучшего вида следует вызывать после функции <a href="#rotate">rotate</a>. Если <var>Ax</var>=<code>NAN</code>, то функция выберет оптимальное соотношение размеров, чтобы шаг по осям x-y был одинаков. При этом, <var>Ay</var> задает фактор пропорциональности шага (обычно 1), или указывает на его автоматический выбор при <var>Ay</var>=<code>NAN</code>.
</p></dd></dl>


<dl>
<dt><a name="index-Push-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Push</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fmat_005fpush"></a>Функция С: <em><code>void</code></em> <strong>mgl_mat_push</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Помещает матрицу преобразования в стек. Позднее вы можете восстановить текущее состояние с помощью функции Pop().
</p></dd></dl>

<dl>
<dt><a name="index-Pop-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pop</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fmat_005fpop"></a>Функция С: <em><code>void</code></em> <strong>mgl_mat_pop</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Заменяет (восстанавливает) матрицу преобразования на последнюю помещенную в стек матрицу.
</p></dd></dl>

<dl>
<dt><a name="index-SetPlotFactor"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetPlotFactor</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fset_005fplotfactor"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_plotfactor</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val)</em></dt>
<dd><p>Задает масштаб картинки. Не рекомендуется устанавливать значения меньше 1.5. Это аналог функции Zoom(), но применяется только к конкретному подграфику. Используйте ноль для включения автоматического масштабирования.
</p></dd></dl>



<p>Также есть 3 функции, которые управляют перспективой <code>Perspective()</code>, масштабированием <code>Zoom()</code> и вращением <code>View()</code> всего рисунка. Т.е. они действуют как ещё одна матрица трансформации. Они были введены для вращения/приближения графика с помощью мыши. Не рекомендуется вызывать их при рисовании графика.
</p>
<a name="perspective"></a><dl>
<dt><a name="index-perspective"></a>Команда MGL: <em></em> <strong>perspective</strong> <em><code>val</code></em></dt>
<dt><a name="index-Perspective-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Perspective</strong> <em>(<code>mreal</code> a)</em></dt>
<dt><a name="index-mgl_005fperspective"></a>Функция С: <em><code>void</code></em> <strong>mgl_perspective</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> a)</em></dt>
<dd><p>Добавляет (включает) перспективу для графика. Параметр <em>a = Depth/(Depth+dz) \in [0,1)</em>. По умолчанию (<code>a=0</code>) перспектива отключена.
</p></dd></dl>

<a name="view"></a><dl>
<dt><a name="index-view"></a>Команда MGL: <em></em> <strong>view</strong> <em><code>tetx tetz [tety=0]</code></em></dt>
<dt><a name="index-View-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>View</strong> <em>(<code>mreal</code> TetX, <code>mreal</code> TetZ, <code>mreal</code> TetY=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fview"></a>Функция С: <em><code>void</code></em> <strong>mgl_view</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> TetX, <code>mreal</code> TetZ, <code>mreal</code> TetY)</em></dt>
<dd><p>Вращает систему координат относительно осей {x, z, y} последовательно на углы <var>TetX</var>, <var>TetZ</var>, <var>TetY</var>. Вращение происходит независимо от <a href="#rotate">rotate</a>. Внимание! эти настройки не могут быть переписаны функцией  <code>DefaultPlotParam()</code>. Используйте <code>Zoom(0,0,1,1)</code> для возвращения к виду по умолчанию.
</p></dd></dl>

<a name="zoom"></a><dl>
<dt><a name="index-zoom"></a>Команда MGL: <em></em> <strong>zoom</strong> <em><code>x1 y1 x2 y2</code></em></dt>
<dt><a name="index-Zoom"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Zoom</strong> <em>(<code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> x2, <code>mreal</code> y2)</em></dt>
<dt><a name="index-mgl_005fset_005fzoom"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_zoom</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> x2, <code>mreal</code> y2)</em></dt>
<dd><p>Масштабирует весь рисунок. После вызова функции текущий график будет очищен и в дальнейшем рисунок будет содержать только область [x1,x2]*[y1,y2] от исходного рисунка. Координаты <var>x1</var>, <var>x2</var>, <var>y1</var>, <var>y2</var> меняются в диапазоне от 0 до 1. Внимание! эти настройки не могут быть переписаны никакими другими функциями, включая  <code>DefaultPlotParam()</code>. Используйте <code>Zoom(0,0,1,1)</code> для возвращения к виду по умолчанию.
</p></dd></dl>


<hr>
<a name="Export-picture"></a>
<div class="header">
<p>
Next: <a href="#Background" accesskey="n" rel="next">Background</a>, Previous: <a href="#Subplots-and-rotation" accesskey="p" rel="prev">Subplots and rotation</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Eksport-risunka"></a>
<h3 class="section">4.5 Экспорт рисунка</h3>

<a name="index-SetSize"></a>

<p>Функции в этой группе сохраняют или дают доступ к полученному рисунку. Поэтом обычно они должны вызываться в конце рисования.
</p>
<a name="setsize"></a><dl>
<dt><a name="index-setsize"></a>Команда MGL: <em></em> <strong>setsize</strong> <em><code>w h</code></em></dt>
<dt><a name="index-SetSize-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetSize</strong> <em>(<code>int</code> width, <code>int</code> height, <code>bool</code> clear=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_size</strong> <em>(<code>HMGL</code> gr, <code>int</code> width, <code>int</code> height)</em></dt>
<dt><a name="index-mgl_005fscale_005fsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_scale_size</strong> <em>(<code>HMGL</code> gr, <code>int</code> width, <code>int</code> height)</em></dt>
<dd><p>Изменяет размер картинки в пикселях. Функция должна вызываться <strong>перед</strong> любыми функциями построения потому что полностью очищает содержимое рисунка при <var>clear</var>=<code>true</code>. Функция только очищает растровый рисунок и масштабирует примитивы при <var>clear</var>=<code>false</code>.
</p></dd></dl>


<a name="setsizescl"></a><dl>
<dt><a name="index-setsizescl"></a>Команда MGL: <em></em> <strong>setsizescl</strong> <em><code>factor</code></em></dt>
<dt><a name="index-SetSizeScl"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetSizeScl</strong> <em>(<code>double</code> factor)</em></dt>
<dt><a name="index-mgl_005fset_005fsize_005fscl"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_size_scl</strong> <em>(<code>HMGL</code> gr, <code>double</code> factor)</em></dt>
<dd><p>Задает множитель для высоты и ширины во всех последующих вызовах <a href="#setsize">setsize</a>.
</p></dd></dl>


<a name="quality"></a><dl>
<dt><a name="index-quality"></a>Команда MGL: <em></em> <strong>quality</strong> <em>[<code>val</code>=2]</em></dt>
<dt><a name="index-SetQuality"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetQuality</strong> <em>(<code>int</code> val=<code>MGL_DRAW_NORM</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fquality"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_quality</strong> <em>(<code>HMGL</code> gr, <code>int</code> val)</em></dt>
<dd><p>Задает качество графика в зависимости от значения <var>val</var>: <code>MGL_DRAW_WIRE=0</code> &ndash; нет рисования граней (наиболее быстрый), <code>MGL_DRAW_FAST=1</code> &ndash; нет интерполяции цвета (быстрый), <code>MGL_DRAW_NORM=2</code> &ndash; высокое качество (нормальный), <code>MGL_DRAW_HIGH=3</code> &ndash; высокое качество с рисованием 3d примитивов (стрелок и маркеров). Если установлен бит <code>MGL_DRAW_LMEM=0x4</code>, то происходит прямое рисование в растровое изображение (меньше затраты памяти). Если установлен бит <code>MGL_DRAW_DOTS=0x8</code>, то рисуются точки вместо примитивов (очень быстро).
</p></dd></dl>

<dl>
<dt><a name="index-GetQuality"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetQuality</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005fquality"></a>Функция С: <em><code>void</code></em> <strong>mgl_get_quality</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает качество графика: <code>MGL_DRAW_WIRE=0</code> &ndash; нет рисования граней (наиболее быстрый), <code>MGL_DRAW_FAST=1</code> &ndash; нет интерполяции цвета (быстрый), <code>MGL_DRAW_NORM=2</code> &ndash; высокое качество (нормальный), <code>MGL_DRAW_HIGH=3</code> &ndash; высокое качество с рисованием 3d примитивов (стрелок и маркеров). Если установлен бит <code>MGL_DRAW_LMEM=0x4</code>, то происходит прямое рисование в растровое изображение (меньше затраты памяти). Если установлен бит <code>MGL_DRAW_DOTS=0x8</code>, то рисуются точки вместо примитивов (очень быстро).
</p></dd></dl>

<dl>
<dt><a name="index-StartGroup"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>StartGroup</strong> <em>(const char *name)</em></dt>
<dt><a name="index-mgl_005fstart_005fgroup"></a>Функция С: <em><code>void</code></em> <strong>mgl_start_group</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>name)</em></dt>
<dd><p>Начинает определение группы. Группа может содержать объекты и другие группы. Они используются для выбора части модели при приближении, изменении прозрачности и т.д.
</p></dd></dl>

<dl>
<dt><a name="index-EndGroup"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>EndGroup</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fend_005fgroup"></a>Функция С: <em><code>void</code></em> <strong>mgl_end_group</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Завершает определение группы.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Export-to-file" accesskey="1">Export to file</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Frames_002fAnimation" accesskey="2">Frames/Animation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bitmap-in-memory" accesskey="3">Bitmap in memory</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parallelization" accesskey="4">Parallelization</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Export-to-file"></a>
<div class="header">
<p>
Next: <a href="#Frames_002fAnimation" accesskey="n" rel="next">Frames/Animation</a>, Up: <a href="#Export-picture" accesskey="u" rel="up">Export picture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Eksport-v-fail"></a>
<h4 class="subsection">4.5.1 Экспорт в файл</h4>

<a name="index-Write"></a>
<a name="index-WriteFrame"></a>
<a name="index-WritePNG"></a>
<a name="index-WriteGIF"></a>
<a name="index-WriteSVG"></a>
<a name="index-WriteBMP"></a>
<a name="index-WriteEPS"></a>
<a name="index-WriteBPS"></a>
<a name="index-WriteTGA"></a>
<a name="index-WriteTEX"></a>
<a name="index-WritePRC"></a>
<a name="index-WriteOBJ"></a>
<a name="index-WriteWGL"></a>
<a name="index-WriteJPEG"></a>
<a name="index-ShowImage"></a>

<p>Эти функции экспортируют текущую картинку (кадр) в файл. Имя файла <var>fname</var> должно иметь соответствующее расширение. Параметр <var>descr</var> дает краткое описание картинки. Пока прозрачность поддерживается только для форматов PNG, SVG, OBJ и PRC.
</p>
<a name="write"></a><dl>
<dt><a name="index-write"></a>Команда MGL: <em></em> <strong>write</strong> <em>['fname'='']</em></dt>
<dt><a name="index-WriteFrame-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteFrame</strong> <em>(<code>const char *</code>fname=<code>&quot;&quot;</code>, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_frame</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в файл <var>fname</var> с типом, определяемым по расширению. Параметр <var>descr</var> добавляет описание (может быть пустым). Если <var>fname</var> пустой, то используется имя &lsquo;<samp>frame####.jpg</samp>&rsquo;, где &lsquo;<samp>####</samp>&rsquo; &ndash; текущий номер кадра и имя &lsquo;<samp>frame</samp>&rsquo; определяется переменной <a href="#plotid">plotid</a>.
</p></dd></dl>

<a name="bbox"></a><dl>
<dt><a name="index-bbox"></a>Команда MGL: <em></em> <strong>bbox</strong> <em>x1 y1 [x2=<code>-1</code> y2=<code>-1</code>]</em></dt>
<dt><a name="index-SetBBox"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetBBox</strong> <em>(<code>int</code> x1=<code>0</code>, <code>int</code> y1=<code>0</code>, <code>int</code> x2=<code>-1</code>, <code>int</code> y2=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fbbox"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_bbox</strong> <em>(<code>HMGL</code> gr, <code>int</code> x1, <code>int</code> y1, <code>int</code> x2, <code>int</code> y2)</em></dt>
<dd><p>Задает область изображения, которая будет сохранена в файл 2D формата. Если <var>x2</var>&lt;0 (<var>y2</var>&lt;0), то исходная ширина (высота) рисунка будет использована. Если <var>x1</var>&lt;0 или <var>y1</var>&lt;0 или <var>x1</var>&gt;=<var>x2</var>|Width или <var>y1</var>&gt;=<var>y2</var>|Height, то обрезания рисунка не будет.
</p></dd></dl>


<dl>
<dt><a name="index-WritePNG-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WritePNG</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>, <code>int</code> compr=<code>&quot;&quot;</code>, <code>bool</code> alpha=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fpng"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_png</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dt><a name="index-mgl_005fwrite_005fpng_005fsolid"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_png_solid</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в PNG файл. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла, <var>alpha</var> &ndash; прозрачность фона. Если при компиляции MathGL не был определен флаг HAVE_PNG, то экспорт в файл не производится.
</p></dd></dl>

<dl>
<dt><a name="index-WriteJPEG-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteJPEG</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fjpg"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_jpg</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в JPEG файл. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если при компиляции MathGL не был определен флаг HAVE_JPEG, то экспорт в файл не производится.
</p></dd></dl>

<dl>
<dt><a name="index-WriteGIF-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteGIF</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fgif"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_gif</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в GIF файл. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если при компиляции MathGL не был определен флаг HAVE_GIF, то экспорт в файл не производится.
</p></dd></dl>

<dl>
<dt><a name="index-WriteBMP-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteBMP</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fbmp"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_bmp</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в BMP файл. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-WriteTGA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteTGA</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005ftga"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_tga</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в TGA файл. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-WriteEPS-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteEPS</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005feps"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_eps</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в EPS файл, используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если имя файла оканчивается на &lsquo;<samp>z</samp>&rsquo; (например, &lsquo;<samp>fname.eps.gz</samp>&rsquo;), то файл автоматически архивируется в формате gzip. Отмечу, что формат EPS не поддерживает интерполяцию цвета, и картинка будет выглядеть как при использовании <a href="#quality">quality</a>=1.
</p></dd></dl>

<dl>
<dt><a name="index-WriteBPS-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteBPS</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005feps-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_eps</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в EPS файл, используя растровое представление графика. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если имя файла оканчивается на &lsquo;<samp>z</samp>&rsquo; (например, &lsquo;<samp>fname.eps.gz</samp>&rsquo;), то файл автоматически архивируется в формате gzip.
</p></dd></dl>

<dl>
<dt><a name="index-WriteSVG-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteSVG</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fsvg"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_svg</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в SVG файл, используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если имя файла оканчивается на &lsquo;<samp>z</samp>&rsquo; (например, &lsquo;<samp>fname.svgz</samp>&rsquo;), то файл автоматически архивируется в формате gzip. Отмечу, что формат SVG не поддерживает интерполяцию цвета, и картинка будет выглядеть как при использовании <a href="#quality">quality</a>=1.
</p></dd></dl>

<dl>
<dt><a name="index-WriteTEX-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteTEX</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005ftex"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_tex</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в LaTeX файл (пакет Tikz/PGF), используя векторное представление графика. Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Отмечу, что сейчас отсутствует изменение размера текста (например, в subplot), что может приводить к неправильному положению надписей.
</p></dd></dl>


<dl>
<dt><a name="index-WritePRC-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WritePRC</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>, <code>bool</code> make_pdf=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fprc"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_prc</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr, <code>int</code> make_pdf)</em></dt>
<dd><p>Экспортирует текущий кадр в PRC файл, используя векторное представление графика (см. <a href="http://en.wikipedia.org/wiki/PRC_%28file_format%29">http://en.wikipedia.org/wiki/PRC_%28file_format%29</a>). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла. Если параметр <var>make_pdf</var>=<code>true</code> и PDF был выбран при конфигурировании MathGL, то также создается соответствующий PDF файл с 3D изображением.
</p></dd></dl>

<dl>
<dt><a name="index-WriteOBJ-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteOBJ</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fobj"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_obj</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в OBJ/MTL файл, используя векторное представление графика (см. <a href="http://en.wikipedia.org/wiki/Wavefront_.obj_file">OBJ формат</a>). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>


<dl>
<dt><a name="index-WriteXYZ"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteXYZ</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_xyz</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в XYZ/XYZL/XYZF файлы, используя векторное представление графика (см. <a href="http://people.sc.fsu.edu/~jburkardt/data/xyz/xyz.html">XYZ формат</a>). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-WriteSTL"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteSTL</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fstl"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_stl</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует текущий кадр в STL файл, используя векторное представление графика (см. <a href="http://en.wikipedia.org/wiki/STL_(file_format)">STL формат</a>). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-WriteOFF"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteOFF</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>, <code>bool</code> colored=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005foff"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_off</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr, <code>bool</code> colored)</em></dt>
<dd><p>Экспортирует текущий кадр в OFF файл, используя векторное представление графика (см. <a href="http://people.sc.fsu.edu/~jburkardt/data/off/off.html">OFF формат</a>). Вследствие чего не рекомендуется сохранять большие графики (поверхности, а особенно поверхности уровня) из-за большого размера файла. Хотя никаких внутренних ограничений на размер выходного файла нет. Для них лучше использовать растровый формат (например, PNG или JPEG). Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>




<dl>
<dt><a name="index-ShowImage-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ShowImage</strong> <em>(<code>const char *</code>viewer, <code>bool</code> nowait=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fshow_005fimage"></a>Функция С: <em><code>void</code></em> <strong>mgl_show_image</strong> <em>(<code>const char *</code>viewer, <code>int</code> nowait)</em></dt>
<dd><p>Отображает текущий кадр используя внешнюю программу просмотра <var>viewer</var>. Функция сохраняет картинку во временный файл и вызывает <var>viewer</var> для его отображения. Если <var>nowait</var>=<code>true</code>, то функция возвращает управление немедленно &ndash; не ждет пока окно просмотра будет закрыто.
</p></dd></dl>


<dl>
<dt><a name="index-WriteJSON"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>WriteJSON</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fwrite_005fjson"></a>Функция С: <em><code>void</code></em> <strong>mgl_write_json</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует точки и примитивы в текстовый файл используя <a href="#JSON-format">JSON format</a>. В дальнейшем этот файл можно загрузить и просмотреть в JavaScript скрипте. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-ExportMGLD"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ExportMGLD</strong> <em>(<code>const char *</code>fname, <code>const char *</code>descr=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fexport_005fmgld"></a>Функция С: <em><code>void</code></em> <strong>mgl_export_mgld</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>const char *</code>descr)</em></dt>
<dd><p>Экспортирует точки и примитивы в файл <a href="#MGLD-format">MGLD format</a>. В дальнейшем этот файл можно загрузить и просмотреть с помощью <code>mglview</code>. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>descr</var> &ndash; описание файла.
</p></dd></dl>

<dl>
<dt><a name="index-ImportMGLD"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ImportMGLD</strong> <em>(<code>const char *</code>fname, <code>bool</code> add=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fimport_005fmgld"></a>Функция С: <em><code>void</code></em> <strong>mgl_import_mgld</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>int</code> add)</em></dt>
<dd><p>Импортирует точки и примитивы из файла в <a href="#MGLD-format">MGLD format</a>. Параметры функции следующие: <var>fname</var> &ndash; имя файла, <var>add</var> &ndash; флаг добавления или замены существующих точек и примитивов.
</p></dd></dl>




<hr>
<a name="Frames_002fAnimation"></a>
<div class="header">
<p>
Next: <a href="#Bitmap-in-memory" accesskey="n" rel="next">Bitmap in memory</a>, Previous: <a href="#Export-to-file" accesskey="p" rel="prev">Export to file</a>, Up: <a href="#Export-picture" accesskey="u" rel="up">Export picture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Kadry_002fAnimaciya"></a>
<h4 class="subsection">4.5.2 Кадры/Анимация</h4>



<a name="index-NewFrame"></a>
<a name="index-EndFrame"></a>
<a name="index-GetNumFrame"></a>
<a name="index-ResetFrames"></a>
<a name="index-StartGIF"></a>
<a name="index-CloseGIF"></a>

<p>Эти функции позволяют создавать несколько картинок одновременно. В большинстве случаев это бесполезно, но для органов управления (см. <a href="#Widget-classes">Widget classes</a>) это позволяет показывать анимацию. Также можно записать несколько кадров в анимированный GIF файл.
</p>
<dl>
<dt><a name="index-NewFrame-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>NewFrame</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fnew_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_new_frame</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Создает новый кадр. Функция возвращает номер текущего кадра. В режиме OpenGL функция не должны вызываться в параллельных потоках! &ndash; используйте прямое создание списка. Функция <code>EndFrame()</code> <strong>должна</strong> быть вызвана после рисования кадра для каждого вызова этой функции.
</p></dd></dl>

<dl>
<dt><a name="index-EndFrame-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>EndFrame</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fend_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_end_frame</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Завершает рисование кадра.
</p></dd></dl>

<dl>
<dt><a name="index-GetNumFrame-1"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetNumFrame</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005fnum_005fframe"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_num_frame</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает число созданных кадров.
</p></dd></dl>

<dl>
<dt><a name="index-GetFrame"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GetFrame</strong> <em>(<code>int</code> i)</em></dt>
<dt><a name="index-mgl_005fget_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_get_frame</strong> <em>(<code>HMGL</code> gr, <code>int</code> i)</em></dt>
<dd><p>Завершает рисование кадра и сохраняет объекты рисования в кадр с номером <var>i</var>, который должен быть в диапазоне [0, <code>GetNumFrame()</code>-1]. Функция аналогична <code>EndFrame()</code>, но не добавляет кадр в GIF изображение.
</p></dd></dl>

<dl>
<dt><a name="index-GetFrame-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GetFrame</strong> <em>(<code>int</code> i)</em></dt>
<dt><a name="index-mgl_005fget_005fframe-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_get_frame</strong> <em>(<code>HMGL</code> gr, <code>int</code> i)</em></dt>
<dd><p>Заменяет объекты рисования на объекты из кадра с номером <var>i</var>. Функция работает если установлен флаг <code>MGL_VECT_FRAME</code> (по умолчанию).
</p></dd></dl>

<dl>
<dt><a name="index-ShowFrame"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ShowFrame</strong> <em>(<code>int</code> i)</em></dt>
<dt><a name="index-mgl_005fshow_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_show_frame</strong> <em>(<code>HMGL</code> gr, <code>int</code> i)</em></dt>
<dd><p>Добавляет объекты рисования из кадра с номером <var>i</var> к уже существующим. Функция работает если установлен флаг <code>MGL_VECT_FRAME</code> (по умолчанию).
</p></dd></dl>

<dl>
<dt><a name="index-DelFrame"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DelFrame</strong> <em>(<code>int</code> i)</em></dt>
<dt><a name="index-mgl_005fdel_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_del_frame</strong> <em>(<code>HMGL</code> gr, <code>int</code> i)</em></dt>
<dd><p>Удаляет объекты рисования для кадра с номером <var>i</var> и сдвигает нумерацию всех последующих кадров. Функция работает если установлен флаг <code>MGL_VECT_FRAME</code> (по умолчанию).
</p></dd></dl>

<dl>
<dt><a name="index-ResetFrames-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ResetFrames</strong> <em>()</em></dt>
<dt><a name="index-mgl_005freset_005fframes"></a>Функция С: <em><code>void</code></em> <strong>mgl_reset_frames</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Сбрасывает счетчик кадров в 0.
</p></dd></dl>

<dl>
<dt><a name="index-ClearFrame"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ClearFrame</strong> <em>(<code>int</code> i)</em></dt>
<dt><a name="index-mgl_005fclear_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_clear_frame</strong> <em>(<code>HMGL</code> gr, <code>int</code> i)</em></dt>
<dd><p>Очищает текущий список объектов.
</p></dd></dl>

<dl>
<dt><a name="index-StartGIF-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>StartGIF</strong> <em>(<code>const char *</code>fname, <code>int</code> ms=<code>100</code>)</em></dt>
<dt><a name="index-mgl_005fstart_005fgif"></a>Функция С: <em><code>void</code></em> <strong>mgl_start_gif</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>int</code> ms)</em></dt>
<dd><p>Начинает запись кадров в анимированный GIF файл <var>fname</var>. Параметр <var>ms</var> задает задержку между кадрами в миллисекундах. Вы <strong>не должны</strong> менять размер рисунка во время создания кино. Используйте CloseGIF() для завершения записи. Эта функция не работает в режиме OpenGL.
</p></dd></dl>

<dl>
<dt><a name="index-CloseGIF-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>CloseGIF</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fclose_005fgif"></a>Функция С: <em><code>void</code></em> <strong>mgl_close_gif</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Завершает запись анимированного GIF файла.
</p></dd></dl>


<hr>
<a name="Bitmap-in-memory"></a>
<div class="header">
<p>
Next: <a href="#Parallelization" accesskey="n" rel="next">Parallelization</a>, Previous: <a href="#Frames_002fAnimation" accesskey="p" rel="prev">Frames/Animation</a>, Up: <a href="#Export-picture" accesskey="u" rel="up">Export picture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Risovanie-v-pamyati"></a>
<h4 class="subsection">4.5.3 Рисование в памяти</h4>


<p>Эти функции возвращают созданный растровый рисунок, его ширину и высоту. В дальнейшем его можно использовать в любой графической библиотеке (см. также, <a href="#Widget-classes">Widget classes</a>) или сохранить в файл (см. также, <a href="#Export-to-file">Export to file</a>).
</p>
<dl>
<dt><a name="index-GetRGB"></a>Метод класса <code>mglGraph</code>: <em><code>const unsigned char *</code></em> <strong>GetRGB</strong> <em>()</em></dt>
<dt><a name="index-GetRGB-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GetRGB</strong> <em>(<code>char *</code>buf, <code>int</code> size)</em></dt>
<dt><a name="index-GetBGRN"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GetBGRN</strong> <em>(<code>char *</code>buf, <code>int</code> size)</em></dt>
<dt><a name="index-mgl_005fget_005frgb"></a>Функция С: <em><code>const unsigned char *</code></em> <strong>mgl_get_rgb</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает растровое изображение в формате RGB для текущего кадра. Формат каждого элемента (пикселя): {red, green, blue}. Число элементов Width*Height. Положение элемента {i,j} есть [3*i + 3*Width*j] (или [4*i + 4*Width*j] для <code>GetBGRN()</code>). В Python вы должны предоставить буфер <var>buf</var> достаточного размера <var>size</var>, т.е. код должен выглядеть следующим образом (для Python)
</p><pre class="verbatim">from mathgl import *
gr = mglGraph();
bits='\t';
bits=bits.expandtabs(4*gr.GetWidth()*gr.GetHeight());
gr.GetBGRN(bits, len(bits));
</pre></dd></dl>

<dl>
<dt><a name="index-GetRGBA"></a>Метод класса <code>mglGraph</code>: <em><code>const unsigned char *</code></em> <strong>GetRGBA</strong> <em>()</em></dt>
<dt><a name="index-GetRGBA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>GetRGBA</strong> <em>(<code>char *</code>buf, <code>int</code> size)</em></dt>
<dt><a name="index-mgl_005fget_005frgba"></a>Функция С: <em><code>const unsigned char *</code></em> <strong>mgl_get_rgba</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает растровое изображение в формате RGBA для текущего кадра. Формат каждого элемента (пикселя): {red, green, blue, alpha}. Число элементов Width*Height. Положение элемента {i,j} есть [4*i + 4*Width*j].
</p></dd></dl>

<dl>
<dt><a name="index-GetWidth"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetWidth</strong> <em>()</em></dt>
<dt><a name="index-GetHeight"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetHeight</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005fwidth"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_width</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fget_005fheight"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_height</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает ширину и высоту изображения.
</p></dd></dl>


<dl>
<dt><a name="index-CalcXYZ"></a>Метод класса <code>mglGraph</code>: <em><code>mglPoint</code></em> <strong>CalcXYZ</strong> <em>(<code>int</code> xs, <code>int</code> ys)</em></dt>
<dt><a name="index-mgl_005fcalc_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_calc_xyz</strong> <em>(<code>HMGL</code> gr, <code>int</code> xs, <code>int</code> ys, <code>mreal *</code>x, <code>mreal *</code>y, <code>mreal *</code>z)</em></dt>
<dd><p>Вычисляет 3D координаты {x,y,z} для экранной точки {xs,ys}. В данный момент игнорируется перспектива графика и формулы перехода в криволинейные координаты. Вычисления производятся для последнего использованного InPlot (см. <a href="#Subplots-and-rotation">Subplots and rotation</a>).
</p></dd></dl>

<dl>
<dt><a name="index-CalcScr"></a>Метод класса <code>mglGraph</code>: <em><code>mglPoint</code></em> <strong>CalcScr</strong> <em>(<code>mglPoint</code> p)</em></dt>
<dt><a name="index-mgl_005fcalc_005fscr"></a>Функция С: <em><code>void</code></em> <strong>mgl_calc_scr</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>int *</code>xs, <code>int *</code>ys)</em></dt>
<dd><p>Вычисляет экранные координаты {xs,ys} для 3D координат {x,y,z}. Вычисления производятся для последнего использованного InPlot (см. <a href="#Subplots-and-rotation">Subplots and rotation</a>).
</p></dd></dl>

<dl>
<dt><a name="index-SetObjId"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetObjId</strong> <em>(<code>int</code> id)</em></dt>
<dt><a name="index-mgl_005fset_005fobj_005fid"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_obj_id</strong> <em>(<code>HMGL</code> gr, <code>int</code> id)</em></dt>
<dd><p>Задает числовой идентификатор для объектов или subplot/inplot.
</p></dd></dl>

<dl>
<dt><a name="index-GetObjId"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetObjId</strong> <em>(<code>int</code> xs, <code>int</code> ys)</em></dt>
<dt><a name="index-mgl_005fget_005fobj_005fid"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_obj_id</strong> <em>(<code>HMGL</code> gr, <code>int</code> xs, <code>int</code> ys)</em></dt>
<dd><p>Возвращает числовой идентификатор верхнего объекта в точке {xs, ys} рисунка.
</p></dd></dl>

<dl>
<dt><a name="index-GetSplId"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>GetSplId</strong> <em>(<code>int</code> xs, <code>int</code> ys)</em></dt>
<dt><a name="index-mgl_005fget_005fspl_005fid"></a>Функция С: <em><code>int</code></em> <strong>mgl_get_spl_id</strong> <em>(<code>HMGL</code> gr, <code>int</code> xs, <code>int</code> ys)</em></dt>
<dd><p>Возвращает числовой идентификатор верхнего &quot;подграфика&quot; в точке {xs, ys} рисунка.
</p></dd></dl>

<dl>
<dt><a name="index-Highlight"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Highlight</strong> <em>(<code>int</code> id)</em></dt>
<dt><a name="index-mgl_005fhighlight"></a>Функция С: <em><code>void</code></em> <strong>mgl_highlight</strong> <em>(<code>HMGL</code> gr, <code>int</code> id)</em></dt>
<dd><p>Выделяет объект с заданным <var>id</var>.
</p></dd></dl>

<dl>
<dt><a name="index-IsActive"></a>Метод класса <code>mglGraph</code>: <em><code>long</code></em> <strong>IsActive</strong> <em>(<code>int</code> xs, <code>int</code> ys, <code>int</code> d=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fis_005factive"></a>Функция С: <em><code>long</code></em> <strong>mgl_is_active</strong> <em>(<code>HMGL</code> gr, <code>int</code> xs, <code>int</code> ys, <code>int</code> d)</em></dt>
<dd><p>Проверяет близка ли точка {<var>xs</var>, <var>ys</var>} к активной точке (т.е. mglBase::Act) с точностью <var>d</var> и возвращает индекс активной точки или <code>-1</code> если не найдено. Активные точки &ndash; специальные точки, которые характеризуют примитивы (например, вершины). Это функция только для опытных пользователей.
</p></dd></dl>

<dl>
<dt><a name="index-SetDrawReg"></a>Метод класса <code>mglGraph</code>: <em><code>long</code></em> <strong>SetDrawReg</strong> <em>(<code>int</code> nx=<code>1</code>, <code>int</code> ny=<code>1</code>, <code>int</code> m=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fset_005fdraw_005freg"></a>Функция С: <em><code>long</code></em> <strong>mgl_set_draw_reg</strong> <em>(<code>HMGL</code> gr, <code>int</code> nx, <code>int</code> ny, <code>int</code> m)</em></dt>
<dd><p>Ограничивает рисование прямоугольной областью <var>m</var>-ой клетки матрицы размером <var>nx</var>*<var>ny</var> (аналогично <a href="#subplot">subplot</a>). Функция может бытб использована для ускорения вывода путем уменьшения выводимых примитивов. Это функция только для опытных пользователей.
</p></dd></dl>



<hr>
<a name="Parallelization"></a>
<div class="header">
<p>
Previous: <a href="#Bitmap-in-memory" accesskey="p" rel="prev">Bitmap in memory</a>, Up: <a href="#Export-picture" accesskey="u" rel="up">Export picture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rasparallelivanie"></a>
<h4 class="subsection">4.5.4 Распараллеливание</h4>


<a name="index-Combine"></a>
<a name="index-MPI_005fSend"></a>
<a name="index-MPI_005fRecv"></a>

<p>Многие функции MathGL используют несколько потоков для ускорения работы (если MathGL была собрана с поддержкой pthread). При этом можно настраивать число используемых потоков.
</p>
<dl>
<dt><a name="index-mgl_005fset_005fnum_005fthr"></a>Функция С: <em><code>int</code></em> <strong>mgl_set_num_thr</strong> <em>(<code>int</code> n)</em></dt>
<dd><p>Задает число потоков, которое будет использовано в MathGL. При <var>n</var>&lt;1 число потоков задается как максимальное число процессоров (ядер) в системе. При <var>n</var>=1 не используется распараллеливание.
</p></dd></dl>

<p>Другая возможность &ndash; комбинирование изображений из разных объектов <code>mglGraph</code>. Эти методы наиболее подходят для компьютерных кластеров, когда данные настолько велики, что не могут поместиться в памяти отдельного компьютера.
</p>
<dl>
<dt><a name="index-Combine-2"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>Combine</strong> <em>(<code>const mglGraph *</code>g)</em></dt>
<dt><a name="index-mgl_005fcombine_005fgr"></a>Функция С: <em><code>int</code></em> <strong>mgl_combine_gr</strong> <em>(<code>HMGL</code> gr, <code>HMGL</code> g)</em></dt>
<dd><p>Комбинирует (добавляет) рисунок из <var>g</var> с <var>gr</var>, принимая во внимание &ldquo;высоту&rdquo; пикселей. Ширина и высота обоих рисунков должна быть одинаковы.
</p></dd></dl>

<dl>
<dt><a name="index-MPI_005fSend-1"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>MPI_Send</strong> <em>(<code>int</code> id)</em></dt>
<dt><a name="index-mgl_005fmpi_005fsend"></a>Функция С: <em><code>int</code></em> <strong>mgl_mpi_send</strong> <em>(<code>HMGL</code> gr, <code>int</code> id)</em></dt>
<dd><p>Посылает рисунок из компьютера (ноды) <var>id</var>, используя MPI. Ширина и высота обоих рисунков должна быть одинаковы.
</p></dd></dl>

<dl>
<dt><a name="index-MPI_005fRecv-1"></a>Метод класса <code>mglGraph</code>: <em><code>int</code></em> <strong>MPI_Recv</strong> <em>(<code>int</code> id)</em></dt>
<dt><a name="index-mgl_005fmpi_005fsend-1"></a>Функция С: <em><code>int</code></em> <strong>mgl_mpi_send</strong> <em>(<code>HMGL</code> gr, <code>int</code> id)</em></dt>
<dd><p>Принимает рисунок из компьютера (ноды) <var>id</var>, используя MPI. Ширина и высота обоих рисунков должна быть одинаковы.
</p></dd></dl>



<hr>
<a name="Background"></a>
<div class="header">
<p>
Next: <a href="#Primitives" accesskey="n" rel="next">Primitives</a>, Previous: <a href="#Export-picture" accesskey="p" rel="prev">Export picture</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Fonovoe-izobrazhenie"></a>
<h3 class="section">4.6 Фоновое изображение</h3>

<a name="index-LoadBackground"></a>
<a name="index-Clf"></a>
<a name="index-Rasterize"></a>

<p>These functions change background image.
</p>
<a name="clf"></a><dl>
<dt><a name="index-clf"></a>Команда MGL: <em></em> <strong>clf</strong> <em>['col']</em></dt>
<dt><a name="index-clf-1"></a>Команда MGL: <em></em> <strong>clf</strong> <em>r g b</em></dt>
<dt><a name="index-Clf-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Clf</strong> <em>()</em></dt>
<dt><a name="index-Clf-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Clf</strong> <em>(<code>const char *</code> col)</em></dt>
<dt><a name="index-Clf-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Clf</strong> <em>(<code>char</code> col)</em></dt>
<dt><a name="index-Clf-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Clf</strong> <em>(<code>mreal</code> r, <code>mreal</code> g, <code>mreal</code> b)</em></dt>
<dt><a name="index-mgl_005fclf"></a>Функция С: <em><code>void</code></em> <strong>mgl_clf</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fclf_005fstr"></a>Функция С: <em><code>void</code></em> <strong>mgl_clf_str</strong> <em>(<code>HMGL</code> gr, <code>const char *</code> col)</em></dt>
<dt><a name="index-mgl_005fclf_005fchr"></a>Функция С: <em><code>void</code></em> <strong>mgl_clf_chr</strong> <em>(<code>HMGL</code> gr, <code>char</code> col)</em></dt>
<dt><a name="index-mgl_005fclf_005frgb"></a>Функция С: <em><code>void</code></em> <strong>mgl_clf_rgb</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> r, <code>mreal</code> g, <code>mreal</code> b)</em></dt>
<dd><p>Очищает рисунок и заполняет фон заданным цветом.
</p></dd></dl>

<a name="rasterize"></a><dl>
<dt><a name="index-rasterize"></a>Команда MGL: <em></em> <strong>rasterize</strong></dt>
<dt><a name="index-Rasterize-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Rasterize</strong> <em>()</em></dt>
<dt><a name="index-mgl_005frasterize"></a>Функция С: <em><code>void</code></em> <strong>mgl_rasterize</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Завершает рисование графика и помещает результат в качестве фона. После этого, очищает список примитивов (как <a href="#clf">clf</a>). Функция полезна для сохранения части графика (например, поверхностей или векторных полей) в растровом виде, а другой части (кривых, осей и пр.) в векторном.
</p></dd></dl>

<a name="background"></a><dl>
<dt><a name="index-background"></a>Команда MGL: <em></em> <strong>background</strong> <em>'fname' [<code>alpha=1</code>]</em></dt>
<dt><a name="index-LoadBackground-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>LoadBackground</strong> <em>(<code>const char *</code> fname, <code>double</code> alpha=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fload_005fbackground"></a>Функция С: <em><code>void</code></em> <strong>mgl_load_background</strong> <em>(<code>HMGL</code> gr, <code>const char *</code> fname, <code>double</code> alpha)</em></dt>
<dd><p>Загружает PNG или JPEG файл <var>fname</var> в качестве фона для графика. Параметр <var>alpha</var> задает прозрачность фона вручную.
</p></dd></dl>



<hr>
<a name="Primitives"></a>
<div class="header">
<p>
Next: <a href="#Text-printing" accesskey="n" rel="next">Text printing</a>, Previous: <a href="#Export-picture" accesskey="p" rel="prev">Export picture</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Risovanie-primitivov"></a>
<h3 class="section">4.7 Рисование примитивов</h3>

<a name="index-Ball"></a>
<a name="index-Line"></a>
<a name="index-Curve"></a>
<a name="index-Glyph"></a>
<a name="index-Face"></a>
<a name="index-FaceX"></a>
<a name="index-FaceY"></a>
<a name="index-FaceZ"></a>
<a name="index-Cone"></a>
<a name="index-Drop"></a>
<a name="index-Sphere"></a>

<a name="index-Mark"></a>
<a name="index-Error"></a>

<p>Эти функции рисуют рисуют простые объекты типа линий, точек, сфер, капель, конусов, и т.д.
</p>
<a name="ball"></a><dl>
<dt><a name="index-ball"></a>Команда MGL: <em></em> <strong>ball</strong> <em><code>x y</code> ['col'='r.']</em></dt>
<dt><a name="index-ball-1"></a>Команда MGL: <em></em> <strong>ball</strong> <em><code>x y z</code> ['col'='r.']</em></dt>
<dt><a name="index-Ball-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Ball</strong> <em>(<code>mglPoint</code> p, <code>char</code> col=<code>'r'</code>)</em></dt>
<dt><a name="index-Mark-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mark</strong> <em>(<code>mglPoint</code> p, <code>const char *</code>mark)</em></dt>
<dt><a name="index-mgl_005fmark"></a>Функция С: <em><code>void</code></em> <strong>mgl_mark</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>const char *</code>mark)</em></dt>
<dd><p>Рисует маркер (точку по умолчанию) с координатами <var>p</var>={<var>x</var>, <var>y</var>, <var>z</var>} и цветом <var>col</var>.
</p></dd></dl>

<a name="errbox"></a><dl>
<dt><a name="index-errbox"></a>Команда MGL: <em></em> <strong>errbox</strong> <em><code>x y ex ey</code> ['stl'='']</em></dt>
<dt><a name="index-errbox-1"></a>Команда MGL: <em></em> <strong>errbox</strong> <em><code>x y z ex ey ez</code> ['stl'='']</em></dt>
<dt><a name="index-Error-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Error</strong> <em>(<code>mglPoint</code> p, <code>mglPoint</code> e, <code>char</code> *stl=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ferror_005fbox"></a>Функция С: <em><code>void</code></em> <strong>mgl_error_box</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> px, <code>mreal</code> py, <code>mreal</code> pz, <code>mreal</code> ex, <code>mreal</code> ey, <code>mreal</code> ez, <code>char *</code>stl)</em></dt>
<dd><p>Рисует 3d error box в точке <var>p</var>={<var>x</var>, <var>y</var>, <var>z</var>} размером <var>e</var>={<var>ex</var>, <var>ey</var>, <var>ez</var>} и стилем <var>stl</var>. Используйте NAN в компонентах <var>e</var> для уменьшения рисуемых элементов.
</p></dd></dl>

<a name="line"></a><dl>
<dt><a name="index-line"></a>Команда MGL: <em></em> <strong>line</strong> <em><code>x1 y1 x2 y2</code> ['stl'='']</em></dt>
<dt><a name="index-line-1"></a>Команда MGL: <em></em> <strong>line</strong> <em><code>x1 y1 z1 x2 y2 z2</code> ['stl'='']</em></dt>
<dt><a name="index-Line-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Line</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>char *</code>stl=<code>&quot;B&quot;</code>, <code>int</code>num=<code>2</code>)</em></dt>
<dt><a name="index-mgl_005fline"></a>Функция С: <em><code>void</code></em> <strong>mgl_line</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>char *</code>stl, <code>int</code>num)</em></dt>
<dd><p>Рисует геодезическую линию (декартовых координатах &ndash; прямую) из точки <var>p1</var> в <var>p2</var> использую стиль линии <var>stl</var>. Параметр <var>num</var> определяет гладкость линии (число точек на линии). Если <var>num</var>=<code>2</code>, то рисуется прямая даже в криволинейных координатах (см. <a href="#Curved-coordinates">Curved coordinates</a>). Наоборот, для больших значений (например, =<code>100</code>) рисуется геодезическая линия (окружность в полярных координатах, парабола в параболических и т.д.). Линия рисуется даже если часть ее лежит вне диапазона осей координат.
</p></dd></dl>

<a name="curve"></a><dl>
<dt><a name="index-curve"></a>Команда MGL: <em></em> <strong>curve</strong> <em><code>x1 y1 dx1 dy1 x2 y2 dx2 dy2</code> ['stl'='']</em></dt>
<dt><a name="index-curve-1"></a>Команда MGL: <em></em> <strong>curve</strong> <em><code>x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2</code> ['stl'='']</em></dt>
<dt><a name="index-Curve-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Curve</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> d1, <code>mglPoint</code> p2, <code>mglPoint</code> d2, <code>const char *</code>stl=<code>&quot;B&quot;</code>, <code>int</code> num=<code>100</code>)</em></dt>
<dt><a name="index-mgl_005fcurve"></a>Функция С: <em><code>void</code></em> <strong>mgl_curve</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> dx1, <code>mreal</code> dy1, <code>mreal</code> dz1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> dx2, <code>mreal</code> dy2, <code>mreal</code> dz2, <code>const char *</code>stl, <code>int</code> num)</em></dt>
<dd><p>Рисует кривую Безье из точки <var>p1</var> в <var>p2</var> используя стиль линии <var>stl</var>. Касательные в точках пропорциональны <var>d1</var>, <var>d2</var>. Параметр <var>num</var> определяет гладкость линии (число точек на линии). Если <var>num</var>=<code>2</code>, то рисуется прямая даже в криволинейных координатах (см. <a href="#Curved-coordinates">Curved coordinates</a>). Наоборот, для больших значений (например, =<code>100</code>) рисуется геодезическая линия (окружность в полярных координатах, парабола в параболических и т.д.). Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
</p></dd></dl>

<a name="face"></a><dl>
<dt><a name="index-face"></a>Команда MGL: <em></em> <strong>face</strong> <em><code>x1 y1 x2 y2 x3 y3 x4 y4</code> ['stl'='']</em></dt>
<dt><a name="index-face-1"></a>Команда MGL: <em></em> <strong>face</strong> <em><code>x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4</code> ['stl'='']</em></dt>
<dt><a name="index-Face-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Face</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>mglPoint</code> p3, <code>mglPoint</code> p4, <code>const char *</code>stl=<code>&quot;w&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fface"></a>Функция С: <em><code>void</code></em> <strong>mgl_face</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> x3, <code>mreal</code> y3, <code>mreal</code> z3, <code>mreal</code> x4, <code>mreal</code> y4, <code>mreal</code> z4, <code>const char *</code>stl)</em></dt>
<dd><p>Рисует заполненный четырехугольник (грань) с углами в точках <var>p1</var>, <var>p2</var>, <var>p3</var>, <var>p4</var> и цветом(-ами) <var>stl</var>. При этом цвет может быть один для всей грани, или различным если указаны все 4 цвета. Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
</p></dd></dl>

<a name="rect"></a><dl>
<dt><a name="index-rect"></a>Команда MGL: <em></em> <strong>rect</strong> <em><code>x1 y1 x2 y2</code> ['stl'='']</em></dt>
<dt><a name="index-rect-1"></a>Команда MGL: <em></em> <strong>rect</strong> <em><code>x1 y1 z1 x2 y2 z2</code> ['stl'='']</em></dt>
<dd><p>Рисует закрашенный прямоугольник (грань) с вершинами {<var>x1</var>, <var>y1</var>, <var>z1</var>} и {<var>x2</var>, <var>y2</var>, <var>z2</var>} цветом <var>stl</var>. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета. Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
</p></dd></dl>

<a name="facex"></a><a name="facey"></a><a name="facez"></a><dl>
<dt><a name="index-facex"></a>Команда MGL: <em></em> <strong>facex</strong> <em><code>x0 y0 z0 wy wz</code> ['stl'='' <code>d1=0 d2=0</code>]</em></dt>
<dt><a name="index-facey"></a>Команда MGL: <em></em> <strong>facey</strong> <em><code>x0 y0 z0 wx wz</code> ['stl'='' <code>d1=0 d2=0</code>]</em></dt>
<dt><a name="index-facez"></a>Команда MGL: <em></em> <strong>facez</strong> <em><code>x0 y0 z0 wx wy</code> ['stl'='' <code>d1=0 d2=0</code>]</em></dt>
<dt><a name="index-FaceX-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FaceX</strong> <em>(<code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wy, <code>mreal</code> wz, <code>const char *</code>stl=<code>&quot;w&quot;</code>, <code>mreal</code> d1=<code>0</code>, <code>mreal</code> d2=<code>0</code>)</em></dt>
<dt><a name="index-FaceY-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FaceY</strong> <em>(<code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wx, <code>mreal</code> wz, <code>const char *</code>stl=<code>&quot;w&quot;</code>, <code>mreal</code> d1=<code>0</code>, <code>mreal</code> d2=<code>0</code>)</em></dt>
<dt><a name="index-FaceZ-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FaceZ</strong> <em>(<code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wx, <code>mreal</code> wy, <code>const char *</code>stl=<code>&quot;w&quot;</code>, <code>mreal</code> d1=<code>0</code>, <code>mreal</code> d2=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005ffacex"></a>Функция С: <em><code>void</code></em> <strong>mgl_facex</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wy, <code>mreal</code> wz, <code>const char *</code>stl, <code>mreal</code> d1, <code>mreal</code> d2)</em></dt>
<dt><a name="index-mgl_005ffacey"></a>Функция С: <em><code>void</code></em> <strong>mgl_facey</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wx, <code>mreal</code> wz, <code>const char *</code>stl, <code>mreal</code> d1, <code>mreal</code> d2)</em></dt>
<dt><a name="index-mgl_005ffacez"></a>Функция С: <em><code>void</code></em> <strong>mgl_facez</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> wx, <code>mreal</code> wy, <code>const char *</code>stl, <code>mreal</code> d1, <code>mreal</code> d2)</em></dt>
<dd><p>Рисует закрашенный прямоугольник (грань) перпендикулярно оси [x,y,z] в точке {<var>x0</var>, <var>y0</var>, <var>z0</var>} цветом <var>stl</var> и шириной <var>wx</var>, <var>wy</var>, <var>wz</var> вдоль соответствующего направления. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета. Параметры <var>d1</var>!=0, <var>d2</var>!=0 задают дополнительный сдвиг последней точки (т.е. рисуют четырехугольник). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
</p></dd></dl>

<a name="sphere"></a><dl>
<dt><a name="index-sphere"></a>Команда MGL: <em></em> <strong>sphere</strong> <em><code>x0 y0 r</code> ['col'='r']</em></dt>
<dt><a name="index-sphere-1"></a>Команда MGL: <em></em> <strong>sphere</strong> <em><code>x0 y0 z0 r</code> ['col'='r']</em></dt>
<dt><a name="index-Sphere-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Sphere</strong> <em>(<code>mglPoint</code> p, <code>mreal</code> r, <code>const char *</code>stl=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsphere"></a>Функция С: <em><code>void</code></em> <strong>mgl_sphere</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> r, <code>const char *</code>stl)</em></dt>
<dd><p>Рисует сферу радиуса <var>r</var> с центром в точке <var>p</var>={<var>x0</var>, <var>y0</var>, <var>z0</var>} цветом <var>stl</var>.
</p></dd></dl>

<a name="drop"></a><dl>
<dt><a name="index-drop"></a>Команда MGL: <em></em> <strong>drop</strong> <em><code>x0 y0 dx dy r</code> ['col'='r' <code>sh=1 asp=1</code>]</em></dt>
<dt><a name="index-drop-1"></a>Команда MGL: <em></em> <strong>drop</strong> <em><code>x0 y0 z0 dx dy dz r</code> ['col'='r' <code>sh=1 asp=1</code>]</em></dt>
<dt><a name="index-Drop-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Drop</strong> <em>(<code>mglPoint</code> p, <code>mglPoint</code> d, <code>mreal</code> r, <code>const char *</code>col=<code>&quot;r&quot;</code>, <code>mreal</code> shift=<code>1</code>, <code>mreal</code> ap=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdrop"></a>Функция С: <em><code>void</code></em> <strong>mgl_drop</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>mreal</code> r, <code>const char *</code>col, <code>mreal</code> shift, <code>mreal</code> ap)</em></dt>
<dd><p>Рисует каплю радиуса <var>r</var> в точке <var>p</var> вытянутую вдоль направления <var>d</var> цветом <var>col</var>. Параметр <var>shift</var> определяет степень вытянутости: &lsquo;<samp>0</samp>&rsquo; &ndash; сфера, &lsquo;<samp>1</samp>&rsquo; &ndash; классическая капля. Параметр <var>ap</var> определяет относительную ширину капли (аналог &quot;эллиптичности&quot; для сферы).
</p></dd></dl>

<a name="cone"></a><dl>
<dt><a name="index-cone"></a>Команда MGL: <em></em> <strong>cone</strong> <em><code>x1 y1 z1 x2 y2 z2 r1</code> [<code>r2=-1</code> 'stl'='' <code>edge=off</code>]</em></dt>
<dt><a name="index-Cone-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cone</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>mreal</code> r1, <code>mreal</code> r2=<code>-1</code>, <code>const char *</code>stl=<code>&quot;B&quot;</code>, <code>bool</code> edge=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fcone"></a>Функция С: <em><code>void</code></em> <strong>mgl_cone</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> r1, <code>mreal</code> r2, <code>const char *</code>stl, <code>int</code> draw_edge)</em></dt>
<dd><p>Рисует трубу (или усеченный конус если <var>edge</var>=<code>false</code>) между точками <var>p1</var>, <var>p2</var> с радиусами на концах <var>r1</var>, <var>r2</var>. Если <var>r2</var>&lt;0, то полагается <var>r2</var>=<var>r1</var>. Цвет конуса задается строкой <var>stl</var>. Параметр <var>stl</var> может содержать:
</p><ul>
<li> &lsquo;<samp>@</samp>&rsquo; для рисования торцов;
</li><li> &lsquo;<samp>#</samp>&rsquo; для сетчатой фигуры;
</li><li> &lsquo;<samp>t</samp>&rsquo; для рисования цилиндра вместо конуса/призмы;
</li><li> &lsquo;<samp>4</samp>&rsquo;, &lsquo;<samp>6</samp>&rsquo;, &lsquo;<samp>8</samp>&rsquo; для рисования квадратной, шестиугольной или восьмиугольной призмы вместо конуса.
</li></ul>

</dd></dl>

<a name="circle"></a><dl>
<dt><a name="index-circle"></a>Команда MGL: <em></em> <strong>circle</strong> <em><code>x0 y0 r</code> ['col'='r']</em></dt>
<dt><a name="index-circle-1"></a>Команда MGL: <em></em> <strong>circle</strong> <em><code>x0 y0 z0 r</code> ['col'='r']</em></dt>
<dt><a name="index-Circle"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Circle</strong> <em>(<code>mglPoint</code> p, <code>mreal</code> r, <code>const char *</code>stl=<code>&quot;r&quot;</code>)</em></dt>
<dd><p>Рисует круг радиуса <var>r</var> с центром в точке <var>p</var>={<var>x0</var>, <var>y0</var>, <var>z0</var>} цветом <var>stl</var>. Если <var>col</var> содержит: &lsquo;<samp>#</samp>&rsquo; то рисуется только граница, &lsquo;<samp>@</samp>&rsquo; то рисуется граница (вторым цветом из <var>col</var> или черными).
</p></dd></dl>

<a name="ellipse"></a><dl>
<dt><a name="index-ellipse"></a>Команда MGL: <em></em> <strong>ellipse</strong> <em><code>x1 y1 x2 y2 r</code> ['col'='r']</em></dt>
<dt><a name="index-ellipse-1"></a>Команда MGL: <em></em> <strong>ellipse</strong> <em><code>x1 y1 z1 x2 y2 z2 r</code> ['col'='r']</em></dt>
<dt><a name="index-Ellipse"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Ellipse</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>mreal</code> r, <code>const char *</code>col=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fellipse"></a>Функция С: <em><code>void</code></em> <strong>mgl_ellipse</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> r, <code>const char *</code>col)</em></dt>
<dd><p>Рисует эллипс радиуса <var>r</var> с фокусами в точках <var>p1</var>, <var>p2</var> цветом <var>stl</var>. Если <var>col</var> содержит: &lsquo;<samp>#</samp>&rsquo; то рисуется только граница, &lsquo;<samp>@</samp>&rsquo; то рисуется граница (вторым цветом из <var>col</var> или черными).
</p></dd></dl>

<a name="rhomb"></a><dl>
<dt><a name="index-rhomb"></a>Команда MGL: <em></em> <strong>rhomb</strong> <em><code>x1 y1 x2 y2 r</code> ['col'='r']</em></dt>
<dt><a name="index-rhomb-1"></a>Команда MGL: <em></em> <strong>rhomb</strong> <em><code>x1 y1 z1 x2 y2 z2 r</code> ['col'='r']</em></dt>
<dt><a name="index-Rhomb"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Rhomb</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>mreal</code> r, <code>const char *</code>col=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-mgl_005frhomb"></a>Функция С: <em><code>void</code></em> <strong>mgl_rhomb</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> x2, <code>mreal</code> y2, <code>mreal</code> z2, <code>mreal</code> r, <code>const char *</code>col)</em></dt>
<dd><p>Рисует ромб ширины <var>r</var> с вершинами в точках <var>p1</var>, <var>p2</var> цветом <var>stl</var>. Если <var>col</var> содержит: &lsquo;<samp>#</samp>&rsquo; то рисуется только граница, &lsquo;<samp>@</samp>&rsquo; то рисуется граница (вторым цветом из <var>col</var> или черными). Если <var>col</var> содержит 3 цвета, то используется градиентная заливка.
</p></dd></dl>

<a name="arc"></a><dl>
<dt><a name="index-arc"></a>Команда MGL: <em></em> <strong>arc</strong> <em><code>x0 y0 x1 y1 a</code> ['col'='r']</em></dt>
<dt><a name="index-arc-1"></a>Команда MGL: <em></em> <strong>arc</strong> <em><code>x0 y0 z0 x1 y1 a</code> ['col'='r']</em></dt>
<dt><a name="index-arc-2"></a>Команда MGL: <em></em> <strong>arc</strong> <em><code>x0 y0 z0 xa ya za x1 y1 z1 a</code> ['col'='r']</em></dt>
<dt><a name="index-Arc"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Arc</strong> <em>(<code>mglPoint</code> p0, <code>mglPoint</code> p1, <code>mreal</code> a, <code>const char *</code>col=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-Arc-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Arc</strong> <em>(<code>mglPoint</code> p0, <code>mglPoint</code> pa, <code>mglPoint</code> p1, <code>mreal</code> a, <code>const char *</code>col=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-mgl_005farc"></a>Функция С: <em><code>void</code></em> <strong>mgl_arc</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> a, <code>const char *</code>col)</em></dt>
<dt><a name="index-mgl_005farc_005fext"></a>Функция С: <em><code>void</code></em> <strong>mgl_arc_ext</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> xa, <code>mreal</code> ya, <code>mreal</code> za, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>mreal</code> a, <code>const char *</code>col)</em></dt>
<dd><p>Рисует дугу вокруг оси <var>pa</var> (по умолчанию вокруг оси z <var>pa</var>={0,0,1}) с центром в <var>p0</var>, начиная с точки <var>p1</var>. Параметр <var>a</var> задает угол дуги в градусах. Строка <var>col</var> задает цвет дуги и тип стрелок на краях.
</p></dd></dl>

<a name="polygon"></a><dl>
<dt><a name="index-polygon"></a>Команда MGL: <em></em> <strong>polygon</strong> <em><code>x0 y0 x1 y1 num</code> ['col'='r']</em></dt>
<dt><a name="index-polygon-1"></a>Команда MGL: <em></em> <strong>polygon</strong> <em><code>x0 y0 z0 x1 y1 z1 num</code> ['col'='r']</em></dt>
<dt><a name="index-Polygon"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Polygon</strong> <em>(<code>mglPoint</code> p0, <code>mglPoint</code> p1, <code>int</code> num, <code>const char *</code>col=<code>&quot;r&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpolygon"></a>Функция С: <em><code>void</code></em> <strong>mgl_polygon</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> x1, <code>mreal</code> y1, <code>mreal</code> z1, <code>int</code> num, <code>const char *</code>col)</em></dt>
<dd><p>Рисует правильный <var>num</var>-угольник с центром в <var>p0</var> с первой вершиной в <var>p1</var> цветом <var>col</var>. Если <var>col</var> содержит: &lsquo;<samp>#</samp>&rsquo; то рисуется только граница, &lsquo;<samp>@</samp>&rsquo; то рисуется граница (вторым цветом из <var>col</var> или черными).
</p></dd></dl>

<a name="logo"></a><dl>
<dt><a name="index-logo"></a>Команда MGL: <em></em> <strong>logo</strong> <em>'fname' [smooth=off]</em></dt>
<dt><a name="index-Logo"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Logo</strong> <em>(<code>const char *</code>fname, <code>bool</code> smooth=<code>false</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Logo-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Logo</strong> <em>(<code>long</code> w, <code>long</code> h, <code>const unsigned char *</code>rgba, <code>bool</code> smooth=<code>false</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flogo"></a>Функция С: <em><code>void</code></em> <strong>mgl_logo</strong> <em>(<code>HMGL</code> gr, <code>long</code> w, <code>long</code> h, <code>const unsigned char *</code>rgba, <code>bool</code> smooth, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flogo_005ffile"></a>Функция С: <em><code>void</code></em> <strong>mgl_logo_file</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>fname, <code>bool</code> smooth, <code>const char *</code>opt)</em></dt>
<dd><p>Draw bitmap (logo) along whole axis range, which can be changed by <a href="#Command-options">Command options</a>. Bitmap can be loaded from file or specified as RGBA values for pixels. Parameter <var>smooth</var> set to draw bitmap without or with color interpolation.
</p></dd></dl>



<a name="symbol"></a><dl>
<dt><a name="index-symbol"></a>Команда MGL: <em></em> <strong>symbol</strong> <em><code>x y</code> 'id' ['fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-symbol-1"></a>Команда MGL: <em></em> <strong>symbol</strong> <em><code>x y z</code> 'id' ['fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-Symbol"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Symbol</strong> <em>(<code>mglPoint</code> p, <code>char</code> id, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fsymbol"></a>Функция С: <em><code>void</code></em> <strong>mgl_symbol</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>char</code> id, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dd><p>Рисует определенный пользователем символ с именем <var>id</var> в точке <var>p</var> стилем <var>fnt</var>. Размер задается параметром <var>size</var> (по умолчанию <code>-1</code>). Строка <var>fnt</var>  может содержать цвет (до разделителя &lsquo;<samp>:</samp>&rsquo;); стили &lsquo;<samp>a</samp>&rsquo; или &lsquo;<samp>A</samp>&rsquo; для вывода в абсолютной позиции ({<var>x</var>, <var>y</var>} полагаются в диапазоне [0,1]) относительно рисунка (для &lsquo;<samp>A</samp>&rsquo;) или subplot/inplot (для &lsquo;<samp>a</samp>&rsquo;); и стиль &lsquo;<samp>w</samp>&rsquo; для рисования только контура символа.
</p></dd></dl>

<dl>
<dt><a name="index-symbol-2"></a>Команда MGL: <em></em> <strong>symbol</strong> <em><code>x y dx dy</code> 'id' ['fnt'=':L' <code>size=-1</code>]</em></dt>
<dt><a name="index-symbol-3"></a>Команда MGL: <em></em> <strong>symbol</strong> <em><code>x y z dx dy dz</code> 'id' ['fnt'=':L' <code>size=-1</code>]</em></dt>
<dt><a name="index-Symbol-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Symbol</strong> <em>(<code>mglPoint</code> p, <code>mglPoint</code> d, <code>char</code> id, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fsymbol_005fdir"></a>Функция С: <em><code>void</code></em> <strong>mgl_symbol_dir</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>const char *</code>text, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dd><p>Аналогично предыдущему, но символ рисуется в повернутым в направлении <var>d</var>.
</p></dd></dl>

<a name="addsymbol"></a><dl>
<dt><a name="index-addsymbol"></a>Команда MGL: <em></em> <strong>addsymbol</strong> <em>'id' xdat ydat</em></dt>
<dt><a name="index-DefineSymbol"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DefineSymbol</strong> <em>(<code>char</code> id, <code>const mglDataA &amp;</code>xdat, <code>const mglDataA &amp;</code>ydat)</em></dt>
<dt><a name="index-mgl_005fdefine_005fsymbol"></a>Функция С: <em><code>void</code></em> <strong>mgl_define_symbol</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> xdat, <code>HCDT</code> ydat)</em></dt>
<dd><p>Добавляет определенный пользователем символ с именем <var>id</var> и границей {<var>xdat</var>, <var>ydat</var>}. Значения <code>NAN</code> задают разрыв (скачок) граничной кривой.
</p></dd></dl>



<hr>
<a name="Text-printing"></a>
<div class="header">
<p>
Next: <a href="#Axis-and-Colorbar" accesskey="n" rel="next">Axis and Colorbar</a>, Previous: <a href="#Primitives" accesskey="p" rel="prev">Primitives</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Vyvod-teksta"></a>
<h3 class="section">4.8 Вывод текста</h3>

<a name="index-Puts"></a>
<a name="index-Putsw"></a>
<a name="index-Text"></a>
<a name="index-fgets"></a>

<p>Функции для вывода текста позволяют вывести строку текста в произвольном месте рисунка, в произвольном направлении и вдоль произвольной кривой. MathGL позволяет использовать произвольное начертание шрифта и многие ТеХ-ие команды (детальнее см. <a href="#Font-styles">Font styles</a>). Все функции вывода текста имеют варианты для 8-bit строк (<code>char *</code>) и для Unicode строк (<code>wchar_t *</code>). В первом случае используется конверсия из текущей локали, т.е. иногда вам требуется явно указать локаль с помощью функции <code>setlocale()</code>. Аргумент <var>size</var> определяет размер текста: размер шрифта если положителен или относительный размер (=-<var>size</var>*<code>SetFontSize()</code>) если отрицателен. Начертание шрифта (STIX, arial, courier, times и др.) можно изменить с помощью функции LoadFont(). See <a href="#Font-settings">Font settings</a>.
</p>
<p>Параметры шрифта задаются строкой, которая может содержать символы цвета &lsquo;<samp>wkrgbcymhRGBCYMHW</samp>&rsquo; (см. <a href="#Color-styles">Color styles</a>). Также после символа &lsquo;<samp>:</samp>&rsquo; можно указать  символы стиля (&lsquo;<samp>rbiwou</samp>&rsquo;) и/или выравнивания (&lsquo;<samp>LRCTV</samp>&rsquo;). Стили шрифта: &lsquo;<samp>r</samp>&rsquo; &ndash; прямой, &lsquo;<samp>i</samp>&rsquo; &ndash; курсив, &lsquo;<samp>b</samp>&rsquo; &ndash; жирный, &lsquo;<samp>w</samp>&rsquo; &ndash; контурный, &lsquo;<samp>o</samp>&rsquo; &ndash; надчеркнутый, &lsquo;<samp>u</samp>&rsquo; &ndash; подчеркнутый. По умолчанию используется прямой шрифт. Типы выравнивания: &lsquo;<samp>L</samp>&rsquo; &ndash; по левому краю (по умолчанию), &lsquo;<samp>C</samp>&rsquo; &ndash; по центру, &lsquo;<samp>R</samp>&rsquo; &ndash; по правому краю, &lsquo;<samp>T</samp>&rsquo; &ndash; под текстом, &lsquo;<samp>V</samp>&rsquo; &ndash; по центру вертикально. Например, строка &lsquo;<samp>b:iC</samp>&rsquo; соответствует курсиву синего цвета с выравниванием по центру. Начиная с MathGL версии 2.3, вы можете задать цветовой градиент для выводимой строки (см. <a href="#Color-scheme">Color scheme</a>).
</p>
<p>Если строка содержит символы &lsquo;<samp>aA</samp>&rsquo;, то текст выводится в абсолютных координатах (полагаются в диапазоне [0,1]). При этом используются координаты относительно рисунка (если указано &lsquo;<samp>A</samp>&rsquo;) или относительно последнего subplot/inplot (если указано &lsquo;<samp>a</samp>&rsquo;). Если строка содержит символ &lsquo;<samp>@</samp>&rsquo;, то вокруг текста рисуется прямоугольник.
</p>
<p>См. раздел <a href="#Text-features">Text features</a>, для примеров кода и графика.
</p>
<a name="text"></a><dl>
<dt><a name="index-text"></a>Команда MGL: <em></em> <strong>text</strong> <em><code>x y</code> 'text' ['fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-text-1"></a>Команда MGL: <em></em> <strong>text</strong> <em><code>x y z</code> 'text' ['fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-Puts-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Puts</strong> <em>(<code>mglPoint</code> p, <code>const char *</code>text, <code>const char *</code>fnt=<code>&quot;:C&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-Putsw-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Putsw</strong> <em>(<code>mglPoint</code> p, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>&quot;:C&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-Puts-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Puts</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>const char *</code>text, <code>const char *</code>fnt=<code>&quot;:AC&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-Putsw-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Putsw</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>&quot;:AC&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fputs"></a>Функция С: <em><code>void</code></em> <strong>mgl_puts</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>const char *</code>text, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dt><a name="index-mgl_005fputsw"></a>Функция С: <em><code>void</code></em> <strong>mgl_putsw</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>const wchar_t *</code>text, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dd><p>Выводит строку <var>text</var> от точки <var>p</var> шрифтом определяемым строкой <var>fnt</var>. Размер шрифта задается параметром <var>size</var> (по умолчанию <code>-1</code>).
</p></dd></dl>

<dl>
<dt><a name="index-text-2"></a>Команда MGL: <em></em> <strong>text</strong> <em><code>x y dx dy</code> 'text' ['fnt'=':L' <code>size=-1</code>]</em></dt>
<dt><a name="index-text-3"></a>Команда MGL: <em></em> <strong>text</strong> <em><code>x y z dx dy dz</code> 'text' ['fnt'=':L' <code>size=-1</code>]</em></dt>
<dt><a name="index-Puts-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Puts</strong> <em>(<code>mglPoint</code> p, <code>mglPoint</code> d, <code>const char *</code>text, <code>const char *</code>fnt=<code>':L'</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-Putsw-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Putsw</strong> <em>(<code>mglPoint</code> p, <code>mglPoint</code> d, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>':L'</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fputs_005fdir"></a>Функция С: <em><code>void</code></em> <strong>mgl_puts_dir</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>const char *</code>text, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dt><a name="index-mgl_005fputsw_005fdir"></a>Функция С: <em><code>void</code></em> <strong>mgl_putsw_dir</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>mreal</code> dx, <code>mreal</code> dy, <code>mreal</code> dz, <code>const wchar_t *</code>text, <code>const char *</code>fnt, <code>mreal</code> size)</em></dt>
<dd><p>Выводит строку <var>text</var> от точки <var>p</var> вдоль направления <var>d</var>. Параметр <var>fnt</var> задает стиль текста и указывает выводить текст под линией (&lsquo;<samp>T</samp>&rsquo;) или над ней (&lsquo;<samp>t</samp>&rsquo;).
</p></dd></dl>

<a name="fgets"></a><dl>
<dt><a name="index-fgets-1"></a>Команда MGL: <em></em> <strong>fgets</strong> <em><code>x y</code> 'fname' [<code>n=0</code> 'fnt'='' <code>size=-1.4</code>]</em></dt>
<dt><a name="index-fgets-2"></a>Команда MGL: <em></em> <strong>fgets</strong> <em><code>x y z</code> 'fname' [<code>n=0</code> 'fnt'='' <code>size=-1.4</code>]</em></dt>
<dd><p>Выводит <var>n</var>-ую строку файла <var>fname</var> от точки {<var>x</var>,<var>y</var>,<var>z</var>} шрифтом <var>fnt</var> и размером <var>size</var>. По умолчанию используются параметры заданные командой <a href="#font">font</a>.
</p></dd></dl>

<dl>
<dt><a name="index-text-4"></a>Команда MGL: <em></em> <strong>text</strong> <em>ydat 'text' ['fnt'='']</em></dt>
<dt><a name="index-text-5"></a>Команда MGL: <em></em> <strong>text</strong> <em>xdat ydat 'text' ['fnt'='' <code>size=-1 zval=nan</code>]</em></dt>
<dt><a name="index-text-6"></a>Команда MGL: <em></em> <strong>text</strong> <em>xdat ydat zdat 'text' ['fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-Text-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Text-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Text-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Text-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Text-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Text-6"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Text</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const wchar_t *</code>text, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftext_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_text_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextw_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_textw_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const wchar_t *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftext_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_text_xy</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextw_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_textw_xy</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>const wchar_t *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftext_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_text_xyz</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextw_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_textw_xyz</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const wchar_t *</code>text, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Выводит строку <var>text</var> вдоль кривой {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]} шрифтом <var>fnt</var>. Строка <var>fnt</var> может содержать символы: &lsquo;<samp>t</samp>&rsquo; для вывода текста под кривой (по умолчанию), или &lsquo;<samp>T</samp>&rsquo; для вывода текста под кривой. Размеры по 1-ой размерности должны быть одинаковы для всех массивов <code>x.nx=y.nx=z.nx</code>. Если массив <var>x</var> не указан, то используется &quot;автоматический&quot; массив со значениями в диапазоне осей координат (см. <a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a>). Если массив <var>z</var> не указан, то используется минимальное значение оси z. Строка <var>opt</var> содержит опции команды (см. <a href="#Command-options">Command options</a>).
</p></dd></dl>


<hr>
<a name="Axis-and-Colorbar"></a>
<div class="header">
<p>
Next: <a href="#Legend" accesskey="n" rel="next">Legend</a>, Previous: <a href="#Text-printing" accesskey="p" rel="prev">Text printing</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osi-i-Colorbar"></a>
<h3 class="section">4.9 Оси и Colorbar</h3>

<a name="index-Axis-1"></a>
<a name="index-Box"></a>
<a name="index-Grid"></a>
<a name="index-Colorbar"></a>
<a name="index-Label"></a>

<p>Эти функции рисуют объекты для &quot;измерения&quot; типа осей координат, цветовой таблицы (colorbar), сетку по осям, обрамляющий параллелепипед и подписи по осям координат. См. также см. <a href="#Axis-settings">Axis settings</a>.
</p>
<a name="axis"></a><dl>
<dt><a name="index-axis-2"></a>Команда MGL: <em></em> <strong>axis</strong> <em>['dir'='xyz' 'stl'='']</em></dt>
<dt><a name="index-Axis-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Axis</strong> <em>(<code>const char *</code>dir=<code>&quot;xyz&quot;</code>, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005faxis"></a>Функция С: <em><code>void</code></em> <strong>mgl_axis</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>dir, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует оси координат и метки на них (см. <a href="#Axis-settings">Axis settings</a>) в направлениях &lsquo;<samp>xyz</samp>&rsquo;, указанных строкой <var>dir</var>. Строка <var>dir</var> может содержать:
</p><ul>
<li> &lsquo;<samp>xyz</samp>&rsquo; для рисования соответствующих осей;
</li><li> &lsquo;<samp>XYZ</samp>&rsquo; для рисования соответствующих осей с метками с другой стороны;
</li><li> &lsquo;<samp>~</samp>&rsquo; или &lsquo;<samp>_</samp>&rsquo; для осей без подписей;
</li><li> &lsquo;<samp>U</samp>&rsquo; для невращаемых подписей;
</li><li> &lsquo;<samp>^</samp>&rsquo; для инвертирования положения по умолчанию;
</li><li> &lsquo;<samp>!</samp>&rsquo; для отключения улучшения вида меток (см. <a href="#tuneticks">tuneticks</a>);
</li><li> &lsquo;<samp>AKDTVISO</samp>&rsquo; для вывода стрелки на конце оси;
</li><li> &lsquo;<samp>a</samp>&rsquo; для принудительной автоматической расстановки меток;
</li><li> &lsquo;<samp>:</samp>&rsquo; для рисования линий через точку (0,0,0);
</li><li> &lsquo;<samp>f</samp>&rsquo; для вывода чисел в фиксированном формате;
</li><li> &lsquo;<samp>E</samp>&rsquo; для вывода &lsquo;<samp>E</samp>&rsquo; вместо &lsquo;<samp>e</samp>&rsquo;;
</li><li> &lsquo;<samp>F</samp>&rsquo; для вывода в формате LaTeX;
</li><li> &lsquo;<samp>+</samp>&rsquo; для вывода &lsquo;<samp>+</samp>&rsquo; для положительных чисел;
</li><li> &lsquo;<samp>-</samp>&rsquo; для вывода обычного &lsquo;<samp>-</samp>&rsquo;;
</li><li> &lsquo;<samp>0123456789</samp>&rsquo; для задания точности при выводе чисел.
</li></ul>
<p>Стиль меток и оси(ей) задается строкой <var>stl</var>. Опция <code>value</code> задает угол вращения меток оси. См. раздел <a href="#Axis-and-ticks">Axis and ticks</a>, для примеров кода и графика.
</p></dd></dl>

<a name="colorbar"></a><dl>
<dt><a name="index-colorbar"></a>Команда MGL: <em></em> <strong>colorbar</strong> <em>['sch'='']</em></dt>
<dt><a name="index-Colorbar-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Colorbar</strong> <em>(<code>const char *</code>sch=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcolorbar"></a>Функция С: <em><code>void</code></em> <strong>mgl_colorbar</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>sch)</em></dt>
<dd><p>Рисует полосу соответствия цвета и числовых значений (colorbar) для цветовой схемы <var>sch</var> (используется текущая для <code>sch=&quot;&quot;</code>) с краю от графика. Строка <var>sch</var> также может содержать:
</p><ul>
<li> &lsquo;<samp>&lt;&gt;^_</samp>&rsquo; для расположения слева, справа, сверху или снизу соответственно;
</li><li> &lsquo;<samp>I</samp>&rsquo; для расположения около осей (по умолчанию, на краях subplot);
</li><li> &lsquo;<samp>A</samp>&rsquo; для использования абсолютных координат (относительно рисунка);
</li><li> &lsquo;<samp>~</samp>&rsquo; для colorbar без подписей;
</li><li> &lsquo;<samp>!</samp>&rsquo; для отключения улучшения вида меток (см. <a href="#tuneticks">tuneticks</a>);
</li><li> &lsquo;<samp>a</samp>&rsquo; для принудительной автоматической расстановки меток;
</li><li> &lsquo;<samp>f</samp>&rsquo; для вывода чисел в фиксированном формате;
</li><li> &lsquo;<samp>E</samp>&rsquo; для вывода &lsquo;<samp>E</samp>&rsquo; вместо &lsquo;<samp>e</samp>&rsquo;;
</li><li> &lsquo;<samp>F</samp>&rsquo; для вывода в формате LaTeX;
</li><li> &lsquo;<samp>+</samp>&rsquo; для вывода &lsquo;<samp>+</samp>&rsquo; для положительных чисел;
</li><li> &lsquo;<samp>-</samp>&rsquo; для вывода обычного &lsquo;<samp>-</samp>&rsquo;;
</li><li> &lsquo;<samp>0123456789</samp>&rsquo; для задания точности при выводе чисел.
</li></ul>
<p>См. раздел <a href="#Colorbars">Colorbars</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-colorbar-1"></a>Команда MGL: <em></em> <strong>colorbar</strong> <em>vdat ['sch'='']</em></dt>
<dt><a name="index-Colorbar-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Colorbar</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const char *</code>sch=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcolorbar_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_colorbar_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>const char *</code>sch)</em></dt>
<dd><p>Аналогично предыдущему, но для цветовой схемы без сглаживания с заданными значениями <var>v</var>. См. раздел <a href="#contd-sample">contd sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-colorbar-2"></a>Команда MGL: <em></em> <strong>colorbar</strong> <em>'sch' <code>x y [w=1 h=1]</code></em></dt>
<dt><a name="index-Colorbar-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Colorbar</strong> <em>(<code>const char *</code>sch, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> w=<code>1</code>, <code>mreal</code> h=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fcolorbar_005fext"></a>Функция С: <em><code>void</code></em> <strong>mgl_colorbar_ext</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>sch, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> w, <code>mreal</code> h)</em></dt>
<dd><p>Аналогично первому, но в произвольном месте графика {<var>x</var>, <var>y</var>} (полагаются в диапазоне [0,1]). Параметры <var>w</var>, <var>h</var> задают относительную ширину и высоту colorbar.
</p></dd></dl>

<dl>
<dt><a name="index-colorbar-3"></a>Команда MGL: <em></em> <strong>colorbar</strong> <em>vdat 'sch' <code>x y [w=1 h=1]</code></em></dt>
<dt><a name="index-Colorbar-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Colorbar</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const char *</code>sch, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> w=<code>1</code>, <code>mreal</code> h=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fcolorbar_005fval_005fext"></a>Функция С: <em><code>void</code></em> <strong>mgl_colorbar_val_ext</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>const char *</code>sch, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> w, <code>mreal</code> h)</em></dt>
<dd><p>Аналогично предыдущему, но для цветовой схемы <var>sch</var> без сглаживания с заданными значениями <var>v</var>. См. раздел <a href="#contd-sample">contd sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="grid"></a><dl>
<dt><a name="index-grid"></a>Команда MGL: <em></em> <strong>grid</strong> <em>['dir'='xyz' 'pen'='B']</em></dt>
<dt><a name="index-Grid-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grid</strong> <em>(<code>const char *</code>dir=<code>&quot;xyz&quot;</code>, <code>const char *</code>pen=<code>&quot;B&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005faxis_005fgrid"></a>Функция С: <em><code>void</code></em> <strong>mgl_axis_grid</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>dir, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии сетки в направлениях перпендикулярным <var>dir</var>. Если <var>dir</var> содержит &lsquo;<samp>!</samp>&rsquo;, то линии рисуются также и для координат под-меток. Шаг сетки такой же как у меток осей координат. Стиль линий задается параметром <var>pen</var> (по умолчанию &ndash; сплошная темно синяя линия &lsquo;<samp>B-</samp>&rsquo;).
</p></dd></dl>

<a name="box"></a><dl>
<dt><a name="index-box"></a>Команда MGL: <em></em> <strong>box</strong> <em>['stl'='k' <code>ticks=on</code>]</em></dt>
<dt><a name="index-Box-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Box</strong> <em>(<code>const char *</code>col=<code>&quot;&quot;</code>, <code>bool</code> ticks=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fbox"></a>Функция С: <em><code>void</code></em> <strong>mgl_box</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fbox_005fstr"></a>Функция С: <em><code>void</code></em> <strong>mgl_box_str</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>col, <code>int</code> ticks)</em></dt>
<dd><p>Рисует ограничивающий параллелепипед цветом <var>col</var>. Если <var>col</var> содержит &lsquo;<samp>@</samp>&rsquo;, то рисуются закрашенные задние грани. При этом первый цвет используется для граней (по умолчанию светло жёлтый), а последний для рёбер и меток.
</p></dd></dl>

<a name="xlabel"></a><a name="ylabel"></a><a name="zlabel"></a><a name="tlabel"></a><a name="clabel"></a><dl>
<dt><a name="index-xlabel"></a>Команда MGL: <em></em> <strong>xlabel</strong> <em>'text' [<code>pos=1</code>]</em></dt>
<dt><a name="index-ylabel"></a>Команда MGL: <em></em> <strong>ylabel</strong> <em>'text' [<code>pos=1</code>]</em></dt>
<dt><a name="index-zlabel"></a>Команда MGL: <em></em> <strong>zlabel</strong> <em>'text' [<code>pos=1</code>]</em></dt>
<dt><a name="index-tlabel"></a>Команда MGL: <em></em> <strong>tlabel</strong> <em>'text' [<code>pos=1</code>]</em></dt>
<dt><a name="index-clabel"></a>Команда MGL: <em></em> <strong>clabel</strong> <em>'text' [<code>pos=1</code>]</em></dt>
<dt><a name="index-Label-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>char</code> dir, <code>const char *</code>text, <code>mreal</code> pos=<code>1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>char</code> dir, <code>const wchar_t *</code>text, <code>mreal</code> pos=<code>1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flabel"></a>Функция С: <em><code>void</code></em> <strong>mgl_label</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>const char *</code>text, <code>mreal</code> pos, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabelw"></a>Функция С: <em><code>void</code></em> <strong>mgl_labelw</strong> <em>(<code>HMGL</code> gr, <code>char</code> dir, <code>const wchar_t *</code>text, <code>mreal</code> pos, <code>const char *</code>opt)</em></dt>
<dd><p>Выводит подпись <var>text</var> для оси <var>dir</var>=&lsquo;<samp>x</samp>&rsquo;,&lsquo;<samp>y</samp>&rsquo;,&lsquo;<samp>z</samp>&rsquo;,&lsquo;<samp>t</samp>&rsquo;,&lsquo;<samp>c</samp>&rsquo;, где &lsquo;<samp>t</samp>&rsquo; &ndash; &ldquo;тернарная&rdquo; ось <em>t=1-x-y</em>; &lsquo;<samp>c</samp>&rsquo; &ndash; для цвета (следует вызывать после <a href="#colorbar">colorbar</a>). Параметр <var>pos</var> задает положение подписи: при <var>pos</var>=0 &ndash; по центру оси, при <var>pos</var>&gt;0 &ndash; около максимальных значений, при <var>pos</var>&lt;0 &ndash; около минимальных значений. Опция <code>value</code> задает дополнительный сдвиг текста. See <a href="#Text-printing">Text printing</a>.
</p></dd></dl>


<hr>
<a name="Legend"></a>
<div class="header">
<p>
Next: <a href="#g_t1D-plotting" accesskey="n" rel="next">1D plotting</a>, Previous: <a href="#Axis-and-Colorbar" accesskey="p" rel="prev">Axis and Colorbar</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Legenda"></a>
<h3 class="section">4.10 Легенда</h3>

<a name="index-Legend"></a>
<a name="index-AddLegend"></a>
<a name="index-ClearLegend"></a>
<a name="index-SetLegendBox"></a>
<a name="index-SetLegendMarks"></a>

<p>Эти функции обеспечивают рисование легенды графика (полезно для <a href="#g_t1D-plotting">1D plotting</a>). Запись в легенде состоит из двух строк: одна для стиля линии и маркеров, другая с текстом описания (с включенным разбором TeX-их команд). Можно использовать непосредственно массивы строк, или накопление во внутренние массивы с помощью функции AddLegend() с последующим отображением. Положение легенды можно задать автоматически или вручную. Параметры <var>fnt</var> и <var>size</var> задают стиль и размер шрифта (см. <a href="#Font-settings">Font settings</a>). Опция <code>value</code> задает зазор между примером линии и текстом (по умолчанию 0.1). Опция <code>size</code> задает размер текста. Если стиль линии пустой, то соответствующий текст печатается без отступа. Строка <var>fnt</var> может содержать:
</p><ul>
<li> стиль текста для записей;
</li><li> &lsquo;<samp>A</samp>&rsquo; для расположения относительно всего рисунка, а не текущего subplot;
</li><li> &lsquo;<samp>^</samp>&rsquo; для размещения снаружи от указанных координат;
</li><li> &lsquo;<samp>#</samp>&rsquo; для вывода прямоугольника вокруг легенды;
</li><li> &lsquo;<samp>-</samp>&rsquo; для горизонтального расположения записей;
</li><li> цвета для заливки (1-ый), для границы (2-ой) и для текста записей (3-ий). Если указано меньше трех цветов, то цвет границы черный (для 2 и менее цветов), и цвет заливки белый (для 1 и менее цвета).
</li></ul>
<p>См. раздел <a href="#Legend-sample">Legend sample</a>, для примеров кода и графика.
</p>
<a name="legend"></a><dl>
<dt><a name="index-legend-2"></a>Команда MGL: <em></em> <strong>legend</strong> <em>[<code>pos=3</code> 'fnt'='#']</em></dt>
<dt><a name="index-Legend-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Legend</strong> <em>(<code>int</code> pos=<code>0x3</code>, <code>const char *</code>fnt=<code>&quot;#&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flegend"></a>Функция С: <em><code>void</code></em> <strong>mgl_legend</strong> <em>(<code>HMGL</code> gr, <code>int</code> pos, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует легенду из накопленных записей шрифтом <var>fnt</var>. Параметр <var>pos</var> задает положение легенды: &lsquo;<samp>0</samp>&rsquo; &ndash; в нижнем левом углу, &lsquo;<samp>1</samp>&rsquo; &ndash; нижнем правом углу, &lsquo;<samp>2</samp>&rsquo; &ndash; верхнем левом углу, &lsquo;<samp>3</samp>&rsquo; &ndash; верхнем правом углу (по умолчанию). Опция <code>value</code> задает зазор между примером линии и текстом (по умолчанию 0.1).
</p></dd></dl>

<dl>
<dt><a name="index-legend-3"></a>Команда MGL: <em></em> <strong>legend</strong> <em><code>x y</code> ['fnt'='#']</em></dt>
<dt><a name="index-Legend-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Legend</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>const char *</code>fnt=<code>&quot;#&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flegend_005fpos"></a>Функция С: <em><code>void</code></em> <strong>mgl_legend_pos</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует легенду из накопленных записей шрифтом <var>fnt</var>. Положение легенды задается параметрами <var>x</var>, <var>y</var>, которые полагаются нормированными в диапазоне [0,1]. Опция <code>value</code> задает зазор между примером линии и текстом (по умолчанию 0.1).
</p></dd></dl>

<a name="addlegend"></a><dl>
<dt><a name="index-addlegend"></a>Команда MGL: <em></em> <strong>addlegend</strong> <em>'text' 'stl'</em></dt>
<dt><a name="index-AddLegend-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddLegend</strong> <em>(<code>const char *</code>text, <code>const char *</code>style)</em></dt>
<dt><a name="index-AddLegend-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>AddLegend</strong> <em>(<code>const wchar_t *</code>text, <code>const char *</code>style)</em></dt>
<dt><a name="index-mgl_005fadd_005flegend"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_legend</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>text, <code>const char *</code>style)</em></dt>
<dt><a name="index-mgl_005fadd_005flegendw"></a>Функция С: <em><code>void</code></em> <strong>mgl_add_legendw</strong> <em>(<code>HMGL</code> gr, <code>const wchar_t *</code>text, <code>const char *</code>style)</em></dt>
<dd><p>Добавляет описание <var>text</var> кривой со стилем <var>style</var> (см. <a href="#Line-styles">Line styles</a>) во внутренний массив записей легенды.
</p></dd></dl>

<a name="clearlegend"></a><dl>
<dt><a name="index-clearlegend"></a>Команда MGL: <em></em> <strong>clearlegend</strong></dt>
<dt><a name="index-ClearLegend-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ClearLegend</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fclear_005flegend"></a>Функция С: <em><code>void</code></em> <strong>mgl_clear_legend</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Очищает внутренний массив записей легенды.
</p></dd></dl>

<a name="legendmarks"></a><dl>
<dt><a name="index-legendmarks"></a>Команда MGL: <em></em> <strong>legendmarks</strong> <em><code>val</code></em></dt>
<dt><a name="index-SetLegendMarks-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SetLegendMarks</strong> <em>(<code>int</code> num)</em></dt>
<dt><a name="index-mgl_005fset_005flegend_005fmarks"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_legend_marks</strong> <em>(<code>HMGL</code> gr, <code>int</code> num)</em></dt>
<dd><p>Задает число маркеров в легенде. По умолчанию используется 1 маркер.
</p></dd></dl>


<hr>
<a name="g_t1D-plotting"></a>
<div class="header">
<p>
Next: <a href="#g_t2D-plotting" accesskey="n" rel="next">2D plotting</a>, Previous: <a href="#Legend" accesskey="p" rel="prev">Legend</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="g_t1D-grafiki"></a>
<h3 class="section">4.11 1D графики</h3>

<a name="index-Plot"></a>
<a name="index-Radar"></a>
<a name="index-Tens"></a>
<a name="index-Area"></a>
<a name="index-Region"></a>
<a name="index-Stem"></a>
<a name="index-Bars"></a>
<a name="index-Barh"></a>
<a name="index-Chart"></a>
<a name="index-Step"></a>
<a name="index-Torus"></a>
<a name="index-Tube"></a>
<a name="index-Mark-1"></a>
<a name="index-TextMark"></a>
<a name="index-Error-1"></a>
<a name="index-BoxPlot"></a>
<a name="index-Candle"></a>
<a name="index-Tape"></a>
<a name="index-Label-1"></a>
<a name="index-Cones"></a>

<p>Эти функции строят графики для одномерных (1D) массивов. Одномерными считаются массивы, зависящие только от одного параметра (индекса) подобно кривой в параметрической форме {x(i),y(i),z(i)}, i=1...n. По умолчанию (если отсутствуют) значения <var>x</var>[i] равно распределены в диапазоне оси х, и <var>z</var>[i] равно минимальному значению оси z. Графики рисуются для каждой строки массива данных если он двумерный. Размер по 1-ой координате <strong>должен быть одинаков</strong> для всех массивов <code>x.nx=y.nx=z.nx</code>.
</p>
<p>Строка <var>pen</var> задает цвет и стиль линии и маркеров (см. <a href="#Line-styles">Line styles</a>). По умолчанию (<code>pen=&quot;&quot;</code>) рисуется сплошная линия с текущим цветом из палитры (см. <a href="#Palette-and-colors">Palette and colors</a>). Символ &lsquo;<samp>!</samp>&rsquo; в строке задает использование нового цвета из палитры для каждой точки данных (не для всей кривой, как по умолчанию). Строка <var>opt</var> задает опции графика (см. <a href="#Command-options">Command options</a>).
</p>
<a name="plot"></a><dl>
<dt><a name="index-plot"></a>Команда MGL: <em></em> <strong>plot</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-plot-1"></a>Команда MGL: <em></em> <strong>plot</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-plot-2"></a>Команда MGL: <em></em> <strong>plot</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Plot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Plot</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Plot-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Plot</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Plot-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Plot</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_plot</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fplot_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_plot_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fplot_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_plot_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют ломанную линию по точкам {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Если <var>pen</var> содержит &lsquo;<samp>a</samp>&rsquo;, то рисуются и сегменты между точками вне диапазона осей координат. Если <var>pen</var> содержит &lsquo;<samp>~</samp>&rsquo;, то число сегментов уменьшается для квази-линейных участков. См. также <a href="#area">area</a>, <a href="#step">step</a>, <a href="#stem">stem</a>, <a href="#tube">tube</a>, <a href="#mark">mark</a>, <a href="#error">error</a>, <a href="#belt">belt</a>, <a href="#tens">tens</a>, <a href="#tape">tape</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#plot-sample">plot sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="radar"></a><dl>
<dt><a name="index-radar"></a>Команда MGL: <em></em> <strong>radar</strong> <em>adat ['stl'='']</em></dt>
<dt><a name="index-Radar-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Radar</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fradar"></a>Функция С: <em><code>void</code></em> <strong>mgl_radar</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют radar chart, представляющий собой ломанную с вершинами на радиальных линиях (типа ломанной в полярных координатах). Параметр <code>value</code> в опциях <var>opt</var> задает дополнительный сдвиг данных (т.е. использование <var>a</var>+<code>value</code> вместо <var>a</var>). Если <var>pen</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется &quot;сетка&quot; (радиальные линии). Если <var>pen</var> содержит &lsquo;<samp>a</samp>&rsquo;, то рисуются и сегменты между точками вне диапазона осей координат. См. также <a href="#plot">plot</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#radar-sample">radar sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="step"></a><dl>
<dt><a name="index-step"></a>Команда MGL: <em></em> <strong>step</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-step-1"></a>Команда MGL: <em></em> <strong>step</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-step-2"></a>Команда MGL: <em></em> <strong>step</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Step-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Step</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Step-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Step</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Step-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Step</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fstep"></a>Функция С: <em><code>void</code></em> <strong>mgl_step</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fstep_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_step_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fstep_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_step_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют ступеньки для точек массива. Если <var>x</var>.nx&gt;<var>y</var>.nx, то массив <var>x</var> задает границы ступенек, а не их конец. См. также <a href="#plot">plot</a>, <a href="#stem">stem</a>, <a href="#tile">tile</a>, <a href="#boxs">boxs</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#step-sample">step sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tens"></a><dl>
<dt><a name="index-tens"></a>Команда MGL: <em></em> <strong>tens</strong> <em>ydat cdat ['stl'='']</em></dt>
<dt><a name="index-tens-1"></a>Команда MGL: <em></em> <strong>tens</strong> <em>xdat ydat cdat ['stl'='']</em></dt>
<dt><a name="index-tens-2"></a>Команда MGL: <em></em> <strong>tens</strong> <em>xdat ydat zdat cdat ['stl'='']</em></dt>
<dt><a name="index-Tens-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tens</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>c, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tens-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tens</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>c, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tens-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tens</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftens"></a>Функция С: <em><code>void</code></em> <strong>mgl_tens</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> c, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftens_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_tens_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> c, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftens_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_tens_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют ломанную линию по точкам с цветом, определяемым массивом <var>c</var> (типа графика натяжений). Строка <var>pen</var> задает цветовую схему (см. <a href="#Color-scheme">Color scheme</a>) и стиль линий и/или маркеров (см. <a href="#Line-styles">Line styles</a>). Если <var>pen</var> содержит &lsquo;<samp>a</samp>&rsquo;, то рисуются и сегменты между точками вне диапазона осей координат. Если <var>pen</var> содержит &lsquo;<samp>~</samp>&rsquo;, то число сегментов уменьшается для квази-линейных участков. См. также <a href="#plot">plot</a>, <a href="#mesh">mesh</a>, <a href="#fall">fall</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#tens-sample">tens sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tape"></a><dl>
<dt><a name="index-tape"></a>Команда MGL: <em></em> <strong>tape</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-tape-1"></a>Команда MGL: <em></em> <strong>tape</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-tape-2"></a>Команда MGL: <em></em> <strong>tape</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Tape-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tape</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tape-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tape</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tape-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tape</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftape"></a>Функция С: <em><code>void</code></em> <strong>mgl_tape</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftape_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_tape_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftape_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_tape_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют ленты, которые вращаются вокруг кривой {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]} как её нормали. Начальная лента(ы) выбираются в плоскости x-y (для &lsquo;<samp>x</samp>&rsquo; в <var>pen</var>) и/или y-z (для &lsquo;<samp>x</samp>&rsquo; в <var>pen</var>). Ширина лент пропорциональна <a href="#barwidth">barwidth</a>, а также может быть изменена опцией <code>value</code>. См. также <a href="#plot">plot</a>, <a href="#flow">flow</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#tape-sample">tape sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="area"></a><dl>
<dt><a name="index-area"></a>Команда MGL: <em></em> <strong>area</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-area-1"></a>Команда MGL: <em></em> <strong>area</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-area-2"></a>Команда MGL: <em></em> <strong>area</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Area-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Area</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Area-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Area</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Area-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Area</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005farea"></a>Функция С: <em><code>void</code></em> <strong>mgl_area</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005farea_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_area_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005farea_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_area_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют ломанную линию между точками и закрашивает её вниз до плоскости осей координат. Градиентная заливка используется если число цветов равно удвоенному число кривых. Если <var>pen</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется только каркас. Если <var>pen</var> содержит &lsquo;<samp>a</samp>&rsquo;, то рисуются и сегменты между точками вне диапазона осей координат. См. также <a href="#plot">plot</a>, <a href="#bars">bars</a>, <a href="#stem">stem</a>, <a href="#region">region</a>. См. раздел <a href="#area-sample">area sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="region"></a><dl>
<dt><a name="index-region"></a>Команда MGL: <em></em> <strong>region</strong> <em>ydat1 ydat2 ['stl'='']</em></dt>
<dt><a name="index-region-1"></a>Команда MGL: <em></em> <strong>region</strong> <em>xdat ydat1 ydat2 ['stl'='']</em></dt>
<dt><a name="index-region-2"></a>Команда MGL: <em></em> <strong>region</strong> <em>xdat1 ydat1 xdat2 ydat2 ['stl'='']</em></dt>
<dt><a name="index-region-3"></a>Команда MGL: <em></em> <strong>region</strong> <em>xdat1 ydat1 zdat1 xdat2 ydat2 zdat2 ['stl'='']</em></dt>
<dt><a name="index-Region-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Region</strong> <em>(<code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Region-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Region</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Region-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Region</strong> <em>(<code>const mglDataA &amp;</code>x1, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>x2, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Region-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Region</strong> <em>(<code>const mglDataA &amp;</code>x1, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>z1, <code>const mglDataA &amp;</code>x2, <code>const mglDataA &amp;</code>y2, <code>const mglDataA &amp;</code>z2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fregion"></a>Функция С: <em><code>void</code></em> <strong>mgl_region</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y1, <code>HCDT</code> y2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fregion_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_region_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y1, <code>HCDT</code> y2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fregion_005f3d"></a>Функция С: <em><code>void</code></em> <strong>mgl_region_3d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x1, <code>HCDT</code> y1, <code>HCDT</code> z1, <code>HCDT</code> x2, <code>HCDT</code> y2, <code>HCDT</code> z2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции закрашивают область между 2 кривыми. Градиентная заливка используется если число цветов равно удвоенному число кривых. Если в 2d версии <var>pen</var> содержит &lsquo;<samp>i</samp>&rsquo;, то закрашивается только область y1&lt;y&lt;y2, в противном случае будет закрашена и область y2&lt;y&lt;y1. Если <var>pen</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется только каркас. Если <var>pen</var> содержит &lsquo;<samp>a</samp>&rsquo;, то рисуются и сегменты между точками вне диапазона осей координат. См. также <a href="#area">area</a>, <a href="#bars">bars</a>, <a href="#stem">stem</a>. См. раздел <a href="#region-sample">region sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="stem"></a><dl>
<dt><a name="index-stem"></a>Команда MGL: <em></em> <strong>stem</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-stem-1"></a>Команда MGL: <em></em> <strong>stem</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-stem-2"></a>Команда MGL: <em></em> <strong>stem</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Stem-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Stem</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Stem-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Stem</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Stem-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Stem</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fstem"></a>Функция С: <em><code>void</code></em> <strong>mgl_stem</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fstem_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_stem_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fstem_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_stem_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют вертикальные линии из точек до плоскости осей координат. См. также <a href="#area">area</a>, <a href="#bars">bars</a>, <a href="#plot">plot</a>, <a href="#mark">mark</a>. См. раздел <a href="#stem-sample">stem sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="bars"></a><dl>
<dt><a name="index-bars"></a>Команда MGL: <em></em> <strong>bars</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-bars-1"></a>Команда MGL: <em></em> <strong>bars</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-bars-2"></a>Команда MGL: <em></em> <strong>bars</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Bars-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Bars</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Bars-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Bars</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Bars-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Bars</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fbars"></a>Функция С: <em><code>void</code></em> <strong>mgl_bars</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbars_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_bars_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbars_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_bars_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют вертикальные полосы (прямоугольники) из точек до плоскости осей координат. Строка <var>pen</var> может содержать:
</p><ul>
<li> &lsquo;<samp>a</samp>&rsquo; для вывода линий одной поверх другой (как при суммировании);
</li><li> &lsquo;<samp>f</samp>&rsquo; для определения кумулятивного эффекта последовательности положительных и отрицательных значений (график типа waterfall);
</li><li> &lsquo;<samp>F</samp>&rsquo; для использования одинаковой (минимальной) ширины полосок;
</li><li> &lsquo;<samp>&lt;</samp>&rsquo;, &lsquo;<samp>^</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo; для выравнивания полосок влево, вправо или центрирования относительно их координат.
</li></ul>
<p>Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Если <var>x</var>.nx&gt;<var>y</var>.nx, то массив <var>x</var> задает границы полос, а не их центр. См. также <a href="#barh">barh</a>, <a href="#cones">cones</a>, <a href="#area">area</a>, <a href="#stem">stem</a>, <a href="#chart">chart</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#bars-sample">bars sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="barh"></a><dl>
<dt><a name="index-barh"></a>Команда MGL: <em></em> <strong>barh</strong> <em>vdat ['stl'='']</em></dt>
<dt><a name="index-barh-1"></a>Команда MGL: <em></em> <strong>barh</strong> <em>ydat vdat ['stl'='']</em></dt>
<dt><a name="index-Barh-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Barh</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Barh-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Barh</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>v, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fbarh"></a>Функция С: <em><code>void</code></em> <strong>mgl_barh</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbarh_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_barh_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> v, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют горизонтальные полосы (прямоугольники) из точек до плоскости осей координат. Строка <var>pen</var> может содержать:
</p><ul>
<li> &lsquo;<samp>a</samp>&rsquo; для вывода линий одной поверх другой (как при суммировании);
</li><li> &lsquo;<samp>f</samp>&rsquo; для определения кумулятивного эффекта последовательности положительных и отрицательных значений (график типа waterfall);
</li><li> &lsquo;<samp>F</samp>&rsquo; для использования одинаковой (минимальной) ширины полосок;
</li><li> &lsquo;<samp>&lt;</samp>&rsquo;, &lsquo;<samp>^</samp>&rsquo; or &lsquo;<samp>&gt;</samp>&rsquo; для выравнивания полосок влево, вправо или центрирования относительно их координат.
</li></ul>
<p>Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Если <var>x</var>.nx&gt;<var>y</var>.nx, то массив <var>x</var> задает границы полос, а не их центр. См. также <a href="#bars">bars</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#barh-sample">barh sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="cones"></a><dl>
<dt><a name="index-cones"></a>Команда MGL: <em></em> <strong>cones</strong> <em>ydat ['stl'='']</em></dt>
<dt><a name="index-cones-1"></a>Команда MGL: <em></em> <strong>cones</strong> <em>xdat ydat ['stl'='']</em></dt>
<dt><a name="index-cones-2"></a>Команда MGL: <em></em> <strong>cones</strong> <em>xdat ydat zdat ['stl'='']</em></dt>
<dt><a name="index-Cones-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cones</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cones-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cones</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cones-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cones</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcones"></a>Функция С: <em><code>void</code></em> <strong>mgl_cones</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcones_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_cones_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcones_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_cones_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют конусы из точек до плоскости осей координат. Если строка <var>pen</var> содержит символ &lsquo;<samp>a</samp>&rsquo;, то линии рисуются одна поверх другой. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. Параметр <var>pen</var> может содержать:
</p><ul>
<li> &lsquo;<samp>@</samp>&rsquo; для рисования торцов;
</li><li> &lsquo;<samp>#</samp>&rsquo; для сетчатой фигуры;
</li><li> &lsquo;<samp>t</samp>&rsquo; для рисования цилиндра вместо конуса/призмы;
</li><li> &lsquo;<samp>4</samp>&rsquo;, &lsquo;<samp>6</samp>&rsquo;, &lsquo;<samp>8</samp>&rsquo; для рисования квадратной, шестиугольной или восьмиугольной призмы вместо конуса;
</li><li> &lsquo;<samp>&lt;</samp>&rsquo;, &lsquo;<samp>^</samp>&rsquo; или &lsquo;<samp>&gt;</samp>&rsquo; для выравнивания конусов влево, вправо или по центру относительно их координат.
</li></ul>
<p>См. также <a href="#bars">bars</a>, <a href="#cone">cone</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#cones-sample">cones sample</a>, для примеров кода и графика.
</p></dd></dl>



<a name="chart"></a><dl>
<dt><a name="index-chart"></a>Команда MGL: <em></em> <strong>chart</strong> <em>adat ['col'='']</em></dt>
<dt><a name="index-Chart-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Chart</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>col=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fchart"></a>Функция С: <em><code>void</code></em> <strong>mgl_chart</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>col, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует цветные полосы (пояса) для массива данных <var>a</var>. Число полос равно числу строк <var>a</var> (равно <var>a.ny</var>). Цвет полос поочерёдно меняется из цветов указанных в <var>col</var> или в палитре (см. <a href="#Palette-and-colors">Palette and colors</a>). Пробел в цветах соответствует прозрачному &quot;цвету&quot;, т.е. если <var>col</var> содержит пробел(ы), то соответствующая полоса не рисуется. Ширина полосы пропорциональна значению элемента в <var>a</var>. График строится только для массивов не содержащих отрицательных значений. Если строка <var>col</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется также чёрная граница полос. График выглядит лучше в (после вращения системы координат) и/или в полярной системе координат (становится Pie chart). См. раздел <a href="#chart-sample">chart sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="boxplot"></a><dl>
<dt><a name="index-boxplot"></a>Команда MGL: <em></em> <strong>boxplot</strong> <em>adat ['stl'='']</em></dt>
<dt><a name="index-boxplot-1"></a>Команда MGL: <em></em> <strong>boxplot</strong> <em>xdat adat ['stl'='']</em></dt>
<dt><a name="index-BoxPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>BoxPlot</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-BoxPlot-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>BoxPlot</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fboxplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_boxplot</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fboxplot_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_boxplot_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> a, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют boxplot (называемый также как box-and-whisker diagram или как &quot;ящик с усами&quot;) в точках <var>x</var>[i] на плоскости <var>z</var> = <var>zVal</var> (по умолчанию <var>z</var> равно минимальному значению оси z). Это график, компактно изображающий распределение вероятностей <var>a</var>[i,j] (минимум, нижний квартиль (Q1), медиана (Q2), верхний квартиль (Q3) и максимум) вдоль второго (j-го) направления. Если <var>pen</var> содержит &lsquo;<samp>&lt;</samp>&rsquo;, &lsquo;<samp>^</samp>&rsquo; или &lsquo;<samp>&gt;</samp>&rsquo;, то полоски будут выровнены влево, вправо или центрированы относительно их координат. См. также <a href="#plot">plot</a>, <a href="#error">error</a>, <a href="#bars">bars</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#boxplot-sample">boxplot sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="candle"></a><dl>
<dt><a name="index-candle"></a>Команда MGL: <em></em> <strong>candle</strong> <em>vdat1 ['stl'='']</em></dt>
<dt><a name="index-candle-1"></a>Команда MGL: <em></em> <strong>candle</strong> <em>vdat1 vdat2 ['stl'='']</em></dt>
<dt><a name="index-candle-2"></a>Команда MGL: <em></em> <strong>candle</strong> <em>vdat1 ydat1 ydat2 ['stl'='']</em></dt>
<dt><a name="index-candle-3"></a>Команда MGL: <em></em> <strong>candle</strong> <em>vdat1 vdat2 ydat1 ydat2 ['stl'='']</em></dt>
<dt><a name="index-candle-4"></a>Команда MGL: <em></em> <strong>candle</strong> <em>xdat vdat1 vdat2 ydat1 ydat2 ['stl'='']</em></dt>
<dt><a name="index-Candle-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Candle</strong> <em>(<code>const mglDataA &amp;</code>v1, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Candle-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Candle</strong> <em>(<code>const mglDataA &amp;</code>v1, <code>const mglDataA &amp;</code>v2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Candle-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Candle</strong> <em>(<code>const mglDataA &amp;</code>v1, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Candle-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Candle</strong> <em>(<code>const mglDataA &amp;</code>v1, <code>const mglDataA &amp;</code>v2, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Candle-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Candle</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v1, <code>const mglDataA &amp;</code>v2, <code>const mglDataA &amp;</code>y1, <code>const mglDataA &amp;</code>y2, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcandle"></a>Функция С: <em><code>void</code></em> <strong>mgl_candle</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v1, <code>HCDT</code> y1, <code>HCDT</code> y2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcandle_005fyv"></a>Функция С: <em><code>void</code></em> <strong>mgl_candle_yv</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v1, <code>HCDT</code> v2, <code>HCDT</code> y1, <code>HCDT</code> y2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcandle_005fxyv"></a>Функция С: <em><code>void</code></em> <strong>mgl_candle_xyv</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> v1, <code>HCDT</code> v2, <code>HCDT</code> y1, <code>HCDT</code> y2, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют candlestick chart в точках <var>x</var>[i]. Этот график показывает прямоугольником (&quot;свечой&quot;) диапазон изменения величины. Прозрачная (белая) свеча соответствует росту величины <var>v1</var>[i]&lt;<var>v2</var>[i], чёрная &ndash; уменьшению. &quot;Тени&quot; показывают минимальное <var>y1</var> и максимальное <var>y2</var> значения. Если <var>v2</var> отсутствует, то он определяется как <var>v2</var>[i]=<var>v1</var>[i+1]. Можно использовать разные цвета для растущих и падающих дней если число указанных цветов равно удвоенному числу кривых для построения. Если <var>pen</var> содержит &lsquo;<samp>#</samp>&rsquo;, то прозрачная свеча будет использована и при 2-цветной схеме. См. также <a href="#plot">plot</a>, <a href="#bars">bars</a>, <a href="#ohlc">ohlc</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#candle-sample">candle sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="ohlc"></a><dl>
<dt><a name="index-ohlc"></a>Команда MGL: <em></em> <strong>ohlc</strong> <em>odat hdat ldat cdat ['stl'='']</em></dt>
<dt><a name="index-ohlc-1"></a>Команда MGL: <em></em> <strong>ohlc</strong> <em>xdat odat hdat ldat cdat ['stl'='']</em></dt>
<dt><a name="index-OHLC"></a>MМетод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>OHLC</strong> <em>(<code>const mglDataA &amp;</code>o, <code>const mglDataA &amp;</code>h, <code>const mglDataA &amp;</code>l, <code>const mglDataA &amp;</code>c, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-OHLC-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>OHLC</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>o, <code>const mglDataA &amp;</code>h, <code>const mglDataA &amp;</code>l, <code>const mglDataA &amp;</code>c, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fohlc"></a>Функция С: <em><code>void</code></em> <strong>mgl_ohlc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> o, <code>HCDT</code> h, <code>HCDT</code> l, <code>HCDT</code> c, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fohlc_005fx"></a>Функция С: <em><code>void</code></em> <strong>mgl_ohlc_x</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> o, <code>HCDT</code> h, <code>HCDT</code> l, <code>HCDT</code> c, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют Open-High-Low-Close диаграмму. Этот график содержит вертикальные линии между максимальным <var>h</var> и минимальным <var>l</var> значениями, и горизонтальные линии перед/после вертикальной линии для начального <var>o</var> и конечного <var>c</var> значений процесса (обычно цены). Можно использовать разные цвета для растущих и падающих дней если число указанных цветов равно удвоенному числу кривых для построения. См. также <a href="#candle">candle</a>, <a href="#plot">plot</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#ohlc-sample">ohlc sample</a>, для примеров кода и графика.
</p></dd></dl>


<a name="error"></a><dl>
<dt><a name="index-error"></a>Команда MGL: <em></em> <strong>error</strong> <em>ydat yerr ['stl'='']</em></dt>
<dt><a name="index-error-1"></a>Команда MGL: <em></em> <strong>error</strong> <em>xdat ydat yerr ['stl'='']</em></dt>
<dt><a name="index-error-2"></a>Команда MGL: <em></em> <strong>error</strong> <em>xdat ydat xerr yerr ['stl'='']</em></dt>
<dt><a name="index-Error-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Error</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ey, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Error-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Error</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ey, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Error-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Error</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ex, <code>const mglDataA &amp;</code>ey, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ferror"></a>Функция С: <em><code>void</code></em> <strong>mgl_error</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> ey, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ferror_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_error_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ey, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ferror_005fexy"></a>Функция С: <em><code>void</code></em> <strong>mgl_error_exy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ex, <code>HCDT</code> ey, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют размер ошибки {<var>ex</var>[i], <var>ey</var>[i]} в точках {<var>x</var>[i], <var>y</var>[i]} на плоскости <var>z</var> = <var>zVal</var> (по умолчанию <var>z</var> равно минимальному значению оси z). Такой график полезен для отображения ошибки эксперимента, вычислений и пр. Если <var>pen</var> содержит &lsquo;<samp>@</samp>&rsquo;, то будут использованы большие полупрозрачные маркеры. См. также <a href="#plot">plot</a>, <a href="#mark">mark</a>. См. раздел <a href="#error-sample">error sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="mark"></a><dl>
<dt><a name="index-mark"></a>Команда MGL: <em></em> <strong>mark</strong> <em>ydat rdat ['stl'='']</em></dt>
<dt><a name="index-mark-1"></a>Команда MGL: <em></em> <strong>mark</strong> <em>xdat ydat rdat ['stl'='']</em></dt>
<dt><a name="index-mark-2"></a>Команда MGL: <em></em> <strong>mark</strong> <em>xdat ydat zdat rdat ['stl'='']</em></dt>
<dt><a name="index-Mark-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mark</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Mark-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Mark-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fmark_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_mark_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fmark_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_mark_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fmark_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_mark_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют маркеры размером <var>r</var>[i]*<a href="#marksize">marksize</a> (см. <a href="#Default-sizes">Default sizes</a>) в точках {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Для рисования маркеров одинакового размера можно использовать функцию <a href="#plot">plot</a> с невидимой линией (со стилем содержащим &lsquo;<samp> </samp>&rsquo;). Для маркеров с размером как у координат можно использовать <a href="#error">error</a> со стилем &lsquo;<samp>@</samp>&rsquo;. См. также <a href="#plot">plot</a>, <a href="#textmark">textmark</a>, <a href="#error">error</a>, <a href="#stem">stem</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#mark-sample">mark sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="textmark"></a><dl>
<dt><a name="index-textmark"></a>Команда MGL: <em></em> <strong>textmark</strong> <em>ydat 'txt' ['stl'='']</em></dt>
<dt><a name="index-textmark-1"></a>Команда MGL: <em></em> <strong>textmark</strong> <em>ydat rdat 'txt' ['stl'='']</em></dt>
<dt><a name="index-textmark-2"></a>Команда MGL: <em></em> <strong>textmark</strong> <em>xdat ydat rdat 'txt' ['stl'='']</em></dt>
<dt><a name="index-textmark-3"></a>Команда MGL: <em></em> <strong>textmark</strong> <em>xdat ydat zdat rdat 'txt' ['stl'='']</em></dt>
<dt><a name="index-TextMark-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-6"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-7"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TextMark-8"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TextMark</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftextmark"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmark</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmarkw"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmarkw</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmark_005fyr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmark_yr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmarkw_005fyr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmarkw_yr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmark_005fxyr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmark_xyr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmarkw_005fxyr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmarkw_xyr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmark_005fxyzr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmark_xyzr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftextmarkw_005fxyzr"></a>Функция С: <em><code>void</code></em> <strong>mgl_textmarkw_xyzr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют текст <var>txt</var> как маркер с размером пропорциональным <var>r</var>[i]*<var>marksize</var> в точках {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. См. также <a href="#plot">plot</a>, <a href="#mark">mark</a>, <a href="#stem">stem</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#textmark-sample">textmark sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="label"></a><dl>
<dt><a name="index-label"></a>Команда MGL: <em></em> <strong>label</strong> <em>ydat 'txt' ['stl'='']</em></dt>
<dt><a name="index-label-1"></a>Команда MGL: <em></em> <strong>label</strong> <em>xdat ydat 'txt' ['stl'='']</em></dt>
<dt><a name="index-label-2"></a>Команда MGL: <em></em> <strong>label</strong> <em>xdat ydat zdat 'txt' ['stl'='']</em></dt>
<dt><a name="index-Label-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-6"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-7"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-8"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Label-9"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Label</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flabel-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_label</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabelw-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_labelw</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabel_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_label_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabelw_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_labelw_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabel_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_label_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flabelw_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_labelw_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Функции выводят текстовую строку <var>txt</var> в точках {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Если строка <var>txt</var> содержит &lsquo;<samp>%x</samp>&rsquo;, &lsquo;<samp>%y</samp>&rsquo;, &lsquo;<samp>%z</samp>&rsquo; или &lsquo;<samp>%n</samp>&rsquo;, то они будут заменены на значения соответствующих координат или на номер точки. Строка <var>fnt</var> может содержать:
</p><ul>
<li> стиль текста <a href="#Font-styles">Font styles</a>;
</li><li> &lsquo;<samp>f</samp>&rsquo; для вывода чисел в фиксированном формате;
</li><li> &lsquo;<samp>E</samp>&rsquo; для вывода &lsquo;<samp>E</samp>&rsquo; вместо &lsquo;<samp>e</samp>&rsquo;;
</li><li> &lsquo;<samp>F</samp>&rsquo; для вывода в формате LaTeX;
</li><li> &lsquo;<samp>+</samp>&rsquo; для вывода &lsquo;<samp>+</samp>&rsquo; для положительных чисел;
</li><li> &lsquo;<samp>-</samp>&rsquo; для вывода обычного &lsquo;<samp>-</samp>&rsquo;;
</li><li> &lsquo;<samp>0123456789</samp>&rsquo; для задания точности при выводе чисел.
</li></ul>
<p>См. также <a href="#plot">plot</a>, <a href="#mark">mark</a>, <a href="#textmark">textmark</a>, <a href="#table">table</a>. См. раздел <a href="#label-sample">label sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="table"></a><dl>
<dt><a name="index-table"></a>Команда MGL: <em></em> <strong>table</strong> <em>vdat 'txt' ['stl'='#']</em></dt>
<dt><a name="index-table-1"></a>Команда MGL: <em></em> <strong>table</strong> <em>x y vdat 'txt' ['stl'='#']</em></dt>
<dt><a name="index-Table"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Table</strong> <em>(<code>const mglDataA &amp;</code>val, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Table-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Table</strong> <em>(<code>const mglDataA &amp;</code>val, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Table-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Table</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>const mglDataA &amp;</code>val, <code>const char *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Table-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Table</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>const mglDataA &amp;</code>val, <code>const wchar_t *</code>txt, <code>const char *</code>fnt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftable"></a>Функция С: <em><code>void</code></em> <strong>mgl_table</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>HCDT</code> val, <code>const char *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftablew"></a>Функция С: <em><code>void</code></em> <strong>mgl_tablew</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>HCDT</code> val, <code>const wchar_t *</code>txt, <code>const char *</code>fnt, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует таблицу значений массива <var>val</var> с заголовками <var>txt</var> (разделенными символом новой строки &lsquo;<samp>\n</samp>&rsquo;) в точке {<var>x</var>, <var>y</var>} (по умолчанию {0,0}) относительно текущего subplot. Строка <var>fnt</var> может содержать:
</p><ul>
<li> стиль текста <a href="#Font-styles">Font styles</a>;
</li><li> &lsquo;<samp>#</samp>&rsquo; для рисования границ ячеек;
</li><li> &lsquo;<samp>=</samp>&rsquo; для одинаковой ширины всех ячеек;
</li><li> &lsquo;<samp>|</samp>&rsquo; для ограничения ширины таблицы шириной subplot (эквивалентно опции &lsquo;<samp>value 1</samp>&rsquo;);
</li><li> &lsquo;<samp>f</samp>&rsquo; для вывода чисел в фиксированном формате;
</li><li> &lsquo;<samp>E</samp>&rsquo; для вывода &lsquo;<samp>E</samp>&rsquo; вместо &lsquo;<samp>e</samp>&rsquo;;
</li><li> &lsquo;<samp>F</samp>&rsquo; для вывода в формате LaTeX;
</li><li> &lsquo;<samp>+</samp>&rsquo; для вывода &lsquo;<samp>+</samp>&rsquo; для положительных чисел;
</li><li> &lsquo;<samp>-</samp>&rsquo; для вывода обычного &lsquo;<samp>-</samp>&rsquo;;
</li><li> &lsquo;<samp>0123456789</samp>&rsquo; для задания точности при выводе чисел.
</li></ul>
<p>Опция <code>value</code> задает ширину таблицы (по умолчанию 1). См. также <a href="#plot">plot</a>, <a href="#label">label</a>. См. раздел <a href="#table-sample">table sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="iris"></a><dl>
<dt><a name="index-iris"></a>Команда MGL: <em></em> <strong>iris</strong> <em>dats 'ids' ['stl'='']</em></dt>
<dt><a name="index-iris-1"></a>Команда MGL: <em></em> <strong>iris</strong> <em>dats rngs 'ids' ['stl'='']</em></dt>
<dt><a name="index-Iris"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Iris</strong> <em>(<code>const mglDataA &amp;</code>dats, <code>const char *</code>ids, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Iris-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Iris</strong> <em>(<code>const mglDataA &amp;</code>dats, <code>const wchar_t *</code>ids, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Iris-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Iris</strong> <em>(<code>const mglDataA &amp;</code>dats, <code>const mglDataA &amp;</code>rngs, <code>const char *</code>ids, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Iris-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Iris</strong> <em>(<code>const mglDataA &amp;</code>dats, <code>const mglDataA &amp;</code>rngs, <code>const wchar_t *</code>ids, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005firis_005f1"></a>Функция С: <em><code>void</code></em> <strong>mgl_iris_1</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> dats, <code>const char *</code>ids, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005firisw_005f1"></a>Функция С: <em><code>void</code></em> <strong>mgl_irisw_1</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> dats, <code>const wchar_t *</code>ids, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005firis"></a>Функция С: <em><code>void</code></em> <strong>mgl_iris</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> dats, <code>HCDT</code> rngs, <code>const char *</code>ids, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005firisw"></a>Функция С: <em><code>void</code></em> <strong>mgl_irisw</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> dats, <code>HCDT</code> rngs, <code>const wchar_t *</code>ids, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует Ирисы Фишера для определения зависимостей данных <var>dats</var> друг от друга (см. <a href="http://en.wikipedia.org/wiki/Iris_flower_data_set">http://en.wikipedia.org/wiki/Iris_flower_data_set</a>). Массив <var>rngs</var> размером 2*<var>dats</var>.nx задает диапазон изменения осей для каждой из колонки. Строка <var>ids</var> содержит имена колонок данных, разделенных символом &lsquo;<samp>;</samp>&rsquo;. Опция <code>value</code> задает размер текста для имен данных. На график можно добавить новый набор данных если указать тот же размер <var>rngs</var> и использовать пустую строку имен <var>ids</var>. См. также <a href="#plot">plot</a>. См. раздел <a href="#iris-sample">iris sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tube"></a><dl>
<dt><a name="index-tube"></a>Команда MGL: <em></em> <strong>tube</strong> <em>ydat rdat ['stl'='']</em></dt>
<dt><a name="index-tube-1"></a>Команда MGL: <em></em> <strong>tube</strong> <em>ydat <code>rval</code> ['stl'='']</em></dt>
<dt><a name="index-tube-2"></a>Команда MGL: <em></em> <strong>tube</strong> <em>xdat ydat rdat ['stl'='']</em></dt>
<dt><a name="index-tube-3"></a>Команда MGL: <em></em> <strong>tube</strong> <em>xdat ydat <code>rval</code> ['stl'='']</em></dt>
<dt><a name="index-tube-4"></a>Команда MGL: <em></em> <strong>tube</strong> <em>xdat ydat zdat rdat ['stl'='']</em></dt>
<dt><a name="index-tube-5"></a>Команда MGL: <em></em> <strong>tube</strong> <em>xdat ydat zdat <code>rval</code> ['stl'='']</em></dt>
<dt><a name="index-Tube-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tube-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>y, <code>mreal</code> r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tube-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tube-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>mreal</code> r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tube-5"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tube-6"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tube</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>mreal</code> r, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftube_005fr"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube_r</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftube"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> y, <code>mreal</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftube_005fxyr"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube_xyr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftube_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>mreal</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftube_005fxyzr"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube_xyzr</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftube_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_tube_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>mreal</code> r, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют трубу радиуса <var>r</var>[i] вдоль кривой между точками {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Опция <code>value</code> число сегментов в поперечном сечении (по умолчанию 25). См. также <a href="#plot">plot</a>. См. раздел <a href="#tube-sample">tube sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="torus"></a><dl>
<dt><a name="index-torus"></a>Команда MGL: <em></em> <strong>torus</strong> <em>rdat zdat ['stl'='']</em></dt>
<dt><a name="index-Torus-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Torus</strong> <em>(<code>const mglDataA &amp;</code>r, <code>const mglDataA &amp;</code>z, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftorus"></a>Функция С: <em><code>void</code></em> <strong>mgl_torus</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> r, <code>HCDT</code> z, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют поверхность вращения кривой {<var>r</var>, <var>z</var>} относительно оси. Если строка <var>pen</var> содержит &lsquo;<samp>x</samp>&rsquo; или &lsquo;<samp>z</samp>&rsquo;, то ось вращения будет выбрана в указанном направлении (по умолчанию вдоль оси y). Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#plot">plot</a>, <a href="#axial">axial</a>. См. раздел <a href="#torus-sample">torus sample</a>, для примеров кода и графика.
</p></dd></dl>



<a name="lamerey"></a><dl>
<dt><a name="index-lamerey"></a>Команда MGL: <em></em> <strong>lamerey</strong> <em><code>x0</code> ydat ['stl'='']</em></dt>
<dt><a name="index-lamerey-1"></a>Команда MGL: <em></em> <strong>lamerey</strong> <em><code>x0</code> 'y(x)' ['stl'='']</em></dt>
<dt><a name="index-Lamerey"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Lamerey</strong> <em>(<code>double</code> x0, <code>const mglDataA &amp;</code>y, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Lamerey-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Lamerey</strong> <em>(<code>double</code> x0, <code>const char *</code>y, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005flamerey_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_lamerey_dat</strong> <em>(<code>HMGL</code> gr, <code>double</code> x0, <code>HCDT</code> y, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005flamerey_005fstr"></a>Функция С: <em><code>void</code></em> <strong>mgl_lamerey_str</strong> <em>(<code>HMGL</code> gr, <code>double</code> x0, <code>const char *</code>y, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют диаграмму Ламерея для точечного отображения x_new = y(x_old) начиная с точки <var>x0</var>. Строка <var>stl</var> может содержать стиль линии, символ &lsquo;<samp>v</samp>&rsquo; для стрелок, символ &lsquo;<samp>~</samp>&rsquo; для исключения первого сегмента. Опция <code>value</code> задает число сегментов для рисования (по умолчанию 20). См. также <a href="#plot">plot</a>, <a href="#fplot">fplot</a>, <a href="#bifurcation">bifurcation</a>, <a href="#pmap">pmap</a>. См. раздел <a href="#lamerey-sample">lamerey sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="bifurcation"></a><dl>
<dt><a name="index-bifurcation"></a>Команда MGL: <em></em> <strong>bifurcation</strong> <em><code>dx</code> ydat ['stl'='']</em></dt>
<dt><a name="index-bifurcation-1"></a>Команда MGL: <em></em> <strong>bifurcation</strong> <em><code>dx</code> 'y(x)' ['stl'='']</em></dt>
<dt><a name="index-Bifurcation"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Bifurcation</strong> <em>(<code>double</code> dx, <code>const mglDataA &amp;</code>y, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Bifurcation-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Bifurcation</strong> <em>(<code>double</code> dx, <code>const char *</code>y, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fbifurcation_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_bifurcation_dat</strong> <em>(<code>HMGL</code> gr, <code>double</code> dx, <code>HCDT</code> y, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbifurcation_005fstr"></a>Функция С: <em><code>void</code></em> <strong>mgl_bifurcation_str</strong> <em>(<code>HMGL</code> gr, <code>double</code> dx, <code>const char *</code>y, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют бифуркационную диаграмму (диаграмму удвоения периода) для точечного отображения x_new = y(x_old). Параметр <var>dx</var> задает точность по оси x. Строка <var>stl</var> задает цвет. Опция <code>value</code> задает число учитываемых стационарных точек (по умолчанию 1024). См. также <a href="#plot">plot</a>, <a href="#fplot">fplot</a>, <a href="#lamerey">lamerey</a>. См. раздел <a href="#bifurcation-sample">bifurcation sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="pmap"></a><dl>
<dt><a name="index-pmap"></a>Команда MGL: <em></em> <strong>pmap</strong> <em>ydat sdat ['stl'='']</em></dt>
<dt><a name="index-pmap-1"></a>Команда MGL: <em></em> <strong>pmap</strong> <em>xdat ydat sdat ['stl'='']</em></dt>
<dt><a name="index-pmap-2"></a>Команда MGL: <em></em> <strong>pmap</strong> <em>xdat ydat zdat sdat ['stl'='']</em></dt>
<dt><a name="index-Pmap"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pmap</strong> <em>(<code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>s, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Pmap-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pmap</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>s, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Pmap-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pmap</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>s, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpmap"></a>Функция С: <em><code>void</code></em> <strong>mgl_pmap</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> y, <code>HCDT</code> s, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpmap_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_pmap_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HMDT</code> y, <code>HCDT</code> s, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpmap_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_pmap_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HMDT</code> y, <code>HCDT</code> z, <code>HCDT</code> s, <code>const char *</code>stl, <code>const char *</code>opt)</em></dt>
<dd><p>Функции рисуют отображение Пуанкаре для кривой {<var>x</var>, <var>y</var>, <var>z</var>} при условии <var>s</var>=0. Проще говоря, рисуются точки пересечения кривой и поверхности. Строка <var>stl</var> задает стиль маркеров. См. также <a href="#plot">plot</a>, <a href="#mark">mark</a>, <a href="#lamerey">lamerey</a>. См. раздел <a href="#pmap-sample">pmap sample</a>, для примеров кода и графика.
</p></dd></dl>



<hr>
<a name="g_t2D-plotting"></a>
<div class="header">
<p>
Next: <a href="#g_t3D-plotting" accesskey="n" rel="next">3D plotting</a>, Previous: <a href="#g_t1D-plotting" accesskey="p" rel="prev">1D plotting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="g_t2D-grafiki"></a>
<h3 class="section">4.12 2D графики</h3>

<a name="index-Mesh"></a>
<a name="index-Fall"></a>
<a name="index-Belt"></a>
<a name="index-Surf"></a>
<a name="index-Boxs"></a>
<a name="index-Tile"></a>
<a name="index-Dens"></a>
<a name="index-Cont"></a>
<a name="index-ContF"></a>
<a name="index-ContD"></a>
<a name="index-Axial"></a>
<a name="index-Grad"></a>
<a name="index-Grid-1"></a>

<p>Эти функции строят графики для двумерных (2D) массивов. Двумерными считаются массивы, зависящие только от двух параметров (индексов) подобно матрице <em>f(x_i,y_j), i=1...n, j=1...m</em>. По умолчанию (если отсутствуют) значения <var>x</var>, <var>y</var> равно распределены в диапазоне осей координат. Младшие размерности массивов <var>x</var>, <var>y</var>, <var>z</var> должны быть одинаковы <code>x.nx=z.nx &amp;&amp; y.nx=z.ny</code> или <code>x.nx=y.nx=z.nx &amp;&amp; x.ny=y.ny=z.ny</code>. Массивы <var>x</var> и <var>y</var> могут быть векторами (не матрицами как <var>z</var>). График строится для каждого z среза данных. Строка <var>sch</var> задает цветовую схему (см. <a href="#Color-scheme">Color scheme</a>). Строка <var>opt</var> задает опции графика (см. <a href="#Command-options">Command options</a>).
</p>
<a name="surf"></a><dl>
<dt><a name="index-surf"></a>Команда MGL: <em></em> <strong>surf</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-surf-1"></a>Команда MGL: <em></em> <strong>surf</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Surf-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрически заданную поверхность {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетка на поверхности. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#mesh">mesh</a>, <a href="#dens">dens</a>, <a href="#belt">belt</a>, <a href="#tile">tile</a>, <a href="#boxs">boxs</a>, <a href="#surfc">surfc</a>, <a href="#surfa">surfa</a>. См. раздел <a href="#surf-sample">surf sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="mesh"></a><dl>
<dt><a name="index-mesh"></a>Команда MGL: <em></em> <strong>mesh</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-mesh-1"></a>Команда MGL: <em></em> <strong>mesh</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Mesh-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mesh</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Mesh-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Mesh</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fmesh"></a>Функция С: <em><code>void</code></em> <strong>mgl_mesh</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fmesh_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_mesh_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует сетчатую поверхность, заданную параметрически {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. См. также <a href="#surf">surf</a>, <a href="#fall">fall</a>, <a href="#meshnum">meshnum</a>, <a href="#cont">cont</a>, <a href="#tens">tens</a>. См. раздел <a href="#mesh-sample">mesh sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="fall"></a><dl>
<dt><a name="index-fall"></a>Команда MGL: <em></em> <strong>fall</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-fall-1"></a>Команда MGL: <em></em> <strong>fall</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Fall-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fall</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fall-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fall</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffall"></a>Функция С: <em><code>void</code></em> <strong>mgl_fall</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffall_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_fall_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует водопад для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. График удобен для построения нескольких кривых, сдвинутых вглубь друг относительно друга. Если <var>sch</var> содержит &lsquo;<samp>x</samp>&rsquo;, то линии рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также <a href="#belt">belt</a>, <a href="#mesh">mesh</a>, <a href="#tens">tens</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#fall-sample">fall sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="belt"></a><dl>
<dt><a name="index-belt"></a>Команда MGL: <em></em> <strong>belt</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-belt-1"></a>Команда MGL: <em></em> <strong>belt</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Belt-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Belt</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Belt-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Belt</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fbelt"></a>Функция С: <em><code>void</code></em> <strong>mgl_belt</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbelt_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_belt_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует ленточки для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. График может использоваться как 3d обобщение графика <a href="#plot">plot</a>. Если <var>sch</var> содержит &lsquo;<samp>x</samp>&rsquo;, то ленточки рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также <a href="#fall">fall</a>, <a href="#surf">surf</a>, <a href="#beltc">beltc</a>, <a href="#plot">plot</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#belt-sample">belt sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="boxs"></a><dl>
<dt><a name="index-boxs"></a>Команда MGL: <em></em> <strong>boxs</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-boxs-1"></a>Команда MGL: <em></em> <strong>boxs</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Boxs-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Boxs</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Boxs-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Boxs</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fboxs"></a>Функция С: <em><code>void</code></em> <strong>mgl_boxs</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fboxs_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_boxs_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует вертикальные ящики для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. См. также <a href="#surf">surf</a>, <a href="#dens">dens</a>, <a href="#tile">tile</a>, <a href="#step">step</a>. См. раздел <a href="#boxs-sample">boxs sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tile"></a><dl>
<dt><a name="index-tile"></a>Команда MGL: <em></em> <strong>tile</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-tile-1"></a>Команда MGL: <em></em> <strong>tile</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-tile-2"></a>Команда MGL: <em></em> <strong>tile</strong> <em>xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-Tile-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tile</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tile-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tile</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Tile-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Tile</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftile"></a>Функция С: <em><code>void</code></em> <strong>mgl_tile</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftile_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_tile_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftile_005fxyc"></a>Функция С: <em><code>void</code></em> <strong>mgl_tile_xyc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует плитки для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с цветом, заданным массивом <var>c</var>[i,j]. Если строка <var>sch</var> содержит стиль &lsquo;<samp>x</samp>&rsquo; или &lsquo;<samp>y</samp>&rsquo;, то плитки будут ориентированы перпендикулярно x- или y-оси. График может использоваться как 3d обобщение <a href="#step">step</a>. См. также <a href="#surf">surf</a>, <a href="#boxs">boxs</a>, <a href="#step">step</a>, <a href="#tiles">tiles</a>. См. раздел <a href="#tile-sample">tile sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="dens"></a><dl>
<dt><a name="index-dens"></a>Команда MGL: <em></em> <strong>dens</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-dens-1"></a>Команда MGL: <em></em> <strong>dens</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Dens-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dens</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>mreal</code> zVal=<code>NAN</code>)</em></dt>
<dt><a name="index-Dens-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dens</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>mreal</code> zVal=<code>NAN</code>)</em></dt>
<dt><a name="index-mgl_005fdens"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdens_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует график плотности для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z</var> равном минимальному значению оси z. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетка. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#surf">surf</a>, <a href="#cont">cont</a>, <a href="#contf">contf</a>, <a href="#boxs">boxs</a>, <a href="#tile">tile</a>, <code>dens[xyz]</code>. См. раздел <a href="#dens-sample">dens sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="cont"></a><dl>
<dt><a name="index-cont"></a>Команда MGL: <em></em> <strong>cont</strong> <em>vdat zdat ['sch'='']</em></dt>
<dt><a name="index-cont-1"></a>Команда MGL: <em></em> <strong>cont</strong> <em>vdat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Cont-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cont-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont_005f_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont__val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fxy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_xy_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z=v</var>[k] или при <var>z</var>  равном минимальному значению оси z если <var>sch</var> содержит &lsquo;<samp>_</samp>&rsquo;. Линии уровня рисуются для <var>z</var>[i,j]=<var>v</var>[k]. Если <var>sch</var> содержит &lsquo;<samp>t</samp>&rsquo; или &lsquo;<samp>T</samp>&rsquo;, то значения <var>v</var>[k] будут выведены вдоль контуров над (или под) кривой. См. также <a href="#dens">dens</a>, <a href="#contf">contf</a>, <a href="#contd">contd</a>, <a href="#axial">axial</a>, <code>cont[xyz]</code>. См. раздел <a href="#cont-sample">cont sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-cont-2"></a>Команда MGL: <em></em> <strong>cont</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-cont-3"></a>Команда MGL: <em></em> <strong>cont</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Cont-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cont-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7). Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то будут строится только контуры по уровням седловых точек.
</p></dd></dl>

<a name="contf"></a><dl>
<dt><a name="index-contf"></a>Команда MGL: <em></em> <strong>contf</strong> <em>vdat zdat ['sch'='']</em></dt>
<dt><a name="index-contf-1"></a>Команда MGL: <em></em> <strong>contf</strong> <em>vdat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContF-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContF</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContF-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContF</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fxy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_xy_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z=v</var>[k] или при <var>z</var>  равном минимальному значению оси z если <var>sch</var> содержит &lsquo;<samp>_</samp>&rsquo;. Линии уровня рисуются для <var>z</var>[i,j]=<var>v</var>[k]. См. также <a href="#dens">dens</a>, <a href="#cont">cont</a>, <a href="#contd">contd</a>, <code>contf[xyz]</code>. См. раздел <a href="#contf-sample">contf sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-contf-2"></a>Команда MGL: <em></em> <strong>contf</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-contf-3"></a>Команда MGL: <em></em> <strong>contf</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContF-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContF</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContF-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContF</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>

<a name="contd"></a><dl>
<dt><a name="index-contd"></a>Команда MGL: <em></em> <strong>contd</strong> <em>vdat zdat ['sch'='']</em></dt>
<dt><a name="index-contd-1"></a>Команда MGL: <em></em> <strong>contd</strong> <em>vdat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContD-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContD</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContD-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContD</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontd_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contd_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontd_005fxy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contd_xy_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z=v</var>[k] или при <var>z</var>  равном минимальному значению оси z если <var>sch</var> содержит &lsquo;<samp>_</samp>&rsquo;. Линии уровня рисуются для <var>z</var>[i,j]=<var>v</var>[k]. Строка <var>sch</var> задает цвета контуров: цвет k-го контура определяется как k-ый цвет строки. См. также <a href="#dens">dens</a>, <a href="#cont">cont</a>, <a href="#contf">contf</a>. См. раздел <a href="#contd-sample">contd sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-contd-2"></a>Команда MGL: <em></em> <strong>contd</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-contd-3"></a>Команда MGL: <em></em> <strong>contd</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContD-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContD</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContD-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContD</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontd"></a>Функция С: <em><code>void</code></em> <strong>mgl_contd</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontd_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_contd_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>


<a name="contp"></a><dl>
<dt><a name="index-contp"></a>Команда MGL: <em></em> <strong>contp</strong> <em>vdat xdat ydat zdat adat ['sch'='']</em></dt>
<dt><a name="index-ContP"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContP</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontp_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contp_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. Линии уровня рисуются для <var>a</var>[i,j]=<var>v</var>[k]. Если <var>sch</var> содержит &lsquo;<samp>t</samp>&rsquo; или &lsquo;<samp>T</samp>&rsquo;, то значения <var>v</var>[k] будут выведены вдоль контуров над (или под) кривой. Если <var>sch</var> содержит &lsquo;<samp>f</samp>&rsquo;, то контуры будут закрашены. См. также <a href="#cont">cont</a>, <a href="#contf">contf</a>, <a href="#surfc">surfc</a>, <code>cont[xyz]</code>. </p></dd></dl>

<dl>
<dt><a name="index-contp-1"></a>Команда MGL: <em></em> <strong>contp</strong> <em>xdat ydat zdat adat ['sch'='']</em></dt>
<dt><a name="index-ContP-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContP</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontp"></a>Функция С: <em><code>void</code></em> <strong>mgl_contp</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>

<a name="contv"></a><dl>
<dt><a name="index-contv"></a>Команда MGL: <em></em> <strong>contv</strong> <em>vdat zdat ['sch'='']</em></dt>
<dt><a name="index-contv-1"></a>Команда MGL: <em></em> <strong>contv</strong> <em>vdat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContV"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContV</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContV-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContV</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontv_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contv_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontv_005fxy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contv_xy_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует вертикальные цилиндры от линий уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z</var>=<var>v</var>[k] или при <var>z</var>  равном минимальному значению оси z если <var>sch</var> содержит &lsquo;<samp>_</samp>&rsquo;. Линии уровня рисуются для <var>z</var>[i,j]=<var>v</var>[k]. См. также <a href="#cont">cont</a>, <a href="#contf">contf</a>. См. раздел <a href="#contv-sample">contv sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-contv-2"></a>Команда MGL: <em></em> <strong>contv</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-contv-3"></a>Команда MGL: <em></em> <strong>contv</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-ContV-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContV</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContV-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContV</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontv"></a>Функция С: <em><code>void</code></em> <strong>mgl_contv</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontv_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_contv_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>

<a name="axial"></a><dl>
<dt><a name="index-axial"></a>Команда MGL: <em></em> <strong>axial</strong> <em>vdat zdat ['sch'='']</em></dt>
<dt><a name="index-axial-1"></a>Команда MGL: <em></em> <strong>axial</strong> <em>vdat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Axial-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Axial</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Axial-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Axial</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005faxial_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_axial_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005faxial_005fxy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_axial_xy_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность вращения линии уровня для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]}. Линии уровня рисуются для <var>z</var>[i,j]=<var>v</var>[k]. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. Если строка содержит символы &lsquo;<samp>x</samp>&rsquo; или &lsquo;<samp>z</samp>&rsquo;, то ось вращения устанавливается в указанное направление (по умолчанию вдоль &lsquo;<samp>y</samp>&rsquo;). См. также <a href="#cont">cont</a>, <a href="#contf">contf</a>, <a href="#torus">torus</a>, <a href="#surf3">surf3</a>. См. раздел <a href="#axial-sample">axial sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-axial-2"></a>Команда MGL: <em></em> <strong>axial</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-axial-3"></a>Команда MGL: <em></em> <strong>axial</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Axial-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Axial</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>int</code> num=<code>3</code>)</em></dt>
<dt><a name="index-Axial-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Axial</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>int</code> num=<code>3</code>)</em></dt>
<dt><a name="index-mgl_005faxial"></a>Функция С: <em><code>void</code></em> <strong>mgl_axial</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005faxial_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_axial_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Как предыдущий с вектором <var>v</var> из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 3).
</p></dd></dl>

<a name="grid2"></a><dl>
<dt><a name="index-grid2"></a>Команда MGL: <em></em> <strong>grid2</strong> <em>zdat ['sch'='']</em></dt>
<dt><a name="index-grid2-1"></a>Команда MGL: <em></em> <strong>grid2</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Grid-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grid</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Grid-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grid</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fgrid"></a>Функция С: <em><code>void</code></em> <strong>mgl_grid</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fgrid_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_grid_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует плоскую сету для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} при <var>z</var> равном минимальному значению оси z. См. также <a href="#dens">dens</a>, <a href="#cont">cont</a>, <a href="#contf">contf</a>, <a href="#grid3">grid3</a>, <a href="#meshnum">meshnum</a>.
</p></dd></dl>



<hr>
<a name="g_t3D-plotting"></a>
<div class="header">
<p>
Next: <a href="#Dual-plotting" accesskey="n" rel="next">Dual plotting</a>, Previous: <a href="#g_t2D-plotting" accesskey="p" rel="prev">2D plotting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="g_t3D-grafiki"></a>
<h3 class="section">4.13 3D графики</h3>

<a name="index-Surf3"></a>
<a name="index-Dens3"></a>
<a name="index-Cont3"></a>
<a name="index-ContF3"></a>
<a name="index-Grid3"></a>
<a name="index-Cloud"></a>
<a name="index-Beam"></a>

<p>Эти функции строят графики для трехмерных (3D) массивов. Трёхмерными считаются массивы, зависящие от трёх параметров (индексов) подобно матрице <em>f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l</em>. По умолчанию (если отсутствуют) значения <var>x</var>, <var>y</var>, <var>z</var> равно распределены в диапазоне осей координат. Младшие размерности массивов <var>x</var>, <var>y</var>, <var>z</var> должны быть одинаковы <code>x.nx=a.nx &amp;&amp; y.nx=a.ny &amp;&amp; z.nz=a.nz</code> или <code>x.nx=y.nx=z.nx=a.nx &amp;&amp; x.ny=y.ny=z.ny=a.ny &amp;&amp; x.nz=y.nz=z.nz=a.nz</code>. Массивы <var>x</var>, <var>y</var> и <var>z</var> могут быть векторами (не матрицами как <var>a</var>). Строка <var>sch</var> задает цветовую схему (см. <a href="#Color-scheme">Color scheme</a>). Строка <var>opt</var> задает опции графика (см. <a href="#Command-options">Command options</a>).
</p>

<a name="surf3"></a><dl>
<dt><a name="index-surf3"></a>Команда MGL: <em></em> <strong>surf3</strong> <em>adat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-surf3-1"></a>Команда MGL: <em></em> <strong>surf3</strong> <em>xdat ydat zdat adat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-Surf3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) при <var>a</var>(x,y,z)=<var>val</var>. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. Замечу, что возможно некорректная отрисовка граней вследствие неопределённости построения сечения если поверхность пересекает ячейку данных 2 и более раз. См. также <a href="#cloud">cloud</a>, <a href="#dens3">dens3</a>, <a href="#surf3c">surf3c</a>, <a href="#surf3a">surf3a</a>, <a href="#axial">axial</a>. См. раздел <a href="#surf3-sample">surf3 sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-surf3-2"></a>Команда MGL: <em></em> <strong>surf3</strong> <em>adat ['sch'='']</em></dt>
<dt><a name="index-surf3-3"></a>Команда MGL: <em></em> <strong>surf3</strong> <em>xdat ydat zdat adat ['sch'='']</em></dt>
<dt><a name="index-Surf3-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 3).
</p></dd></dl>

<a name="cloud"></a><dl>
<dt><a name="index-cloud"></a>Команда MGL: <em></em> <strong>cloud</strong> <em>adat ['sch'='']</em></dt>
<dt><a name="index-cloud-1"></a>Команда MGL: <em></em> <strong>cloud</strong> <em>xdat ydat zdat adat ['sch'='']</em></dt>
<dt><a name="index-Cloud-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cloud</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cloud-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cloud</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcloud"></a>Функция С: <em><code>void</code></em> <strong>mgl_cloud</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcloud_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_cloud_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует облачный график для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]). График состоит из кубиков с цветом и прозрачностью пропорциональной значениям <var>a</var>. Результат похож на облако &ndash; малые значения прозрачны, а большие нет. Число кубиков зависит от <a href="#meshnum">meshnum</a>. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то будет построен график более низкого качества, но с заметно меньшим использованием памяти. Если <var>sch</var> содержит &lsquo;<samp>i</samp>&rsquo;, то прозрачность будет инвертирована, т.е. области с более высокими значениями будут более прозрачны, а с более низким &ndash; менее прозрачны. См. также <a href="#surf3">surf3</a>, <a href="#meshnum">meshnum</a>. См. раздел <a href="#cloud-sample">cloud sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="dens3"></a><dl>
<dt><a name="index-dens3"></a>Команда MGL: <em></em> <strong>dens3</strong> <em>adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-dens3-1"></a>Команда MGL: <em></em> <strong>dens3</strong> <em>xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Dens3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dens3</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Dens3-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dens3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdens3"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdens3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует график плотности для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]). График рисуется на срезе <var>sVal</var> в направлении {&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;}, указанном в строке <var>sch</var> (по умолчанию, в напралении &lsquo;<samp>y</samp>&rsquo;). Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на срезе рисуется сетка. См. также <a href="#cont3">cont3</a>, <a href="#contf3">contf3</a>, <a href="#dens">dens</a>, <a href="#grid3">grid3</a>. См. раздел <a href="#dens3-sample">dens3 sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="cont3"></a><dl>
<dt><a name="index-cont3"></a>Команда MGL: <em></em> <strong>cont3</strong> <em>vdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-cont3-1"></a>Команда MGL: <em></em> <strong>cont3</strong> <em>vdat xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Cont3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont3</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cont3-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont3</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont3_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont3_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont3_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont3_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]). Линии рисуются для значений из массива <var>v</var> на срезе <var>sVal</var> в направлении {&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;}, указанном в строке <var>sch</var> (по умолчанию, в напралении &lsquo;<samp>y</samp>&rsquo;). Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на срезе рисуется сетка. Если <var>sch</var> содержит &lsquo;<samp>t</samp>&rsquo; или &lsquo;<samp>T</samp>&rsquo;, то значения <var>v</var>[k] будут выведены вдоль контуров над (или под) кривой. См. также <a href="#dens3">dens3</a>, <a href="#contf3">contf3</a>, <a href="#cont">cont</a>, <a href="#grid3">grid3</a>. См. раздел <a href="#cont3-sample">cont3 sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-cont3-2"></a>Команда MGL: <em></em> <strong>cont3</strong> <em>adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-cont3-3"></a>Команда MGL: <em></em> <strong>cont3</strong> <em>xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Cont3-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont3</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Cont3-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Cont3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont3"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> линий уровня равномерно распределённых в диапазоне изменения цвета. Величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>

<a name="contf3"></a><dl>
<dt><a name="index-contf3"></a>Команда MGL: <em></em> <strong>contf3</strong> <em>vdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-contf3-1"></a>Команда MGL: <em></em> <strong>contf3</strong> <em>vdat xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Contf3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Contf3</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Contf3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Contf3</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf3_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf3_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf3_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf3_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует закрашенные линии (контуры) уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]). Линии рисуются для значений из массива <var>v</var> на срезе <var>sVal</var> в направлении {&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;}, указанном в строке <var>sch</var> (по умолчанию, в напралении &lsquo;<samp>y</samp>&rsquo;). Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на срезе рисуется сетка. См. также <a href="#dens3">dens3</a>, <a href="#cont3">cont3</a>, <a href="#contf">contf</a>, <a href="#grid3">grid3</a>. См. раздел <a href="#contf3-sample">contf3 sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-contf3-2"></a>Команда MGL: <em></em> <strong>contf3</strong> <em>adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-contf3-3"></a>Команда MGL: <em></em> <strong>contf3</strong> <em>xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Contf3-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Contf3</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Contf3-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Contf3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf3"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> закрашенных линий (контуров) уровня равномерно распределённых в диапазоне изменения цвета. Величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7).
</p></dd></dl>

<a name="grid3"></a><dl>
<dt><a name="index-grid3"></a>Команда MGL: <em></em> <strong>grid3</strong> <em>adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-grid3-1"></a>Команда MGL: <em></em> <strong>grid3</strong> <em>xdat ydat zdat adat ['sch'='' <code>sval=-1</code>]</em></dt>
<dt><a name="index-Grid3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grid3</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Grid3-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grid3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fgrid3"></a>Функция С: <em><code>void</code></em> <strong>mgl_grid3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fgrid3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_grid3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует сетку для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]). График рисуется на срезе <var>sVal</var> в направлении {&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;}, указанном в строке <var>sch</var> (по умолчанию, в напралении &lsquo;<samp>y</samp>&rsquo;). См. также <a href="#cont3">cont3</a>, <a href="#contf3">contf3</a>, <a href="#dens3">dens3</a>, <a href="#grid2">grid2</a>, <a href="#meshnum">meshnum</a>.
</p></dd></dl>

<a name="beam"></a><dl>
<dt><a name="index-beam"></a>Команда MGL: <em></em> <strong>beam</strong> <em>tr g1 g2 adat <code>rval</code> ['sch'='' <code>flag=0 num=3</code>]</em></dt>
<dt><a name="index-Beam-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Beam</strong> <em>(<code>const mglDataA &amp;</code>tr, <code>const mglDataA &amp;</code>g1, <code>const mglDataA &amp;</code>g2, <code>const mglDataA &amp;</code>a, <code>mreal</code> r, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>int</code> flag=<code>0</code>, <code>int</code> num=<code>3</code>)</em></dt>
<dt><a name="index-Beam-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Beam</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>tr, <code>const mglDataA &amp;</code>g1, <code>const mglDataA &amp;</code>g2, <code>const mglDataA &amp;</code>a, <code>mreal</code> r, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>int</code> flag=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fbeam"></a>Функция С: <em><code>void</code></em> <strong>mgl_beam</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> tr, <code>HCDT</code> g1, <code>HCDT</code> g2, <code>HCDT</code> a, <code>mreal</code> r, <code>const char *</code>stl, <code>int</code> flag, <code>int</code> num)</em></dt>
<dt><a name="index-mgl_005fbeam_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_beam_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> tr, <code>HCDT</code> g1, <code>HCDT</code> g2, <code>HCDT</code> a, <code>mreal</code> r, <code>const char *</code>stl, <code>int</code> flag)</em></dt>
<dd><p>Рисует поверхность уровня для 3d массива <var>a</var> при постоянном значении <var>a</var>=<var>val</var>. Это специальный тип графика для <var>a</var> заданного в сопровождающей системе координат вдоль кривой <var>tr</var> с ортами <var>g1</var>, <var>g2</var> и с поперечным размером <var>r</var>. Переменная <var>flag</var> &ndash; битовый флаг: &lsquo;<samp>0x1</samp>&rsquo; - рисовать в сопровождающих (не лабораторных) координатах; &lsquo;<samp>0x2</samp>&rsquo; - рисовать проекцию на плоскость <em>\rho-z</em>; &lsquo;<samp>0x4</samp>&rsquo; - рисовать нормированное в каждом сечении поле. Размеры массивов по 1-му индексу <var>tr</var>, <var>g1</var>, <var>g2</var> должны быть nx&gt;2. Размеры массивов по 2-му индексу <var>tr</var>, <var>g1</var>, <var>g2</var> и размер по 3-му индексу массива <var>a</var> должны быть одинаковы. См. также <a href="#surf3">surf3</a>.
</p></dd></dl>



<hr>
<a name="Dual-plotting"></a>
<div class="header">
<p>
Next: <a href="#Vector-fields" accesskey="n" rel="next">Vector fields</a>, Previous: <a href="#g_t3D-plotting" accesskey="p" rel="prev">3D plotting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Parnye-grafiki"></a>
<h3 class="section">4.14 Парные графики</h3>

<a name="index-SurfC"></a>
<a name="index-SurfA"></a>
<a name="index-Surf3C"></a>
<a name="index-Surf3A"></a>
<a name="index-TileS"></a>
<a name="index-Map"></a>
<a name="index-STFA"></a>

<p>Эти функции строят графики для двух связанных массивов. Есть несколько основных типов 3D графиков: поверхность и поверхность уровня с окраской по второму массиву (SurfC, Surf3C), поверхность и поверхность уровня с прозрачностью по второму массиву (SurfA, Surf3A), плитки переменного размера (TileS), диаграмма точечного отображения (Map), STFA диаграмма (STFA). По умолчанию (если отсутствуют) значения <var>x</var>, <var>y</var> (и <var>z</var> для <code>Surf3C, Surf3A</code>) равно распределены в диапазоне осей координат. Младшие размерности массивов <var>x</var>, <var>y</var>, <var>z</var>, <var>c</var> должны быть одинаковы <code>x.nx=a.nx &amp;&amp; y.nx=a.ny &amp;&amp; z.nz=a.nz</code> или <code>x.nx=y.nx=z.nx=a.nx &amp;&amp; x.ny=y.ny=z.ny=a.ny &amp;&amp; x.nz=y.nz=z.nz=a.nz</code>. Массивы <var>x</var>, <var>y</var> (и <var>z</var> для <code>Surf3C, Surf3A</code>) могут быть векторами (не матрицами как <var>c</var>). Строка <var>sch</var> задает цветовую схему (см. <a href="#Color-scheme">Color scheme</a>). Строка <var>opt</var> задает опции графика (см. <a href="#Command-options">Command options</a>).
</p>

<a name="surfc"></a><dl>
<dt><a name="index-surfc"></a>Команда MGL: <em></em> <strong>surfc</strong> <em>zdat cdat ['sch'='']</em></dt>
<dt><a name="index-surfc-1"></a>Команда MGL: <em></em> <strong>surfc</strong> <em>xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-SurfC-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfC</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-SurfC-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfC</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurfc"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurfc_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfc_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрически заданную поверхность {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с цветом, заданным массивом <var>c</var>[i,j]. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на поверхности рисуется сетка. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. Размерность массивов <var>z</var> и <var>c</var> должна быть одинакова. График строится для каждого z среза данных. См. также <a href="#surf">surf</a>, <a href="#surfa">surfa</a>, <a href="#beltc">beltc</a>, <a href="#surf3c">surf3c</a>. См. раздел <a href="#surfc-sample">surfc sample</a>, для примеров кода и графика.
</p></dd></dl>


<a name="beltc"></a><dl>
<dt><a name="index-beltc"></a>Команда MGL: <em></em> <strong>beltc</strong> <em>zdat cdat ['sch'='']</em></dt>
<dt><a name="index-beltc-1"></a>Команда MGL: <em></em> <strong>beltc</strong> <em>xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-BeltC"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>BeltC</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-BeltC-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>BeltC</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fbeltc"></a>Функция С: <em><code>void</code></em> <strong>mgl_beltc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fbeltc_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_beltc_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует ленточки для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с цветом, заданным массивом <var>c</var>[i,j]. График может использоваться как 3d обобщение графика <a href="#plot">plot</a>. Если <var>sch</var> содержит &lsquo;<samp>x</samp>&rsquo;, то ленточки рисуются вдоль оси x, иначе (по умолчанию) вдоль оси y. См. также <a href="#belt">belt</a>, <a href="#surfc">surfc</a>, <a href="#meshnum">meshnum</a>. </p></dd></dl>


<a name="surf3c"></a><dl>
<dt><a name="index-surf3c"></a>Команда MGL: <em></em> <strong>surf3c</strong> <em>adat cdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-surf3c-1"></a>Команда MGL: <em></em> <strong>surf3c</strong> <em>xdat ydat zdat adat cdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-Surf3C-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3C</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3C-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3C</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3c_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3c_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3c_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3c_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) при <var>a</var>(x,y,z)=<var>val</var>. Аналогично <a href="#surf3">surf3</a>, но цвет задается массивом <var>c</var>. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#surf3">surf3</a>, <a href="#surfc">surfc</a>, <a href="#surf3a">surf3a</a>. См. раздел <a href="#surf3c-sample">surf3c sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-surf3c-2"></a>Команда MGL: <em></em> <strong>surf3c</strong> <em>adat cdat ['sch'='']</em></dt>
<dt><a name="index-surf3c-3"></a>Команда MGL: <em></em> <strong>surf3c</strong> <em>xdat ydat zdat adat cdat ['sch'='']</em></dt>
<dt><a name="index-Surf3C-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3C</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3C-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3C</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3c"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3c</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3c_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3c_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 3).
</p></dd></dl>


<a name="surfa"></a><dl>
<dt><a name="index-surfa"></a>Команда MGL: <em></em> <strong>surfa</strong> <em>zdat cdat ['sch'='']</em></dt>
<dt><a name="index-surfa-1"></a>Команда MGL: <em></em> <strong>surfa</strong> <em>xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-SurfA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfA</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-SurfA-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfA</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurfa"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfa</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurfa_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfa_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрически заданную поверхность {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с прозрачностью, заданной массивом <var>c</var>[i,j]. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на поверхности рисуется сетка. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. Размерность массивов <var>z</var> и <var>c</var> должна быть одинакова. График строится для каждого z среза данных. См. также <a href="#surf">surf</a>, <a href="#surfc">surfc</a>, <a href="#surf3a">surf3a</a>. См. раздел <a href="#surfa-sample">surfa sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="surf3a"></a><dl>
<dt><a name="index-surf3a"></a>Команда MGL: <em></em> <strong>surf3a</strong> <em>adat cdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-surf3a-1"></a>Команда MGL: <em></em> <strong>surf3a</strong> <em>xdat ydat zdat adat cdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-Surf3A-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3A</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3A-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3A</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3a_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3a_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3a_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3a_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) при <var>a</var>(x,y,z)=<var>val</var>. Аналогично <a href="#surf3">surf3</a>, но прозрачность задается массивом <var>c</var>. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#surf3">surf3</a>, <a href="#surfc">surfc</a>, <a href="#surf3a">surf3a</a>. См. раздел <a href="#surf3a-sample">surf3a sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-surf3a-2"></a>Команда MGL: <em></em> <strong>surf3a</strong> <em>adat cdat ['sch'='']</em></dt>
<dt><a name="index-surf3a-3"></a>Команда MGL: <em></em> <strong>surf3a</strong> <em>xdat ydat zdat adat cdat ['sch'='']</em></dt>
<dt><a name="index-Surf3A-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3A</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3A-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3A</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3a"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3a</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3a_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3a_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> поверхностей уровня равномерно распределённых в диапазоне изменения цвета. При этом массив <var>c</var> может быть вектором со значениями прозрачности и <var>num</var>=<var>c</var>.nx. В противном случае величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 3).
</p></dd></dl>



<a name="surfca"></a><dl>
<dt><a name="index-surfca"></a>Команда MGL: <em></em> <strong>surfca</strong> <em>zdat cdat adat ['sch'='']</em></dt>
<dt><a name="index-surfca-1"></a>Команда MGL: <em></em> <strong>surfca</strong> <em>xdat ydat zdat cdat adat ['sch'='']</em></dt>
<dt><a name="index-SurfCA"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfCA</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-SurfCA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>SurfCA</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurfca"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfca</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>HCDT</code> c, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurfca_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_surfca_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрически заданную поверхность {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с цветом и прозрачностью, заданными массивами <var>c</var>[i,j] и <var>a</var>[i,j] соответственно. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то на поверхности рисуется сетка. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. Размерность массивов <var>z</var> и <var>c</var> должна быть одинакова. График строится для каждого z среза данных. См. также <a href="#surf">surf</a>, <a href="#surfc">surfc</a>, <a href="#surfa">surfa</a>, <a href="#surf3ca">surf3ca</a>. См. раздел <a href="#surfca-sample">surfca sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="surf3ca"></a><dl>
<dt><a name="index-surf3ca"></a>Команда MGL: <em></em> <strong>surf3ca</strong> <em>adat cdat bdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-surf3ca-1"></a>Команда MGL: <em></em> <strong>surf3ca</strong> <em>xdat ydat zdat adat cdat bdat <code>val</code> ['sch'='']</em></dt>
<dt><a name="index-Surf3CA"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3CA</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>b, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3CA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3CA</strong> <em>(<code>mreal</code> val, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>b, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3ca_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3ca_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> a, <code>HCDT</code> c, <code>HCDT</code> b, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3ca_005fxyz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3ca_xyz_val</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> val, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>HCDT</code> b, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность уровня для 3d массива, заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) при <var>a</var>(x,y,z)=<var>val</var>. Аналогично <a href="#surf3">surf3</a>, но цвет и прозрачность задается массивами <var>c</var> и <var>b</var> соответственно. Если <var>sch</var> содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то рисуется поверхность из точек. См. также <a href="#surf3">surf3</a>, <a href="#surfc">surfc</a>, <a href="#surf3a">surf3a</a>. См. раздел <a href="#surf3a-sample">surf3a sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-surf3ca-2"></a>Команда MGL: <em></em> <strong>surf3ca</strong> <em>adat cdat ['sch'='']</em></dt>
<dt><a name="index-surf3ca-3"></a>Команда MGL: <em></em> <strong>surf3ca</strong> <em>xdat ydat zdat adat cdat ['sch'='']</em></dt>
<dt><a name="index-Surf3CA-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3CA</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>b, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Surf3CA-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Surf3CA</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>b, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fsurf3ca"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3ca</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>HCDT</code> c, <code>HCDT</code> b, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fsurf3ca_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_surf3ca_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> c, <code>HCDT</code> b, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему для <var>num</var> поверхностей уровня равномерно распределённых в диапазоне изменения цвета. Здесь величина <var>num</var> равна значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 3).
</p></dd></dl>


<a name="tiles"></a><dl>
<dt><a name="index-tiles"></a>Команда MGL: <em></em> <strong>tiles</strong> <em>zdat rdat ['sch'='']</em></dt>
<dt><a name="index-tiles-1"></a>Команда MGL: <em></em> <strong>tiles</strong> <em>xdat ydat zdat rdat ['sch'='']</em></dt>
<dt><a name="index-tiles-2"></a>Команда MGL: <em></em> <strong>tiles</strong> <em>xdat ydat zdat rdat cdat ['sch'='']</em></dt>
<dt><a name="index-TileS-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TileS</strong> <em>(<code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TileS-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TileS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TileS-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TileS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>r, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftiles"></a>Функция С: <em><code>void</code></em> <strong>mgl_tiles</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftiles_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_tiles_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftiles_005fxyc"></a>Функция С: <em><code>void</code></em> <strong>mgl_tiles_xyc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> r, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует плитки для параметрически заданной поверхности {<var>x</var>[i,j], <var>y</var>[i,j], <var>z</var>[i,j]} с цветом, заданным массивом <var>c</var>[i,j]. Аналогично Tile(), но размер плиток задается массивов <var>r</var>. Если строка <var>sch</var> содержит стиль &lsquo;<samp>x</samp>&rsquo; или &lsquo;<samp>y</samp>&rsquo;, то плитки будут ориентированы перпендикулярно x- или y-оси. Это создает эффект &quot;прозрачности&quot; при экспорте в файлы EPS. График строится для каждого z среза данных. См. также <a href="#surfa">surfa</a>, <a href="#tile">tile</a>. См. раздел <a href="#tiles-sample">tiles sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="map"></a><dl>
<dt><a name="index-map"></a>Команда MGL: <em></em> <strong>map</strong> <em>udat vdat ['sch'='']</em></dt>
<dt><a name="index-map-1"></a>Команда MGL: <em></em> <strong>map</strong> <em>xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-Map-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Map</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Map-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Map</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fmap"></a>Функция С: <em><code>void</code></em> <strong>mgl_map</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fmap_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_map_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует точечное отображение для матриц {<var>ax</var>, <var>ay</var> } параметрически зависящих от координат <var>x</var>, <var>y</var>. Исходное положение ячейки задает ее цвет. Высота пропорциональна якобиану J(ax,ay). График является аналогом диаграммы Арнольда ??? Если <var>sch</var> содержит &lsquo;<samp>.</samp>&rsquo;, то цветные точки рисуются в узлах матриц (полезно для &quot;запутанного&quot; отображения), иначе рисуются грани. См. раздел <a href="#Mapping-visualization">Mapping visualization</a>, для примеров кода и графика.
</p></dd></dl>

<a name="stfa"></a><dl>
<dt><a name="index-stfa"></a>Команда MGL: <em></em> <strong>stfa</strong> <em>re im <code>dn</code> ['sch'='']</em></dt>
<dt><a name="index-stfa-1"></a>Команда MGL: <em></em> <strong>stfa</strong> <em>xdat ydat re im <code>dn</code> ['sch'='']</em></dt>
<dt><a name="index-STFA-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>STFA</strong> <em>(<code>const mglDataA &amp;</code>re, <code>const mglDataA &amp;</code>im, <code>int</code> dn, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-STFA-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>STFA</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>re, <code>const mglDataA &amp;</code>im, <code>int</code> dn, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fstfa"></a>Функция С: <em><code>void</code></em> <strong>mgl_stfa</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> re, <code>HCDT</code> im, <code>int</code> dn, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fstfa_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_stfa_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> re, <code>HCDT</code> im, <code>int</code> dn, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует спектрограмму комплексного массива <var>re</var>+i*<var>im</var> для Фурье размером <var>dn</var> точек в плоскости <var>z</var> равно минимальному значению оси z. Параметр <var>dn</var> &ndash; любое чётное число. Например в 1D случае, результатом будет график плотности от массива <em>res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn</em> размером {int(nx/dn), dn, ny}. Массивы <var>re</var>, <var>im</var> параметрически зависят от координат <var>x</var>, <var>y</var>. Все размеры массивов <var>re</var> и <var>im</var> должны быть одинаковы. Младшие размерности массивов <var>x</var>, <var>y</var>, <var>re</var> должны быть одинаковы. Массивы <var>x</var> и <var>y</var> могут быть векторами (не матрицами как <var>re</var>). См. раздел <a href="#stfa-sample">stfa sample</a>, для примеров кода и графика.
</p></dd></dl>



<hr>
<a name="Vector-fields"></a>
<div class="header">
<p>
Next: <a href="#Other-plotting" accesskey="n" rel="next">Other plotting</a>, Previous: <a href="#Dual-plotting" accesskey="p" rel="prev">Dual plotting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Vektornye-polya"></a>
<h3 class="section">4.15 Векторные поля</h3>

<a name="index-Traj"></a>
<a name="index-Vect"></a>
<a name="index-Dew"></a>
<a name="index-Flow"></a>
<a name="index-FlowP"></a>
<a name="index-Pipe"></a>

<p>Эти функции рисуют графики для 2D и 3D векторных полей. Есть несколько типов графиков: просто векторное поле (Vect), вектора вдоль траектории (Traj), векторное поле каплями (Dew), нити тока (Flow, FlowP), трубки тока (Pipe). По умолчанию (если отсутствуют) значения <var>x</var>, <var>y</var> и <var>z</var> равно распределены в диапазоне осей координат. Младшие размерности массивов <var>x</var>, <var>y</var>, <var>z</var> и <var>ax</var> должны быть одинаковы. Размеры массивов <var>ax</var>, <var>ay</var> и <var>az</var> должны быть одинаковы. Массивы <var>x</var>, <var>y</var> и <var>z</var> могут быть векторами (не матрицами как <var>ax</var>). Строка <var>sch</var> задает цветовую схему (см. <a href="#Color-scheme">Color scheme</a>). Строка <var>opt</var> задает опции графика (см. <a href="#Command-options">Command options</a>).
</p>
<a name="traj"></a><dl>
<dt><a name="index-traj"></a>Команда MGL: <em></em> <strong>traj</strong> <em>xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-traj-1"></a>Команда MGL: <em></em> <strong>traj</strong> <em>xdat ydat zdat udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-Traj-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Traj</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Traj-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Traj</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftraj_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_traj_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code>x, <code>HCDT</code>y, <code>HCDT</code>z, <code>HCDT</code>ax, <code>HCDT</code>ay, <code>HCDT</code>az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftraj_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_traj_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code>x, <code>HCDT</code>y, <code>HCDT</code>ax, <code>HCDT</code>ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует вектора {<var>ax</var>, <var>ay</var>, <var>az</var>} вдоль кривой {<var>x</var>, <var>y</var>, <var>z</var>}. Длина векторов пропорциональна <em>\sqrt{ax^2+ay^2+az^2}</em>. Строка <var>pen</var> задает цвет (см. <a href="#Line-styles">Line styles</a>). По умолчанию (<code>pen=&quot;&quot;</code>) используется текущий цвет из палитры (см. <a href="#Palette-and-colors">Palette and colors</a>). Опция <code>value</code> задает фактор длины векторов (если не нуль) или выбирать длину пропорционально расстоянию между точками кривой (если <code>value=0</code>). Размер по 1-му индексу должен быть 2 или больше. График рисуется для каждой строки если один из массивов матрица. См. также <a href="#vect">vect</a>. См. раздел <a href="#traj-sample">traj sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="vect"></a><dl>
<dt><a name="index-vect"></a>Команда MGL: <em></em> <strong>vect</strong> <em>udat vdat ['sch'='']</em></dt>
<dt><a name="index-vect-1"></a>Команда MGL: <em></em> <strong>vect</strong> <em>xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-Vect-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Vect-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fvect_005f2d"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect_2d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fvect_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует векторное поле {<var>ax</var>, <var>ay</var>} параметрически зависящее от координат <var>x</var>, <var>y</var> на плоскости при <var>z</var> равном минимальному значению оси z. Длина и цвет векторов пропорциональна <em>\sqrt{ax^2+ay^2}</em>. Число рисуемых векторов зависит от <a href="#meshnum">meshnum</a>. Вид стрелок/штрихов может быть изменён символами:
</p><ul>
<li> &lsquo;<samp>f</samp>&rsquo; для стрелок одинаковой длины,
</li><li> &lsquo;<samp>&gt;</samp>&rsquo;, &lsquo;<samp>&lt;</samp>&rsquo; для стрелок начинающихся или заканчивающихся в ячейке сетки (по умолчанию центрированы),
</li><li> &lsquo;<samp>.</samp>&rsquo; для рисования штрихов с точкой в начале вместо стрелок,
</li><li> &lsquo;<samp>=</samp>&rsquo; для использования градиента цвета вдоль стрелок.
</li></ul>
<p>См. также <a href="#flow">flow</a>, <a href="#dew">dew</a>. См. раздел <a href="#vect-sample">vect sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-vect-2"></a>Команда MGL: <em></em> <strong>vect</strong> <em>udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-vect-3"></a>Команда MGL: <em></em> <strong>vect</strong> <em>xdat ydat zdat udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-Vect-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Vect-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fvect_005f3d"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect_3d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fvect_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Это 3d версия графика. Здесь массивы <var>ax</var>, <var>ay</var>, <var>az</var> должны трёхмерными тензорами и длина вектора пропорциональна <em>\sqrt{ax^2+ay^2+az^2}</em>.
</p></dd></dl>

<a name="vect3"></a><dl>
<dt><a name="index-vect3"></a>Команда MGL: <em></em> <strong>vect3</strong> <em>udat vdat wdat ['sch'='' sval]</em></dt>
<dt><a name="index-vect3-1"></a>Команда MGL: <em></em> <strong>vect3</strong> <em>xdat ydat zdat udat vdat wdat ['sch'='' sval]</em></dt>
<dt><a name="index-Vect3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect3</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Vect3-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Vect3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fvect3"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fvect3_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_vect3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует 3D векторное поле {<var>ax</var>, <var>ay</var>, <var>az</var>} параметрически зависящее от координат <var>x</var>, <var>y</var>, <var>z</var>. График рисуется на срезе <var>sVal</var> в направлении {&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;}, указанном в строке <var>sch</var> (по умолчанию, в напралении &lsquo;<samp>y</samp>&rsquo;). Длина и цвет векторов пропорциональна <em>\sqrt{ax^2+ay^2+az^2}</em>. Число рисуемых векторов зависит от <a href="#meshnum">meshnum</a>. Вид стрелок/штрихов может быть изменён символами:
</p><ul>
<li> &lsquo;<samp>f</samp>&rsquo; для стрелок одинаковой длины,
</li><li> &lsquo;<samp>&gt;</samp>&rsquo;, &lsquo;<samp>&lt;</samp>&rsquo; для стрелок начинающихся или заканчивающихся в ячейке сетки (по умолчанию центрированы),
</li><li> &lsquo;<samp>.</samp>&rsquo; для рисования штрихов с точкой в начале вместо стрелок,
</li><li> &lsquo;<samp>=</samp>&rsquo; для использования градиента цвета вдоль стрелок.
</li></ul>
<p>См. также <a href="#vect">vect</a>, <a href="#flow">flow</a>, <a href="#dew">dew</a>. См. раздел <a href="#vect-sample">vect sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="dew"></a><dl>
<dt><a name="index-dew"></a>Команда MGL: <em></em> <strong>dew</strong> <em>udat vdat ['sch'='']</em></dt>
<dt><a name="index-dew-1"></a>Команда MGL: <em></em> <strong>dew</strong> <em>xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-Dew-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dew</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Dew-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dew</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdew"></a>Функция С: <em><code>void</code></em> <strong>mgl_dew</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdew_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_dew_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует капли для векторного поля {<var>ax</var>, <var>ay</var>}, параметрически зависящего от координат <var>x</var>, <var>y</var> при <var>z</var> равном минимальному значению оси z. Замечу, что график требует много памяти и процессорного времени для своего создания! Цвет капель пропорционален <em>\sqrt{ax^2+ay^2}</em>. Число капель определяется <a href="#meshnum">meshnum</a>. См. также <a href="#vect">vect</a>. См. раздел <a href="#dew-sample">dew sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="flow"></a><dl>
<dt><a name="index-flow"></a>Команда MGL: <em></em> <strong>flow</strong> <em>udat vdat ['sch'='']</em></dt>
<dt><a name="index-flow-1"></a>Команда MGL: <em></em> <strong>flow</strong> <em>xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-Flow-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Flow-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fflow_005f2d"></a>Функция С: <em><code>void</code></em> <strong>mgl_flow_2d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fflow_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_flow_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует нити тока для векторного поля {<var>ax</var>, <var>ay</var>}, параметрически зависящего от координат <var>x</var>, <var>y</var> на плоскости при <var>z</var> равном минимальному значению оси z. Число нитей пропорционально значению опции <code>value</code> (по умолчанию 5). Цвет нитей пропорционален <em>\sqrt{ax^2+ay^2}</em>. Строка <var>sch</var> может содержать
</p><ul>
<li> цветовую схему &ndash; тёплые цвета соответствуют нормальному току (типа стока), холодные цвета соответствуют обратному току (типа источника);
</li><li> &lsquo;<samp>#</samp>&rsquo; для использования нитей, начинающихся только на границе;
</li><li> &lsquo;<samp>.</samp>&rsquo; для рисования сепаратрис (нитей из/в стационарных точек).
</li><li> &lsquo;<samp>*</samp>&rsquo; для использования нитей, начинающихся с двумерной сетки внутри данных;
</li><li> &lsquo;<samp>v</samp>&rsquo; для рисования стрелок на нитях;
</li><li> &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; для рисования лент нормалей, начинающихся в плоскостях x-y и y-z соответственно.
</li></ul>
<p>См. также <a href="#pipe">pipe</a>, <a href="#vect">vect</a>, <a href="#tape">tape</a>, <a href="#flow3">flow3</a>, <a href="#barwidth">barwidth</a>. См. раздел <a href="#flow-sample">flow sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-flow-2"></a>Команда MGL: <em></em> <strong>flow</strong> <em>udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-flow-3"></a>Команда MGL: <em></em> <strong>flow</strong> <em>xdat ydat zdat udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-Flow-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Flow-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fflow_005f3d"></a>Функция С: <em><code>void</code></em> <strong>mgl_flow_3d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fflow_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_flow_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Это 3d версия графика. Здесь массивы должны трёхмерными тензорами и цвет пропорционален <em>\sqrt{ax^2+ay^2+az^2}</em>.
</p></dd></dl>

<dl>
<dt><a name="index-flow-4"></a>Команда MGL: <em></em> <strong>flow</strong> <em><code>x0 y0</code> udat vdat ['sch'='']</em></dt>
<dt><a name="index-flow-5"></a>Команда MGL: <em></em> <strong>flow</strong> <em><code>x0 y0</code> xdat ydat udat vdat ['sch'='']</em></dt>
<dt><a name="index-FlowP-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FlowP</strong> <em>(<code>mglPoint</code> p0, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FlowP-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FlowP</strong> <em>(<code>mglPoint</code> p0, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fflowp_005f2d"></a>Функция С: <em><code>void</code></em> <strong>mgl_flowp_2d</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fflowp_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_flowp_xy</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично <a href="#flow">flow</a>, но рисует одну нить из точки <var>p0</var>={<var>x0</var>,<var>y0</var>,<var>z0</var>}. Строка <var>sch</var> также может содержать: &lsquo;<samp>&gt;</samp>&rsquo; или &lsquo;<samp>&lt;</samp>&rsquo; для рисования линии тока только вперед или только назад от заданной точки (по умолчанию, рисует в обе стороны).
</p></dd></dl>

<dl>
<dt><a name="index-flow-6"></a>Команда MGL: <em></em> <strong>flow</strong> <em><code>x0 y0 z0</code> udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-flow-7"></a>Команда MGL: <em></em> <strong>flow</strong> <em><code>x0 y0 z0</code> xdat ydat zdat udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-FlowP-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FlowP</strong> <em>(<code>mglPoint</code> p0, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FlowP-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FlowP</strong> <em>(<code>mglPoint</code> p0, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fflowp_005f3d"></a>Функция С: <em><code>void</code></em> <strong>mgl_flowp_3d</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fflowp_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_flowp_xyz</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Это 3d версия графика.
</p></dd></dl>

<a name="flow3"></a><dl>
<dt><a name="index-flow3"></a>MGL command: <em></em> <strong>flow3</strong> <em>udat vdat wdat ['sch'='']</em></dt>
<dt><a name="index-flow3-1"></a>MGL command: <em></em> <strong>flow3</strong> <em>xdat ydat zdat udat vdat ['sch'='']</em></dt>
<dt><a name="index-Flow3"></a>Method on <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow3</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>double</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Flow3-1"></a>Method on <code>mglGraph</code>: <em><code>void</code></em> <strong>Flow3</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>double</code> sVal=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fflow3"></a>C function: <em><code>void</code></em> <strong>mgl_flow3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>double</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fflow3_005fxyz"></a>C function: <em><code>void</code></em> <strong>mgl_flow3_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>double</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>The function draws flow threads for the 3D vector field {<var>ax</var>, <var>ay</var>, <var>az</var>} parametrically depending on coordinates <var>x</var>, <var>y</var>, <var>z</var>. Flow threads starts from given plane. Option <code>value</code> set the approximate number of threads (default is 5). String <var>sch</var> may contain:
</p><ul>
<li> color scheme &ndash; up-half (warm) corresponds to normal flow (like attractor), bottom-half (cold) corresponds to inverse flow (like source);
</li><li> &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; for normal of starting plane (default is y-direction);
</li><li> &lsquo;<samp>v</samp>&rsquo; for drawing arrows on the threads;
</li><li> &lsquo;<samp>t</samp>&rsquo; for drawing tapes of normals in x-y and y-z planes.
</li></ul>
<p>See also <a href="#flow">flow</a>, <a href="#pipe">pipe</a>, <a href="#vect">vect</a>. См. раздел <a href="#flow3-sample">flow3 sample</a>, для примеров кода и графика.
</p></dd></dl>


<a name="grad"></a><dl>
<dt><a name="index-grad"></a>Команда MGL: <em></em> <strong>grad</strong> <em>pdat ['sch'='']</em></dt>
<dt><a name="index-grad-1"></a>Команда MGL: <em></em> <strong>grad</strong> <em>xdat ydat pdat ['sch'='']</em></dt>
<dt><a name="index-grad-2"></a>Команда MGL: <em></em> <strong>grad</strong> <em>xdat ydat zdat pdat ['sch'='']</em></dt>
<dt><a name="index-Grad-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grad</strong> <em>(<code>const mglDataA &amp;</code>phi, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Grad-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grad</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>phi, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Grad-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Grad</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>phi, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fgrad"></a>Функция С: <em><code>void</code></em> <strong>mgl_grad</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> phi, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fgrad_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_grad_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> phi, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fgrad_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_grad_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> phi, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии градиента скалярного поля <var>phi</var>[i,j] (или <var>phi</var>[i,j,k] в 3d случае) заданного параметрически {<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]}. Число линий пропорционально значению опции <code>value</code> (по умолчанию 5). См. также <a href="#dens">dens</a>, <a href="#cont">cont</a>, <a href="#flow">flow</a>.
</p></dd></dl>

<a name="pipe"></a><dl>
<dt><a name="index-pipe"></a>Команда MGL: <em></em> <strong>pipe</strong> <em>udat vdat ['sch'='' <code>r0=0.05</code>]</em></dt>
<dt><a name="index-pipe-1"></a>Команда MGL: <em></em> <strong>pipe</strong> <em>xdat ydat udat vdat ['sch'='' <code>r0=0.05</code>]</em></dt>
<dt><a name="index-Pipe-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pipe</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> r0=<code>0.05</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Pipe-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pipe</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> r0=<code>0.05</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpipe_005f2d"></a>Функция С: <em><code>void</code></em> <strong>mgl_pipe_2d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>mreal</code> r0, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpipe_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_pipe_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>const char *</code>sch, <code>mreal</code> r0, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует трубки тока для векторного поля {<var>ax</var>, <var>ay</var>}, параметрически зависящего от координат <var>x</var>, <var>y</var> на плоскости при <var>z</var> равном минимальному значению оси z. Число трубок пропорционально значению опции <code>value</code>. Цвет и радиус трубок пропорционален <em>\sqrt{ax^2+ay^2}</em>. Тёплые цвета соответствуют нормальному току (типа стока). Холодные цвета соответствуют обратному току (типа источника). Параметр <var>r0</var> задает радиус трубок. При <var>r0</var>&lt;0 радиус трубок обратно пропорционален их амплитуде. См. также <a href="#flow">flow</a>, <a href="#vect">vect</a>. См. раздел <a href="#pipe-sample">pipe sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-pipe-2"></a>Команда MGL: <em></em> <strong>pipe</strong> <em>udat vdat wdat ['sch'='' <code>r0=0.05</code>]</em></dt>
<dt><a name="index-pipe-3"></a>Команда MGL: <em></em> <strong>pipe</strong> <em>xdat ydat zdat udat vdat wdat ['sch'='' <code>r0=0.05</code>]</em></dt>
<dt><a name="index-Pipe-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pipe</strong> <em>(<code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> r0=<code>0.05</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Pipe-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Pipe</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>ax, <code>const mglDataA &amp;</code>ay, <code>const mglDataA &amp;</code>az, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>mreal</code> r0=<code>0.05</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpipe_005f3d"></a>Функция С: <em><code>void</code></em> <strong>mgl_pipe_3d</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>mreal</code> r0, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpipe_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_pipe_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> ax, <code>HCDT</code> ay, <code>HCDT</code> az, <code>const char *</code>sch, <code>mreal</code> r0, <code>const char *</code>opt)</em></dt>
<dd><p>Это 3d версия графика. Здесь массивы <var>ax</var>, <var>ay</var>, <var>az</var> должны трёхмерными тензорами и цвет пропорционален <em>\sqrt{ax^2+ay^2+az^2}</em>.
</p></dd></dl>



<hr>
<a name="Other-plotting"></a>
<div class="header">
<p>
Next: <a href="#Nonlinear-fitting" accesskey="n" rel="next">Nonlinear fitting</a>, Previous: <a href="#Vector-fields" accesskey="p" rel="prev">Vector fields</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Prochie-grafiki"></a>
<h3 class="section">4.16 Прочие графики</h3>

<a name="index-DensXYZ"></a>
<a name="index-ContXYZ"></a>
<a name="index-ContFXYZ"></a>
<a name="index-Dots"></a>
<a name="index-Crust"></a>
<a name="index-TriPlot"></a>
<a name="index-TriCont"></a>
<a name="index-QuadPlot"></a>
<a name="index-FPlot"></a>
<a name="index-FSurf"></a>

<p>Это функции, не относящиеся к какой-то специальной категории. Сюда входят функции построения графиков по текстовым формулам (FPlot и FSurf), рисования поверхностей из треугольников и четырёхугольников (TriPlot, TriCont, QuadPlot), произвольных точек в пространстве (Dots) и реконструкции по ним поверхности (Crust), графики плотности и линии уровня на плоскостях, перпендикулярных осям x, y или z (Dens[XYZ], Cont[XYZ], ContF[XYZ]). Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива. Параметры цветовой схемы задаются строкой. See <a href="#Color-scheme">Color scheme</a>.
</p>
<a name="densz"></a><a name="densy"></a><a name="densx"></a><a name="DensXYZ"></a><dl>
<dt><a name="index-densx"></a>Команда MGL: <em></em> <strong>densx</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-densy"></a>Команда MGL: <em></em> <strong>densy</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-densz"></a>Команда MGL: <em></em> <strong>densz</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-DensX"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DensX</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-DensY"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DensY</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-DensZ"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DensZ</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdens_005fx"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens_x</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdens_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdens_005fz"></a>Функция С: <em><code>void</code></em> <strong>mgl_dens_z</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Эти функции рисуют график плотности на x, y или z плоскостях. Если <var>a</var> &ndash; 3d массив, то выполняется интерполяция к заданному срезу <var>sVal</var>. Функции полезны для создания проекций 3D массивов на оси координат. См. также <a href="#ContXYZ">ContXYZ</a>, <a href="#ContFXYZ">ContFXYZ</a>, <a href="#dens">dens</a>, <a href="#Data-manipulation">Data manipulation</a>. См. раздел <a href="#dens_005fxyz-sample">dens_xyz sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="contz"></a><a name="conty"></a><a name="contx"></a><a name="ContXYZ"></a><dl>
<dt><a name="index-contx"></a>Команда MGL: <em></em> <strong>contx</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-conty"></a>Команда MGL: <em></em> <strong>conty</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-contz"></a>Команда MGL: <em></em> <strong>contz</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-ContX"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContX</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContY"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContY</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContZ"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContZ</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont_005fx"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_x</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fz"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_z</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Эти функции рисуют линии уровня на x, y или z плоскостях. Если <var>a</var> &ndash; 3d массив, то выполняется интерполяция к заданному срезу <var>sVal</var>. Опция <code>value</code> задает число контуров. Функции полезны для создания проекций 3D массивов на оси координат. См. также <a href="#ContFXYZ">ContFXYZ</a>, <a href="#DensXYZ">DensXYZ</a>, <a href="#cont">cont</a>, <a href="#Data-manipulation">Data manipulation</a>. См. раздел <a href="#cont_005fxyz-sample">cont_xyz sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-ContX-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContX</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContY-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContY</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContZ-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContZ</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcont_005fx_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_x_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_y_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcont_005fz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_cont_z_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему с ручным заданием значений для линий уровня.
</p></dd></dl>

<a name="contfz"></a><a name="contfy"></a><a name="contfx"></a><a name="ContFXYZ"></a><dl>
<dt><a name="index-contfx"></a>Команда MGL: <em></em> <strong>contfx</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-contfy"></a>Команда MGL: <em></em> <strong>contfy</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-contfz"></a>Команда MGL: <em></em> <strong>contfz</strong> <em>dat ['sch'='' <code>sval=nan</code>]</em></dt>
<dt><a name="index-ContFX"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFX</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContFY"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFY</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContFZ"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFZ</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf_005fx"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_x</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fy"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fz"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_z</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Эти функции рисуют закрашенные контуры уровня на x, y или z плоскостях. Если <var>a</var> &ndash; 3d массив, то выполняется интерполяция к заданному срезу <var>sVal</var>. Опция <code>value</code> задает число контуров. Функции полезны для создания проекций 3D массивов на оси координат. См. также <a href="#ContFXYZ">ContFXYZ</a>, <a href="#DensXYZ">DensXYZ</a>, <a href="#cont">cont</a>, <a href="#Data-manipulation">Data manipulation</a>. См. раздел <a href="#contf_005fxyz-sample">contf_xyz sample</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-ContFX-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFX</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContFY-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFY</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-ContFZ-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>ContFZ</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>a, <code>const char *</code>stl=<code>&quot;&quot;</code>, <code>mreal</code> sVal=<code>NAN</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcontf_005fx_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_x_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fy_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_y_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fcontf_005fz_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_contf_z_val</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> a, <code>const char *</code>stl, <code>mreal</code> sVal, <code>const char *</code>opt)</em></dt>
<dd><p>Аналогично предыдущему с ручным заданием значений для линий уровня.
</p></dd></dl>

<a name="fplot"></a><dl>
<dt><a name="index-fplot"></a>Команда MGL: <em></em> <strong>fplot</strong> <em>'y(x)' ['pen'='']</em></dt>
<dt><a name="index-FPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FPlot</strong> <em>(<code>const char *</code>eqY, <code>const char *</code>pen=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffplot"></a>Функция С: <em><code>void</code></em> <strong>mgl_fplot</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eqY, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует функцию &lsquo;<samp>eqY(x)</samp>&rsquo; в плоскости <var>z</var> равно минимальному значению оси z с координатой &lsquo;<samp>x</samp>&rsquo; в диапазоне осей координат. Опция <code>value</code> задает начальное число точек. См. также <a href="#plot">plot</a>.
</p></dd></dl>

<dl>
<dt><a name="index-fplot-1"></a>Команда MGL: <em></em> <strong>fplot</strong> <em>'x(t)' 'y(t)' 'z(t)' ['pen'='']</em></dt>
<dt><a name="index-FPlot-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FPlot</strong> <em>(<code>const char *</code>eqX, <code>const char *</code>eqY, <code>const char *</code>eqZ, <code>const char *</code>pen, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffplot_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_fplot_xyz</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eqX, <code>const char *</code>eqY, <code>const char *</code>eqZ, <code>const char *</code>pen, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрическую кривую {&lsquo;<samp>eqX(t)</samp>&rsquo;, &lsquo;<samp>eqY(t)</samp>&rsquo;, &lsquo;<samp>eqZ(t)</samp>&rsquo;}, где координата &lsquo;<samp>t</samp>&rsquo; меняется в диапазоне [0, 1]. Опция <code>value</code> задает начальное число точек. См. также <a href="#plot">plot</a>.
</p></dd></dl>

<a name="fsurf"></a><dl>
<dt><a name="index-fsurf"></a>Команда MGL: <em></em> <strong>fsurf</strong> <em>'z(x,y)' ['sch'='']</em></dt>
<dt><a name="index-FSurf-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FSurf</strong> <em>(<code>const char *</code>eqZ, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>);</em></dt>
<dt><a name="index-mgl_005ffsurf"></a>Функция С: <em><code>void</code></em> <strong>mgl_fsurf</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eqZ, <code>const char *</code>sch, <code>const char *</code>opt);</em></dt>
<dd><p>Рисует поверхность &lsquo;<samp>eqY(x,y)</samp>&rsquo; с координатами &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo; в диапазоне <code>xrange, yrange</code>. Опция <code>value</code> задает число точек. См. также <a href="#surf">surf</a>.
</p></dd></dl>

<dl>
<dt><a name="index-fsurf-1"></a>Команда MGL: <em></em> <strong>fsurf</strong> <em>'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='']</em></dt>
<dt><a name="index-FSurf-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>FSurf</strong> <em>(<code>const char *</code>eqX, <code>const char *</code>eqY, <code>const char *</code>eqZ, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffsurf_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_fsurf_xyz</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eqX, <code>const char *</code>eqY, <code>const char *</code>eqZ, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует параметрическую поверхность {&lsquo;<samp>eqX(u,v)</samp>&rsquo;, &lsquo;<samp>eqY(u,v)</samp>&rsquo;, &lsquo;<samp>eqZ(u,v)</samp>&rsquo;}, где координаты &lsquo;<samp>u</samp>&rsquo;, &lsquo;<samp>v</samp>&rsquo; меняются в диапазоне [0, 1]. Опция <code>value</code> задает число точек. См. также <a href="#surf">surf</a>.
</p></dd></dl>

<a name="triplot"></a><dl>
<dt><a name="index-triplot"></a>Команда MGL: <em></em> <strong>triplot</strong> <em>idat xdat ydat ['sch'='']</em></dt>
<dt><a name="index-triplot-1"></a>Команда MGL: <em></em> <strong>triplot</strong> <em>idat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-triplot-2"></a>Команда MGL: <em></em> <strong>triplot</strong> <em>idat xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-TriPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TriPlot-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TriPlot-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftriplot_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_triplot_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftriplot_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_triplot_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftriplot_005fxyzc"></a>Функция С: <em><code>void</code></em> <strong>mgl_triplot_xyzc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность из треугольников. Вершины треугольников задаются индексами <var>id</var> в массиве точек {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Строка <var>sch</var> задает цветовую схему. Если строка содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Размер по 1-му индексу массива <var>id</var> должен быть 3 или больше. Массивы <var>x</var>, <var>y</var>, <var>z</var> должны иметь одинаковые размеры. Массив <var>c</var> задает цвет треугольников (если <var>id</var>.ny=<var>c</var>.nx) или цвет вершин (если <var>x</var>.nx=<var>c</var>.nx). См. также <a href="#dots">dots</a>, <a href="#crust">crust</a>, <a href="#quadplot">quadplot</a>, <a href="#triangulation">triangulation</a>. См. раздел <a href="#triplot-sample">triplot sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tricont"></a><dl>
<dt><a name="index-tricont"></a>Команда MGL: <em></em> <strong>tricont</strong> <em>vdat idat xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-tricont-1"></a>Команда MGL: <em></em> <strong>tricont</strong> <em>vdat idat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-tricont-2"></a>Команда MGL: <em></em> <strong>tricont</strong> <em>idat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-TriCont-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriCont</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TriCont-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriCont</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TriContV"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriContV</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-TriContV-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>TriContV</strong> <em>(<code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ftricont_005fxyzc"></a>Функция С: <em><code>void</code></em> <strong>mgl_tricont_xyzc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftricont_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_tricont_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftricont_005fxyzcv"></a>Функция С: <em><code>void</code></em> <strong>mgl_tricont_xyzcv</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ftricont_005fxyzv"></a>Функция С: <em><code>void</code></em> <strong>mgl_tricont_xyzv</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> v, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует линии уровня поверхности из треугольников при <var>z</var>=<var>v</var>[k] (или при <var>z</var> равном минимальному значению оси z если <var>sch</var> содержит &lsquo;<samp>_</samp>&rsquo;). Вершины треугольников задаются индексами <var>id</var> в массиве точек {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Если аргуент <var>v</var> не задан, то используется массив из <var>num</var> элементов равно распределенных в диапазоне изменения цвета. Здесь <var>num</var> равен значению параметра <code>value</code> в опциях <var>opt</var> (по умолчанию 7). Строка <var>sch</var> задает цветовую схему. Размер по 1-му индексу массива <var>id</var> должен быть 3 или больше. Массивы <var>x</var>, <var>y</var>, <var>z</var> должны иметь одинаковые размеры. Массив <var>c</var> задает цвет треугольников (если <var>id</var>.ny=<var>c</var>.nx) или цвет вершин (если <var>x</var>.nx=<var>c</var>.nx). См. также <a href="#triplot">triplot</a>, <a href="#cont">cont</a>, <a href="#triangulation">triangulation</a>.
</p></dd></dl>

<a name="quadplot"></a><dl>
<dt><a name="index-quadplot"></a>Команда MGL: <em></em> <strong>quadplot</strong> <em>idat xdat ydat ['sch'='']</em></dt>
<dt><a name="index-quadplot-1"></a>Команда MGL: <em></em> <strong>quadplot</strong> <em>idat xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-quadplot-2"></a>Команда MGL: <em></em> <strong>quadplot</strong> <em>idat xdat ydat zdat cdat ['sch'='']</em></dt>
<dt><a name="index-QuadPlot-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>QuadPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-QuadPlot-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>QuadPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-QuadPlot-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>QuadPlot</strong> <em>(<code>const mglDataA &amp;</code>id, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fquadplot_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_quadplot_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fquadplot_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_quadplot_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fquadplot_005fxyzc"></a>Функция С: <em><code>void</code></em> <strong>mgl_quadplot_xyzc</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> id, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует поверхность из четырёхугольников. Вершины четырёхугольников задаются индексами <var>id</var> в массиве точек {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Строка <var>sch</var> задает цветовую схему. Если строка содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Размер по 1-му индексу массива <var>id</var> должен быть 4 или больше. Массивы <var>x</var>, <var>y</var>, <var>z</var> должны иметь одинаковые размеры. Массив <var>c</var> задает цвет четырёхугольников (если <var>id</var>.ny=<var>c</var>.nx) или цвет вершин (если <var>x</var>.nx=<var>c</var>.nx). См. также <a href="#triplot">triplot</a>. См. раздел <a href="#triplot-sample">triplot sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="dots"></a><dl>
<dt><a name="index-dots"></a>Команда MGL: <em></em> <strong>dots</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-dots-1"></a>Команда MGL: <em></em> <strong>dots</strong> <em>xdat ydat zdat adat ['sch'='']</em></dt>
<dt><a name="index-Dots-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dots</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Dots-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dots</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Dots-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Dots</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>c, <code>const mglDataA &amp;</code>a, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdots"></a>Функция С: <em><code>void</code></em> <strong>mgl_dots</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdots_005fa"></a>Функция С: <em><code>void</code></em> <strong>mgl_dots_a</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdots_005fca"></a>Функция С: <em><code>void</code></em> <strong>mgl_dots_ca</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> c, <code>HCDT</code> a, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Рисует произвольно расположенные точки {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Строка <var>sch</var> задает цветовую схему и тип маркеров. Если определёны массивы <var>c</var>, <var>a</var> то они задают цвет и прозрачность точек соответственно. Непрозрачные точки с заданным цветом можно нарисовать с помощью <a href="#tens">tens</a>, используя стиль &lsquo;<samp> .</samp>&rsquo;. Массивы <var>x</var>, <var>y</var>, <var>z</var>, <var>a</var> должны иметь одинаковые размеры. См. также <a href="#crust">crust</a>, <a href="#tens">tens</a>, <a href="#mark">mark</a>, <a href="#plot">plot</a>. См. раздел <a href="#dots-sample">dots sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="crust"></a><dl>
<dt><a name="index-crust"></a>Команда MGL: <em></em> <strong>crust</strong> <em>xdat ydat zdat ['sch'='']</em></dt>
<dt><a name="index-Crust-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Crust</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>sch=<code>&quot;&quot;</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcrust"></a>Функция С: <em><code>void</code></em> <strong>mgl_crust</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>sch, <code>const char *</code>opt)</em></dt>
<dd><p>Реконструирует и рисует поверхность по произвольно расположенным точкам {<var>x</var>[i], <var>y</var>[i], <var>z</var>[i]}. Опция <var>value</var> задает радиус ошибки (увеличите для удаления дыр). Строка <var>sch</var> задает цветовую схему. Если строка содержит &lsquo;<samp>#</samp>&rsquo;, то рисуется сетчатая поверхность. Массивы <var>x</var>, <var>y</var>, <var>z</var> должны иметь одинаковые размеры. См. также <a href="#dots">dots</a>, <a href="#triplot">triplot</a>. </p></dd></dl>


<hr>
<a name="Nonlinear-fitting"></a>
<div class="header">
<p>
Next: <a href="#Data-manipulation" accesskey="n" rel="next">Data manipulation</a>, Previous: <a href="#Other-plotting" accesskey="p" rel="prev">Other plotting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nonlinear-fitting-1"></a>
<h3 class="section">4.17 Nonlinear fitting</h3>

<a name="index-Fit"></a>
<a name="index-FitS"></a>
<a name="index-PutsFit"></a>
<a name="index-mglFitPnts"></a>
<a name="index-Fit2"></a>
<a name="index-Fit3"></a>

<p>Эти функции подбирают параметры функции для наилучшей аппроксимации данных, т.е. минимизируют сумму <em>\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2</em>. При этом аппроксимирующая функция &lsquo;<samp>f</samp>&rsquo; может зависеть от одного аргумента &lsquo;<samp>x</samp>&rsquo; (1D случай), от двух аргументов &lsquo;<samp>x,y</samp>&rsquo; (2D случай) или от трех аргументов &lsquo;<samp>x,y,z</samp>&rsquo; (3D случай). Функция &lsquo;<samp>f</samp>&rsquo; также может зависеть от параметров. Список параметров задается строкой <var>var</var> (например, &lsquo;<samp>abcd</samp>&rsquo;). Обычно пользователь должен предоставить начальные значения параметров в переменной <var>ini</var>. Однако, при его отсутствии используются нулевые значения. Параметр <var>print</var>=<code>true</code> включает вывод найденной формулы в <var>Message</var> (см. <a href="#Error-handling">Error handling</a>).
</p>
<p>Функции Fit() и FitS() не рисуют полученные массивы. Они заполняют массив <var>fit</var> по формуле &lsquo;<samp>f</samp>&rsquo; с найденными коэффициентами и возвращают <em>\chi^2</em> ошибку аппроксимации. При этом, координаты &lsquo;<samp>x,y,z</samp>&rsquo; равно распределены в диапазоне осей координат. Число точек в <var>fit</var> определяется опцией <code>value</code> (по умолчанию <var>mglFitPnts</var>=100). Функции используют библиотеку GSL. См. раздел <a href="#Nonlinear-fitting-hints">Nonlinear fitting hints</a>, для примеров кода и графика.
</p>
<a name="fits"></a><dl>
<dt><a name="index-fits"></a>Команда MGL: <em></em> <strong>fits</strong> <em>res adat sdat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fits-1"></a>Команда MGL: <em></em> <strong>fits</strong> <em>res xdat adat sdat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fits-2"></a>Команда MGL: <em></em> <strong>fits</strong> <em>res xdat ydat adat sdat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fits-3"></a>Команда MGL: <em></em> <strong>fits</strong> <em>res xdat ydat zdat adat sdat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-FitS-1"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-2"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-3"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-4"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-5"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-6"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-7"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-FitS-8"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>FitS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>s, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffit_005fys"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_ys</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>HCDT</code> s, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxys"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xys</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> a, <code>HCDT</code> s, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxyzs"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xyzs</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> a, <code>HCDT</code> s, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxyzas"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xyzas</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>HCDT</code> s, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dd><p>&quot;Подгоняют&quot; формулу вдоль x-, y- и z-направлений для 3d массива заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) с весовым множителем <var>s</var>[i,j,k].
</p></dd></dl>

<a name="fit"></a><dl>
<dt><a name="index-fit"></a>Команда MGL: <em></em> <strong>fit</strong> <em>res adat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fit-1"></a>Команда MGL: <em></em> <strong>fit</strong> <em>res xdat adat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fit-2"></a>Команда MGL: <em></em> <strong>fit</strong> <em>res xdat ydat adat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-fit-3"></a>Команда MGL: <em></em> <strong>fit</strong> <em>res xdat ydat zdat adat 'func' 'var' [ini=0]</em></dt>
<dt><a name="index-Fit-1"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-2"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-3"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-4"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-5"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-6"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-7"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit-8"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffit_005fy"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_y</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxy"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxyz"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005fxyza"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_xyza</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dd><p>&quot;Подгоняют&quot; формулу вдоль x-, y- и z-направлений для 3d массива заданного параметрически <var>a</var>[i,j,k](<var>x</var>[i,j,k], <var>y</var>[i,j,k], <var>z</var>[i,j,k]) с весовым множителем 1.
</p></dd></dl>


<dl>
<dt><a name="index-Fit2-1"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit2</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit2-2"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit2</strong> <em>(<code>mglData &amp;</code>fit, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit3-1"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit3</strong> <em>(<code>mglData &amp;</code>fit, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fit3-2"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Fit3</strong> <em>(<code>mglData &amp;</code>fit, <code>const mglDataA &amp;</code>a, <code>const char *</code>func, <code>const char *</code>var, <code>mglData &amp;</code>ini, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005ffit_005f2"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_2</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005ffit_005f3"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_fit_3</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> a, <code>const char *</code>func, <code>const char *</code>var, <code>HMDT</code> ini, <code>const char *</code>opt)</em></dt>
<dd><p>&quot;Подгоняют&quot; формулу вдоль всех направлений для 2d или 3d массива <var>a</var> с <var>s</var>=1 и <var>x</var>, <var>y</var>, <var>z</var> равно распределёнными в диапазоне осей координат.
</p></dd></dl>

<a name="putsfit"></a><dl>
<dt><a name="index-putsfit"></a>Команда MGL: <em></em> <strong>putsfit</strong> <em><code>x y</code> ['pre'='' 'fnt'='' <code>size=-1</code>]</em></dt>
<dt><a name="index-PutsFit-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>PutsFit</strong> <em>(<code>mglPoint</code> p, <code>const char *</code>prefix=<code>&quot;&quot;</code>, <code>const char *</code>font=<code>&quot;&quot;</code>, <code>mreal</code> size=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fputs_005ffit"></a>Функция С: <em><code>void</code></em> <strong>mgl_puts_fit</strong> <em>(<code>HMGL</code> gr, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>const char *</code>prefix, <code>const char *</code>font, <code>mreal</code> size)</em></dt>
<dd><p>Печатает последнюю подобранную формулу с найденными коэффициентами в точке <var>p0</var>. Строка <var>prefix</var> будет напечатана перед формулой. Все другие параметры такие же как в <a href="#Text-printing">Text printing</a>.
</p></dd></dl>

<dl>
<dt><a name="index-_0028_0029-1"></a>Метод класса <code>mglGraph</code>: <em><code>const char *</code>GetFit</em> <strong>()</strong></dt>
<dt><a name="index-mgl_005fget_005ffit"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_get_fit</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fget_005ffit-1"></a>Fortran процедура: <em><code></code></em> <strong>mgl_get_fit</strong> <em>(<code>long</code> gr, <code>char *</code>out, <code>int</code> len)</em></dt>
<dd><p>Возвращает последнюю подобранную формулу с найденными коэффициентами.
</p></dd></dl>

<dl>
<dt><a name="index-GetFitChi"></a>Метод класса <code>mglGraph</code>: <em><code>mreal</code></em> <strong>GetFitChi</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005ffit_005fchi"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_get_fit_chi</strong> <em>()</em></dt>
<dd><p>Возвращает величину \chi для последней подобранной формулы.
</p></dd></dl>

<dl>
<dt><a name="index-GetFitCovar"></a>Метод класса <code>mglGraph</code>: <em><code>mreal</code></em> <strong>GetFitCovar</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005ffit_005fcovar"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_get_fit_covar</strong> <em>()</em></dt>
<dd><p>Возвращает ковариационную матрицу для последней подобранной формулы.
</p></dd></dl>




<hr>
<a name="Data-manipulation"></a>
<div class="header">
<p>
Previous: <a href="#Nonlinear-fitting" accesskey="p" rel="prev">Nonlinear fitting</a>, Up: <a href="#MathGL-core" accesskey="u" rel="up">MathGL core</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Raspredelenie-dannykh"></a>
<h3 class="section">4.18 Распределение данных</h3>

<a name="index-Hist"></a>
<a name="index-Fill"></a>
<a name="index-DataGrid"></a>

<dl>
<dt><a name="index-hist"></a>Команда MGL: <em></em> <strong>hist</strong> <em><small>RES</small> xdat adat</em></dt>
<dt><a name="index-hist-1"></a>Команда MGL: <em></em> <strong>hist</strong> <em><small>RES</small> xdat ydat adat</em></dt>
<dt><a name="index-hist-2"></a>Команда MGL: <em></em> <strong>hist</strong> <em><small>RES</small> xdat ydat zdat adat</em></dt>
<dt><a name="index-Hist-2"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>a, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Hist-3"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>a, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Hist-4"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>a, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fhist_005fx"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_hist_x</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> a, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fhist_005fxy"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_hist_xy</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> a, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fhist_005fxyz"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_hist_xyz</strong> <em>(<code>HMGL</code> gr, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> a, <code>const char *</code>opt)</em></dt>
<dd><p>Создают распределения данных. Они не рисуют данные. Функции могут быть полезны в случае когда данные пользователя определены на случайно расположенных точка (например, после PIC расчетов) и он хочет построить график, требующий регулярных данных (данных на сетках). Диапазон сеток равен диапазону осей координат. Массивы <var>x</var>, <var>y</var>, <var>z</var> определяют положение (координаты) точек. Массив <var>a</var> задает значения данных. Число точек в результате <var>res</var> определяется опцией <code>value</code> (по умолчанию <var>mglFitPnts</var>=100).
</p></dd></dl>


<dl>
<dt><a name="index-fill"></a>Команда MGL: <em></em> <strong>fill</strong> <em>dat 'eq'</em></dt>
<dt><a name="index-fill-1"></a>Команда MGL: <em></em> <strong>fill</strong> <em>dat 'eq' vdat</em></dt>
<dt><a name="index-fill-2"></a>Команда MGL: <em></em> <strong>fill</strong> <em>dat 'eq' vdat wdat</em></dt>
<dt><a name="index-Fill-2"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>mglData &amp;</code>u, <code>const char *</code>eq, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-3"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>mglData &amp;</code>u, <code>const char *</code>eq, <code>const mglDataA &amp;</code>v, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-4"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>mglData &amp;</code>u, <code>const char *</code>eq, <code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>w, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005ffill_005feq"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_fill_eq</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> u, <code>const char *</code>eq, <code>HCDT</code>v, <code>HCDT</code>w, <code>const char *</code>opt)</em></dt>
<dd><p>Заполняют значения массива &lsquo;<samp>u</samp>&rsquo; в соответствии с формулой в строке <var>eq</var>. Формула &ndash; произвольное выражение, зависящее от переменных &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;, &lsquo;<samp>u</samp>&rsquo;, &lsquo;<samp>v</samp>&rsquo;, &lsquo;<samp>w</samp>&rsquo;. Координаты &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; полагаются в диапазоне изменения осей координат. Переменная &lsquo;<samp>u</samp>&rsquo; &ndash; значение исходного массива. Переменные &lsquo;<samp>v</samp>&rsquo; и &lsquo;<samp>w</samp>&rsquo; &ndash; значения массивов <var>v</var>, <var>w</var>, которые могут быть <code>NULL</code> (т.е. могут быть опущены).
</p></dd></dl>

<dl>
<dt><a name="index-datagrid"></a>Команда MGL: <em></em> <strong>datagrid</strong> <em>dat xdat ydat zdat</em></dt>
<dt><a name="index-DataGrid-1"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>DataGrid</strong> <em>(<code>mglData &amp;</code>u, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fgrid"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_grid</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> u, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>opt)</em></dt>
<dd><p>Заполняет значения массива &lsquo;<samp>u</samp>&rsquo; результатом линейной интерполяции по триангулированной поверхности, найденной по произвольно расположенным точкам &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;. NAN значение используется для точек сетки вне триангулированной поверхности. См. раздел <a href="#Making-regular-data">Making regular data</a>, для примеров кода и графика.
</p></dd></dl>

<dl>
<dt><a name="index-refill"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat vdat [sl=-1]</em></dt>
<dt><a name="index-refill-1"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat ydat vdat [sl=-1]</em></dt>
<dt><a name="index-refill-2"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat ydat zdat vdat</em></dt>
<dt><a name="index-Refill-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>mglDataA &amp;</code>dat, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v, <code>long</code> sl=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Refill-2"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>mglDataA &amp;</code>dat, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>v, <code>long</code> sl=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Refill-3"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>mglDataA &amp;</code>dat, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>v, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fgr"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_gr</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> v, <code>long</code> sl, <code>const char *</code>opt)</em></dt>
<dd><p>Заполняет значениями интерполяции массива <var>v</var> в точках {<var>x</var>, <var>y</var>, <var>z</var>}={<code>X[i], Y[j], Z[k]</code>} (или {<var>x</var>, <var>y</var>, <var>z</var>}={<code>X[i,j,k], Y[i,j,k], Z[i,j,k]</code>} если <var>x</var>, <var>y</var>, <var>z</var> не 1d массивы), где <code>X,Y,Z</code> равномерно распределены в диапазоне осей координат и имеют такой же размер как и массив <var>dat</var>. Если параметр <var>sl</var> равен 0 или положительный, то изменятся будет только <var>sl</var>-ый срез.
</p></dd></dl>



<dl>
<dt><a name="index-pde"></a>Команда MGL: <em></em> <strong>pde</strong> <em><small>RES</small> 'ham' ini_re ini_im [<code>dz=0.1 k0=100</code>]</em></dt>
<dt><a name="index-PDE"></a>Метод класса <code>mglGraph</code>: <em><code>mglData</code></em> <strong>PDE</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>mreal</code> dz=<code>0.1</code>, <code>mreal</code> k0=<code>100</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpde_005fsolve"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_pde_solve</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>mreal</code> dz, <code>mreal</code> k0, <code>const char *</code>opt)</em></dt>
<dd><p>Решает уравнение в частных производных du/dz = i*k0*<var>ham</var>(p,q,x,y,z,|u|)[u], где p=-i/k0*d/dx, q=-i/k0*d/dy &ndash; псевдо-дифференциальные оперторы. Параметры <var>ini_re</var>, <var>ini_im</var> задают действительную и мнимую часть начального распределения поля. Координаты &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; полагаются в диапазоне изменения осей координат. Отмечу, ято в действительности этот диапазон увеличен на 3/2 для уменьшения отражения от границ сетки. Параметр <var>dz</var> задает шаг по эволюционной координате z. Сейчас используется упрощенный вид функции <var>ham</var> &ndash; исключены все &ldquo;смешанные&rdquo; члены (типа &lsquo;<samp>x*p</samp>&rsquo;-&gt;x*d/dx). Например, в 2D случае это функция вида <em>ham = f(p,z) + g(x,z,u)</em>. Однако, коммутирующие члены (типа &lsquo;<samp>x*q</samp>&rsquo;-&gt;x*d/dy) разрешены. Переменная &lsquo;<samp>u</samp>&rsquo; используется для амплитуды поля |u|, что позволяет решать нелинейные задачи &ndash; например уравнение Шредингера <code>ham=&quot;p^2 + q^2 - u^2&quot;</code>. Вы можете задавать мнимую часть для поглощения волн, например <code>ham = &quot;p^2 + i*x*(x&gt;0)&quot;</code>, но только для линейной зависимости от переменной &lsquo;<samp>i</samp>&rsquo; (т.е. <em>ham = hre+i*him</em>). См. раздел <a href="#PDE-solving-hints">PDE solving hints</a>, для примеров кода и графика.
</p></dd></dl>









<hr>
<a name="Widget-classes"></a>
<div class="header">
<p>
Next: <a href="#Data-processing" accesskey="n" rel="next">Data processing</a>, Previous: <a href="#MathGL-core" accesskey="p" rel="prev">MathGL core</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>

<a name="g_t_0060_0060Okonnye_0027_0027-klassy"></a>
<h2 class="chapter">5 &ldquo;Оконные&rdquo; классы</h2>

<a name="index-mglWnd"></a>
<a name="index-mglGLUT"></a>
<a name="index-Fl_005fMathGL"></a>
<a name="index-QMathGL"></a>
<a name="index-window-1"></a>
<a name="index-widgets-1"></a>

<p>Есть целый набор &ldquo;оконных&rdquo; классов для создания окон с графикой MathGL: <code>mglWnd</code> и <code>mglGLUT</code> для окон целиком, <code>Fl_MathGL</code> и <code>QMathGL</code> для виджетов. Все эти классы позволяют пользователю просмотривать, вращать, экспортировать рисунок. Большинство из них (кроме <code>mglGLUT</code>) имеют панель инструментов для упрощения изменения графика. Все оконные классы имеют схожий набор функций. Ниже приведен список классов с краткими комментариями.
</p>
<p>Для рисования можно использовать: указатель <code>NULL</code> если планируется обновлять график вручную, глобальную функцию типа <code>int draw(<code>HMGL</code> gr, <code>void *</code>p)</code> или <code>int draw(<code>mglGraph *</code>gr)</code>, или экземпляр класса, производного от <a href="#mglDraw-class">mglDraw class</a>. Этот класс определен в <code>#include &lt;mgl2/wnd.h&gt;</code> и имеет 2 основных виртуальных метода:
</p><pre class="verbatim">class mglDraw
{
public:
    virtual int Draw(mglGraph *) { return 0; };
    virtual void Reload() {};
};
</pre><p>Вам следует наследовать свой класс от <code>mglDraw</code> и определить один или оба метода.
</p>
<p>Непосредственно окна можно создать используя один из следующих классов (см. <a href="#Using-MathGL-window">Using MathGL window</a> для примеров).
</p>

<dl>
<dt><a name="index-mglFLTK"></a>Конструктор класса <code>mglFLTK</code>: <em></em> <strong>mglFLTK</strong> <em>(<code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglFLTK-1"></a>Конструктор класса <code>mglFLTK</code>: <em></em> <strong>mglFLTK</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>, <code>void *</code>par=<code>NULL</code>, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p)=0)</em></dt>
<dt><a name="index-mglFLTK-2"></a>Конструктор класса <code>mglFLTK</code>: <em></em> <strong>mglFLTK</strong> <em>(<code>int</code> (*draw)(<code>mglGraph *</code>gr), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglFLTK-3"></a>Конструктор класса <code>mglFLTK</code>: <em></em> <strong>mglFLTK</strong> <em>(<code>mglDraw *</code>draw, <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcreate_005fgraph_005ffltk"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_create_graph_fltk</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title, <code>void *</code>par, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dd>
<p>Создает FLTK окно для вывода графика. Параметр <var>draw</var> &ndash; указатель (имя) функции рисования. Есть возможность создания нескольких кадров вначале (требует больше памяти) и их быстрая анимации в дальнейшем. В этом случае функция <var>draw</var> должна возвращать число кадров или ноль для рисования по запросу. Замечу, что <var>draw</var> может быть равна <code>NULL</code> для отображения статической (текущей) картинки. Параметр <var>title</var> задает заголовок окна. Параметр <var>par</var> содержит указатель на данные, передаваемые функции рисования <var>draw</var>. FLTK окна обеспечивают быстрое рисование и хорошо поддерживают многопоточность.
</p></dd></dl>

<dl>
<dt><a name="index-RunThr"></a>Метод класса <code>mglWnd</code>: <em><code>int</code></em> <strong>RunThr</strong> <em>()</em></dt>
<dt><a name="index-mgl_005ffltk_005fthr"></a>Функция С: <em><code>int</code></em> <strong>mgl_fltk_thr</strong> <em>()</em></dt>
<dd><p>Запускает цикл обработки сообщений в отдельном потоке. В данный момент работает только для окон FLTK.
</p></dd></dl>


<dl>
<dt><a name="index-mglQT"></a>Конструктор класса <code>mglQT</code>: <em></em> <strong>mglQT</strong> <em>(<code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglQT-1"></a>Конструктор класса <code>mglQT</code>: <em></em> <strong>mglQT</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>, <code>void *</code>par=<code>NULL</code>, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p)=0)</em></dt>
<dt><a name="index-mglQT-2"></a>Конструктор класса <code>mglQT</code>: <em></em> <strong>mglQT</strong> <em>(<code>int</code> (*draw)(<code>mglGraph *</code>gr), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglQT-3"></a>Конструктор класса <code>mglQT</code>: <em></em> <strong>mglQT</strong> <em>(<code>mglDraw *</code>draw, <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcreate_005fgraph_005fqt"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_create_graph_qt</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title, <code>void *</code>par, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dd>
<p>Создает Qt окно для вывода графика. Параметр <var>draw</var> &ndash; указатель (имя) функции рисования. Есть возможность создания нескольких кадров вначале (требует больше памяти) и их быстрая анимации в дальнейшем. В этом случае функция <var>draw</var> должна возвращать число кадров или ноль для рисования по запросу. Замечу, что <var>draw</var> может быть равна <code>NULL</code> для отображения статической (текущей) картинки. Параметр <var>title</var> задает заголовок окна. Параметр <var>par</var> содержит указатель на данные, передаваемые функции рисования <var>draw</var>.
</p></dd></dl>


<dl>
<dt><a name="index-mglGLUT-1"></a>Конструктор класса <code>mglGLUT</code>: <em></em> <strong>mglGLUT</strong> <em>(<code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglGLUT-2"></a>Конструктор класса <code>mglGLUT</code>: <em></em> <strong>mglGLUT</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>, <code>void *</code>par=<code>NULL</code>, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p)=0)</em></dt>
<dt><a name="index-mglGLUT-3"></a>Конструктор класса <code>mglGLUT</code>: <em></em> <strong>mglGLUT</strong> <em>(<code>int</code> (*draw)(<code>mglGraph *</code>gr), <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mglGLUT-4"></a>Конструктор класса <code>mglGLUT</code>: <em></em> <strong>mglGLUT</strong> <em>(<code>mglDraw *</code>draw, <code>const char *</code>title=<code>&quot;MathGL&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fcreate_005fgraph_005fglut"></a>Функция С: <em><code>HMGL</code></em> <strong>mgl_create_graph_glut</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>const char *</code>title, <code>void *</code>par, <code>void</code> (*reload)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dd>
<p>Создает окно для вывода графика. Параметр <var>draw</var> &ndash; указатель (имя) функции рисования. Есть возможность создания нескольких кадров вначале (требует больше памяти) и их быстрая анимации в дальнейшем. В этом случае функция <var>draw</var> должна возвращать число кадров или ноль для рисования по запросу. Замечу, что <var>draw</var> может быть равна <code>NULL</code> для отображения статической (текущей) картинки. Параметр <var>title</var> задает заголовок окна. Параметр <var>par</var> содержит указатель на данные, передаваемые функции рисования <var>draw</var>. Параметр <var>kind</var> может иметь следующие значения: &lsquo;<samp>0</samp>&rsquo; &ndash; использовать окно FLTK, &lsquo;<samp>1</samp>&rsquo; &ndash; использовать окно Qt.
</p>
<p>В окне просмотра можно использовать клавиши: &rsquo;a&rsquo;, &rsquo;d&rsquo;, &rsquo;w&rsquo;, &rsquo;s&rsquo; для вращения; &rsquo;,&rsquo;, &rsquo;.&rsquo; для просмотра предыдущего и следующего кадров; &rsquo;r&rsquo; для переключения прозрачности; &rsquo;f&rsquo; для переключения оспещенности; &rsquo;x&rsquo; для закрытия окна.
</p></dd></dl>



<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#mglWnd-class" accesskey="1">mglWnd class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mglDraw-class" accesskey="2">mglDraw class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Fl_005fMathGL-class" accesskey="3">Fl_MathGL class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#QMathGL-class" accesskey="4">QMathGL class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#wxMathGL-class" accesskey="5">wxMathGL class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<a name="mglWnd-class"></a>
<div class="header">
<p>
Next: <a href="#Fl_005fMathGL-class" accesskey="n" rel="next">Fl_MathGL class</a>, Up: <a href="#Widget-classes" accesskey="u" rel="up">Widget classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Klass-mglWnd"></a>
<h3 class="section">5.1 Класс mglWnd</h3>

<a name="index-mglWnd-1"></a>
<a name="index-window-2"></a>

<p>Это абстрактный класс производный от класса mglGraph (см. <a href="#MathGL-core">MathGL core</a>). Он определен в <code>#include &lt;mgl2/wnd.h&gt;</code>. Класс содержит методы для создания и управления окном, содержащим графику MathGL. Производные от него классы существует отдельно для каждой библиотеки виджетов: <code>mglQT</code> в <code>#include &lt;mgl2/qt.h&gt;</code>, <code>mglFLTK</code> в <code>#include &lt;mgl2/fltk.h&gt;</code>.
</p>
<dl>
<dt><a name="index-Run"></a>Метод класса <code>mglWnd</code>: <em><code>int</code></em> <strong>Run</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fqt_005frun"></a>Функция С: <em><code>int</code></em> <strong>mgl_qt_run</strong> <em>()</em></dt>
<dt><a name="index-mgl_005ffltk_005frun"></a>Функция С: <em><code>int</code></em> <strong>mgl_fltk_run</strong> <em>()</em></dt>
<dd><p>Запускает цикл обработки сообщений. Обычно эта функция должна вызываться в отдельном потоке или последней функцией в <code>main()</code>.
</p></dd></dl>

<dl>
<dt><a name="index-SetDrawFunc"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>SetDrawFunc</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>void *</code>par=<code>NULL</code>, <code>void</code> (*reload)(<code>void *</code>p)=<code>NULL</code>)</em></dt>
<dt><a name="index-SetDrawFunc-1"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>SetDrawFunc</strong> <em>(<code>int</code> (*draw)(<code>mglGraph *</code>gr))</em></dt>
<dt><a name="index-SetDrawFunc-2"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>SetDrawFunc</strong> <em>(<code>mglDraw *</code>obj)</em></dt>
<dt><a name="index-mgl_005fwnd_005fset_005ffunc"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_set_func</strong> <em>(<code>HMGL</code> gr, <code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p), <code>void *</code>par, <code>void</code> (*reload)(<code>void *</code>p))</em></dt>
<dd><p>Устанавливает функцию, которая будет вызвана при перерисовке (<var>draw</var>) и при повторной загрузке данных (<var>reload</var>), или объект <var>obj</var> класса, производного от <code>mglDraw</code>.
</p></dd></dl>

<dl>
<dt><a name="index-SetClickFunc"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>SetClickFunc</strong> <em>(<code>void</code> (*func)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dt><a name="index-mgl_005fset_005fclick_005ffunc"></a>Функция С: <em><code>void</code></em> <strong>mgl_set_click_func</strong> <em>(<code>void</code> (*func)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dd><p>Устанавливает функцию, которая будет вызвана при щелчке мышью.
</p></dd></dl>

<dl>
<dt><a name="index-SetMutex_0028pthread_005fmutex_005ft-_002amutex_0029"></a>Method on <code>mglWnd</code>: <em><code>void</code></em> <strong>SetMutex(<code>pthread_mutex_t *</code>mutex)</strong></dt>
<dt><a name="index-mgl_005fwnd_005fset_005fmutex_0028HMGL"></a>C function: <em><code>void</code></em> <strong>mgl_wnd_set_mutex(<code>HMGL</code></strong> <em>gr, <code>pthread_mutex_t *</code>mutex)</em></dt>
<dd><p>Устанавливает внешний mutex для блокировки/разблокировки внешних вычислений с помощью меню или кнопок окна. Функция вызывается автоматически при использовании <a href="#mglDraw-class">mglDraw class</a>.
</p></dd></dl>

<dl>
<dt><a name="index-ToggleAlpha"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ToggleAlpha</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005ftoggle_005falpha"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_toggle_alpha</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Включает/выключает прозрачность, но не перекрывает ее включение в пользовательской функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-ToggleLight"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ToggleLight</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005ftoggle_005flight"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_toggle_light</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Включает/выключает освещение, но не перекрывает его включение в пользовательской функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-ToggleRotate"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ToggleRotate</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005ftoggle_005frotate"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_toggle_rotate</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Включает/выключает вращение мышкой. Нажатая левая кнопка используется для вращения, средняя для сдвига, правая для приближения/перспективы.
</p></dd></dl>
<dl>
<dt><a name="index-ToggleZoom"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ToggleZoom</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005ftoggle_005fzoom"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_toggle_zoom</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Включает/выключает приближение мышкой. Выделите прямоугольную область и она будет приближена.
</p></dd></dl>
<dl>
<dt><a name="index-ToggleNo"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ToggleNo</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005ftoggle_005fno"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_toggle_no</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Выключает вращение и приближение мышкой, а также восстанавливает исходный вид графика.
</p></dd></dl>
<dl>
<dt><a name="index-Update"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>Update</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fupdate"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_update</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Обновляет содержимое окна. Функция полезна при ручном обновлении содержимого, пока долгий расчет идет в параллельном потоке.
</p></dd></dl>
<dl>
<dt><a name="index-ReLoad"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>ReLoad</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005freload"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_reload</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Перегружает данные и обновляет рисунок. Функция также обновляет число кадров, которое создает функция рисования.
</p></dd></dl>
<dl>
<dt><a name="index-Adjust-2"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>Adjust</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fadjust"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_adjust</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Подгоняет размер рисунка под размер окна.
</p></dd></dl>
<dl>
<dt><a name="index-NextFrame"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>NextFrame</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fnext_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_next_frame</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Показывает следующий кадр, если он есть.
</p></dd></dl>
<dl>
<dt><a name="index-PrevFrame"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>PrevFrame</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fprev_005fframe"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_prev_frame</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Показывает предыдущий кадр, если он есть.
</p></dd></dl>
<dl>
<dt><a name="index-Animation"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>Animation</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fanimation"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_animation</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Запускает/останавливает анимацию кадров.
</p></dd></dl>

<dl>
<dt><a name="index-SetDelay"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>SetDelay</strong> <em>(<code>double</code> dt)</em></dt>
<dt><a name="index-mgl_005fwnd_005fset_005fdelay"></a>Функция С: <em><code>void</code></em> <strong>mgl_wnd_set_delay</strong> <em>(<code>HMGL</code> gr, <code>double</code> dt)</em></dt>
<dd><p>Задает задержку при анимации в секундах. По умолчанию интервал &ndash; 1 секунда.
</p></dd></dl>

<dl>
<dt><a name="index-GetDelay"></a>Метод класса <code>mglWnd</code>: <em><code>double</code></em> <strong>GetDelay</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fwnd_005fget_005fdelay"></a>Функция С: <em><code>double</code></em> <strong>mgl_wnd_get_delay</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает задержку при анимации в секундах.
</p></dd></dl>

<dl>
<dt><a name="index-Setup"></a>Метод класса <code>mglWnd</code>: <em><code>void</code></em> <strong>Setup</strong> <em>(<code>bool</code> clfupd=<code>true</code>, <code>bool</code> showpos=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fsetup_005fwindow"></a>Функция С: <em><code>void</code></em> <strong>mgl_setup_window</strong> <em>(<code>HMGL</code> gr, <code>bool</code> clfupd, <code>bool</code> showpos)</em></dt>
<dd><p>Включает/выключает:
</p><ul>
<li> очистку рисунка перед Update();
</li><li> показ позиции щелчка мыши на рисунке.
</li></ul>
</dd></dl>

<dl>
<dt><a name="index-LastMousePos"></a>Метод класса <code>mglWnd</code>: <em><code>mglPoint</code></em> <strong>LastMousePos</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fget_005flast_005fmouse_005fpos"></a>Функция С: <em><code>void</code></em> <strong>mgl_get_last_mouse_pos</strong> <em>(<code>HMGL</code> gr, <code>mreal *</code>x, <code>mreal *</code>y, <code>mreal *</code>z)</em></dt>
<dd><p>Возвращает положение щелчка мыши.
</p></dd></dl>

<dl>
<dt><a name="index-Widget"></a>Method on <code>mglWnd</code>: <em><code>void *</code></em> <strong>Widget</strong> <em>()</em></dt>
<dt><a name="index-mgl_005ffltk_005fwidget"></a>C function: <em><code>void *</code></em> <strong>mgl_fltk_widget</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dt><a name="index-mgl_005fqt_005fwidget"></a>C function: <em><code>void *</code></em> <strong>mgl_qt_widget</strong> <em>(<code>HMGL</code> gr)</em></dt>
<dd><p>Возвращает указатель на виджет (<a href="#Fl_005fMathGL-class">Fl_MathGL class</a> or <a href="#QMathGL-class">QMathGL class</a>), используемый для рисования.
</p></dd></dl>


<hr>
<a name="mglDraw-class"></a>
<div class="header">
<p>
Next: <a href="#Fl_005fMathGL-class" accesskey="n" rel="next">Fl_MathGL class</a>, Previous: <a href="#mglWnd-class" accesskey="p" rel="prev">mglWnd class</a>, Up: <a href="#Widget-classes" accesskey="u" rel="up">Widget classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="mglDraw-class-1"></a>
<h3 class="section">5.2 mglDraw class</h3>

<a name="index-mglDraw"></a>

<p>This class provide base functionality for callback drawing and running calculation in separate thread. It is defined in <code>#include &lt;mgl2/wnd.h&gt;</code>. You should make inherited class and implement virtual functions if you need it.
</p>
<dl>
<dt><a name="index-Draw"></a>Virtual method on <code>mglDraw</code>: <em><code>int</code></em> <strong>Draw</strong> <em>(<code>mglGraph *</code>gr)</em></dt>
<dd><p>This is callback drawing function, which will be called when any redrawing is required for the window. There is support of a list of plots (frames). So as one can prepare a set of frames at first and redraw it fast later (but it requires more memory). Function should return positive number of frames for the list or zero if it will plot directly. 
</p></dd></dl>

<dl>
<dt><a name="index-Reload"></a>Virtual method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Reload</strong> <em>()</em></dt>
<dd><p>This is callback function, which will be called if user press menu or toolbutton to reload data. 
</p></dd></dl>

<dl>
<dt><a name="index-Click"></a>Virtual method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Click</strong> <em>()</em></dt>
<dd><p>This is callback function, which will be called if user click mouse. 
</p></dd></dl>

<dl>
<dt><a name="index-Calc"></a>Virtual method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Calc</strong> <em>()</em></dt>
<dd><p>This is callback function, which will be called if user start calculations in separate thread by calling <code>mglDraw::Run()</code> function. It should periodically call <code>mglDraw::Check()</code> function to check if calculations should be paused. 
</p></dd></dl>

<dl>
<dt><a name="index-Run-1"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Run</strong> <em>()</em></dt>
<dd><p>Runs <code>mglDraw::Calc()</code> function in separate thread. It also initialize <code>mglDraw::thr</code> variable and unlock <code>mglDraw::mutex</code>. Function is present only if FLTK support for widgets was enabled.
</p></dd></dl>

<dl>
<dt><a name="index-Cancel"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Cancel</strong> <em>()</em></dt>
<dd><p>Cancels thread with calculations. Function is present only if FLTK support for widgets was enabled.
</p></dd></dl>

<dl>
<dt><a name="index-Pause"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Pause</strong> <em>()</em></dt>
<dd><p>Pauses thread with calculations by locking <code>mglDraw::mutex</code>. You should call <code>mglDraw::Continue()</code> to continue calculations. Function is present only if FLTK support for widgets was enabled.
</p></dd></dl>

<dl>
<dt><a name="index-Continue"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Continue</strong> <em>()</em></dt>
<dd><p>Continues calculations by unlocking <code>mglDraw::mutex</code>. Function is present only if FLTK support for widgets was enabled.
</p></dd></dl>

<dl>
<dt><a name="index-Continue-1"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Continue</strong> <em>()</em></dt>
<dd><p>Checks if calculations should be paused and pause it. Function is present only if FLTK support for widgets was enabled.
</p></dd></dl>


<hr>
<a name="Fl_005fMathGL-class"></a>
<div class="header">
<p>
Next: <a href="#QMathGL-class" accesskey="n" rel="next">QMathGL class</a>, Previous: <a href="#mglDraw-class" accesskey="p" rel="prev">mglDraw class</a>, Up: <a href="#Widget-classes" accesskey="u" rel="up">Widget classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Klass-Fl_005fMathGL"></a>
<h3 class="section">5.3 Класс Fl_MathGL</h3>

<a name="index-Fl_005fMathGL-1"></a>
<a name="index-widgets-2"></a>

<p>Класс реализует элемент интерфейса FLTK для отображения графики MathGL. Он определен в <code>#include &lt;mgl2/Fl_MathGL.h&gt;</code>.
</p>
<div align="center"><img src="fltk.png" alt="Пример окна FLTK с графикой MathGL.">
</div>
<dl>
<dt><a name="index-set_005fdraw-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_draw</strong> <em>(<code>int</code> (*draw)(<code>HMGL</code> gr, <code>void *</code>p))</em></dt>
<dt><a name="index-set_005fdraw-on-Fl_005fMathGL-1"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_draw</strong> <em>(<code>int</code> (*draw)(<code>mglGraph *</code>gr))</em></dt>
<dt><a name="index-set_005fdraw-on-Fl_005fMathGL-2"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_draw</strong> <em>(<code>mglDraw *</code>draw)</em></dt>
<dd><p>Устанавливает функцию рисования как глобальную функцию или как функцию член класса, производного от <code>mglDraw</code>. Поддерживается список графиков (кадров), так что можно вначале их нарисовать (требует довольно много памяти), а потом достаточно быстро отображать. Функция должна возвращать положительное число создаваемых кадров или ноль для непосредственного рисования. Параметр <var>par</var> содержит указатель на данные пользователя, передаваемый функции рисования <var>draw</var>.
</p></dd></dl>
<dl>
<dt><a name="index-_0028_0029-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>mglDraw *</code>get_class</em> <strong>()</strong></dt>
<dd><p>Указатель на экземпляр класса <code>mglDraw</code> или <code>NULL</code> если отсутствует.
</p></dd></dl>

<dl>
<dt><a name="index-update-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>update</strong> <em>()</em></dt>
<dd><p>Обновляет (перерисовывает) график.
</p></dd></dl>
<dl>
<dt><a name="index-set_005fangle-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_angle</strong> <em>(<code>mreal</code> t, <code>mreal</code> p)</em></dt>
<dd><p>Задает углы для дополнительного вращения графика.
</p></dd></dl>
<dl>
<dt><a name="index-set_005fflag-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_flag</strong> <em>(<code>int</code> f)</em></dt>
<dd><p>Задает битовые флаги для: 1 - прозрачности, 2 - освещения.
</p></dd></dl>
<dl>
<dt><a name="index-set_005fstate-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_state</strong> <em>(<code>bool</code> z, <code>bool</code> r)</em></dt>
<dd><p>Задает флаги обработки движений мыши: <var>z</var>=<code>true</code> &ndash; разрешает приближение выделения, <var>r</var>=<code>true</code> разрешает вращение/сдвиг/приближение/перспективу.
</p></dd></dl>

<dl>
<dt><a name="index-set_005fzoom-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_zoom</strong> <em>(<code>mreal</code> X1, <code>mreal</code> Y1, <code>mreal</code> X2, <code>mreal</code> Y2)</em></dt>
<dd><p>Задает область приближения.
</p></dd></dl>
<dl>
<dt><a name="index-get_005fzoom-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>get_zoom</strong> <em>(<code>mreal *</code>X1, <code>mreal *</code>Y1, <code>mreal *</code>X2, <code>mreal *</code>Y2)</em></dt>
<dd><p>Возвращает область приближения.
</p></dd></dl>

<dl>
<dt><a name="index-set_005fpopup-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_popup</strong> <em>(<code>const Fl_Menu_Item *</code>pmenu, <code>Fl_Widget *</code>w, <code>void *</code>v)</em></dt>
<dd><p>Задает указатель на всплывающее меню.
</p></dd></dl>

<dl>
<dt><a name="index-set_005fgraph-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_graph</strong> <em>(<code>mglCanvas *</code>gr)</em></dt>
<dt><a name="index-set_005fgraph-on-Fl_005fMathGL-1"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_graph</strong> <em>(<code>mglGraph *</code>gr)</em></dt>
<dd><p>Задает экземпляр класс для рисования вместо встроеного. Fl_MathGL автоматически удалит его при удалении виджета и при новом вызове <code>set_graph()</code>.
</p></dd></dl>
<dl>
<dt><a name="index-get_005fgraph-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>mglGraph *</code></em> <strong>get_graph</strong> <em>()</em></dt>
<dd><p>Возвращает указатель на объект, строящий графики.
</p></dd></dl>

<dl>
<dt><a name="index-set_005fshow_005fwarn-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_show_warn</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Флаг показа окна с сообщениями после выполнения скрипта.
</p></dd></dl>
<dl>
<dt><a name="index-stop-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>stop</strong> <em>(<code>bool</code> stop=<code>true</code>)</em></dt>
<dd><p>Запрос на остановку рисования.
</p></dd></dl>
<dl>
<dt><a name="index-set_005fhandle_005fkey-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>void</code></em> <strong>set_handle_key</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Вкл/выкл обработку нажатий клавиш (как в mglview, по умолчанию выкл).
</p></dd></dl>
<dl>
<dt><a name="index-get_005flast_005fid-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>int</code></em> <strong>get_last_id</strong> <em>()</em></dt>
<dd><p>Вернуть id последнего выделенного объекта.
</p></dd></dl>
<dl>
<dt><a name="index-running-on-Fl_005fMathGL"></a>Method on Fl_MathGL: <em><code>bool</code></em> <strong>running</strong> <em>()</em></dt>
<dd><p>Проверяет выполняется ли сейчас скрипт или нет.
</p></dd></dl>

<dl>
<dt><a name="index-tet_005fval-of-Fl_005fMathGL"></a>Widget option of Fl_MathGL: <em><code>Fl_Valuator *</code></em> <strong>tet_val</strong></dt>
<dd><p>Указатель на внешний элемент управления для изменения угла tet.
</p></dd></dl>
<dl>
<dt><a name="index-phi_005fval-of-Fl_005fMathGL"></a>Widget option of Fl_MathGL: <em><code>Fl_Valuator *</code></em> <strong>phi_val</strong></dt>
<dd><p>Указатель на внешний элемент управления для изменения угла phi.
</p></dd></dl>


<hr>
<a name="QMathGL-class"></a>
<div class="header">
<p>
Next: <a href="#wxMathGL-class" accesskey="n" rel="next">wxMathGL class</a>, Previous: <a href="#Fl_005fMathGL-class" accesskey="p" rel="prev">Fl_MathGL class</a>, Up: <a href="#Widget-classes" accesskey="u" rel="up">Widget classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Klass-QMathGL"></a>
<h3 class="section">5.4 Класс QMathGL</h3>

<a name="index-QMathGL-1"></a>
<a name="index-widgets-3"></a>

<p>Класс реализует элемент интерфейса Qt для отображения графики MathGL. Он определен в <code>#include &lt;mgl2/qt.h&gt;</code>.
</p>
<div align="center"><img src="qt.png" alt="Пример окна Qt с графикой MathGL.">
</div>
<dl>
<dt><a name="index-setDraw-on-QMathGL"></a>Method on QMathGL: <em><code>void</code></em> <strong>setDraw</strong> <em>(<code>mglDraw *</code>dr)</em></dt>
<dd><p>Задает функцию рисования из класса производного от <code>mglDraw</code>.
</p></dd></dl>
<dl>
<dt><a name="index-setDraw-on-QMathGL-1"></a>Method on QMathGL: <em><code>void</code></em> <strong>setDraw</strong> <em>(<code>int (*</code>draw<code>)(mglBase *</code>gr, <code>void *</code>p<code>)</code>, <code>void *</code>par=<code>NULL</code>)</em></dt>
<dt><a name="index-setDraw-on-QMathGL-2"></a>Method on QMathGL: <em><code>void</code></em> <strong>setDraw</strong> <em>(<code>int (*</code>draw<code>)(mglGraph *</code>gr<code>)</code>)</em></dt>
<dd><p>Задает функцию рисования <var>draw</var>. Поддерживается список графиков (кадров), так что можно вначале их нарисовать (требует довольно много памяти), а потом достаточно быстро отображать. Функция должна возвращать положительное число создаваемых кадров или ноль для непосредственного рисования. Параметр <var>par</var> содержит указатель на данные пользователя, передаваемый функции рисования <var>draw</var>.
</p></dd></dl>

<dl>
<dt><a name="index-setGraph-on-QMathGL"></a>Method on QMathGL: <em><code>void</code></em> <strong>setGraph</strong> <em>(<code>mglCanvas *</code>gr)</em></dt>
<dt><a name="index-setGraph-on-QMathGL-1"></a>Method on QMathGL: <em><code>void</code></em> <strong>setGraph</strong> <em>(<code>mglGraph *</code>gr)</em></dt>
<dd><p>Устанавливает указатель на внешний экземпляр класса для рисования (вместо встроенного). Отмечу, что QMathGL автоматически удалит этот объект при удалении элемента интерфейса или при новом вызове <code>setGraph()</code>.
</p></dd></dl>
<dl>
<dt><a name="index-getGraph-on-QMathGL"></a>Method on QMathGL: <em><code>HMGL</code></em> <strong>getGraph</strong> <em>()</em></dt>
<dd><p>Возвращает указатель на объект, строящий графики.
</p></dd></dl>

<dl>
<dt><a name="index-setPopup-on-QMathGL"></a>Method on QMathGL: <em><code>void</code></em> <strong>setPopup</strong> <em>(<code>QMenu *</code>p)</em></dt>
<dd><p>Задает указатель на всплывающее меню.
</p></dd></dl>
<dl>
<dt><a name="index-setSize-on-QMathGL"></a>Method on QMathGL: <em><code>void</code></em> <strong>setSize</strong> <em>(<code>int</code> w, <code>int</code> h)</em></dt>
<dd><p>Задает размеры элемента управления и картинки.
</p></dd></dl>
<dl>
<dt><a name="index-getRatio-on-QMathGL"></a>Method on QMathGL: <em><code>double</code></em> <strong>getRatio</strong> <em>()</em></dt>
<dd><p>Возвращает соотношение сторон рисунка.
</p></dd></dl>

<dl>
<dt><a name="index-getPer-on-QMathGL"></a>Method on QMathGL: <em><code>int</code></em> <strong>getPer</strong> <em>()</em></dt>
<dd><p>Возвращает величину перспективы в процентах.
</p></dd></dl>
<dl>
<dt><a name="index-getPhi-on-QMathGL"></a>Method on QMathGL: <em><code>int</code></em> <strong>getPhi</strong> <em>()</em></dt>
<dd><p>Возвращает величину угла Phi в градусах.
</p></dd></dl>
<dl>
<dt><a name="index-getTet-on-QMathGL"></a>Method on QMathGL: <em><code>int</code></em> <strong>getTet</strong> <em>()</em></dt>
<dd><p>Возвращает величину угла Theta в градусах.
</p></dd></dl>
<dl>
<dt><a name="index-getAlpha-on-QMathGL"></a>Method on QMathGL: <em><code>bool</code></em> <strong>getAlpha</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя прозрачности.
</p></dd></dl>
<dl>
<dt><a name="index-getLight-on-QMathGL"></a>Method on QMathGL: <em><code>bool</code></em> <strong>getLight</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя освещения.
</p></dd></dl>
<dl>
<dt><a name="index-getZoom-on-QMathGL"></a>Method on QMathGL: <em><code>bool</code></em> <strong>getZoom</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя приближения мышью.
</p></dd></dl>
<dl>
<dt><a name="index-getRotate-on-QMathGL"></a>Method on QMathGL: <em><code>bool</code></em> <strong>getRotate</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя вращения мышью.
</p></dd></dl>


<dl>
<dt><a name="index-refresh"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>refresh</strong> <em>()</em></dt>
<dd><p>Перерисовывает (обновляет) элемент управления без вызова функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-update"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>update</strong> <em>()</em></dt>
<dd><p>Обновляет рисунок путем вызова функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-copy"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>copy</strong> <em>()</em></dt>
<dd><p>Копирует график в буфер обмена.
</p></dd></dl>
<dl>
<dt><a name="index-copyClickCoor"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>copyClickCoor</strong> <em>()</em></dt>
<dd><p>Копирует координаты щелчка мышью (как текст).
</p></dd></dl>
<dl>
<dt><a name="index-print"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>print</strong> <em>()</em></dt>
<dd><p>Печатает текущий рисунок.
</p></dd></dl>

<dl>
<dt><a name="index-stop-1"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>stop</strong> <em>()</em></dt>
<dd><p>Посылает сигнал остановки рисования.
</p></dd></dl>
<dl>
<dt><a name="index-adjust-1"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>adjust</strong> <em>()</em></dt>
<dd><p>Подгоняет размер картинки под размер окна.
</p></dd></dl>
<dl>
<dt><a name="index-nextSlide"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>nextSlide</strong> <em>()</em></dt>
<dd><p>Показывает следующий кадр.
</p></dd></dl>
<dl>
<dt><a name="index-prevSlide"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>prevSlide</strong> <em>()</em></dt>
<dd><p>Показывает предыдущий кадр.
</p></dd></dl>
<dl>
<dt><a name="index-animation"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>animation</strong> <em>(<code>bool</code> st=<code>true</code>)</em></dt>
<dd><p>Запускает анимацию.
</p></dd></dl>

<dl>
<dt><a name="index-setPer"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setPer</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину перспективы.
</p></dd></dl>
<dl>
<dt><a name="index-setPhi"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setPhi</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину угла Phi.
</p></dd></dl>
<dl>
<dt><a name="index-setTet"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setTet</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину угла Theta.
</p></dd></dl>
<dl>
<dt><a name="index-setAlpha"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setAlpha</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает прозрачность.
</p></dd></dl>
<dl>
<dt><a name="index-setLight"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setLight</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает освещение.
</p></dd></dl>
<dl>
<dt><a name="index-setGrid"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setGrid</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает рисование сетки абсолютных координат на графике.
</p></dd></dl>
<dl>
<dt><a name="index-setZoom"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setZoom</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает приближение мышью.
</p></dd></dl>
<dl>
<dt><a name="index-setRotate"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setRotate</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает вращение мышью.
</p></dd></dl>
<dl>
<dt><a name="index-zoomIn"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>zoomIn</strong> <em>()</em></dt>
<dd><p>Приблиажет график.
</p></dd></dl>
<dl>
<dt><a name="index-zoomOut"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>zoomOut</strong> <em>()</em></dt>
<dd><p>Отдаляет график.
</p></dd></dl>
<dl>
<dt><a name="index-shiftLeft"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>shiftLeft</strong> <em>()</em></dt>
<dd><p>Сдвигает график влево.
</p></dd></dl>
<dl>
<dt><a name="index-shiftRight"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>shiftRight</strong> <em>()</em></dt>
<dd><p>Сдвигает график вправо.
</p></dd></dl>
<dl>
<dt><a name="index-shiftUp"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>shiftUp</strong> <em>()</em></dt>
<dd><p>Сдвигает график вверх.
</p></dd></dl>
<dl>
<dt><a name="index-shiftDown"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>shiftDown</strong> <em>()</em></dt>
<dd><p>Сдвигает график вниз.
</p></dd></dl>
<dl>
<dt><a name="index-restore"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>restore</strong> <em>()</em></dt>
<dd><p>Восстанавливает приближение и поворот графика в значения по умолчанию.
</p></dd></dl>

<dl>
<dt><a name="index-exportPNG"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportPNG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в PNG файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportPNGs"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportPNGs</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в PNG файл без прозрачности.
</p></dd></dl>
<dl>
<dt><a name="index-exportJPG"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportJPG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в JPEG файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportBPS"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportBPS</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в растровый EPS файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportEPS"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportEPS</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный EPS файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportSVG"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportSVG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный SVG файл.
</p></dd></dl>

<dl>
<dt><a name="index-exportGIF"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportGIF</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в GIF файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportTEX"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportTEX</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный LaTeX/Tikz файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportTGA"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportTGA</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в TGA файл.
</p></dd></dl>

<dl>
<dt><a name="index-exportXYZ"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportXYZ</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный XYZ/XYZL/XYZF файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportOBJ"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportOBJ</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный OBJ/MTL файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportSTL"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportSTL</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный STL файл.
</p></dd></dl>
<dl>
<dt><a name="index-exportOFF"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>exportOFF</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный OFF файл.
</p></dd></dl>

<dl>
<dt><a name="index-setUsePrimitives"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setUsePrimitives</strong> <em>(<code>bool</code> use)</em></dt>
<dd><p>Разрешает использовать список примитивов для кадров. Это позволяет вращать/масштабировать кадры, но требует значительно больше памяти. По умолчанию разрешено (=<code>true</code>).
</p></dd></dl>
<dl>
<dt><a name="index-setMGLFont"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>setMGLFont</strong> <em>(<code>QString</code> path)</em></dt>
<dd><p>Восстанавливает (<var>path</var>=<code>&quot;&quot;</code>) или загружает файлы шрифтов.
</p></dd></dl>

<dl>
<dt><a name="index-about"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>about</strong> <em>()</em></dt>
<dd><p>Показывает информацию о программе.
</p></dd></dl>
<dl>
<dt><a name="index-aboutQt"></a>Slot on <code>QMathGL</code>: <em><code>void</code></em> <strong>aboutQt</strong> <em>()</em></dt>
<dd><p>Показывает информацию о версии Qt.
</p></dd></dl>

<dl>
<dt><a name="index-phiChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>phiChanged</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Угол Phi изменен.
</p></dd></dl>
<dl>
<dt><a name="index-tetChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>tetChanged</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Угол Tet изменен.
</p></dd></dl>
<dl>
<dt><a name="index-perChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>perChanged</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Перспектива изменена.
</p></dd></dl>
<dl>
<dt><a name="index-alphaChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>alphaChanged</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Прозрачность изменена.
</p></dd></dl>
<dl>
<dt><a name="index-lightChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>lightChanged</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Освещение изменено.
</p></dd></dl>
<dl>
<dt><a name="index-gridChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>gridChanged</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Рисование сетки изменено.
</p></dd></dl>
<dl>
<dt><a name="index-zoomChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>zoomChanged</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Режим приближения мышью изменен.
</p></dd></dl>
<dl>
<dt><a name="index-rotateChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>rotateChanged</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Режим вращения мышью изменен.
</p></dd></dl>

<dl>
<dt><a name="index-mouseClick"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>mouseClick</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dd><p>Был щелчок мышью в точке {x,y,z}.
</p></dd></dl>
<dl>
<dt><a name="index-frameChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>frameChanged</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Требуется новый кадр для отображения.
</p></dd></dl>
<dl>
<dt><a name="index-showWarn"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>showWarn</strong> <em>(<code>QString</code> warn)</em></dt>
<dd><p>Есть предупреждения.
</p></dd></dl>
<dl>
<dt><a name="index-posChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>posChanged</strong> <em>(<code>QString</code> pos)</em></dt>
<dd><p>Положение щелчка мышью изменилось.
</p></dd></dl>
<dl>
<dt><a name="index-objChanged"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>objChanged</strong> <em>(<code>int</code> id)</em></dt>
<dd><p>Изменился id объекта на графике (из-за щелчка мышью).
</p></dd></dl>
<dl>
<dt><a name="index-refreshData"></a>Signal on <code>QMathGL</code>: <em><code>void</code></em> <strong>refreshData</strong> <em>()</em></dt>
<dd><p>Данные могли измениться (рисование завершено).
</p></dd></dl>


<dl>
<dt><a name="index-appName-of-QMathGL"></a>QMathGL option of QMathGL: <em><code>QString</code></em> <strong>appName</strong></dt>
<dd><p>Имя приложения для окон сообщений.
</p></dd></dl>
<dl>
<dt><a name="index-autoResize-of-QMathGL"></a>QMathGL option of QMathGL: <em><code>bool</code></em> <strong>autoResize</strong></dt>
<dd><p>Разрешить изменять размер рисунка (по умолчанию false).
</p></dd></dl>





<hr>
<a name="wxMathGL-class"></a>
<div class="header">
<p>
Previous: <a href="#QMathGL-class" accesskey="p" rel="prev">QMathGL class</a>, Up: <a href="#Widget-classes" accesskey="u" rel="up">Widget classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Klass-wxMathGL"></a>
<h3 class="section">5.5 Класс wxMathGL</h3>

<a name="index-wxMathGL"></a>
<a name="index-widgets-4"></a>

<p>Класс реализует элемент интерфейса WX для отображения графики MathGL. Он определен в <code>#include &lt;mgl2/wx.h&gt;</code>.
</p>
<dl>
<dt><a name="index-SetDraw-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetDraw</strong> <em>(<code>mglDraw *</code>dr)</em></dt>
<dd><p>Задает функцию рисования из класса производного от <code>mglDraw</code>.
</p></dd></dl>
<dl>
<dt><a name="index-SetDraw-on-wxMathGL-1"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetDraw</strong> <em>(<code>int (*</code>draw<code>)(mglBase *</code>gr, <code>void *</code>p<code>)</code>, <code>void *</code>par=<code>NULL</code>)</em></dt>
<dt><a name="index-SetDraw-on-wxMathGL-2"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetDraw</strong> <em>(<code>int (*</code>draw<code>)(mglGraph *</code>gr<code>)</code>)</em></dt>
<dd><p>Задает функцию рисования <var>draw</var>. Поддерживается список графиков (кадров), так что можно вначале их нарисовать (требует довольно много памяти), а потом достаточно быстро отображать. Функция должна возвращать положительное число создаваемых кадров или ноль для непосредственного рисования. Параметр <var>par</var> содержит указатель на данные пользователя, передаваемый функции рисования <var>draw</var>.
</p></dd></dl>

<dl>
<dt><a name="index-SetGraph-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetGraph</strong> <em>(<code>mglCanvas *</code>gr)</em></dt>
<dt><a name="index-SetGraph-on-wxMathGL-1"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetGraph</strong> <em>(<code>mglGraph *</code>gr)</em></dt>
<dd><p>Устанавливает указатель на внешний экземпляр класса для рисования (вместо встроенного). Отмечу, что wxMathGL автоматически удалит этот объект при удалении элемента интерфейса или при новом вызове <code>setGraph()</code>.
</p></dd></dl>
<dl>
<dt><a name="index-GetGraph-on-wxMathGL"></a>Method on wxMathGL: <em><code>HMGL</code></em> <strong>GetGraph</strong> <em>()</em></dt>
<dd><p>Возвращает указатель на объект, строящий графики.
</p></dd></dl>

<dl>
<dt><a name="index-SetPopup-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetPopup</strong> <em>(<code>QMenu *</code>p)</em></dt>
<dd><p>Задает указатель на всплывающее меню.
</p></dd></dl>
<dl>
<dt><a name="index-SetSize-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetSize</strong> <em>(<code>int</code> w, <code>int</code> h)</em></dt>
<dd><p>Задает размеры элемента управления и картинки.
</p></dd></dl>
<dl>
<dt><a name="index-GetRatio-on-wxMathGL"></a>Method on wxMathGL: <em><code>double</code></em> <strong>GetRatio</strong> <em>()</em></dt>
<dd><p>Возвращает соотношение сторон рисунка.
</p></dd></dl>

<dl>
<dt><a name="index-GetPer-on-wxMathGL"></a>Method on wxMathGL: <em><code>int</code></em> <strong>GetPer</strong> <em>()</em></dt>
<dd><p>Возвращает величину перспективы в процентах.
</p></dd></dl>
<dl>
<dt><a name="index-GetPhi-on-wxMathGL"></a>Method on wxMathGL: <em><code>int</code></em> <strong>GetPhi</strong> <em>()</em></dt>
<dd><p>Возвращает величину угла Phi в градусах.
</p></dd></dl>
<dl>
<dt><a name="index-GetTet-on-wxMathGL"></a>Method on wxMathGL: <em><code>int</code></em> <strong>GetTet</strong> <em>()</em></dt>
<dd><p>Возвращает величину угла Theta в градусах.
</p></dd></dl>
<dl>
<dt><a name="index-GetAlpha-on-wxMathGL"></a>Method on wxMathGL: <em><code>bool</code></em> <strong>GetAlpha</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя прозрачности.
</p></dd></dl>
<dl>
<dt><a name="index-GetLight-on-wxMathGL"></a>Method on wxMathGL: <em><code>bool</code></em> <strong>GetLight</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя освещения.
</p></dd></dl>
<dl>
<dt><a name="index-GetZoom-on-wxMathGL"></a>Method on wxMathGL: <em><code>bool</code></em> <strong>GetZoom</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя приближения мышью.
</p></dd></dl>
<dl>
<dt><a name="index-GetRotate-on-wxMathGL"></a>Method on wxMathGL: <em><code>bool</code></em> <strong>GetRotate</strong> <em>()</em></dt>
<dd><p>Возвращает состояние переключателя вращения мышью.
</p></dd></dl>


<dl>
<dt><a name="index-Repaint-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Repaint</strong> <em>()</em></dt>
<dd><p>Перерисовывает (обновляет) элемент управления без вызова функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-Update-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Update</strong> <em>()</em></dt>
<dd><p>Обновляет рисунок путем вызова функции рисования.
</p></dd></dl>
<dl>
<dt><a name="index-Copy-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Copy</strong> <em>()</em></dt>
<dd><p>Копирует график в буфер обмена.
</p></dd></dl>
<dl>
<dt><a name="index-Print-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Print</strong> <em>()</em></dt>
<dd><p>Печатает текущий рисунок.
</p></dd></dl>

<dl>
<dt><a name="index-Adjust-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Adjust</strong> <em>()</em></dt>
<dd><p>Подгоняет размер картинки под размер окна.
</p></dd></dl>
<dl>
<dt><a name="index-NextSlide-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>NextSlide</strong> <em>()</em></dt>
<dd><p>Показывает следующий кадр.
</p></dd></dl>
<dl>
<dt><a name="index-PrevSlide-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>PrevSlide</strong> <em>()</em></dt>
<dd><p>Показывает предыдущий кадр.
</p></dd></dl>
<dl>
<dt><a name="index-Animation-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Animation</strong> <em>(<code>bool</code> st=<code>true</code>)</em></dt>
<dd><p>Запускает анимацию.
</p></dd></dl>

<dl>
<dt><a name="index-SetPer-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetPer</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину перспективы.
</p></dd></dl>
<dl>
<dt><a name="index-SetPhi-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetPhi</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину угла Phi.
</p></dd></dl>
<dl>
<dt><a name="index-SetTet-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetTet</strong> <em>(<code>int</code> val)</em></dt>
<dd><p>Задает величину угла Theta.
</p></dd></dl>
<dl>
<dt><a name="index-SetAlpha-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetAlpha</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает прозрачность.
</p></dd></dl>
<dl>
<dt><a name="index-SetLight-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetLight</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает освещение.
</p></dd></dl>
<dl>
<dt><a name="index-SetZoom-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetZoom</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает приближение мышью.
</p></dd></dl>
<dl>
<dt><a name="index-SetRotate-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>SetRotate</strong> <em>(<code>bool</code> val)</em></dt>
<dd><p>Включает/выключает вращение мышью.
</p></dd></dl>
<dl>
<dt><a name="index-ZoomIn-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ZoomIn</strong> <em>()</em></dt>
<dd><p>Приблиажет график.
</p></dd></dl>
<dl>
<dt><a name="index-ZoomOut-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ZoomOut</strong> <em>()</em></dt>
<dd><p>Отдаляет график.
</p></dd></dl>
<dl>
<dt><a name="index-ShiftLeft-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ShiftLeft</strong> <em>()</em></dt>
<dd><p>Сдвигает график влево.
</p></dd></dl>
<dl>
<dt><a name="index-ShiftRight-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ShiftRight</strong> <em>()</em></dt>
<dd><p>Сдвигает график вправо.
</p></dd></dl>
<dl>
<dt><a name="index-ShiftUp-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ShiftUp</strong> <em>()</em></dt>
<dd><p>Сдвигает график вверх.
</p></dd></dl>
<dl>
<dt><a name="index-ShiftDown-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ShiftDown</strong> <em>()</em></dt>
<dd><p>Сдвигает график вниз.
</p></dd></dl>
<dl>
<dt><a name="index-Restore-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>Restore</strong> <em>()</em></dt>
<dd><p>Восстанавливает приближение и поворот графика в значения по умолчанию.
</p></dd></dl>

<dl>
<dt><a name="index-About-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>About</strong> <em>()</em></dt>
<dd><p>Показывает информацию о программе.
</p></dd></dl>

<dl>
<dt><a name="index-ExportPNG-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportPNG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в PNG файл.
</p></dd></dl>
<dl>
<dt><a name="index-ExportPNGs-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportPNGs</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в PNG файл без прозрачности.
</p></dd></dl>
<dl>
<dt><a name="index-ExportJPG-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportJPG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в JPEG файл.
</p></dd></dl>
<dl>
<dt><a name="index-ExportBPS-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportBPS</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в растровый EPS файл.
</p></dd></dl>
<dl>
<dt><a name="index-ExportEPS-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportEPS</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный EPS файл.
</p></dd></dl>
<dl>
<dt><a name="index-ExportSVG-on-wxMathGL"></a>Method on wxMathGL: <em><code>void</code></em> <strong>ExportSVG</strong> <em>(<code>QString</code> fname=<code>&quot;&quot;</code>)</em></dt>
<dd><p>Сохраняет текущий рисунок в векторный SVG файл.
</p></dd></dl>




<hr>
<a name="Data-processing"></a>
<div class="header">
<p>
Next: <a href="#MGL-scripts" accesskey="n" rel="next">MGL scripts</a>, Previous: <a href="#Widget-classes" accesskey="p" rel="prev">Widget classes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Obrabotka-dannykh"></a>
<h2 class="chapter">6 Обработка данных</h2>



<p>В данной главе описываются классы <code>mglData</code> и <code>mglDataC</code> для работы с массивами действительных и комплексных данных, определённые в <code>#include &lt;mgl2/data.h&gt;</code> и <code>#include &lt;mgl2/datac.h&gt;</code> соответственно. Оба класса являются наследниками абстрактного класса <code>mglDataA</code>, и могут быть использованы в аргументах всех функций рисования (см. <a href="#MathGL-core">MathGL core</a>). Классы содержат функции для выделения памяти и изменения размера данных, чтения данных из файла, численного дифференцирования, интегрирования, интерполяции и пр., заполнения по текстовой формуле и т.д. Классы позволяют работать с данными размерности не более 3 (как функции от трёх переменных &ndash; x,y,z). По умолчанию внутреннее представление данных использует тип mreal (и dual=std::complex&lt;mreal&gt; для <code>mglDataC</code>), который может быть сконфигурирован как float или double на этапе установки указав опцию <code>--enable-double</code> (см. <a href="#Installation">Installation</a>). Тип float удобен в силу меньшего размера занимаемой памяти и, как правило, достаточной для построения графиков точности. Однако, тип double имеет большую точность, что может быть важно, например, для осей с метками времени. Массивы которые могут быть созданы командами MGL отображаются Small Caps шрифтом (например, <small>DAT</small>).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Public-variables" accesskey="1">Public variables</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-constructor" accesskey="2">Data constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-resizing" accesskey="3">Data resizing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-filling" accesskey="4">Data filling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#File-I_002fO" accesskey="5">File I/O</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Make-another-data" accesskey="6">Make another data</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-changing" accesskey="7">Data changing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Interpolation" accesskey="8">Interpolation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-information" accesskey="9">Data information</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Operators">Operators</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Global-functions">Global functions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Evaluate-expression">Evaluate expression</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Special-data-classes">Special data classes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Public-variables"></a>
<div class="header">
<p>
Next: <a href="#Data-constructor" accesskey="n" rel="next">Data constructor</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Peremennye"></a>
<h3 class="section">6.1 Переменные</h3>



<dl>
<dt><a name="index-a-of-mglData"></a>Variable of mglData: <em><code>mreal *</code></em> <strong>a</strong></dt>
<dt><a name="index-a-of-mglDataC"></a>Variable of mglDataC: <em><code>dual *</code></em> <strong>a</strong></dt>
<dd><p>Указатель на массив данных. Это одномерный массив. Например, матрица [nx x ny x nz] представляется одномерным массивом длиной nx*ny*nz, где элемент с индексами {i, j, k} находится как a[i+nx*j+nx*ny*k] (индексы отсчитываются от нуля).
</p></dd></dl>
<dl>
<dt><a name="index-nx-of-mglData"></a>Variable of mglData: <em><code>int</code></em> <strong>nx</strong></dt>
<dt><a name="index-nx-of-mglDataC"></a>Variable of mglDataC: <em><code>long</code></em> <strong>nx</strong></dt>
<dd><p>Размер массива по 1-ой размерности (&rsquo;x&rsquo; размерности).
</p></dd></dl>
<dl>
<dt><a name="index-ny-of-mglData"></a>Variable of mglData: <em><code>int</code></em> <strong>ny</strong></dt>
<dt><a name="index-ny-of-mglDataC"></a>Variable of mglDataC: <em><code>long</code></em> <strong>ny</strong></dt>
<dd><p>Размер массива по 2-ой размерности (&rsquo;y&rsquo; размерности).
</p></dd></dl>
<dl>
<dt><a name="index-nz-of-mglData"></a>Variable of mglData: <em><code>int</code></em> <strong>nz</strong></dt>
<dt><a name="index-nz-of-mglDataC"></a>Variable of mglDataC: <em><code>long</code></em> <strong>nz</strong></dt>
<dd><p>Размер массива по 3-ей размерности (&rsquo;z&rsquo; размерности).
</p></dd></dl>
<dl>
<dt><a name="index-id-of-mglData"></a>Variable of mglData: <em><code>std::string</code></em> <strong>id</strong></dt>
<dt><a name="index-id-of-mglDataC"></a>Variable of mglDataC: <em><code>std::string</code></em> <strong>id</strong></dt>
<dd><p>Имена колонки (или среза при nz&gt;1) &ndash; один символ на колонку.
</p></dd></dl>
<dl>
<dt><a name="index-link-of-mglData"></a>Variable of mglData: <em><code>bool</code></em> <strong>link</strong></dt>
<dt><a name="index-link-of-mglDataC"></a>Variable of mglDataC: <em><code>bool</code></em> <strong>link</strong></dt>
<dd><p>Флаг использования указателя на внешние данные, включает запрет на удаление массива данных.
</p></dd></dl>

<dl>
<dt><a name="index-s-of-mglDataA"></a>Variable of mglDataA: <em><code>std::wstring</code></em> <strong>s</strong></dt>
<dd><p>Имя массива данных, использующееся при разборе MGL скриптов.
</p></dd></dl>
<dl>
<dt><a name="index-temp-of-mglDataA"></a>Variable of mglDataA: <em><code>bool</code></em> <strong>temp</strong></dt>
<dd><p>Флаг временной переменной, которая может быть удалена в любой момент.
</p></dd></dl>
<dl>
<dt><a name="index-func-of-mglDataA"></a>Variable of mglDataA: <em><code>void (*)(void *)</code></em> <strong>func</strong></dt>
<dd><p>Указатель на callback функцию, которая будет вызвана при удлалении данных.
</p></dd></dl>
<dl>
<dt><a name="index-o-of-mglDataA"></a>Variable of mglDataA: <em><code>void *</code></em> <strong>o</strong></dt>
<dd><p>Указатель для callback функции.
</p></dd></dl>

<dl>
<dt><a name="index-GetVal"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>GetVal</strong> <em>(<code>long</code> i)</em></dt>
<dt><a name="index-GetVal-1"></a>Метод класса <code>mglDataC</code>: <em><code>mreal</code></em> <strong>GetVal</strong> <em>(<code>long</code> i)</em></dt>
<dt><a name="index-SetVal"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>SetVal</strong> <em>(<code>mreal</code> val, <code>long</code> i)</em></dt>
<dt><a name="index-SetVal-1"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>SetVal</strong> <em>(<code>mreal</code> val, <code>long</code> i)</em></dt>
<dd><p>Присваивает или возвращает значение используя &quot;непрерывную&quot; индексацию без проверки выхода за границы массива. Индекс <var>i</var> должен быть в диапазоне [0, nx*ny*nz-1].
</p></dd></dl>

<dl>
<dt><a name="index-GetNx-1"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNx</strong> <em>()</em></dt>
<dt><a name="index-GetNy-1"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNy</strong> <em>()</em></dt>
<dt><a name="index-GetNz-1"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNz</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fnx"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_nx</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fny"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_ny</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fnz"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_nz</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает размер данных в направлении x, y и z соответственно.
</p></dd></dl>

<dl>
<dt><a name="index-mgl_005fdata_005fget_005fvalue"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_get_value</strong> <em>(<code>HCDT</code> dat, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdatac_005fget_005fvalue"></a>Функция С: <em><code>dual</code></em> <strong>mgl_datac_get_value</strong> <em>(<code>HCDT</code> dat, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdata_005fvalue"></a>Функция С: <em><code>mreal *</code></em> <strong>mgl_data_value</strong> <em>(<code>HMDT</code> dat, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdatac_005fvalue"></a>Функция С: <em><code>dual *</code></em> <strong>mgl_datac_value</strong> <em>(<code>HADT</code> dat, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fvalue"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_value</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> v, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fvalue"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_value</strong> <em>(<code>HADT</code> dat, <code>dual</code> v, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dd><p>Присваивает или возвращает значение ячейки данных с проверкой выхода за пределы массива.
</p></dd></dl>
<dl>
<dt><a name="index-mgl_005fdata_005fdata"></a>Функция С: <em><code>const mreal *</code></em> <strong>mgl_data_data</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает указатель на внутренний массив данных.
</p></dd></dl>

<dl>
<dt><a name="index-mgl_005fdata_005fset_005ffunc"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_func</strong> <em>(<code>mglDataA *</code>dat, <code>void (*</code>func<code>)(void *)</code>, <code>void *</code>par)</em></dt>
<dd><p>Задает указатель на callback функцию, которая будет вызвана при удлалении данных.
</p></dd></dl>

<dl>
<dt><a name="index-mgl_005fdata_005fset_005fname"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_name</strong> <em>(<code>mglDataA *</code>dat, <code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fname_005fw"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_name_w</strong> <em>(<code>mglDataA *</code>dat, <code>const wchar_t *</code>name)</em></dt>
<dd><p>Задает имя массива данных, использующееся при разборе MGL скриптов.
</p></dd></dl>



<hr>
<a name="Data-constructor"></a>
<div class="header">
<p>
Next: <a href="#Data-resizing" accesskey="n" rel="next">Data resizing</a>, Previous: <a href="#Public-variables" accesskey="p" rel="prev">Public variables</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sozdanie-i-udalenie-dannykh"></a>
<h3 class="section">6.2 Создание и удаление данных</h3>

<a name="index-mglData"></a>


<a name="new"></a><dl>
<dt><a name="index-new"></a>Команда MGL: <em></em> <strong>new</strong> <em><small>DAT</small> [<code>nx=1</code> 'eq']</em></dt>
<dt><a name="index-new-1"></a>Команда MGL: <em></em> <strong>new</strong> <em><small>DAT</small> <code>nx ny</code> ['eq']</em></dt>
<dt><a name="index-new-2"></a>Команда MGL: <em></em> <strong>new</strong> <em><small>DAT</small> <code>nx ny nz</code> ['eq']</em></dt>
<dt><a name="index-mglData-1"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>int</code> mx=<code>1</code>, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-mglDataC"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> mx=<code>1</code>, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fcreate_005fdata"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_create_data</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fcreate_005fdata_005fsize"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_create_data_size</strong> <em>(<code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dd><p>Выделяет память для массива данных и заполняет её нулями. Если указана формула <var>eq</var>, то данные заполняются также как при использовании <a href="#fill">fill</a>.
</p></dd></dl>

<a name="copy"></a><dl>
<dt><a name="index-copy-1"></a>Команда MGL: <em></em> <strong>copy</strong> <em><small>DAT</small> dat2 ['eq'='']</em></dt>
<dt><a name="index-copy-2"></a>Команда MGL: <em></em> <strong>copy</strong> <em><small>DAT</small> <code>val</code></em></dt>
<dt><a name="index-mglData-2"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>const mglData &amp;</code>dat2)</em></dt>
<dt><a name="index-mglData-3"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>const mglDataA *</code>dat2)</em></dt>
<dt><a name="index-mglData-4"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>int</code> size, <code>const mreal *</code>dat2)</em></dt>
<dt><a name="index-mglData-5"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>int</code> size, <code>int</code> cols, <code>const mreal *</code>dat2)</em></dt>
<dt><a name="index-mglData-6"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>int</code> size, <code>const double *</code>dat2)</em></dt>
<dt><a name="index-mglData-7"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>int</code> size, <code>int</code> cols, <code>const double *</code>dat2)</em></dt>
<dt><a name="index-mglData-8"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>const double *</code>dat2, <code>int</code> size)</em></dt>
<dt><a name="index-mglData-9"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>const double *</code>dat2, <code>int</code> size, <code>int</code> cols)</em></dt>
<dt><a name="index-mglDataC-1"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>const mglDataA &amp;</code>dat2)</em></dt>
<dt><a name="index-mglDataC-2"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>const mglDataA *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-3"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>const float *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-4"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>int</code> cols, <code>const float *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-5"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>const double *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-6"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>int</code> cols, <code>const double *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-7"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>const dual *</code>dat2)</em></dt>
<dt><a name="index-mglDataC-8"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>int</code> size, <code>int</code> cols, <code>const dual *</code>dat2)</em></dt>
<dd><p>Копирует данные из другого экземпляра данных. Если указана формула <var>eq</var>, то данные заполняются также как при использовании <a href="#fill">fill</a>.
</p></dd></dl>

<dl>
<dt><a name="index-copy-3"></a>Команда MGL: <em></em> <strong>copy</strong> <em><small>REDAT</small> <small>IMDAT</small> dat2</em></dt>
<dd><p>Копирует действительную и мнимую часть данных из комплексного массива данных <var>dat2</var>.
</p></dd></dl>

<dl>
<dt><a name="index-copy-4"></a>Команда MGL: <em></em> <strong>copy</strong> <em><small>DAT</small> 'name'</em></dt>
<dd><p>Копирует данные из другого экземпляра данных с именем <var>name</var>. При этом имя <var>name</var> может быть некорректным с точки зрения MGL (например, взятым из HDF5 файла).
</p></dd></dl>



<dl>
<dt><a name="index-read"></a>Команда MGL: <em></em> <strong>read</strong> <em><small>DAT</small> 'fname'</em></dt>
<dt><a name="index-mglData-10"></a>Конструктор класса <code>mglData</code>: <em></em> <strong>mglData</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mglDataC-9"></a>Конструктор класса <code>mglDataC</code>: <em></em> <strong>mglDataC</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fcreate_005fdata_005ffile"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_create_data_file</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fcreate_005fdatac_005ffile"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_create_datac_file</strong> <em>(<code>const char *</code>fname)</em></dt>
<dd><p>Читает данные из текстового файла с автоматическим определением размеров массива.
</p></dd></dl>

<dl>
<dt><a name="index-delete"></a>Команда MGL: <em></em> <strong>delete</strong> <em>dat</em></dt>
<dt><a name="index-delete-1"></a>Команда MGL: <em></em> <strong>delete</strong> <em>'name'</em></dt>
<dt><a name="index-_007emglData"></a>Destructor on <code>mglData</code>: <em></em> <strong>~mglData</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdelete_005fdata"></a>Функция С: <em><code>void</code></em> <strong>mgl_delete_data</strong> <em>(<code>HMDT</code> dat)</em></dt>
<dt><a name="index-_007emglDataC"></a>Destructor on <code>mglDataC</code>: <em></em> <strong>~mglDataC</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdelete_005fdatac"></a>Функция С: <em><code>void</code></em> <strong>mgl_delete_datac</strong> <em>(<code>HADT</code> dat)</em></dt>
<dd><p>Удаляет массив данных из памяти.
</p></dd></dl>



<hr>
<a name="Data-resizing"></a>
<div class="header">
<p>
Next: <a href="#Data-filling" accesskey="n" rel="next">Data filling</a>, Previous: <a href="#Data-constructor" accesskey="p" rel="prev">Data constructor</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Izmenenie-razmerov-dannykh"></a>
<h3 class="section">6.3 Изменение размеров данных</h3>

<a name="index-Create"></a>
<a name="index-Rearrange"></a>
<a name="index-Extend"></a>
<a name="index-Transpose"></a>
<a name="index-Squeeze"></a>
<a name="index-Crop"></a>
<a name="index-Insert"></a>
<a name="index-Delete"></a>
<a name="index-Sort"></a>
<a name="index-Clean"></a>
<a name="index-Join"></a>


<dl>
<dt><a name="index-new-3"></a>Команда MGL: <em></em> <strong>new</strong> <em><small>DAT</small> [<code>nx=1 ny=1 nz=1</code>]</em></dt>
<dt><a name="index-Create-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Create</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-Create-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Create</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fcreate"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_create</strong> <em>(<code>HMDT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dt><a name="index-mgl_005fdatac_005fcreate"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_create</strong> <em>(<code>HADT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dd><p>Создает/пересоздает массив данных указанного размера и заполняет его нулями. Ничего не делает при <var>mx</var>, <var>my</var>, <var>mz</var> отрицательных или равных нулю.
</p></dd></dl>

<a name="rearrange"></a><dl>
<dt><a name="index-rearrange"></a>Команда MGL: <em></em> <strong>rearrange</strong> <em>dat <code>mx [my=0 mz=0]</code></em></dt>
<dt><a name="index-Rearrange-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Rearrange</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>0</code>, <code>int</code> mz=<code>0</code>)</em></dt>
<dt><a name="index-Rearrange-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Rearrange</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>0</code>, <code>int</code> mz=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005frearrange"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_rearrange</strong> <em>(<code>HMDT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dt><a name="index-mgl_005fdatac_005frearrange"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_rearrange</strong> <em>(<code>HADT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dd><p>Изменяет размерность данных без изменения самого массива данных, так что результирующий массив <var>mx</var>*<var>my</var>*<var>mz</var> &lt; nx*ny*nz. Если один из параметров <var>my</var> или <var>mz</var> ноль, то он будет выбран оптимальным образом. Например, если <var>my</var>=0, то будет <var>my</var>=nx*ny*nz/<var>mx</var> и <var>mz</var>=1.
</p></dd></dl>

<a name="transpose"></a><dl>
<dt><a name="index-transpose"></a>Команда MGL: <em></em> <strong>transpose</strong> <em>dat ['dim'='yxz']</em></dt>
<dt><a name="index-Transpose-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Transpose</strong> <em>(<code>const char *</code>dim=<code>&quot;yx&quot;</code>)</em></dt>
<dt><a name="index-Transpose-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Transpose</strong> <em>(<code>const char *</code>dim=<code>&quot;yx&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005ftranspose"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_transpose</strong> <em>(<code>const char *</code>dim)</em></dt>
<dt><a name="index-mgl_005fdatac_005ftranspose"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_transpose</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dim)</em></dt>
<dd><p>Транспонирует (меняет порядок размерностей) массив данных. Новый порядок размерностей задается строкой <var>dim</var>. Функция может быть полезна для транспонирования одномерных (или квазиодномерных) массивов после чтения их из файла.
</p></dd></dl>

<a name="extend"></a><dl>
<dt><a name="index-extend"></a>Команда MGL: <em></em> <strong>extend</strong> <em>dat <code>n1 [n2=0]</code></em></dt>
<dt><a name="index-Extend-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Extend</strong> <em>(<code>int</code> n1, <code>int</code> n2=<code>0</code>)</em></dt>
<dt><a name="index-Extend-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Extend</strong> <em>(<code>int</code> n1, <code>int</code> n2=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fextend"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_extend</strong> <em>(<code>HMDT</code> dat, <code>int</code> n1, <code>int</code> n2)</em></dt>
<dt><a name="index-mgl_005fdatac_005fextend"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_extend</strong> <em>(<code>HADT</code> dat, <code>int</code> n1, <code>int</code> n2)</em></dt>
<dd><p>Увеличивает размер данных путем вставки (|<var>n1</var>|+1) новых срезов после (для <var>n1</var>&gt;0) или перед (для <var>n1</var>&lt;0) существующими данными. Можно добавить сразу 2 размерности для 1d массива, используя второй параметр <var>n2</var>. Данные в новые срезы будут скопированы из существующих. Например, для <var>n1</var>&gt;0 новый массив будет
a_ij^new = a_i^old where j=0...<var>n1</var>. Соответственно, для <var>n1</var>&lt;0 новый массив будет a_ij^new = a_j^old, где i=0...|<var>n1</var>|.
</p></dd></dl>

<a name="squeeze"></a><dl>
<dt><a name="index-squeeze"></a>Команда MGL: <em></em> <strong>squeeze</strong> <em>dat <code>rx [ry=1 rz=1 sm=off]</code></em></dt>
<dt><a name="index-Squeeze-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Squeeze</strong> <em>(<code>int</code> rx, <code>int</code> ry=<code>1</code>, <code>int</code> rz=<code>1</code>, <code>bool</code> smooth=<code>false</code>)</em></dt>
<dt><a name="index-Squeeze-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Squeeze</strong> <em>(<code>int</code> rx, <code>int</code> ry=<code>1</code>, <code>int</code> rz=<code>1</code>, <code>bool</code> smooth=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fsqueeze"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_squeeze</strong> <em>(<code>HMDT</code> dat, <code>int</code> rx, <code>int</code> ry, <code>int</code> rz, <code>int</code> smooth)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsqueeze"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_squeeze</strong> <em>(<code>HADT</code> dat, <code>int</code> rx, <code>int</code> ry, <code>int</code> rz, <code>int</code> smooth)</em></dt>
<dd><p>Уменьшает размер данных путём удаления элементов с индексами не кратными <var>rx</var>, <var>ry</var>, <var>rz</var> соответственно. Параметр <var>smooth</var> задает использовать сглаживания
(т.е. out[i]=\sum_{j=i,i+r} a[j]/r) или нет (т.е. out[i]=a[j*r]).
</p></dd></dl>

<a name="crop"></a><dl>
<dt><a name="index-crop"></a>Команда MGL: <em></em> <strong>crop</strong> <em>dat <code>n1 n2</code> 'dir'</em></dt>
<dt><a name="index-Crop-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Crop</strong> <em>(<code>int</code> n1, <code>int</code> n2, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-Crop-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Crop</strong> <em>(<code>int</code> n1, <code>int</code> n2, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fcrop"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_crop</strong> <em>(<code>HMDT</code> dat, <code>int</code> n1, <code>int</code> n2, <code>char</code> dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fcrop"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_crop</strong> <em>(<code>HADT</code> dat, <code>int</code> n1, <code>int</code> n2, <code>char</code> dir)</em></dt>
<dd><p>Обрезает границы данных при <var>i</var>&lt;<var>n1</var> и <var>i</var>&gt;<var>n2</var> (при <var>n2</var>&gt;0) или <var>i</var>&gt;<code>n[xyz]</code>-<var>n2</var> (при <var>n2</var>&lt;=0) вдоль направления <var>dir</var>.
</p></dd></dl>

<dl>
<dt><a name="index-crop-1"></a>Команда MGL: <em></em> <strong>crop</strong> <em>dat 'how'</em></dt>
<dt><a name="index-Crop-3"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Crop</strong> <em>(<code>const char *</code>how=<code>&quot;235x&quot;</code>)</em></dt>
<dt><a name="index-Crop-4"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Crop</strong> <em>(<code>const char *</code>how=<code>&quot;235x&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fcrop_005fopt"></a>Функция Сn: <em><code>void</code></em> <strong>mgl_data_crop_opt</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>how)</em></dt>
<dt><a name="index-mgl_005fdatac_005fcrop_005fopt"></a>Функция Сn: <em><code>void</code></em> <strong>mgl_datac_crop_opt</strong> <em>(<code>HADT</code> dat, <code>const char *</code>how)</em></dt>
<dd><p>Обрезает дальний край данных, чтобы сделать их более оптимальным для быстрого преобразования Фурье. Размер массива будет равен наиболее близким к исходному из 2^n*3^m*5^l. Строка <var>how</var> может содержать: &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; для направлений, и &lsquo;<samp>2</samp>&rsquo;, &lsquo;<samp>3</samp>&rsquo;, &lsquo;<samp>5</samp>&rsquo; для использования соответствующего основания.
</p></dd></dl>

<a name="insert"></a><dl>
<dt><a name="index-insert"></a>Команда MGL: <em></em> <strong>insert</strong> <em>dat 'dir' <code>[pos=off num=0]</code></em></dt>
<dt><a name="index-Insert-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Insert</strong> <em>(<code>char</code> dir, <code>int</code> pos=<code>0</code>, <code>int</code> num=<code>1</code>)</em></dt>
<dt><a name="index-Insert-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Insert</strong> <em>(<code>char</code> dir, <code>int</code> pos=<code>0</code>, <code>int</code> num=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005finsert"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_insert</strong> <em>(<code>HMDT</code> dat, <code>char</code> dir, <code>int</code> pos, <code>char</code> num)</em></dt>
<dt><a name="index-mgl_005fdatac_005finsert"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_insert</strong> <em>(<code>HADT</code> dat, <code>char</code> dir, <code>int</code> pos, <code>char</code> num)</em></dt>
<dd><p>Вставляет <var>num</var> срезов вдоль направления <var>dir</var> с позиции <var>pos</var> и заполняет их нулями.
</p></dd></dl>

<a name="delete"></a><dl>
<dt><a name="index-delete-2"></a>Команда MGL: <em></em> <strong>delete</strong> <em>dat 'dir' <code>[pos=off num=0]</code></em></dt>
<dt><a name="index-Delete-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Delete</strong> <em>(<code>char</code> dir, <code>int</code> pos=<code>0</code>, <code>int</code> num=<code>1</code>)</em></dt>
<dt><a name="index-Delete-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Delete</strong> <em>(<code>char</code> dir, <code>int</code> pos=<code>0</code>, <code>int</code> num=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fdelete"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_delete</strong> <em>(<code>HMDT</code> dat, <code>char</code> dir, <code>int</code> pos, <code>char</code> num)</em></dt>
<dt><a name="index-mgl_005fdatac_005fdelete"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_delete</strong> <em>(<code>HADT</code> dat, <code>char</code> dir, <code>int</code> pos, <code>char</code> num)</em></dt>
<dd><p>Удаляет <var>num</var> срезов вдоль направления <var>dir</var> с позиции <var>pos</var>.
</p></dd></dl>

<dl>
<dt><a name="index-delete-3"></a>Команда MGL: <em></em> <strong>delete</strong> <em>dat</em></dt>
<dt><a name="index-delete-4"></a>Команда MGL: <em></em> <strong>delete</strong> <em>'name'</em></dt>
<dd><p>Удаляет массив данных из памяти.
</p></dd></dl>

<a name="sort"></a><dl>
<dt><a name="index-sort"></a>Команда MGL: <em></em> <strong>sort</strong> <em>dat <code>idx [idy=-1]</code></em></dt>
<dt><a name="index-Sort-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Sort</strong> <em>(<code>lond</code> idx, <code>long</code> idy=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fsort"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_sort</strong> <em>(<code>HMDT</code> dat, <code>lond</code> idx, <code>long</code> idy)</em></dt>
<dd><p>Сортирует строки (или срезы в 3D случае) по значениям в указанной колонке <var>idx</var> (или ячейках {<var>idx</var>,<var>idy</var>} для 3D случая). Не используйте в многопоточных функциях!
</p></dd></dl>

<a name="clean"></a><dl>
<dt><a name="index-clean"></a>Команда MGL: <em></em> <strong>clean</strong> <em>dat <code>idx</code></em></dt>
<dt><a name="index-Clean-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Clean</strong> <em>(<code>lond</code> idx)</em></dt>
<dt><a name="index-mgl_005fdata_005fclean"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_clean</strong> <em>(<code>HMDT</code> dat, <code>lond</code> idx)</em></dt>
<dd><p>Удаляет строки в которых значения для заданной колонки <var>idx</var> совпадают со значениями в следующей строке.
</p></dd></dl>


<a name="join"></a><dl>
<dt><a name="index-join"></a>Команда MGL: <em></em> <strong>join</strong> <em>dat vdat [v2dat ...]</em></dt>
<dt><a name="index-Join-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Join</strong> <em>(<code>const mglDataA &amp;</code>vdat)</em></dt>
<dt><a name="index-Join-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Join</strong> <em>(<code>const mglDataA &amp;</code>vdat)</em></dt>
<dt><a name="index-mgl_005fdata_005fjoin"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_join</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> vdat)</em></dt>
<dt><a name="index-mgl_005fdatac_005fjoin"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_join</strong> <em>(<code>HADT</code> dat, <code>HCDT</code> vdat)</em></dt>
<dd><p>Объединяет данные из массива <var>vdat</var> с данными массива <var>dat</var>. При этом, функция увеличивает размер массива <var>dat</var>: в z-направлении для массивов с одинаковыми размерами по x и y; в y-направлении для массивов с одинаковыми размерами по x; в x-направлении в остальных случаях.
</p></dd></dl>


<hr>
<a name="Data-filling"></a>
<div class="header">
<p>
Next: <a href="#File-I_002fO" accesskey="n" rel="next">File I/O</a>, Previous: <a href="#Data-resizing" accesskey="p" rel="prev">Data resizing</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Zapolnenie-dannykh"></a>
<h3 class="section">6.4 Заполнение данных</h3>

<a name="index-Fill-1"></a>
<a name="index-Modify"></a>
<a name="index-Set"></a>
<a name="index-List"></a>
<a name="index-Var"></a>
<a name="index-Refill"></a>

<a name="list"></a><dl>
<dt><a name="index-list"></a>Команда MGL: <em></em> <strong>list</strong> <em><small>DAT</small> <code>v1 ...</code></em></dt>
<dd><p>Создает новый массив данных <var>dat</var> и заполняет его числовыми значениями аргументов <code>v1 ...</code>. Команда может создавать одно- и двухмерные массивы с произвольными значениями. Для создания 2d массива следует использовать разделитель &lsquo;<samp>|</samp>&rsquo;, который означает начало новой строки данных. Размер массива данных будет [maximal of row sizes * number of rows]. Например, команда <code>list 1 | 2 3</code> создаст массив [1 0; 2 3]. Замечу, что максимальное число аргументов равно 1000.
</p></dd></dl>
<dl>
<dt><a name="index-list-1"></a>Команда MGL: <em></em> <strong>list</strong> <em><small>DAT</small> d1 ...</em></dt>
<dd><p>Создает новый массив данных <var>dat</var> и заполняет его значениями из массивов <var>d1 ...</var>. Команда может создавать двух- и трёхмерные (если аргументы &ndash; двумерные массивы) массивы. Меньшая размерность всех массивов в аргументах должна совпадать. В противном случае аргумент (массив) будет пропущен.
</p></dd></dl>

<dl>
<dt><a name="index-Set-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mreal *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-Set-2"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const double *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fmreal"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_mreal</strong> <em>(<code>HMDT</code> dat, <code>const mreal *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fdouble"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_double</strong> <em>(<code>HMDT</code> dat, <code>const double *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-Set-3"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const float *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-Set-4"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const double *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-Set-5"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const dual *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005ffloat"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_float</strong> <em>(<code>HADT</code> dat, <code>const mreal *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fdouble"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_double</strong> <em>(<code>HADT</code> dat, <code>const double *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fcomplex"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_complex</strong> <em>(<code>HADT</code> dat, <code>const dual *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dd><p>Выделяет память и копирует данные из массивов типа <code>mreal*</code> или <code>double*</code>, т.е. из массивов определённых как <code>mreal a[NX*NY*NZ];</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Set-6"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mreal **</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-Set-7"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const double **</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fmreal2"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_mreal2</strong> <em>(<code>HMDT</code> dat, <code>const mreal **</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fdouble2"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_double2</strong> <em>(<code>HMDT</code> dat, <code>const double **</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dd><p>Выделяет память и копирует данные из массивов типа <code>mreal**</code> или <code>double**</code> с размерностями <var>N1</var>, <var>N2</var>, т.е. из массивов определённых как <code>mreal a[N1][N2];</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Set-8"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mreal ***</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-Set-9"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const double ***</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fmreal3"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_mreal3</strong> <em>(<code>HMDT</code> dat, <code>const mreal ***</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fdouble3"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_double3</strong> <em>(<code>HMDT</code> dat, <code>const double ***</code>A, <code>int</code> N1, <code>int</code> N2)</em></dt>
<dd><p>Выделяет память и копирует данные из массивов типа <code>mreal***</code> или <code>double***</code> с размерностями <var>N1</var>, <var>N2</var>, <var>N3</var>, т.е. из массивов определённых как <code>mreal a[N1][N2][N3];</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Set-10"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>gsl_vector *</code>v)</em></dt>
<dt><a name="index-Set-11"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>gsl_vector *</code>v)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fvector"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_vector</strong> <em>(<code>HMDT</code> dat, <code>gsl_vector *</code>v)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fvector"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_vector</strong> <em>(<code>HADT</code> dat, <code>gsl_vector *</code>v)</em></dt>
<dd><p>Выделяет память и копирует данные из структуры типа <code>gsl_vector *</code>.
</p></dd></dl>
<dl>
<dt><a name="index-Set-12"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>gsl_matrix *</code>m)</em></dt>
<dt><a name="index-Set-13"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>gsl_matrix *</code>m)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fmatrix"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_matrix</strong> <em>(<code>HMDT</code> dat, <code>gsl_matrix *</code>m)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fmatrix"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_matrix</strong> <em>(<code>HADT</code> dat, <code>gsl_matrix *</code>m)</em></dt>
<dd><p>Выделяет память и копирует данные из структуры типа <code>gsl_matrix *</code>.
</p></dd></dl>
<dl>
<dt><a name="index-Set-14"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mglDataA &amp;</code>from)</em></dt>
<dt><a name="index-Set-15"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>HCDT</code> from)</em></dt>
<dt><a name="index-mgl_005fdata_005fset"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> from)</em></dt>
<dt><a name="index-Set-16"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mglDataA &amp;</code>from)</em></dt>
<dt><a name="index-Set-17"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>HCDT</code> from)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set</strong> <em>(<code>HADT</code> dat, <code>HCDT</code> from)</em></dt>
<dd><p>Выделяет память и копирует данные из другого экземпляра данных <var>from</var>.
</p></dd></dl>

<dl>
<dt><a name="index-Set-18"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const mglDataA &amp;</code>re, <code>const mglDataA &amp;</code>im)</em></dt>
<dt><a name="index-Set-19"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>HCDT</code> re, <code>HCDT</code> im)</em></dt>
<dt><a name="index-SetAmpl"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>SetAmpl</strong> <em>(<code>HCDT</code> ampl, <code>const mglDataA &amp;</code>phase)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fri"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_ri</strong> <em>(<code>HADT</code> dat, <code>HCDT</code> re, <code>HCDT</code> im)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fap"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_ap</strong> <em>(<code>HADT</code> dat, <code>HCDT</code> ampl, <code>HCDT</code> phase)</em></dt>
<dd><p>Выделяет память и копирует данные из экземпляра данных для действительной <var>re</var> и мнимой <var>im</var> частей комплексного массива данных.
</p></dd></dl>

<dl>
<dt><a name="index-Set-20"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;int&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-21"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;int&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-22"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;float&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-23"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;float&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-24"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;double&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-25"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;double&gt; &amp;</code>d)</em></dt>
<dt><a name="index-Set-26"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const std::vector&lt;dual&gt; &amp;</code>d)</em></dt>
<dd><p>Выделяет память и копирует данные из массива типа <code>std::vector&lt;T&gt;</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Set-27"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const char *</code>str, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fvalues"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_values</strong> <em>(<code>const char *</code>str, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-Set-28"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Set</strong> <em>(<code>const char *</code>str, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fvalues"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_values</strong> <em>(<code>const char *</code>str, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dd><p>Выделяет память и сканирует массив данных из строки.
</p></dd></dl>


<dl>
<dt><a name="index-SetList"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>SetList</strong> <em>(<code>long</code> n, ...)</em></dt>
<dd><p>Allocate memory and set data from variable argument list of <em>double</em> values. Note, you need to specify decimal point &lsquo;<samp>.</samp>&rsquo; for integer values! For example, the code <code>SetList(2,0.,1.);</code> is correct, but the code <code>SetList(2,0,1);</code> is incorrect.
</p></dd></dl>


<dl>
<dt><a name="index-Link"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Link</strong> <em>(<code>mglData &amp;</code>from)</em></dt>
<dt><a name="index-Link-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Link</strong> <em>(<code>mreal *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005flink"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_link</strong> <em>(<code>HMDT</code> dat, <code>const mreal *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dt><a name="index-Link-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Link</strong> <em>(<code>mglDataC &amp;</code>from)</em></dt>
<dt><a name="index-Link-3"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Link</strong> <em>(<code>dual *</code>A, <code>int</code> NX, <code>int</code> NY=<code>1</code>, <code>int</code> NZ=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdatac_005flink"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_link</strong> <em>(<code>HADT</code> dat, <code>const mreal *</code>A, <code>int</code> NX, <code>int</code> NY, <code>int</code> NZ)</em></dt>
<dd><p>Устанавливает флаг использования внешнего массива данных, которые не будут удалены. Флаг может быть возвращён в исходное состояние и создан новый внутренний массив если использовались функции изменяющие размер данных.
</p></dd></dl>

<a name="var"></a><dl>
<dt><a name="index-var"></a>Команда MGL: <em></em> <strong>var</strong> <em><small>DAT</small> <code>num v1 [v2=nan]</code></em></dt>
<dd><p>Создает новый одномерный массив данных <var>dat</var> размером <var>num</var>, и заполняет его равномерно в диапазоне [<var>v1</var>, <var>v2</var>]. Если <var>v2</var>=<code>nan</code>, то используется <var>v2=v1</var>.
</p></dd></dl>

<a name="fill"></a><dl>
<dt><a name="index-fill-3"></a>Команда MGL: <em></em> <strong>fill</strong> <em>dat v1 v2 ['dir'='x']</em></dt>
<dt><a name="index-Fill-5"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>mreal</code> v1, <code>mreal</code> v2, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-Fill-6"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>dual</code> v1, <code>dual</code> v2, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005ffill"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_fill</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> v1, <code>mreal</code> v2, <code>char</code> dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005ffill"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_fill</strong> <em>(<code>HADT</code> dat, <code>dual</code> v1, <code>dual</code> v2, <code>char</code> dir)</em></dt>
<dd><p>Заполняет значениями равно распределёнными в диапазоне [<var>x1</var>, <var>x2</var>] в направлении <var>dir</var>={&lsquo;<samp>x</samp>&rsquo;,&lsquo;<samp>y</samp>&rsquo;,&lsquo;<samp>z</samp>&rsquo;}.
</p></dd></dl>

<dl>
<dt><a name="index-fill-4"></a>Команда MGL: <em></em> <strong>fill</strong> <em>dat 'eq'[vdat wdat]</em></dt>
<dt><a name="index-Fill-7"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-8"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const mglDataA &amp;</code>vdat, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-9"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const mglDataA &amp;</code>vdat, <code>const mglDataA &amp;</code>wdat, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-10"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-11"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const mglDataA &amp;</code>vdat, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Fill-12"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>eq, <code>const mglDataA &amp;</code>vdat, <code>const mglDataA &amp;</code>wdat, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005ffill_005feq-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_fill_eq</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> dat, <code>const char *</code>eq, <code>HCDT</code> vdat, <code>HCDT</code> wdat, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdatac_005ffill_005feq"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_fill_eq</strong> <em>(<code>HMGL</code> gr, <code>HADT</code> dat, <code>const char *</code>eq, <code>HCDT</code> vdat, <code>HCDT</code> wdat, <code>const char *</code>opt)</em></dt>
<dd><p>Заполняет значениями вычисленными по формуле <var>eq</var>. Формула представляет собой произвольное выражение, зависящее от переменных &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;, &lsquo;<samp>u</samp>&rsquo;, &lsquo;<samp>v</samp>&rsquo;, &lsquo;<samp>w</samp>&rsquo;. Координаты &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; полагаются меняющимися в диапазоне <var>Min</var> x <var>Max</var> (в отличие от функции <code>Modify</code>). Переменная &lsquo;<samp>u</samp>&rsquo; &ndash; значения исходного массива, переменные &lsquo;<samp>v</samp>&rsquo;, &lsquo;<samp>w</samp>&rsquo; &ndash; значения массивов <var>vdat</var>, <var>wdat</var>. Последние могут быть <code>NULL</code>, т.е. опущены.
</p></dd></dl>

<a name="modify"></a><dl>
<dt><a name="index-modify"></a>Команда MGL: <em></em> <strong>modify</strong> <em>dat 'eq' [<code>dim=0</code>]</em></dt>
<dt><a name="index-modify-1"></a>Команда MGL: <em></em> <strong>modify</strong> <em>dat 'eq' vdat [wdat]</em></dt>
<dt><a name="index-Modify-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>int</code> dim=<code>0</code>)</em></dt>
<dt><a name="index-Modify-2"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>const mglDataA &amp;</code>v)</em></dt>
<dt><a name="index-Modify-3"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>w)</em></dt>
<dt><a name="index-Modify-4"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>int</code> dim=<code>0</code>)</em></dt>
<dt><a name="index-Modify-5"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>const mglDataA &amp;</code>v)</em></dt>
<dt><a name="index-Modify-6"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Modify</strong> <em>(<code>const char *</code>eq, <code>const mglDataA &amp;</code>v, <code>const mglDataA &amp;</code>w)</em></dt>
<dt><a name="index-mgl_005fdata_005fmodify"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_modify</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>eq, <code>int</code> dim)</em></dt>
<dt><a name="index-mgl_005fdata_005fmodify_005fvw"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_modify_vw</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>eq, <code>HCDT</code> v, <code>HCDT</code> w)</em></dt>
<dt><a name="index-mgl_005fdatac_005fmodify"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_modify</strong> <em>(<code>HADT</code> dat, <code>const char *</code>eq, <code>int</code> dim)</em></dt>
<dt><a name="index-mgl_005fdatac_005fmodify_005fvw"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_modify_vw</strong> <em>(<code>HADT</code> dat, <code>const char *</code>eq, <code>HCDT</code> v, <code>HCDT</code> w)</em></dt>
<dd><p>Аналогично предыдущему с координатами &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;, меняющимися в диапазоне [0,1]. Если указан <var>dim</var>&gt;0, то изменяются только слои &gt;=<var>dim</var>.
</p></dd></dl>

<a name="fillsample"></a><dl>
<dt><a name="index-fillsample"></a>Команда MGL: <em></em> <strong>fillsample</strong> <em>dat 'how'</em></dt>
<dt><a name="index-FillSample"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>FillSample</strong> <em>(<code>const char *</code>how)</em></dt>
<dt><a name="index-mgl_005fdata_005ffill_005fsample"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_fill_sample</strong> <em>(<code>HMDT</code> a, <code>const char *</code>how)</em></dt>
<dd><p>Заполняет массив данных &rsquo;x&rsquo; или &rsquo;k&rsquo; значениями для преобразований Ханкеля (&rsquo;h&rsquo;) или Фурье (&rsquo;f&rsquo;).
</p></dd></dl>


<a name="datagrid"></a><dl>
<dt><a name="index-datagrid-1"></a>Команда MGL: <em></em> <strong>datagrid</strong> <em>dat xdat ydat zdat</em></dt>
<dt><a name="index-Grid-5"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Grid</strong> <em>(<code>HMGL</code> gr, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Grid-6"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Grid</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dt><a name="index-mgl_005fdata_005fgrid-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_grid</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> u, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fdata_005fgrid_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_grid_xy</strong> <em>(<code>HMDT</code> u, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2)</em></dt>
<dd><p>Заполняет значения массива результатом линейной интерполяции (считая координаты равнораспределенными в диапазоне осей координат или в диапазоне [x1,x2]*[y1,y2]) по триангулированной поверхности, найденной по произвольно расположенным точкам &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;. NAN значение используется для точек сетки вне триангулированной поверхности. См. раздел <a href="#Making-regular-data">Making regular data</a>, для примеров кода и графика.
</p></dd></dl>


<a name="put"></a><dl>
<dt><a name="index-put"></a>Команда MGL: <em></em> <strong>put</strong> <em>dat <code>val [i=all j=all k=all]</code></em></dt>
<dt><a name="index-Put"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Put</strong> <em>(<code>mreal</code> val, <code>int</code> i=<code>-1</code>, <code>int</code> j=<code>-1</code>, <code>int</code> k=<code>-1</code>)</em></dt>
<dt><a name="index-Put-1"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Put</strong> <em>(<code>dual</code> val, <code>int</code> i=<code>-1</code>, <code>int</code> j=<code>-1</code>, <code>int</code> k=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fput_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_put_val</strong> <em>(<code>HMDT</code> a, <code>mreal</code> val, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdatac_005fput_005fval"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_put_val</strong> <em>(<code>HADT</code> a, <code>dual</code> val, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dd><p>Присваивает значения (под-)массива <var>dat</var>[<var>i</var>, <var>j</var>, <var>k</var>] = <var>val</var>. Индексы <var>i</var>, <var>j</var>, <var>k</var> равные &lsquo;<samp>-1</samp>&rsquo; задают значения <var>val</var> для всего диапазона соответствующего направления(ий). Например, <code>Put(val,-1,0,-1);</code> задает a[i,0,j]=<var>val</var> для i=0...(nx-1), j=0...(nz-1).
</p></dd></dl>

<dl>
<dt><a name="index-put-1"></a>Команда MGL: <em></em> <strong>put</strong> <em>dat vdat [<code>i=all j=all k=all</code>]</em></dt>
<dt><a name="index-Put-2"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Put</strong> <em>(<code>const mglDataA &amp;</code>v, <code>int</code> i=<code>-1</code>, <code>int</code> j=<code>-1</code>, <code>int</code> k=<code>-1</code>)</em></dt>
<dt><a name="index-Put-3"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Put</strong> <em>(<code>const mglDataA &amp;</code>v, <code>int</code> i=<code>-1</code>, <code>int</code> j=<code>-1</code>, <code>int</code> k=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fput_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_put_dat</strong> <em>(<code>HMDT</code> a, <code>HCDT</code> v, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdatac_005fput_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_put_dat</strong> <em>(<code>HADT</code> a, <code>HCDT</code> v, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dd><p>Копирует значения из массива <var>v</var> в диапазон значений данного массива. Индексы <var>i</var>, <var>j</var>, <var>k</var> равные &lsquo;<samp>-1</samp>&rsquo; задают диапазон изменения значений в соответствующих направление(ях). Младшие размерности массива <var>v</var> должны быть больше выбранного диапазона массива. Например, <code>Put(v,-1,0,-1);</code> присвоит a[i,0,j]=<var>v</var>.ny&gt;nz ? <var>v</var>.a[i,j] : <var>v</var>.a[i], где i=0...(nx-1), j=0...(nz-1) и условие v.nx&gt;=nx выполнено.
</p></dd></dl>

<a name="refill"></a><dl>
<dt><a name="index-refill-3"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat vdat [sl=-1]</em></dt>
<dt><a name="index-refill-4"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat ydat vdat [sl=-1]</em></dt>
<dt><a name="index-refill-5"></a>Команда MGL: <em></em> <strong>refill</strong> <em>dat xdat ydat zdat vdat</em></dt>
<dt><a name="index-Refill-4"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v, <code>mreal</code> x1, <code>mreal</code> x2, <code>long</code> sl=<code>-1</code>)</em></dt>
<dt><a name="index-Refill-5"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v, <code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>long</code> sl=<code>-1</code>)</em></dt>
<dt><a name="index-Refill-6"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>v, <code>mglPoint</code> p1, <code>mglPoint</code> p2, <code>long</code> sl=<code>-1</code>)</em></dt>
<dt><a name="index-Refill-7"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>v, <code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dt><a name="index-Refill-8"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>HMGL</code> gr, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v, <code>long</code> sl=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Refill-9"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>HMGL</code> gr, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>v, <code>long</code> sl=<code>-1</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-Refill-10"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Refill</strong> <em>(<code>HMGL</code> gr, <code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z, <code>const mglDataA &amp;</code>v, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fx"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_x</strong> <em>(<code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> v, <code>mreal</code> x1, <code>mreal</code> x2, <code>long</code> sl)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fxy"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_xy</strong> <em>(<code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> v, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>long</code> sl)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fxyz"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_xyz</strong> <em>(<code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> v, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>mreal</code> z1, <code>mreal</code> z2)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fgr-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_gr</strong> <em>(<code>HMGL</code> gr, <code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z, <code>HCDT</code> v, <code>long</code> sl, <code>const char *</code>opt)</em></dt>
<dd><p>Заполняет значениями интерполяции массива <var>v</var> в точках {<var>x</var>, <var>y</var>, <var>z</var>}={<code>X[i], Y[j], Z[k]</code>} (или {<var>x</var>, <var>y</var>, <var>z</var>}={<code>X[i,j,k], Y[i,j,k], Z[i,j,k]</code>} если <var>x</var>, <var>y</var>, <var>z</var> не 1d массивы), где <code>X,Y,Z</code> равномерно распределены в диапазоне [<var>x1</var>,<var>x2</var>]*[<var>y1</var>,<var>y2</var>]*[<var>z1</var>,<var>z2</var>] и имеют такой же размер как и заполняемый массив. Если параметр <var>sl</var> равен 0 или положительный, то изменятся будет только <var>sl</var>-ый срез.
</p></dd></dl>

<a name="gspline"></a><dl>
<dt><a name="index-gspline"></a>Команда MGL: <em></em> <strong>gspline</strong> <em>dat xdat vdat [sl=-1]</em></dt>
<dt><a name="index-RefillGS"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>RefillGS</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>v, <code>mreal</code> x1, <code>mreal</code> x2, <code>long</code> sl=<code>-1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005frefill_005fgs"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_refill_gs</strong> <em>(<code>HMDT</code> a, <code>HCDT</code> x, <code>HCDT</code> v, <code>mreal</code> x1, <code>mreal</code> x2, <code>long</code> sl)</em></dt>
<dd><p>Заполняет значениями глобального кубического сплайна для массива <var>v</var> в точках <var>x</var>=<code>X[i]</code>, где <code>X</code> равномерно распределен в диапазоне [<var>x1</var>,<var>x2</var>] и имеет такой же размер как и заполняемый массив. Если параметр <var>sl</var> равен 0 или положительный, то изменятся будет только <var>sl</var>-ый срез.
</p></dd></dl>

<a name="idset"></a><dl>
<dt><a name="index-idset"></a>Команда MGL: <em></em> <strong>idset</strong> <em>dat 'ids'</em></dt>
<dt><a name="index-SetColumnId"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>SetColumnId</strong> <em>(<code>const char *</code>ids)</em></dt>
<dt><a name="index-mgl_005fdata_005fset_005fid"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_set_id</strong> <em>(<code>const char *</code>ids)</em></dt>
<dt><a name="index-SetColumnId-1"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>SetColumnId</strong> <em>(<code>const char *</code>ids)</em></dt>
<dt><a name="index-mgl_005fdatac_005fset_005fid"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_set_id</strong> <em>(<code>HADT</code> a, <code>const char *</code>ids)</em></dt>
<dd><p>Задает названия <var>ids</var> для колонок массива данных. Строка должна содержать один символ &rsquo;a&rsquo;...&rsquo;z&rsquo; на колонку. Эти названия используются в функции <a href="#column">column</a>.
</p></dd></dl>



<hr>
<a name="File-I_002fO"></a>
<div class="header">
<p>
Next: <a href="#Make-another-data" accesskey="n" rel="next">Make another data</a>, Previous: <a href="#Data-filling" accesskey="p" rel="prev">Data filling</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Chtenie_002fsokhranenie-dannykh"></a>
<h3 class="section">6.5 Чтение/сохранение данных</h3>

<a name="index-Read"></a>
<a name="index-ReadMat"></a>
<a name="index-ReadRange"></a>
<a name="index-ReadAll"></a>
<a name="index-Save"></a>
<a name="index-ReadHDF"></a>
<a name="index-SaveHDF"></a>
<a name="index-Import"></a>
<a name="index-Export"></a>

<a name="read"></a><dl>
<dt><a name="index-read-1"></a>Команда MGL: <em></em> <strong>read</strong> <em><small>DAT</small> 'fname'</em></dt>
<dt><a name="index-read-2"></a>Команда MGL: <em></em> <strong>read</strong> <em><small>REDAT</small> <small>IMDAT</small> 'fname'</em></dt>
<dt><a name="index-Read-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Read</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-Read-2"></a>Метод класса <code>mglDataC</code>: <em><code>bool</code></em> <strong>Read</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fdata_005fread"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_read</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread"></a>Функция С: <em><code>int</code></em> <strong>mgl_datac_read</strong> <em>(<code>HADT</code> dat, <code>const char *</code>fname)</em></dt>
<dd><p>Читает данные из текстового файла с разделителями символом пробела/табуляции с автоматическим определением размера массива. Двойной перевод строки начинает новый срез данных (по направлению z).
</p></dd></dl>

<dl>
<dt><a name="index-read-3"></a>Команда MGL: <em></em> <strong>read</strong> <em><small>DAT</small> 'fname' <code>mx [my=1 mz=1]</code></em></dt>
<dt><a name="index-read-4"></a>Команда MGL: <em></em> <strong>read</strong> <em><small>REDAT</small> <small>IMDAT</small> 'fname' <code>mx [my=1 mz=1]</code></em></dt>
<dt><a name="index-Read-3"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Read</strong> <em>(<code>const char *</code>fname, <code>int</code> mx, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-Read-4"></a>Метод класса <code>mglDataC</code>: <em><code>bool</code></em> <strong>Read</strong> <em>(<code>const char *</code>fname, <code>int</code> mx, <code>int</code> my=<code>1</code>, <code>int</code> mz=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fread_005fdim"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_read_dim</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread_005fdim"></a>Функция С: <em><code>int</code></em> <strong>mgl_datac_read_dim</strong> <em>(<code>HADT</code> dat, <code>const char *</code>fname, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dd><p>Читает данные из текстового файла с заданными размерами. Ничего не делается если параметры <var>mx</var>, <var>my</var> или <var>mz</var> равны нулю или отрицательны.
</p></dd></dl>

<a name="readmat"></a><dl>
<dt><a name="index-readmat"></a>Команда MGL: <em></em> <strong>readmat</strong> <em><small>DAT</small> 'fname' [<code>dim=2</code>]</em></dt>
<dt><a name="index-ReadMat-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>ReadMat</strong> <em>(<code>const char *</code>fname, <code>int</code> dim=<code>2</code>)</em></dt>
<dt><a name="index-ReadMat-2"></a>Метод класса <code>mglDataC</code>: <em><code>bool</code></em> <strong>ReadMat</strong> <em>(<code>const char *</code>fname, <code>int</code> dim=<code>2</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fread_005fmat"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_read_mat</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>int</code> dim)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread_005fmat"></a>Функция С: <em><code>int</code></em> <strong>mgl_datac_read_mat</strong> <em>(<code>HADT</code> dat, <code>const char *</code>fname, <code>int</code> dim)</em></dt>
<dd><p>Читает данные из текстового файла с размерами, указанными в первых <var>dim</var> числах файла. При этом переменная <var>dim</var> задает размерность (1d, 2d, 3d) данных.
</p></dd></dl>

<a name="readall"></a><dl>
<dt><a name="index-readall"></a>Команда MGL: <em></em> <strong>readall</strong> <em><small>DAT</small> 'templ' <code>v1 v2 [dv=1 slice=off]</code></em></dt>
<dt><a name="index-ReadRange-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>ReadRange</strong> <em>(<code>const char *</code>templ, <code>mreal</code> from, <code>mreal</code> to, <code>mreal</code> step=<code>1.f</code>, <code>bool</code> as_slice=<code>false</code>)</em></dt>
<dt><a name="index-ReadRange-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>ReadRange</strong> <em>(<code>const char *</code>templ, <code>mreal</code> from, <code>mreal</code> to, <code>mreal</code> step=<code>1</code>, <code>bool</code> as_slice=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fread_005frange"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_read_range</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>templ, <code>mreal</code> from, <code>mreal</code> to, <code>mreal</code> step, <code>int</code> as_slice)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread_005frange"></a>Функция С: <em><code>int</code></em> <strong>mgl_datac_read_range</strong> <em>(<code>HADT</code> dat, <code>const char *</code>templ, <code>mreal</code> from, <code>mreal</code> to, <code>mreal</code> step, <code>int</code> as_slice)</em></dt>
<dd><p>Объединяет данные из нескольких текстовых файлов. Имена файлов определяются вызовом функции <code>sprintf(fname,templ,val);</code>, где <var>val</var> меняется от <var>from</var> до <var>to</var> с шагом <var>step</var>. Данные загружаются один за другим в один и тот же срез данных (при <var>as_slice</var>=<code>false</code>) или срез-за-срезом (при <var>as_slice</var>=<code>true</code>).
</p></dd></dl>

<dl>
<dt><a name="index-readall-1"></a>Команда MGL: <em></em> <strong>readall</strong> <em><small>DAT</small> 'templ' <code>[slice=off]</code></em></dt>
<dt><a name="index-ReadAll-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>ReadAll</strong> <em>(<code>const char *</code>templ, <code>bool</code> as_slice=<code>false</code>)</em></dt>
<dt><a name="index-ReadAll-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>ReadAll</strong> <em>(<code>const char *</code>templ, <code>bool</code> as_slice=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fread_005fall"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_read_all</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>templ, <code>int</code> as_slice)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread_005fall"></a>Функция С: <em><code>int</code></em> <strong>mgl_datac_read_all</strong> <em>(<code>HADT</code> dat, <code>const char *</code>templ, <code>int</code> as_slice)</em></dt>
<dd><p>Объединяет данные из нескольких текстовых файлов, чьи имена удовлетворяют шаблону <var>templ</var> (например, <var>templ</var>=<code>&quot;t_*.dat&quot;</code>). Данные загружаются один за другим в один и тот же срез данных (при <var>as_slice</var>=<code>false</code>) или срез-за-срезом (при <var>as_slice</var>=<code>true</code>).
</p></dd></dl>

<a name="scanfile"></a><dl>
<dt><a name="index-scanfile"></a>Команда MGL: <em></em> <strong>scanfile</strong> <em><small>DAT</small> 'fname' 'templ'</em></dt>
<dt><a name="index-ScanFile"></a>Метод класса <code>mglData</code>: <em><code>bool</code></em> <strong>ScanFile</strong> <em>(<code>const char *</code>fname, <code>const char *</code>templ)</em></dt>
<dt><a name="index-mgl_005fdata_005fscan_005ffile"></a>Функция С: <em><code>int</code></em> <strong>mgl_data_scan_file</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>const char *</code>templ)</em></dt>
<dd><p>Читает файл <var>fname</var> построчно и каждую строку сканирует на соответствие шаблону <var>templ</var>. Полученные числа (обозначаются как &lsquo;<samp>%g</samp>&rsquo; в шаблоне) сохраняются. См. раздел <a href="#Saving-and-scanning-file">Saving and scanning file</a>, для примеров кода и графика.
</p></dd></dl>

<a name="save"></a><dl>
<dt><a name="index-save"></a>Команда MGL: <em></em> <strong>save</strong> <em>dat 'fname'</em></dt>
<dt><a name="index-Save-1"></a>Метод класса <code>mglDataA</code>: <em><code>void</code></em> <strong>Save</strong> <em>(<code>const char *</code>fname, <code>int</code> ns=<code>-1</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsave"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_save</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>fname, <code>int</code> ns)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsave"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_save</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>fname, <code>int</code> ns)</em></dt>
<dd><p>Сохраняет весь массив данных при <var>ns</var>=<code>-1</code> или только <var>ns</var>-ый срез в текстовый файл.
</p></dd></dl>

<dl>
<dt><a name="index-save-1"></a>Команда MGL: <em></em> <strong>save</strong> <em>'str' 'fname' ['mode'='a']</em></dt>
<dd><p>Сохраняет строку <var>str</var> в файл <var>fname</var>. Для параметра <var>mode</var>=&lsquo;<samp>a</samp>&rsquo; происходит добавление строки (по умолчанию): для  <var>mode</var>=&lsquo;<samp>w</samp>&rsquo; файл будет перезаписан. См. раздел <a href="#Saving-and-scanning-file">Saving and scanning file</a>, для примеров кода и графика.
</p></dd></dl>

<a name="readhdf"></a><dl>
<dt><a name="index-readhdf"></a>Команда MGL: <em></em> <strong>readhdf</strong> <em><small>DAT</small> 'fname' 'dname'</em></dt>
<dt><a name="index-ReadHDF-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>ReadHDF</strong> <em>(<code>const char *</code>fname, <code>const char *</code>dname)</em></dt>
<dt><a name="index-ReadHDF-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>ReadHDF</strong> <em>(<code>const char *</code>fname, <code>const char *</code>dname)</em></dt>
<dt><a name="index-mgl_005fdata_005fread_005fhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_read_hdf</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>const char *</code>dname)</em></dt>
<dt><a name="index-mgl_005fdatac_005fread_005fhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_read_hdf</strong> <em>(<code>HADT</code> dat, <code>const char *</code>fname, <code>const char *</code>dname)</em></dt>
<dd><p>Читает массив с именем <var>dname</var> из HDF5 или HDF4 файла <var>fname</var>. Функция ничего не делает если библиотека была собрана без поддержки HDF5|HDF4.
</p></dd></dl>

<a name="savehdf"></a><dl>
<dt><a name="index-savehdf"></a>Команда MGL: <em></em> <strong>savehdf</strong> <em>dat 'fname' 'dname' [<code>rewrite</code>=<code>off</code>]</em></dt>
<dt><a name="index-SaveHDF-1"></a>Метод класса <code>mglDataA</code>: <em><code>void</code></em> <strong>SaveHDF</strong> <em>(<code>const char *</code>fname, <code>const char *</code>dname, <code>bool</code> rewrite=<code>false</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsave_005fhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_save_hdf</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>fname, <code>const char *</code>dname, <code>int</code> rewrite)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsave_005fhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_save_hdf</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>fname, <code>const char *</code>dname, <code>int</code> rewrite)</em></dt>
<dd><p>Сохраняет массив под именем <var>dname</var> в HDF5 или HDF4 файл <var>fname</var>. Функция ничего не делает если библиотека была собрана без поддержки HDF5|HDF4.
</p></dd></dl>

<a name="datas"></a><dl>
<dt><a name="index-datas"></a>Команда MGL: <em></em> <strong>datas</strong> <em>'fname'</em></dt>
<dt><a name="index-DatasHDF"></a>Метод класса <code>mglDataA</code>: <em><code>int</code></em> <strong>DatasHDF</strong> <em>(<code>const char *</code>fname, <code>char *</code>buf, <code>long</code> size) <code>static</code></em></dt>
<dt><a name="index-mgl_005fdatas_005fhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_datas_hdf</strong> <em>(<code>const char *</code>fname, <code>char *</code>buf, <code>long</code> size)</em></dt>
<dd><p>Помещает имена массивов данных в HDF5 файле <var>fname</var> в строку <var>buf</var> разделёнными символом табуляции &rsquo;\t&rsquo;. В версии MGL имена массивов будут выведены как сообщение. Функция ничего не делает если библиотека была собрана без поддержки HDF5.
</p></dd></dl>

<a name="openhdf"></a><dl>
<dt><a name="index-openhdf"></a>Команда MGL: <em></em> <strong>openhdf</strong> <em>'fname'</em></dt>
<dt><a name="index-OpenHDF"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>OpenHDF</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fparser_005fopenhdf"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_openhdf</strong> <em>(<code>HMPR</code> pr, <code>const char *</code>fname)</em></dt>
<dd><p>Читает все массивы данных из HDF5 файла <var>fname</var> и создает переменные MGL с соответствующими именами. Если имя данных начинается с &lsquo;<samp>!</samp>&rsquo;, то будут созданы комплексные массивы.
</p></dd></dl>

<dl>
<dt><a name="index-mgl_005fdatas_005fhdf_005fstr"></a>Функция С: <em><code>const char * const *</code></em> <strong>mgl_datas_hdf_str</strong> <em>(<code>HMPR</code> pr, <code>const char *</code>fname)</em></dt>
<dd><p>Помещает имена данных из HDF файла <var>fname</var> в массив строк (последняя строка &quot;&quot;). Массив строк будет изменен при следующем вызове функции.
</p></dd></dl>

<a name="import"></a><dl>
<dt><a name="index-import"></a>Команда MGL: <em></em> <strong>import</strong> <em><small>DAT</small> 'fname' 'sch' [<code>v1=0 v2=1</code>]</em></dt>
<dt><a name="index-Import-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Import</strong> <em>(<code>const char *</code>fname, <code>const char *</code>scheme, <code>mreal</code> v1=<code>0</code>, mreal v2=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fimport"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_import</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>const char *</code>scheme, <code>mreal</code> v1, mreal v2)</em></dt>
<dd><p>Читает данные из растрового файла. RGB значения пикселов преобразуются в число в диапазоне [<var>v1</var>, <var>v2</var>] используя цветовую схему <var>sch</var> (see <a href="#Color-scheme">Color scheme</a>).
</p></dd></dl>

<a name="export"></a><dl>
<dt><a name="index-export"></a>Команда MGL: <em></em> <strong>export</strong> <em>dat 'fname' 'sch' [<code>v1=0 v2=0</code>]</em></dt>
<dt><a name="index-Export-1"></a>Метод класса <code>mglDataA</code>: <em><code>void</code></em> <strong>Export</strong> <em>(<code>const char *</code>fname, <code>const char *</code>scheme, <code>mreal</code> v1=<code>0</code>, mreal v2=<code>0</code>, <code>int</code> ns=<code>-1</code>) const</em></dt>
<dt><a name="index-mgl_005fdata_005fexport"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_export</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>fname, <code>const char *</code>scheme, <code>mreal</code> v1, mreal v2, <code>int</code> ns) const</em></dt>
<dd><p>Сохраняет данные в растровый файл. Числовые значения, нормированные в диапазон [<var>v1</var>, <var>v2</var>], преобразуются в RGB значения пикселов, используя цветовую схему <var>sch</var> (see <a href="#Color-scheme">Color scheme</a>). Если <var>v1</var>&gt;=<var>v2</var>, то значения <var>v1</var>, <var>v2</var> определяются автоматически как минимальное и максимальное значение данных.
</p></dd></dl>


<hr>
<a name="Make-another-data"></a>
<div class="header">
<p>
Next: <a href="#Data-changing" accesskey="n" rel="next">Data changing</a>, Previous: <a href="#File-I_002fO" accesskey="p" rel="prev">File I/O</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Make-another-data-1"></a>
<h3 class="section">6.6 Make another data</h3>

<a name="index-SubData"></a>
<a name="index-Column"></a>
<a name="index-Trace"></a>
<a name="index-Hist-1"></a>
<a name="index-Resize"></a>
<a name="index-Evaluate"></a>
<a name="index-Combine-1"></a>
<a name="index-Momentum"></a>
<a name="index-Sum"></a>
<a name="index-Min"></a>
<a name="index-Max"></a>
<a name="index-Roots"></a>
<a name="index-Correl"></a>
<a name="index-AutoCorrel"></a>

<a name="subdata"></a><dl>
<dt><a name="index-subdata"></a>Команда MGL: <em></em> <strong>subdata</strong> <em><small>RES</small> dat <code>xx [yy=all zz=all]</code></em></dt>
<dt><a name="index-SubData-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>SubData</strong> <em>(<code>mreal</code> xx, <code>mreal</code> yy=<code>-1</code>, <code>mreal</code> zz=<code>-1</code>) <code>const</code></em></dt>
<dt><a name="index-SubData-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>SubData</strong> <em>(<code>mreal</code> xx, <code>mreal</code> yy=<code>-1</code>, <code>mreal</code> zz=<code>-1</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsubdata"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_subdata</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> xx, <code>mreal</code> yy, <code>mreal</code> zz)</em></dt>
<dd><p>Возвращает в <var>res</var> подмассив массива данных <var>dat</var> с фиксированными значениями индексов с положительными значениями. Например, <code>SubData(-1,2)</code> выделяет третью строку (индексы начинаются с нуля), <code>SubData(4,-1)</code> выделяет 5-ую колонку, <code>SubData(-1,-1,3)</code> выделяет 4-ый срез и т.д. В MGL скриптах обычно используется упрощенная версия <code>dat(xx,yy,zz)</code>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<dl>
<dt><a name="index-subdata-1"></a>Команда MGL: <em></em> <strong>subdata</strong> <em><small>RES</small> dat xdat [ydat zdat]</em></dt>
<dt><a name="index-SubData-3"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>SubData</strong> <em>(<code>const mglDataA &amp;</code>xx, <code>const mglDataA &amp;</code>yy, <code>const mglDataA &amp;</code>zz) <code>const</code></em></dt>
<dt><a name="index-SubData-4"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>SubData</strong> <em>(<code>const mglDataA &amp;</code>xx, <code>const mglDataA &amp;</code>yy, <code>const mglDataA &amp;</code>zz) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsubdata_005fext"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_subdata_ext</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> xx, <code>HCDT</code> yy, <code>HCDT</code> zz)</em></dt>
<dd><p>Возвращает в <var>res</var> подмассив массива данных <var>dat</var> с индексами, заданными в массивах <var>xx</var>, <var>yy</var>, <var>zz</var> (косвенная адресация). Результат будет иметь размерность массивов с индексами. Размеры массивов <var>xx</var>, <var>yy</var>, <var>zz</var> с индексами должна быть одинакова, либо должны быть &quot;скаляром&quot; (т.е. 1*1*1). В MGL скриптах обычно используется упрощенная версия <code>dat(xx,yy,zz)</code>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="column"></a><dl>
<dt><a name="index-column"></a>Команда MGL: <em></em> <strong>column</strong> <em><small>RES</small> dat 'eq'</em></dt>
<dt><a name="index-Column-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Column</strong> <em>(<code>const char *</code>eq) <code>const</code></em></dt>
<dt><a name="index-Column-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Column</strong> <em>(<code>const char *</code>eq) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fcolumn"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_column</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>eq)</em></dt>
<dd><p>Возвращает массив данных заполненный по формуле <var>eq</var>, вычисленной для именованных колонок (или срезов). Например, <code>Column(&quot;n*w^2/exp(t)&quot;);</code>. Имена колонок должны быть предварительно заданы функцией <a href="#idset">idset</a> или при чтении файлов данных. В MGL скриптах обычно используется упрощенная версия <code>dat('eq')</code>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="resize"></a><dl>
<dt><a name="index-resize"></a>Команда MGL: <em></em> <strong>resize</strong> <em><small>RES</small> dat <code>mx [my=1 mz=1]</code></em></dt>
<dt><a name="index-Resize-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Resize</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>0</code>, <code>int</code> mz=<code>0</code>, <code>mreal</code> x1=<code>0</code>, <code>mreal</code> x2=<code>1</code>, <code>mreal</code> y1=<code>0</code>, <code>mreal</code> y2=<code>1</code>, <code>mreal</code> z1=<code>0</code>, <code>mreal</code> z2=<code>1</code>) <code>const</code></em></dt>
<dt><a name="index-Resize-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Resize</strong> <em>(<code>int</code> mx, <code>int</code> my=<code>0</code>, <code>int</code> mz=<code>0</code>, <code>mreal</code> x1=<code>0</code>, <code>mreal</code> x2=<code>1</code>, <code>mreal</code> y1=<code>0</code>, <code>mreal</code> y2=<code>1</code>, <code>mreal</code> z1=<code>0</code>, <code>mreal</code> z2=<code>1</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fresize"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_resize</strong> <em>(<code>HCDT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz)</em></dt>
<dt><a name="index-mgl_005fdata_005fresize_005fbox"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_resize_box</strong> <em>(<code>HCDT</code> dat, <code>int</code> mx, <code>int</code> my, <code>int</code> mz, <code>mreal</code> x1, <code>mreal</code> x2, <code>mreal</code> y1, <code>mreal</code> y2, <code>mreal</code> z1, <code>mreal</code> z2)</em></dt>
<dd><p>Возвращает массив данных размером <var>mx</var>, <var>my</var>, <var>mz</var> со значениями полученными интерполяцией значений из части [<var>x1</var>,<var>x2</var>] x [<var>y1</var>,<var>y2</var>] x [<var>z1</var>,<var>z2</var>] исходного массива. Величины x,y,z полагаются нормированными в диапазоне [0,1]. Если значение <var>mx</var>, <var>my</var> или <var>mz</var> равно 0, то исходный размер используется.  Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="evaluate"></a><dl>
<dt><a name="index-evaluate"></a>Команда MGL: <em></em> <strong>evaluate</strong> <em><small>RES</small> dat idat [<code>norm=on</code>]</em></dt>
<dt><a name="index-evaluate-1"></a>Команда MGL: <em></em> <strong>evaluate</strong> <em><small>RES</small> dat idat jdat [<code>norm=on</code>]</em></dt>
<dt><a name="index-evaluate-2"></a>Команда MGL: <em></em> <strong>evaluate</strong> <em><small>RES</small> dat idat jdat kdat [<code>norm=on</code>]</em></dt>
<dt><a name="index-Evaluate-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Evaluate-2"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>const mglDataA &amp;</code>jdat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Evaluate-3"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>const mglDataA &amp;</code>jdat, <code>const mglDataA &amp;</code>kdat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Evaluate-4"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Evaluate-5"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>const mglDataA &amp;</code>jdat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Evaluate-6"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Evaluate</strong> <em>(<code>const mglDataA &amp;</code>idat, <code>const mglDataA &amp;</code>jdat, <code>const mglDataA &amp;</code>kdat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fevaluate"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_evaluate</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> idat, <code>HCDT</code> jdat, <code>HCDT</code> kdat, <code>int</code> norm)</em></dt>
<dd><p>Возвращает массив данных, полученный в результате интерполяции исходного массива в точках других массивов (например, res[i,j]=dat[idat[i,j],jdat[i,j]]). Размеры массивов <var>idat</var>, <var>jdat</var>, <var>kdat</var> должны совпадать. Координаты в <var>idat</var>, <var>jdat</var>, <var>kdat</var> полагаются нормированными в диапазон [0,1] (при <var>norm</var>=<code>true</code>) или в диапазоны [0,nx], [0,ny], [0,nz] соответственно. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="section"></a><dl>
<dt><a name="index-section"></a>Команда MGL: <em></em> <strong>section</strong> <em><small>RES</small> dat ids ['dir'='y' <code>val=nan</code>]</em></dt>
<dt><a name="index-section-1"></a>Команда MGL: <em></em> <strong>section</strong> <em><small>RES</small> dat <code>id</code> ['dir'='y' <code>val=nan</code>]</em></dt>
<dt><a name="index-Section"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Section</strong> <em>(<code>const mglDataA &amp;</code>ids, <code>const char *</code>dir=<code>'y'</code>, <code>mreal</code> val=<code>NAN</code>) <code>const</code></em></dt>
<dt><a name="index-Section-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Section</strong> <em>(<code>long</code> id, <code>const char *</code>dir=<code>'y'</code>, <code>mreal</code> val=<code>NAN</code>) <code>const</code></em></dt>
<dt><a name="index-Section-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Section</strong> <em>(<code>const mglDataA &amp;</code>ids, <code>const char *</code>dir=<code>'y'</code>, <code>mreal</code> val=<code>NAN</code>) <code>const</code></em></dt>
<dt><a name="index-Section-3"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Section</strong> <em>(<code>long</code> id, <code>const char *</code>dir=<code>'y'</code>, <code>mreal</code> val=<code>NAN</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsection"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_section</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> ids, <code>const char *</code>dir, <code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fdata_005fsection_005fval"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_section_val</strong> <em>(<code>HCDT</code> dat, <code>long</code> id, <code>const char *</code>dir, <code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsection"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_datac_section</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> ids, <code>const char *</code>dir, <code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsection_005fval"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_datac_section_val</strong> <em>(<code>HCDT</code> dat, <code>long</code> id, <code>const char *</code>dir, <code>mreal</code> val)</em></dt>
<dd><p>Возвращает массив данных, являющийся <var>id</var>-ой секцией (диапазоном срезов, разделенных значениями <var>val</var>) исходного массива <var>dat</var>. Для <var>id</var>&lt;0 используется обратный порядок (т.e. -1 даст последнюю секцию). Если указано несколько <var>ids</var>, то выходной массив будет результатом последовательного объединения секций.
</p></dd></dl>

<a name="solve"></a><dl>
<dt><a name="index-solve"></a>Команда MGL: <em></em> <strong>solve</strong> <em><small>RES</small> dat <code>val</code> 'dir' [<code>norm=on</code>]</em></dt>
<dt><a name="index-solve-1"></a>Команда MGL: <em></em> <strong>solve</strong> <em><small>RES</small> dat <code>val</code> 'dir' idat [<code>norm=on</code>]</em></dt>
<dt><a name="index-Solve"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Solve</strong> <em>(<code>mreal</code> val, <code>char</code> dir, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-Solve-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Solve</strong> <em>(<code>mreal</code> val, <code>char</code> dir, <code>const mglDataA &amp;</code>idat, <code>bool</code> norm=<code>true</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsolve"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_solve</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> val, <code>char</code> dir, <code>HCDT</code> idat, <code>int</code> norm)</em></dt>
<dd><p>Возвращает массив индексов (корней) вдоль выбранного направления <var>dir</var> в которых значения массива <var>dat</var> равны <var>val</var>. Выходной массив будет иметь размеры массива <var>dat</var> в направлениях поперечных <var>dir</var>. Если предоставлен массив <var>idat</var>, то его значения используются как стартовые при поиске. Это позволяет найти несколько веток с помощью последовательного вызова функции. Индексы полагаются нормированными в диапазон [0,1] (при <var>norm</var>=<code>true</code>) или в диапазоны [0,nx], [0,ny], [0,nz] соответственно. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов. См. раздел <a href="#Solve-sample">Solve sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="roots"></a><dl>
<dt><a name="index-roots"></a>Команда MGL: <em></em> <strong>roots</strong> <em><small>RES</small> 'func' ini ['var'='x']</em></dt>
<dt><a name="index-roots-1"></a>Команда MGL: <em></em> <strong>roots</strong> <em><small>RES</small> 'func' <code>ini</code> ['var'='x']</em></dt>
<dt><a name="index-Roots-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Roots</strong> <em>(<code>const char *</code>func, <code>char</code> var) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005froots"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_roots</strong> <em>(<code>const char *</code>func, <code>HCDT</code> ini, <code>char</code> var)</em></dt>
<dt><a name="index-mgl_005ffind_005froot_005ftxt"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_find_root_txt</strong> <em>(<code>const char *</code>func, <code>mreal</code> ini, <code>char</code> var)</em></dt>
<dd><p>Возвращает массив корней уравнения &rsquo;func&rsquo;=0 для переменной <var>var</var> с начальными положениями <var>ini</var>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<dl>
<dt><a name="index-roots-2"></a>Команда MGL: <em></em> <strong>roots</strong> <em><small>RES</small> 'funcs' 'vars' ini</em></dt>
<dt><a name="index-MultiRoots"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>MultiRoots</strong> <em>(<code>const char *</code>funcs, <code>const char *</code>vars) <code>const</code></em></dt>
<dt><a name="index-MultiRoots-1"></a>Метод класса <code>mglDataC</code>: <em><code>mglDataC</code></em> <strong>MultiRoots</strong> <em>(<code>const char *</code>funcs, <code>const char *</code>vars) <code>const</code></em></dt>
<dt><a name="index-mgl_005ffind_005froots_005ftxt"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_find_roots_txt</strong> <em>(<code>const char *</code>func, <code>const char *</code>vars, <code>HCDT</code> ini)</em></dt>
<dt><a name="index-mgl_005ffind_005froots_005ftxt_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_find_roots_txt_c</strong> <em>(<code>const char *</code>func, <code>const char *</code>vars, <code>HCDT</code> ini)</em></dt>
<dd><p>Возвращает массив корней системы уравнений &rsquo;funcs&rsquo;=0 для переменных <var>vars</var> с начальными значениями <var>ini</var>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="detect"></a><dl>
<dt><a name="index-detect"></a>Команда MGL: <em></em> <strong>detect</strong> <em><small>RES</small> dat <code>lvl dj [di=0 minlen=0]</code></em></dt>
<dt><a name="index-Detect"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Detect</strong> <em>(<code>mreal</code> lvl, <code>mreal</code> dj, <code>mreal</code> di=<code>0</code>, <code>mreal</code> minlen=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fdetect"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_detect</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> lvl, <code>mreal</code> dj, <code>mreal</code> di, <code>mreal</code> minlen)</em></dt>
<dd><p>Возвращает массив кривых {x,y}, разделенных NAN значениями, для локальных максимумов массива <var>dat</var> как функцию координаты x. Шумы амплитудой меньше <var>lvl</var> игнорируются. Параметр <var>dj</var> (в диапазоне [0,ny]) задает область &quot;притяжения&quot; точек в y-направлении к кривой. Аналогично, <var>di</var> продолжает кривые в x-направлении через разрывы длиной менее <var>di</var> точек. Кривые с минимальной длинной менее <var>minlen</var> игнорируются.
</p></dd></dl>

<a name="hist"></a><dl>
<dt><a name="index-hist-3"></a>Команда MGL: <em></em> <strong>hist</strong> <em><small>RES</small> dat <code>num v1 v2 [nsub=0]</code></em></dt>
<dt><a name="index-hist-4"></a>Команда MGL: <em></em> <strong>hist</strong> <em><small>RES</small> dat wdat <code>num v1 v2 [nsub=0]</code></em></dt>
<dt><a name="index-Hist-5"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>int</code> n, <code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>int</code> nsub=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Hist-6"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>const mglDataA &amp;</code>w, <code>int</code> n, <code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>int</code> nsub=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Hist-7"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>int</code> n, <code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>int</code> nsub=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Hist-8"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Hist</strong> <em>(<code>const mglDataA &amp;</code>w, <code>int</code> n, <code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>int</code> nsub=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fhist"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_hist</strong> <em>(<code>HCDT</code> dat, <code>int</code> n, <code>mreal</code> v1, <code>mreal</code> v2, <code>int</code> nsub)</em></dt>
<dt><a name="index-mgl_005fdata_005fhist_005fw"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_hist_w</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> w, <code>int</code> n, <code>mreal</code> v1, <code>mreal</code> v2, <code>int</code> nsub)</em></dt>
<dd><p>Возвращает распределение (гистограмму) из <var>n</var> точек от значений массива в диапазоне [<var>v1</var>, <var>v2</var>]. Массив <var>w</var> задает веса элементов (по умолчанию все веса равны 1). Параметр <var>nsub</var> задает число дополнительных точек интерполяции (для сглаживания получившейся гистограммы). Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов. См. также <a href="#Data-manipulation">Data manipulation</a>
</p></dd></dl>

<a name="momentum"></a><dl>
<dt><a name="index-momentum"></a>Команда MGL: <em></em> <strong>momentum</strong> <em><small>RES</small> dat 'how' ['dir'='z']</em></dt>
<dt><a name="index-Momentum-2"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Momentum</strong> <em>(<code>char</code> dir, <code>const char *</code>how) <code>const</code></em></dt>
<dt><a name="index-Momentum-3"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Momentum</strong> <em>(<code>char</code> dir, <code>const char *</code>how) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmomentum"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_momentum</strong> <em>(<code>HCDT</code> dat, <code>char</code> dir, <code>const char *</code>how)</em></dt>
<dd><p>Возвращает момент (1d массив) данных вдоль направления <var>dir</var>. Строка <var>how</var> определяет тип момента. Момент определяется как
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
если <var>dir</var>=&lsquo;<samp>z</samp>&rsquo; и т.д. Координаты &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; &ndash; индексы массива в диапазоне [0,1]. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="sum"></a><dl>
<dt><a name="index-sum"></a>Команда MGL: <em></em> <strong>sum</strong> <em><small>RES</small> dat 'dir'</em></dt>
<dt><a name="index-Sum-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Sum</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-Sum-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Sum</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fsum"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_sum</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Возвращает результат суммирования данных вдоль направления(ий) <var>dir</var>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="max"></a><dl>
<dt><a name="index-max"></a>Команда MGL: <em></em> <strong>max</strong> <em><small>RES</small> dat 'dir'</em></dt>
<dt><a name="index-Max-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Max</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-Max-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Max</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmax_005fdir"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_max_dir</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Возвращает максимальное значение данных вдоль направления(ий) <var>dir</var>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="min"></a><dl>
<dt><a name="index-min"></a>Команда MGL: <em></em> <strong>min</strong> <em><small>RES</small> dat 'dir'</em></dt>
<dt><a name="index-Min-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Min</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-Min-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Min</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmin_005fdir"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_min_dir</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Возвращает минимальное значение данных вдоль направления(ий) <var>dir</var>. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="combine"></a><dl>
<dt><a name="index-combine"></a>Команда MGL: <em></em> <strong>combine</strong> <em><small>RES</small> adat bdat</em></dt>
<dt><a name="index-Combine-3"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Combine</strong> <em>(<code>const mglDataA &amp;</code>a) <code>const</code></em></dt>
<dt><a name="index-Combine-4"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Combine</strong> <em>(<code>const mglDataA &amp;</code>a) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fcombine"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_combine</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> a)</em></dt>
<dd><p>Возвращает прямое произведение массивов (наподобие, res[i,j] = adat[i]*bdat[j] и т.д.). Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="trace"></a><dl>
<dt><a name="index-trace"></a>Команда MGL: <em></em> <strong>trace</strong> <em><small>RES</small> dat</em></dt>
<dt><a name="index-Trace-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Trace</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-Trace-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Trace</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005ftrace"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_trace</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает массив диагональных элементов a[i,i] (для 2D данных) или a[i,i,i] (для 3D данных) где i=0...nx-1. В 1D случае возвращается сам массив данных. Размеры массива данных должен быть ny,nz &gt;= nx или ny,nz = 1. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<a name="correl"></a><dl>
<dt><a name="index-correl"></a>Команда MGL: <em></em> <strong>correl</strong> <em><small>RES</small> adat bdat 'dir'</em></dt>
<dt><a name="index-Correl-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Correl</strong> <em>(<code>const mglDataA &amp;</code>b, <code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-AutoCorrel-1"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>AutoCorrel</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-Correl-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglDataC</code></em> <strong>Correl</strong> <em>(<code>const mglDataA &amp;</code>b, <code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-AutoCorrel-2"></a>Метод класса <code>mglDataC</code>: <em><code>mglDataC</code></em> <strong>AutoCorrel</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fcorrel"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_correl</strong> <em>(<code>HCDT</code> a, <code>HCDT</code> b, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fcorrel"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_datac_correl</strong> <em>(<code>HCDT</code> a, <code>HCDT</code> b, <code>const char *</code>dir)</em></dt>
<dd><p>Возвращает корреляцию массивов <var>a</var> (или this в C++) и <var>b</var> вдоль направлений <var>dir</var>. При вычислении используется преобразование Фурье. Поэтому может потребоваться вызов функций <a href="#swap">swap</a> и/или <a href="#norm">norm</a> перед построением. Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов.
</p></dd></dl>

<dl>
<dt><a name="index-Real"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Real</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdatac_005freal"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_datac_real</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает массив действительных частей массива данных.
</p></dd></dl>
<dl>
<dt><a name="index-Imag"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Imag</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdatac_005fimag"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_datac_imag</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает массив мнимых частей массива данных.
</p></dd></dl>
<dl>
<dt><a name="index-Abs"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Abs</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdatac_005fabs"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_datac_abs</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает массив абсолютных значений массива данных.
</p></dd></dl>
<dl>
<dt><a name="index-Arg"></a>Метод класса <code>mglDataC</code>: <em><code>mglData</code></em> <strong>Arg</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdatac_005farg"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_datac_arg</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает массив аргументов массива данных.
</p></dd></dl>

<a name="pulse"></a><dl>
<dt><a name="index-pulse"></a>Команда MGL: <em></em> <strong>pulse</strong> <em><small>RES</small> dat 'dir'</em></dt>
<dt><a name="index-Pulse"></a>Метод класса <code>mglData</code>: <em><code>mglData</code></em> <strong>Pulse</strong> <em>(<code>const char *</code>dir) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fpulse"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_pulse</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Находит параметры импульса вдоль направления <var>dir</var>: максимальное значение (в колонке 0), его положение (в колонке 1), ширина по параболлической аппроксимации (в колонке 3) и по полувысоте (в колонке 2), энергию около максимума (в колонке 4). NAN значения используются для ширин если максимум расположен вблизи границ массива. Отмечу, что для комплексных массивов есть неопределенность определения параметров. Обычно следует использовать квадрат абсолютного значения амплитуды (т.е. |dat[i]|^2). Поэтому MathGL не включает эту функцию в <code>mglDataC</code>, хотя формально C функция будет работать и для них, но будет использовать абсолютное значение амплитуды (т.е. |dat[i]|). Функция возвращает NULL или пустой массив если данные не могут быть созданы при данных значениях аргументов. См. также <a href="#max">max</a>, <a href="#min">min</a>, <a href="#momentum">momentum</a>, <a href="#sum">sum</a>. См. раздел <a href="#Pulse-properties">Pulse properties</a>, для примеров кода и графика.
</p></dd></dl>


<hr>
<a name="Data-changing"></a>
<div class="header">
<p>
Next: <a href="#Interpolation" accesskey="n" rel="next">Interpolation</a>, Previous: <a href="#Make-another-data" accesskey="p" rel="prev">Make another data</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Izmenenie-dannykh"></a>
<h3 class="section">6.7 Изменение данных</h3>

<a name="index-CumSum"></a>
<a name="index-Integral"></a>
<a name="index-Diff"></a>
<a name="index-Diff2"></a>
<a name="index-SinFFT"></a>
<a name="index-CosFFT"></a>
<a name="index-Hankel"></a>
<a name="index-Swap"></a>
<a name="index-Roll"></a>
<a name="index-Mirror"></a>
<a name="index-Sew"></a>
<a name="index-Smooth"></a>
<a name="index-Envelop"></a>
<a name="index-Norm"></a>
<a name="index-NormSl"></a>

<p>These functions change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo; or &lsquo;<samp>z</samp>&rsquo; characters for 1-st, 2-nd and 3-d dimension correspondingly.
</p>
<a name="cumsum"></a><dl>
<dt><a name="index-cumsum"></a>Команда MGL: <em></em> <strong>cumsum</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-CumSum-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>CumSum</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-CumSum-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>CumSum</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fcumsum"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_cumsum</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fcumsum"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_cumsum</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Суммирует с накоплением в выбранном направлении(ях).
</p></dd></dl>

<a name="integrate"></a><dl>
<dt><a name="index-integrate"></a>Команда MGL: <em></em> <strong>integrate</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Integral-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Integral</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Integral-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Integral</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fintegral"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_integral</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fintegral"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_integral</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет интегрирование (методом трапеций) в выбранном направлении(ях).
</p></dd></dl>

<a name="diff"></a><dl>
<dt><a name="index-diff"></a>Команда MGL: <em></em> <strong>diff</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Diff-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Diff-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fdiff"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_diff</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fdiff"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_diff</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет дифференцирование в выбранном направлении(ях).
</p></dd></dl>

<dl>
<dt><a name="index-diff-1"></a>Команда MGL: <em></em> <strong>diff</strong> <em>dat xdat ydat [zdat]</em></dt>
<dt><a name="index-Diff-3"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x)</em></dt>
<dt><a name="index-Diff-4"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-Diff-5"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z)</em></dt>
<dt><a name="index-Diff-6"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x)</em></dt>
<dt><a name="index-Diff-7"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-Diff-8"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diff</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z)</em></dt>
<dt><a name="index-mgl_005fdata_005fdiff_005fpar"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_diff_par</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> x, <code>HCDT</code>y, <code>HCDT</code>z)</em></dt>
<dt><a name="index-mgl_005fdatac_005fdiff_005fpar"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_diff_par</strong> <em>(<code>HADT</code> dat, <code>HCDT</code> x, <code>HCDT</code>y, <code>HCDT</code>z)</em></dt>
<dd><p>Выполняет дифференцирование данных, параметрически зависящих от координат, в направлении <var>x</var> с <var>y</var>, <var>z</var>=constant. Параметр <var>z</var> может быть опущен, что соответствует 2D случаю. Используются следующие формулы (2D случай): <em>da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)</em>, где <em>a_i=da/di, a_j=da/dj</em> обозначает дифференцирование вдоль 1-ой и 2-ой размерности. Похожие формулы используются и в 3D случае. Порядок аргументов можно менять &ndash; например, если данные a(i,j) зависят от координат {x(i,j), y(i,j)}, то обычная производная по &lsquo;<samp>x</samp>&rsquo; будет равна <code>Diff(x,y);</code>, а обычная производная по &lsquo;<samp>y</samp>&rsquo; будет равна <code>Diff(y,x);</code>.
</p></dd></dl>

<a name="diff2"></a><dl>
<dt><a name="index-diff2"></a>Команда MGL: <em></em> <strong>diff2</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Diff2-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Diff2</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Diff2-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diff2</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fdiff2"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_diff2</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fdiff2"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_diff2</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет двойное дифференцирование (как в операторе Лапласа) в выбранном направлении(ях).
</p></dd></dl>

<a name="sinfft"></a><dl>
<dt><a name="index-sinfft"></a>Команда MGL: <em></em> <strong>sinfft</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-SinFFT-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>SinFFT</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fsinfft"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_sinfft</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет синус преобразование в выбранном направлении(ях). Синус преобразование есть <em>\sum a_j \sin(k j)</em> (см. <a href="http://en.wikipedia.org/wiki/Discrete_sine_transform#DST-I">http://en.wikipedia.org/wiki/Discrete_sine_transform#DST-I</a>).
</p></dd></dl>

<a name="cosfft"></a><dl>
<dt><a name="index-cosfft"></a>Команда MGL: <em></em> <strong>cosfft</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-CosFFT-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>CosFFT</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fcosfft"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_cosfft</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет косинус преобразование в выбранном направлении(ях). Синус преобразование есть <em>\sum a_j \cos(k j)</em> (см. <a href="http://en.wikipedia.org/wiki/Discrete_cosine_transform#DCT-I">http://en.wikipedia.org/wiki/Discrete_cosine_transform#DCT-I</a>).
</p></dd></dl>

<dl>
<dt><a name="index-FFT"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>FFT</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005ffft"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_fft</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет фурье преобразование в выбранном направлении(ях). Если строка <var>dir</var> содержит &lsquo;<samp>i</samp>&rsquo;, то используется обратное преобразование фурье. Фурье преобразование есть <em>\sum a_j \exp(i k j)</em> (см. <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform">http://en.wikipedia.org/wiki/Discrete_Fourier_transform</a>).
</p></dd></dl>

<a name="hankel"></a><dl>
<dt><a name="index-hankel"></a>Команда MGL: <em></em> <strong>hankel</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Hankel-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Hankel</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Hankel-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Hankel</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fhankel"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_hankel</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fhankel"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_hankel</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет преобразование Ханкеля в выбранном направлении(ях). Преобразование Ханкеля есть <em>\sum a_j J_0(k j)</em> (см. <a href="http://en.wikipedia.org/wiki/Hankel_transform">http://en.wikipedia.org/wiki/Hankel_transform</a>).
</p></dd></dl>

<a name="wavelet"></a><dl>
<dt><a name="index-wavelet"></a>Команда MGL: <em></em> <strong>wavelet</strong> <em>dat 'dir' <code>k</code></em></dt>
<dt><a name="index-Wavelet"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Wavelet</strong> <em>(<code>const char *</code>dir, <code>int</code> k)</em></dt>
<dt><a name="index-mgl_005fdata_005fwavelet"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_wavelet</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir, <code>int</code> k)</em></dt>
<dd><p>Выполняет преобразование wavelet в выбранном направлении(ях). Параметр <var>dir</var> задает тип:
&lsquo;<samp>d</samp>&rsquo; для daubechies, &lsquo;<samp>D</samp>&rsquo; для центрированного daubechies, &lsquo;<samp>h</samp>&rsquo; для haar, &lsquo;<samp>H</samp>&rsquo; для центрированного haar, &lsquo;<samp>b</samp>&rsquo; для bspline, &lsquo;<samp>B</samp>&rsquo; для центрированного bspline. Если указан символ &lsquo;<samp>i</samp>&rsquo;, то выполняется обратное преобразование. Параметр <var>k</var> задает размер преобразования.
</p></dd></dl>

<a name="swap"></a><dl>
<dt><a name="index-swap"></a>Команда MGL: <em></em> <strong>swap</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Swap-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Swap</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Swap-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Swap</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fswap"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_swap</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fswap"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_swap</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Меняет местами левую и правую части данных в выбранном направлении(ях). Полезно для отображения результата FFT.
</p></dd></dl>

<a name="roll"></a><dl>
<dt><a name="index-roll"></a>Команда MGL: <em></em> <strong>roll</strong> <em>dat 'dir' num</em></dt>
<dt><a name="index-Roll-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Roll</strong> <em>(<code>char</code> dir, <code>num</code>)</em></dt>
<dt><a name="index-Roll-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Roll</strong> <em>(<code>char</code> dir, <code>num</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005froll"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_roll</strong> <em>(<code>HMDT</code> dat, <code>char</code> dir, <code>num</code>)</em></dt>
<dt><a name="index-mgl_005fdatac_005froll"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_roll</strong> <em>(<code>HADT</code> dat, <code>char</code> dir, <code>num</code>)</em></dt>
<dd><p>Сдвигает данные на <var>num</var> ячеек в выбранном направлении(ях). Соответствует замене индекса на <var>i</var>-&gt;(i+<var>num</var>)%nx при <code>dir='x'</code>.
</p></dd></dl>

<a name="mirror"></a><dl>
<dt><a name="index-mirror"></a>Команда MGL: <em></em> <strong>mirror</strong> <em>dat 'dir'</em></dt>
<dt><a name="index-Mirror-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Mirror</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-Mirror-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Mirror</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005fmirror"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_mirror</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005fmirror"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_mirror</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Отражает данные в выбранном направлении(ях). Соответствует замене индекса на <var>i</var>-&gt;<var>n</var>-<var>i</var>. Отмечу, что похожего эффекта на графике можно достичь используя опции (see <a href="#Command-options">Command options</a>), например, <code>surf dat; xrange 1 -1</code>.
</p></dd></dl>

<a name="sew"></a><dl>
<dt><a name="index-sew"></a>Команда MGL: <em></em> <strong>sew</strong> <em>dat ['dir'='xyz' <code>da=2*pi</code>]</em></dt>
<dt><a name="index-Sew-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Sew</strong> <em>(<code>const char *</code>dir, <code>mreal</code> da=<code>2*M_PI</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fsew"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_sew</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir, <code>mreal</code> da)</em></dt>
<dd><p>Удаляет скачки данных (например, скачки фазы после обратных тригонометрических функций) с периодом <var>da</var> в выбранном направлении(ях).
</p></dd></dl>

<a name="smooth"></a><dl>
<dt><a name="index-smooth"></a>Команда MGL: <em></em> <strong>smooth</strong> <em>data ['dir'='xyz']</em></dt>
<dt><a name="index-Smooth-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Smooth</strong> <em>(<code>const char *</code>dir=<code>&quot;xyz&quot;</code>, <code>mreal</code> delta=<code>0</code>)</em></dt>
<dt><a name="index-Smooth-2"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Smooth</strong> <em>(<code>const char *</code>dir=<code>&quot;xyz&quot;</code>, <code>mreal</code> delta=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fsmooth"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_smooth</strong> <em>(<code>HMDT</code> dat, <code>const char *</code>dir, <code>mreal</code> delta)</em></dt>
<dt><a name="index-mgl_005fdatac_005fsmooth"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_smooth</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir, <code>mreal</code> delta)</em></dt>
<dd><p>Сглаживает данные в выбранном направлении(ях) <var>dir</var>. Строка <var>dirs</var> задает направления вдоль которых будет производиться сглаживание. Строка <var>dir</var> может содержать:
</p><ul>
<li> &lsquo;<samp>xyz</samp>&rsquo; &ndash; сглаживание по x-,y-,z-направлениям,
</li><li> &lsquo;<samp>0</samp>&rsquo; &ndash; ничего не делает,
</li><li> &lsquo;<samp>3</samp>&rsquo; &ndash; линейное усреднение по 3 точкам,
</li><li> &lsquo;<samp>5</samp>&rsquo; &ndash; линейное усреднение по 5 точкам,
</li><li> &lsquo;<samp>d1</samp>&rsquo;...&lsquo;<samp>d9</samp>&rsquo; &ndash; линейное усреднение по (2*N+1) точкам,
</li><li> &lsquo;<samp>^</samp>&rsquo; &ndash; определение верхней границы,
</li><li> &lsquo;<samp>_</samp>&rsquo; &ndash; определение нижней границы.
</li></ul>
<p>По умолчанию используется квадратичное усреднение по 5 точкам.
</p></dd></dl>

<a name="envelop"></a><dl>
<dt><a name="index-envelop"></a>Команда MGL: <em></em> <strong>envelop</strong> <em>dat ['dir'='x']</em></dt>
<dt><a name="index-Envelop-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Envelop</strong> <em>(<code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fenvelop"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_envelop</strong> <em>(<code>HMDT</code> dat, <code>char</code> dir)</em></dt>
<dd><p>Находит огибающую данных в выбранном направлении <var>dir</var>.
</p></dd></dl>

<a name="diffract"></a><dl>
<dt><a name="index-diffract"></a>Команда MGL: <em></em> <strong>diffract</strong> <em>dat 'how' <code>q</code></em></dt>
<dt><a name="index-Diffraction"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Diffraction</strong> <em>(<code>const char *</code>how, <code>mreal</code> q)</em></dt>
<dt><a name="index-mgl_005fdatac_005fdiffr"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_diffr</strong> <em>(<code>HADT</code> dat, <code>const char *</code>how, <code>mreal</code> q)</em></dt>
<dd><p>Вычисляет один шаг диффракции в конечно-разностной схеме с параметром <var>q</var>=<em>\delta t/\delta x^2</em> используя метод третьего порядка точности. Параметр <var>how</var> может содержать:
</p><ul>
<li> &lsquo;<samp>xyz</samp>&rsquo; для расчета вдоль x-,y-,z-направления;
</li><li> &lsquo;<samp>r</samp>&rsquo; для аксиально симметричного лапласиана по направлению x;
</li><li> &lsquo;<samp>0</samp>&rsquo; для нулевых граничных условий;
</li><li> &lsquo;<samp>1</samp>&rsquo; для постоянных граничных условий;
</li><li> &lsquo;<samp>2</samp>&rsquo; для линейных граничных условий;
</li><li> &lsquo;<samp>3</samp>&rsquo; для параболлических граничных условий;
</li><li> &lsquo;<samp>4</samp>&rsquo; для экспоненциальных граничных условий;
</li><li> &lsquo;<samp>5</samp>&rsquo; для гауссовых граничных условий.
</li></ul>
</dd></dl>

<a name="norm"></a><dl>
<dt><a name="index-norm"></a>Команда MGL: <em></em> <strong>norm</strong> <em>dat <code>v1 v2 [sym=off dim=0]</code></em></dt>
<dt><a name="index-Norm-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Norm</strong> <em>(<code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>bool</code> sym=<code>false</code>, <code>long</code> dim=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fnorm"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_norm</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> v1, <code>mreal</code> v2, <code>int</code> sym, <code>long</code> dim)</em></dt>
<dd><p>Нормирует данные в интервал [<var>v1</var>,<var>v2</var>]. Если <var>sym</var>=<code>true</code>, то используется симметричный интервал [-max(|v1|,|v2|), max(|v1|,|v2|)]. Изменения применяются только к срезам &gt;=<var>dim</var>.
</p></dd></dl>

<a name="normsl"></a><dl>
<dt><a name="index-normsl"></a>Команда MGL: <em></em> <strong>normsl</strong> <em>dat <code>v1 v2</code> ['dir'='z' <code>keep=on sym=off</code>]</em></dt>
<dt><a name="index-NormSl-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>NormSl</strong> <em>(<code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>1</code>, <code>char</code> dir=<code>'z'</code>, <code>bool</code> keep=<code>true</code>, <code>bool</code> sym=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fnorm_005fslice"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_norm_slice</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> v1, <code>mreal</code> v2, <code>char</code> dir, <code>int</code> keep, <code>int</code> sym)</em></dt>
<dd><p>Нормирует данные срез-за-срезом в выбранном направлении <var>dir</var> в интервал [<var>v1</var>,<var>v2</var>]. Если <var>sym</var>=<code>true</code>, то используется симметричный интервал [-max(|v1|,|v2|), max(|v1|,|v2|)]. Если <var>keep</var>=<code>true</code>, то максимальное значение k-го среза ограничено величиной
<em>\sqrt{\sum a_ij(k)/\sum a_ij(0)}</em>.
</p></dd></dl>

<a name="limit"></a><dl>
<dt><a name="index-limit"></a>Команда MGL: <em></em> <strong>limit</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-Limit"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Limit</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-Limit-1"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>Limit</strong> <em>(<code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fdata_005flimit"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_limit</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> val)</em></dt>
<dt><a name="index-mgl_005fdatac_005flimit"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_limit</strong> <em>(<code>HADT</code> dat, <code>mreal</code> val)</em></dt>
<dd><p>Ограничивает амплитуду данных диапазоном [-<var>val</var>,<var>val</var>]. При этом сохраняется исходный знак (фаза для комплексных чисел). Эквивалентно операции <code>a[i] *= abs(a[i])&lt;val?1.:val/abs(a[i]);</code>.
</p></dd></dl>

<a name="coil"></a><dl>
<dt><a name="index-coil"></a>Команда MGL: <em></em> <strong>coil</strong> <em>dat <code>v1 v2 [sep=on]</code></em></dt>
<dt><a name="index-Coil"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Coil</strong> <em>(<code>mreal</code> v1, <code>mreal</code> v2, <code>bool</code> sep=<code>true</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fcoil"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_coil</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> v1, <code>mreal</code> v2, <code>int</code> sep)</em></dt>
<dd><p>Проецирует периодические данные на диапазон [<var>v1</var>,<var>v2</var>] (аналогично функции <code>mod()</code>). Разделяет ветки по значениям равным <code>NAN</code> если <var>sep</var>=<code>true</code>.
</p></dd></dl>

<a name="dilate"></a><dl>
<dt><a name="index-dilate"></a>Команда MGL: <em></em> <strong>dilate</strong> <em>dat <code>[val=1 step=1]</code></em></dt>
<dt><a name="index-Dilate"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Dilate</strong> <em>(<code>mreal</code> val=<code>1</code>, <code>long</code> step=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fdilate"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_dilate</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> val, <code>long</code> step)</em></dt>
<dd><p>Возвращает &quot;расширенный&quot; на <var>step</var> ячеек массив из 0 и 1 для данных больших порогового значения <var>val</var>. </p></dd></dl>

<a name="erode"></a><dl>
<dt><a name="index-erode"></a>Команда MGL: <em></em> <strong>erode</strong> <em>dat <code>[val=1 step=1]</code></em></dt>
<dt><a name="index-Erode"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>Erode</strong> <em>(<code>mreal</code> val=<code>1</code>, <code>long</code> step=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005ferode"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_erode</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> val, <code>long</code> step)</em></dt>
<dd><p>Возвращает &quot;суженный&quot; на <var>step</var> ячеек массив из 0 и 1 для данных больших порогового значения <var>val</var>. </p></dd></dl>


<hr>
<a name="Interpolation"></a>
<div class="header">
<p>
Next: <a href="#Data-information" accesskey="n" rel="next">Data information</a>, Previous: <a href="#Data-changing" accesskey="p" rel="prev">Data changing</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Interpolyaciya"></a>
<h3 class="section">6.8 Интерполяция</h3>


<p>Скрипты MGL могут использовать интерполяцию кубическими сплайнами с помощью команд <a href="#evaluate">evaluate</a> или <a href="#refill">refill</a>. Также можно использовать <a href="#resize">resize</a> для массива с новыми размерами.
</p>

<p>Однако, есть специальные и более быстрые функции при использовании других языков (C/C++/Fortran/Python/...).
</p>
<a name="index-Spline"></a>
<dl>
<dt><a name="index-Spline-1"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Spline</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Spline-2"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Spline</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fspline"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_spline</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-mgl_005fdatac_005fspline"></a>Функция С: <em><code>dual</code></em> <strong>mgl_datac_spline</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dd><p>Интерполирует данные кубическим сплайном в точке <var>x</var> в [0...nx-1], <var>y</var> в [0...ny-1], <var>z</var> в [0...nz-1].
</p></dd></dl>
<a name="index-Spline1"></a>
<dl>
<dt><a name="index-Spline1-2"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Spline1</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Spline1-3"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Spline1</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dd><p>Интерполирует данные кубическим сплайном в точке <var>x</var>, <var>y</var>, <var>z</var>, где координаты полагаются в интервале [0, 1].
</p></dd></dl>

<dl>
<dt><a name="index-Spline-3"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Spline</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fspline_005fext"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_spline_ext</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>mreal *</code>dx, <code>mreal *</code>dy, <code>mreal *</code>dz)</em></dt>
<dt><a name="index-mgl_005fdatac_005fspline_005fext"></a>Функция С: <em><code>dual</code></em> <strong>mgl_datac_spline_ext</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>dual *</code>dx, <code>dual *</code>dy, <code>dual *</code>dz)</em></dt>
<dd><p>Интерполирует данные кубическим сплайном в точке <var>x</var> в [0...nx-1], <var>y</var> в [0...ny-1], <var>z</var> в [0...nz-1]. Значения производных в точке записываются в <var>dif</var>.
</p></dd></dl>
<a name="index-Spline1-1"></a>
<dl>
<dt><a name="index-Spline1-4"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Spline1</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dd><p>Интерполирует данные кубическим сплайном в точке <var>x</var>, <var>y</var>, <var>z</var>, где координаты полагаются в интервале [0, 1]. Значения производных в точке записываются в <var>dif</var>.
</p></dd></dl>


<a name="index-Linear"></a>
<dl>
<dt><a name="index-Linear-1"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Linear</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Linear-2"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Linear</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005flinear"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_linear</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-mgl_005fdatac_005flinear"></a>Функция С: <em><code>dual</code></em> <strong>mgl_datac_linear</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dd><p>Интерполирует данные линейной функцией в точке <var>x</var> в [0...nx-1], <var>y</var> в [0...ny-1], <var>z</var> в [0...nz-1].
</p></dd></dl>
<a name="index-Linear1"></a>
<dl>
<dt><a name="index-Linear1-2"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Linear1</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Linear1-3"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Linear1</strong> <em>(<code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dd><p>Интерполирует данные линейной функцией в точке <var>x</var>, <var>y</var>, <var>z</var>, где координаты полагаются в интервале [0, 1].
</p></dd></dl>

<dl>
<dt><a name="index-Linear-3"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Linear</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Linear-4"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Linear</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005flinear_005fext"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_linear_ext</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>mreal *</code>dx, <code>mreal *</code>dy, <code>mreal *</code>dz)</em></dt>
<dt><a name="index-mgl_005fdatac_005flinear_005fext"></a>Функция С: <em><code>dual</code></em> <strong>mgl_datac_linear_ext</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z, <code>dual *</code>dx, <code>dual *</code>dy, <code>dual *</code>dz)</em></dt>
<dd><p>Интерполирует данные линейной функцией в точке <var>x</var>, <var>y</var>, <var>z</var>, где координаты полагаются в интервале [0, 1]. Значения производных в точке записываются в <var>dif</var>.
</p></dd></dl>
<a name="index-Linear1-1"></a>
<dl>
<dt><a name="index-Linear1-4"></a>Метод класса <code>mglData</code>: <em><code>mreal</code></em> <strong>Linear1</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-Linear1-5"></a>Метод класса <code>mglDataC</code>: <em><code>dual</code></em> <strong>Linear1</strong> <em>(<code>mglPoint</code> &amp;dif, <code>mreal</code> x, <code>mreal</code> y=<code>0</code>, <code>mreal</code> z=<code>0</code>) <code>const</code></em></dt>
<dd><p>Интерполирует данные линейной функцией в точке <var>x</var>, <var>y</var>, <var>z</var>, где координаты полагаются в интервале [0, 1]. Значения производных в точке записываются в <var>dif</var>.
</p></dd></dl>



<hr>
<a name="Data-information"></a>
<div class="header">
<p>
Next: <a href="#Operators" accesskey="n" rel="next">Operators</a>, Previous: <a href="#Interpolation" accesskey="p" rel="prev">Interpolation</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Informacionnye-funkcii"></a>
<h3 class="section">6.9 Информационные функции</h3>


<p>В MathGL есть ряд функций для получения свойств массива данных. В MGL скриптах большинство из них реализовано в виде &quot;суффиксов&quot;. Суффиксы дают числовое значение некоторой характеристики массива данных. Например, его размер, минимальное и максимальное значение, сумму элементов и т.д. Суффиксы начинаются с точки &lsquo;<samp>.</samp>&rsquo; сразу после массива (без пробелов). Например, <code>a.nx</code> даст размер массива <var>a</var> вдоль x, <code>b(1).max</code> даст максимальное значение второй колонки массива <var>b</var>, <code>(c(:,0)^2).sum</code> даст сумму квадратов в первой строке массива <var>c</var> и т.д.
</p>

<a name="index-PrintInfo"></a>
<a name="info"></a><dl>
<dt><a name="index-info"></a>Команда MGL: <em></em> <strong>info</strong> <em>dat</em></dt>
<dt><a name="index-PrintInfo-1"></a>Метод класса <code>mglDataA</code>: <em><code>const char *</code></em> <strong>PrintInfo</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-PrintInfo-2"></a>Метод класса <code>mglDataA</code>: <em><code>void</code></em> <strong>PrintInfo</strong> <em>(<code>FILE *</code>fp) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005finfo"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_data_info</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dt><a name="index-mgl_005fdata_005finfo-1"></a>Fortran процедура: <em><code></code></em> <strong>mgl_data_info</strong> <em>(<code>long</code> dat, <code>char *</code>out, <code>int</code> len)</em></dt>
<dd><p>Возвращает строку с информацией о данных (размеры, моменты и пр.) или пишет её в файл. В MGL скрипте печатает её как сообщение.
</p></dd></dl>

<dl>
<dt><a name="index-info-1"></a>Команда MGL: <em></em> <strong>info</strong> <em>'txt'</em></dt>
<dd><p>Печатает строку <var>txt</var> как сообщение.
</p></dd></dl>

<dl>
<dt><a name="index-info-2"></a>Команда MGL: <em></em> <strong>info</strong> <em>val</em></dt>
<dd><p>Печатает значение числа <var>val</var> как сообщение.
</p></dd></dl>

<a name="print"></a><dl>
<dt><a name="index-print-1"></a>Команда MGL: <em></em> <strong>print</strong> <em>dat</em></dt>
<dt><a name="index-print-2"></a>Команда MGL: <em></em> <strong>print</strong> <em>'txt'</em></dt>
<dt><a name="index-print-3"></a>Команда MGL: <em></em> <strong>print</strong> <em>val</em></dt>
<dd><p>Аналогично <a href="#info">info</a>, но сразу выводит в stdout.
</p></dd></dl>

<a name="echo"></a><dl>
<dt><a name="index-echo"></a>Команда MGL: <em></em> <strong>echo</strong> <em>dat</em></dt>
<dd><p>Печатает все значения массива <var>dat</var> как сообщение.
</p></dd></dl>

<a name="progress"></a><dl>
<dt><a name="index-progress"></a>Команда MGL: <em></em> <strong>progress</strong> <em><code>val max</code></em></dt>
<dt><a name="index-Progress"></a>Метод класса <code>mglGraph</code>: <em><code>void</code></em> <strong>Progress</strong> <em>(<code>int</code> val, <code>int</code> max)</em></dt>
<dt><a name="index-mgl_005fprogress"></a>Функция С: <em><code>void</code></em> <strong>mgl_progress</strong> <em>(<code>int</code> val, <code>int</code> max)</em></dt>
<dd><p>Отображает прогресс чего-либо как заполненную полоску с относительной длиной <var>val</var>/<var>max</var>. На данный момент работает только в консоли и основанных на FLTK программах, включая <code>mgllab</code> и <code>mglview</code>.
</p></dd></dl>


<a name="index-GetNx"></a>
<a name="index-GetNy"></a>
<a name="index-GetNz"></a>
<a name="g_t_002enx"></a><a name="g_t_002eny"></a><a name="g_t_002enz"></a><dl>
<dt><a name="index-_002enx"></a>MGL suffix: <em>(dat)</em> <strong>.nx</strong></dt>
<dt><a name="index-_002eny"></a>MGL suffix: <em>(dat)</em> <strong>.ny</strong></dt>
<dt><a name="index-_002enz"></a>MGL suffix: <em>(dat)</em> <strong>.nz</strong></dt>
<dt><a name="index-GetNx-2"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNx</strong> <em>()</em></dt>
<dt><a name="index-GetNy-2"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNy</strong> <em>()</em></dt>
<dt><a name="index-GetNz-2"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>GetNz</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fnx-1"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_nx</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fny-1"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_ny</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dt><a name="index-mgl_005fdata_005fget_005fnz-1"></a>Функция С: <em><code>long</code></em> <strong>mgl_data_get_nz</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает размер данных в направлении x, y и z соответственно.
</p></dd></dl>



<a name="index-Maximal"></a>
<a name="g_t_002emax"></a><dl>
<dt><a name="index-_002emax"></a>MGL suffix: <em>(dat)</em> <strong>.max</strong></dt>
<dt><a name="index-Maximal-1"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Maximal</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmax"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_max</strong> <em>(<code>HCDT</code> dat)</em></dt>
<dd><p>Возвращает максимальное значение массива данных.
</p></dd></dl>

<a name="index-Minimal"></a>
<a name="g_t_002emin"></a><dl>
<dt><a name="index-_002emin"></a>MGL suffix: <em>(dat)</em> <strong>.min</strong></dt>
<dt><a name="index-Minimal-1"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Minimal</strong> <em>() <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmin"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_min</strong> <em>(<code>HMDT</code> dat) <code>const</code></em></dt>
<dd><p>Возвращает минимальное значение массива данных.
</p></dd></dl>

<dl>
<dt><a name="index-Minimal-2"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Minimal</strong> <em>(<code>int</code> &amp;i, <code>int</code> &amp;j, <code>int</code> &amp;k) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmin_005fint"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_min_int</strong> <em>(<code>HCDT</code> dat, <code>int</code> *i, <code>int</code> *j, <code>int</code> *k)</em></dt>
<dd><p>Возвращает максимальное значение массива данных и сохраняет его положение в переменные <var>i</var>, <var>j</var>, <var>k</var>.
</p></dd></dl>
<dl>
<dt><a name="index-Maximal-2"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Maximal</strong> <em>(<code>int</code> &amp;i, <code>int</code> &amp;j, <code>int</code> &amp;k) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmax_005fint"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_max_int</strong> <em>(<code>HCDT</code> dat, <code>int</code> *i, <code>int</code> *j, <code>int</code> *k)</em></dt>
<dd><p>Возвращает минимальное значение массива данных и сохраняет его положение в переменные <var>i</var>, <var>j</var>, <var>k</var>.
</p></dd></dl>
<dl>
<dt><a name="index-Minimal-3"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Minimal</strong> <em>(<code>mreal</code> &amp;x, <code>mreal</code> &amp;y, <code>mreal</code> &amp;z) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmin_005freal"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_min_real</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> *x, <code>mreal</code> *y, <code>mreal</code> *z)</em></dt>
<dd><p>Возвращает максимальное значение массива данных и его приближенное (интерполированное) положение в переменные <var>x</var>, <var>y</var>, <var>z</var>.
</p></dd></dl>

<a name="g_t_002emx"></a><a name="g_t_002emy"></a><a name="g_t_002emz"></a><dl>
<dt><a name="index-_002emx"></a>MGL suffix: <em>(dat)</em> <strong>.mx</strong></dt>
<dt><a name="index-_002emy"></a>MGL suffix: <em>(dat)</em> <strong>.my</strong></dt>
<dt><a name="index-_002emz"></a>MGL suffix: <em>(dat)</em> <strong>.mz</strong></dt>
<dt><a name="index-Maximal-3"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Maximal</strong> <em>(<code>mreal</code> &amp;x, <code>mreal</code> &amp;y, <code>mreal</code> &amp;z) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmax_005freal"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_max_real</strong> <em>(<code>HCDT</code> dat, <code>mreal</code> *x, <code>mreal</code> *y, <code>mreal</code> *z)</em></dt>
<dd><p>Возвращает минимальное значение массива данных и его приближенное (интерполированное) положение в переменные <var>x</var>, <var>y</var>, <var>z</var>.
</p></dd></dl>

<a name="g_t_002emxf"></a><a name="g_t_002emyf"></a><a name="g_t_002emzf"></a><a name="g_t_002emxl"></a><a name="g_t_002emyl"></a><a name="g_t_002emzl"></a><dl>
<dt><a name="index-_002emxf"></a>MGL suffix: <em>(dat)</em> <strong>.mxf</strong></dt>
<dt><a name="index-_002emyf"></a>MGL suffix: <em>(dat)</em> <strong>.myf</strong></dt>
<dt><a name="index-_002emzf"></a>MGL suffix: <em>(dat)</em> <strong>.mzf</strong></dt>
<dt><a name="index-_002emxl"></a>MGL suffix: <em>(dat)</em> <strong>.mxl</strong></dt>
<dt><a name="index-_002emyl"></a>MGL suffix: <em>(dat)</em> <strong>.myl</strong></dt>
<dt><a name="index-_002emzl"></a>MGL suffix: <em>(dat)</em> <strong>.mzl</strong></dt>
<dt><a name="index-Maximal-4"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>Maximal</strong> <em>(<code>char</code> dir, <code>long</code> from) <code>const</code></em></dt>
<dt><a name="index-Maximal-5"></a>Метод класса <code>mglDataA</code>: <em><code>long</code></em> <strong>Maximal</strong> <em>(<code>char</code> dir, <code>long</code> from, <code>long</code> &amp;p1, <code>long</code> &amp;p2) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmax_005ffirstl"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_max_firstl</strong> <em>(<code>HCDT</code> dat, <code>char</code> dir, <code>long</code> from, <code>long</code> *p1, <code>long</code> *p2)</em></dt>
<dd><p>Возвращает положение первого (последнего при <var>from</var>&lt;0) максимума в направлении <var>dir</var>, начиная с позиции <var>from</var>. Положение остальных координат для максимума сохраняется в <var>p1</var>, <var>p2</var>.
</p></dd></dl>


<a name="index-Momentum-1"></a>
<a name="g_t_002eax"></a><a name="g_t_002eay"></a><a name="g_t_002eaz"></a><a name="g_t_002eaa"></a><a name="g_t_002esum"></a><a name="g_t_002ewx"></a><a name="g_t_002ewy"></a><a name="g_t_002ewz"></a><a name="g_t_002ewa"></a><a name="g_t_002esx"></a><a name="g_t_002esy"></a><a name="g_t_002esz"></a><a name="g_t_002esa"></a><a name="g_t_002ekx"></a><a name="g_t_002eky"></a><a name="g_t_002ekz"></a><a name="g_t_002eka"></a><dl>
<dt><a name="index-_002esum"></a>MGL suffix: <em>(dat)</em> <strong>.sum</strong></dt>
<dt><a name="index-_002eax"></a>MGL suffix: <em>(dat)</em> <strong>.ax</strong></dt>
<dt><a name="index-_002eay"></a>MGL suffix: <em>(dat)</em> <strong>.ay</strong></dt>
<dt><a name="index-_002eaz"></a>MGL suffix: <em>(dat)</em> <strong>.az</strong></dt>
<dt><a name="index-_002eaa"></a>MGL suffix: <em>(dat)</em> <strong>.aa</strong></dt>
<dt><a name="index-_002ewx"></a>MGL suffix: <em>(dat)</em> <strong>.wx</strong></dt>
<dt><a name="index-_002ewy"></a>MGL suffix: <em>(dat)</em> <strong>.wy</strong></dt>
<dt><a name="index-_002ewz"></a>MGL suffix: <em>(dat)</em> <strong>.wz</strong></dt>
<dt><a name="index-_002ewa"></a>MGL suffix: <em>(dat)</em> <strong>.wa</strong></dt>
<dt><a name="index-_002esx"></a>MGL suffix: <em>(dat)</em> <strong>.sx</strong></dt>
<dt><a name="index-_002esy"></a>MGL suffix: <em>(dat)</em> <strong>.sy</strong></dt>
<dt><a name="index-_002esz"></a>MGL suffix: <em>(dat)</em> <strong>.sz</strong></dt>
<dt><a name="index-_002esa"></a>MGL suffix: <em>(dat)</em> <strong>.sa</strong></dt>
<dt><a name="index-_002ekx"></a>MGL suffix: <em>(dat)</em> <strong>.kx</strong></dt>
<dt><a name="index-_002eky"></a>MGL suffix: <em>(dat)</em> <strong>.ky</strong></dt>
<dt><a name="index-_002ekz"></a>MGL suffix: <em>(dat)</em> <strong>.kz</strong></dt>
<dt><a name="index-_002eka"></a>MGL suffix: <em>(dat)</em> <strong>.ka</strong></dt>
<dt><a name="index-Momentum-4"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Momentum</strong> <em>(<code>char</code> dir, <code>mreal</code> &amp;a, <code>mreal</code> &amp;w) <code>const</code></em></dt>
<dt><a name="index-Momentum-5"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Momentum</strong> <em>(<code>char</code> dir, <code>mreal</code> &amp;m, <code>mreal</code> &amp;w, <code>mreal</code> &amp;s, <code>mreal</code> &amp;k) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005fmomentum_005fval"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_momentum_val</strong> <em>(<code>HCDT</code> dat, <code>char</code> dir, <code>mreal</code> *a, <code>mreal</code> *w, <code>mreal</code> *s, <code>mreal</code> *k)</em></dt>
<dd><p>Возвращает нулевой момент (энергию, <em>I=\sum a_i</em>) и записывает первый (среднее, <em>m = \sum \xi_i a_i/I</em>), второй (ширину, <em>w^2 = \sum (\xi_i-m)^2 a_i/I</em>), третий (асимметрия, <em>s = \sum (\xi_i-m)^3 a_i/ I w^3</em>) и четвёртый моменты (эксцесс, <em>k = \sum (\xi_i-m)^4 a_i / 3 I w^4</em>)). Здесь <em>\xi</em> &ndash; соответствующая координата если <var>dir</var> равно &lsquo;<samp>'x'</samp>&rsquo;, &lsquo;<samp>'y'</samp>&rsquo;, &lsquo;<samp>'z'</samp>&rsquo;. В противном случае среднее, ширина, асимметрия, эксцесс равны <em>m = \sum a_i/N</em>, <em>w^2 = \sum (a_i-m)^2/N</em> и т.д.
</p></dd></dl>

<a name="g_t_002efst"></a><dl>
<dt><a name="index-_002efst"></a>MGL suffix: <em>(dat)</em> <strong>.fst</strong></dt>
<dd><a name="index-Find"></a>
</dd><dt><a name="index-Find-1"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Find</strong> <em>(<code>const char *</code>cond, <code>int</code> &amp;i, <code>int</code> &amp;j, <code>int</code> &amp;k) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005ffirst"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_first</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>cond, <code>int</code> *i, <code>int</code> *j, <code>int</code> *k)</em></dt>
<dd><p>Находит положение (после заданного в <var>i</var>, <var>j</var>, <var>k</var>) первого не нулевого значения формулы <var>cond</var>. Функция возвращает найденное значение и записывает его положение в <var>i</var>, <var>j</var>, <var>k</var>.
</p></dd></dl>

<a name="g_t_002elst"></a><dl>
<dt><a name="index-_002elst"></a>MGL suffix: <em>(dat)</em> <strong>.lst</strong></dt>
<dd><a name="index-Last"></a>
</dd><dt><a name="index-Last-1"></a>Метод класса <code>mglDataA</code>: <em><code>mreal</code></em> <strong>Last</strong> <em>(<code>const char *</code>cond, <code>int</code> &amp;i, <code>int</code> &amp;j, <code>int</code> &amp;k) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005flast"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_last</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>cond, <code>int</code> *i, <code>int</code> *j, <code>int</code> *k)</em></dt>
<dd><p>Находит положение (перед заданного в <var>i</var>, <var>j</var>, <var>k</var>) последнего не нулевого значения формулы <var>cond</var>. Функция возвращает найденное значение и записывает его положение в <var>i</var>, <var>j</var>, <var>k</var>.
</p></dd></dl>

<dl>
<dt><a name="index-Find-2"></a>Метод класса <code>mglDataA</code>: <em><code>int</code></em> <strong>Find</strong> <em>(<code>const char *</code>cond, <code>char</code> dir, <code>int</code> i=<code>0</code>, <code>int</code> j=<code>0</code>, <code>int</code> k=<code>0</code>) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005ffind"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_find</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>cond, <code>int</code> i, <code>int</code> j, <code>int</code> k)</em></dt>
<dd><p>Возвращает положение первого в направлении <var>dir</var> не нулевого значения формулы <var>cond</var>. Поиск начинается с точки {i,j,k}.
</p></dd></dl>
<a name="index-FindAny"></a>
<dl>
<dt><a name="index-FindAny-1"></a>Метод класса <code>mglDataA</code>: <em><code>bool</code></em> <strong>FindAny</strong> <em>(<code>const char *</code>cond) <code>const</code></em></dt>
<dt><a name="index-mgl_005fdata_005ffind_005fany"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_data_find_any</strong> <em>(<code>HCDT</code> dat, <code>const char *</code>cond)</em></dt>
<dd><p>Определяет есть ли хоть одно значение массива, удовлетворяющее условию <var>cond</var>.
</p></dd></dl>

<a name="g_t_002ea"></a><dl>
<dt><a name="index-_002ea"></a>MGL suffix: <em>(dat)</em> <strong>.a</strong></dt>
<dd><p>Возвращает первое число массива (для <code>.a</code> это <code>dat-&gt;a[0]</code>).
</p></dd></dl>



<hr>
<a name="Operators"></a>
<div class="header">
<p>
Next: <a href="#Global-functions" accesskey="n" rel="next">Global functions</a>, Previous: <a href="#Data-information" accesskey="p" rel="prev">Data information</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Operatory"></a>
<h3 class="section">6.10 Операторы</h3>


<dl>
<dt><a name="index-copy-5"></a>Команда MGL: <em></em> <strong>copy</strong> <em><small>DAT</small> dat2 ['eq'='']</em></dt>
<dt><a name="index-operator_003d"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator=</strong> <em>(<code>const mglDataA &amp;</code>d)</em></dt>
<dd><p>Копирует данные из другого экземпляра.
</p></dd></dl>

<dl>
<dt><a name="index-copy-6"></a>Команда MGL: <em></em> <strong>copy</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-operator_003d-1"></a>Метод класса <code>mreal</code>: <em><code>void</code></em> <strong>operator=</strong> <em>(<code>mreal</code> val)</em></dt>
<dd><p>Устанавливает все значения массива равными <var>val</var>.
</p></dd></dl>

<a name="multo"></a><dl>
<dt><a name="index-multo"></a>Команда MGL: <em></em> <strong>multo</strong> <em>dat dat2</em></dt>
<dt><a name="index-multo-1"></a>Команда MGL: <em></em> <strong>multo</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-operator_002a_003d"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator*=</strong> <em>(<code>const mglDataA &amp;</code>d)</em></dt>
<dt><a name="index-operator_002a_003d-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator*=</strong> <em>(<code>mreal</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fmul_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_mul_dat</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fmul_005fnum"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_mul_num</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> d)</em></dt>
<dd><p>Поэлементно умножает на массив <var>d</var> или на число <var>val</var>.
</p></dd></dl>

<a name="divto"></a><dl>
<dt><a name="index-divto"></a>Команда MGL: <em></em> <strong>divto</strong> <em>dat dat2</em></dt>
<dt><a name="index-divto-1"></a>Команда MGL: <em></em> <strong>divto</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-operator_002f_003d"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator/=</strong> <em>(<code>const mglDataA &amp;</code>d)</em></dt>
<dt><a name="index-operator_002f_003d-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator/=</strong> <em>(<code>mreal</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fdiv_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_div_dat</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fdiv_005fnum"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_div_num</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> d)</em></dt>
<dd><p>Поэлементно делит на массив <var>d</var> или на число <var>val</var>.
</p></dd></dl>

<a name="addto"></a><dl>
<dt><a name="index-addto"></a>Команда MGL: <em></em> <strong>addto</strong> <em>dat dat2</em></dt>
<dt><a name="index-addto-1"></a>Команда MGL: <em></em> <strong>addto</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-operator_002b_003d"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator+=</strong> <em>(<code>const mglDataA &amp;</code>d)</em></dt>
<dt><a name="index-operator_002b_003d-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator+=</strong> <em>(<code>mreal</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fadd_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_add_dat</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fadd_005fnum"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_add_num</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> d)</em></dt>
<dd><p>Поэлементно прибавляет <var>d</var> или число <var>val</var>.
</p></dd></dl>

<a name="subto"></a><dl>
<dt><a name="index-subto"></a>Команда MGL: <em></em> <strong>subto</strong> <em>dat dat2</em></dt>
<dt><a name="index-subto-1"></a>Команда MGL: <em></em> <strong>subto</strong> <em>dat <code>val</code></em></dt>
<dt><a name="index-operator_002d_003d"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator-=</strong> <em>(<code>const mglDataA &amp;</code>d)</em></dt>
<dt><a name="index-operator_002d_003d-1"></a>Метод класса <code>mglData</code>: <em><code>void</code></em> <strong>operator-=</strong> <em>(<code>mreal</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fsub_005fdat"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_sub_dat</strong> <em>(<code>HMDT</code> dat, <code>HCDT</code> d)</em></dt>
<dt><a name="index-mgl_005fdata_005fsub_005fnum"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_sub_num</strong> <em>(<code>HMDT</code> dat, <code>mreal</code> d)</em></dt>
<dd><p>Поэлементно вычитает <var>d</var> или число <var>val</var>.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002b"></a>Library Function: <em>mglData</em> <strong>operator+</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002b-1"></a>Library Function: <em>mglData</em> <strong>operator+</strong> <em>(<code>mreal</code> a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002b-2"></a>Library Function: <em>mglData</em> <strong>operator+</strong> <em>(<code>const mglDataA &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Возвращает поэлементную сумму данных.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002d"></a>Library Function: <em>mglData</em> <strong>operator-</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002d-1"></a>Library Function: <em>mglData</em> <strong>operator-</strong> <em>(<code>mreal</code> a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002d-2"></a>Library Function: <em>mglData</em> <strong>operator-</strong> <em>(<code>const mglDataA &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Возвращает поэлементную разность данных.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002a"></a>Library Function: <em>mglData</em> <strong>operator*</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002a-1"></a>Library Function: <em>mglData</em> <strong>operator*</strong> <em>(<code>mreal</code> a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002a-2"></a>Library Function: <em>mglData</em> <strong>operator*</strong> <em>(<code>const mglDataA &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Возвращает поэлементное произведение данных.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002f"></a>Library Function: <em>mglData</em> <strong>operator/</strong> <em>(<code>const mglDataA &amp;</code>a, <code>const mglDataA &amp;</code>b)</em></dt>
<dt><a name="index-operator_002f-1"></a>Library Function: <em>mglData</em> <strong>operator/</strong> <em>(<code>const mglDataA &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Возвращает поэлементное деление данных.
</p></dd></dl>


<hr>
<a name="Global-functions"></a>
<div class="header">
<p>
Next: <a href="#Evaluate-expression" accesskey="n" rel="next">Evaluate expression</a>, Previous: <a href="#Operators" accesskey="p" rel="prev">Operators</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Globalxnye-funkcii"></a>
<h3 class="section">6.11 Глобальные функции</h3>


<p>Эти функции не методы класса <code>mglData</code>, но они дают дополнительные возможности по обработке данных. Поэтому я поместил их в эту главу.
</p>
<a name="transform"></a><dl>
<dt><a name="index-transform"></a>Команда MGL: <em></em> <strong>transform</strong> <em><small>DAT</small> 'type' real imag</em></dt>
<dt><a name="index-mglTransform"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTransform</strong> <em>(<code>const mglDataA &amp;</code>real, <code>const mglDataA &amp;</code>imag, <code>const char *</code>type)</em></dt>
<dt><a name="index-mgl_005ftransform"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_transform</strong> <em>(<code>HCDT</code> real, <code>HCDT</code> imag, <code>const char *</code>type)</em></dt>
<dd><p>Выполняет интегральное преобразование комплексных данных <var>real</var>, <var>imag</var> в выбранном направлении и возвращает модуль результата. Порядок и тип преобразований задается строкой <var>type</var>: первый символ для x-направления, второй для y-направления, третий для z-направления. Возможные символы: &lsquo;<samp>f</samp>&rsquo; &ndash; прямое преобразование Фурье, &lsquo;<samp>i</samp>&rsquo; &ndash; обратное преобразование Фурье, &lsquo;<samp>s</samp>&rsquo; &ndash; синус преобразование, &lsquo;<samp>c</samp>&rsquo; &ndash; косинус преобразование, &lsquo;<samp>h</samp>&rsquo; &ndash; преобразование Ханкеля, &lsquo;<samp>n</samp>&rsquo; или &lsquo;<samp> </samp>&rsquo; &ndash; нет преобразования.
</p></dd></dl>

<a name="transforma"></a><dl>
<dt><a name="index-transforma"></a>Команда MGL: <em></em> <strong>transforma</strong> <em><small>DAT</small> 'type' ampl phase</em></dt>
<dt><a name="index-mglTransformA"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTransformA</strong> <em><code>const mglDataA &amp;</code>ampl, <code>const mglDataA &amp;</code>phase, <code>const char *</code>type)</em></dt>
<dt><a name="index-mgl_005ftransform_005fa"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_transform_a</strong> <em><code>HCDT</code> ampl, <code>HCDT</code> phase, <code>const char *</code>type)</em></dt>
<dd><p>Аналогично предыдущему с заданными амплитудой <var>ampl</var> и фазой <var>phase</var> комплексных чисел.
</p></dd></dl>

<a name="fourier"></a><dl>
<dt><a name="index-fourier"></a>Команда MGL: <em></em> <strong>fourier</strong> <em>reDat imDat 'dir'</em></dt>
<dt><a name="index-fourier-1"></a>Команда MGL: <em></em> <strong>fourier</strong> <em>complexDat 'dir'</em></dt>
<dt><a name="index-mglFourier"></a>Общая функция: <em><code>void</code></em> <strong>mglFourier</strong> <em><code>const mglDataA &amp;</code>re, <code>const mglDataA &amp;</code>im, <code>const char *</code>dir)</em></dt>
<dt><a name="index-FFT-1"></a>Метод класса <code>mglDataC</code>: <em><code>void</code></em> <strong>FFT</strong> <em>(<code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdata_005ffourier"></a>Функция С: <em><code>void</code></em> <strong>mgl_data_fourier</strong> <em><code>HCDT</code> re, <code>HCDT</code> im, <code>const char *</code>dir)</em></dt>
<dt><a name="index-mgl_005fdatac_005ffft-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_datac_fft</strong> <em>(<code>HADT</code> dat, <code>const char *</code>dir)</em></dt>
<dd><p>Выполняет Фурье преобразование для комплексных данных <var>re</var>+i*<var>im</var> в направлениях <var>dir</var>. Результат помещается обратно в массивы <var>re</var> и <var>im</var>. Если <var>dir</var> содержит &lsquo;<samp>i</samp>&rsquo;, то выполняется обратное преобразование Фурье.
</p></dd></dl>

<a name="stfad"></a><dl>
<dt><a name="index-stfad"></a>Команда MGL: <em></em> <strong>stfad</strong> <em><small>RES</small> real imag <code>dn</code> ['dir'='x']</em></dt>
<dt><a name="index-mglSTFA"></a>Общая функция: <em><code>mglData</code></em> <strong>mglSTFA</strong> <em>(<code>const mglDataA &amp;</code>real, <code>const mglDataA &amp;</code>imag, <code>int</code> dn, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fstfa"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_stfa</strong> <em>(<code>HCDT</code> real, <code>HCDT</code> imag, <code>int</code> dn, <code>char</code> dir)</em></dt>
<dd><p>Выполняет оконное преобразование Фурье длиной <var>dn</var> для комплексных данных <var>real</var>, <var>imag</var> и возвращает модуль результата. Например, для <var>dir</var>=&lsquo;<samp>x</samp>&rsquo; результат будет иметь размер {int(nx/dn), dn, ny} и будет равен <em>res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn</em>.
</p></dd></dl>


<a name="triangulate"></a><dl>
<dt><a name="index-triangulate"></a>Команда MGL: <em></em> <strong>triangulate</strong> <em>dat xdat ydat</em></dt>
<dt><a name="index-mglTriangulation"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTriangulation</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-mgl_005ftriangulation_005f2d"></a>Функция С: <em><code>void</code></em> <strong>mgl_triangulation_2d</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y)</em></dt>
<dd><p>Выполняет триангуляцию Делоне для точек на плоскости и возвращает массив, пригодный для <a href="#triplot">triplot</a> и <a href="#tricont">tricont</a>. См. раздел <a href="#Making-regular-data">Making regular data</a>, для примеров кода и графика.
</p></dd></dl>

<a name="tridmat"></a><dl>
<dt><a name="index-tridmat"></a>Команда MGL: <em></em> <strong>tridmat</strong> <em><small>RES ADAT BDAT CDAT DDAT</small> 'how'</em></dt>
<dt><a name="index-mglTridMat"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTridMat</strong> <em>(<code>const mglDataA &amp;</code>A, <code>const mglDataA &amp;</code>B, <code>const mglDataA &amp;</code>C, <code>const mglDataA &amp;</code>D, <code>const char *</code>how)</em></dt>
<dt><a name="index-mglTridMatC"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglTridMatC</strong> <em>(<code>const mglDataA &amp;</code>A, <code>const mglDataA &amp;</code>B, <code>const mglDataA &amp;</code>C, <code>const mglDataA &amp;</code>D, <code>const char *</code>how)</em></dt>
<dt><a name="index-mgl_005fdata_005ftridmat"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_tridmat</strong> <em>(<code>HCDT</code> A, <code>HCDT</code> B, <code>HCDT</code> C, <code>HCDT</code> D, <code>const char*</code>how)</em></dt>
<dt><a name="index-mgl_005fdatac_005ftridmat"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_datac_tridmat</strong> <em>(<code>HCDT</code> A, <code>HCDT</code> B, <code>HCDT</code> C, <code>HCDT</code> D, <code>const char*</code>how)</em></dt>
<dd><p>Возвращает решение трехдиагональной системы уравнений <var>A</var>[i]*x[i-1]+<var>B</var>[i]*x[i]+<var>C</var>[i]*x[i+1]=<var>D</var>[i]. Строка <var>how</var> может содержать:
</p><ul>
<li> &lsquo;<samp>xyz</samp>&rsquo; для решения вдоль x-,y-,z-направлений;
</li><li> &lsquo;<samp>h</samp>&rsquo; для решения вдоль диагонали на плоскости x-y (требует квадратную матрицу);
</li><li> &lsquo;<samp>c</samp>&rsquo; для использования периодических граничных условий;
</li><li> &lsquo;<samp>d</samp>&rsquo; для расчета диффракции/диффузии (т.е. для использования -<var>A</var>[i]*<var>D</var>[i-1]+(2-<var>B</var>[i])*<var>D</var>[i]-<var>C</var>[i]*<var>D</var>[i+1] в правой частиц вместо <var>D</var>[i]).
</li></ul>
<p>Размеры массивов <var>A</var>, <var>B</var>, <var>C</var> должны быть одинаковы. Также их размерности должны совпадать со всеми или с &quot;младшими&quot; размерностями массива <var>D</var>. См. раздел <a href="#PDE-solving-hints">PDE solving hints</a>, для примеров кода и графика.
</p></dd></dl>

<a name="pde"></a><dl>
<dt><a name="index-pde-1"></a>Команда MGL: <em></em> <strong>pde</strong> <em><small>RES</small> 'ham' ini_re ini_im [<code>dz=0.1 k0=100</code>]</em></dt>
<dt><a name="index-mglPDE"></a>Общая функция: <em><code>mglData</code></em> <strong>mglPDE</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>mreal</code> dz=<code>0.1</code>, <code>mreal</code> k0=<code>100</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mglPDEc"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglPDEc</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>mreal</code> dz=<code>0.1</code>, <code>mreal</code> k0=<code>100</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpde_005fsolve-1"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_pde_solve</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>mreal</code> dz, <code>mreal</code> k0, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpde_005fsolve_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_pde_solve_c</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>mreal</code> dz, <code>mreal</code> k0, <code>const char *</code>opt)</em></dt>
<dd><p>Решает уравнение в частных производных du/dz = i*k0*<var>ham</var>(p,q,x,y,z,|u|)[u], где p=-i/k0*d/dx, q=-i/k0*d/dy &ndash; псевдо-дифференциальные операторы. Параметры <var>ini_re</var>, <var>ini_im</var> задают начальное распределение поля. Координаты в уравнении и в решении полагаются в диапазоне осей координат. Замечу, что внутри этот диапазон увеличивается в 3/2 раза для уменьшения отражения от границ расчетного интервала. Параметр <var>dz</var> задает шаг по эволюционной координате z. В данный момент использован упрощенный алгоритм, когда все &ldquo;смешанные&rdquo; члена (типа &lsquo;<samp>x*p</samp>&rsquo;-&gt;x*d/dx) исключаются. Например, в 2D случае это функции типа <em>ham = f(p,z) + g(x,z,u)</em>. При этом допускаются коммутирующие комбинации (типа &lsquo;<samp>x*q</samp>&rsquo;-&gt;x*d/dy). Переменная &lsquo;<samp>u</samp>&rsquo; используется для обозначения амплитуды поля |u|. Это позволяет решать нелинейные задачи &ndash; например, нелинейное уравнение Шредингера <code>ham='p^2+q^2-u^2'</code>. Также можно указать мнимую часть для поглощения (типа <code>ham = 'p^2+i*x*(x&gt;0)'</code>). См. также <a href="#apde">apde</a>, <a href="#qo2d">qo2d</a>, <a href="#qo3d">qo3d</a>. См. раздел <a href="#PDE-solving-hints">PDE solving hints</a>, для примеров кода и графика.
</p></dd></dl>

<a name="apde"></a><dl>
<dt><a name="index-apde"></a>Команда MGL: <em></em> <strong>apde</strong> <em><small>RES</small> 'ham' ini_re ini_im [<code>dz=0.1 k0=100</code>]</em></dt>
<dt><a name="index-mglAPDE"></a>Общая функция: <em><code>mglData</code></em> <strong>mglAPDE</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>mreal</code> dz=<code>0.1</code>, <code>mreal</code> k0=<code>100</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mglAPDEc"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglAPDEc</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>mreal</code> dz=<code>0.1</code>, <code>mreal</code> k0=<code>100</code>, <code>const char *</code>opt=<code>&quot;&quot;</code>)</em></dt>
<dt><a name="index-mgl_005fpde_005fsolve_005fadv"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_pde_solve_adv</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>mreal</code> dz, <code>mreal</code> k0, <code>const char *</code>opt)</em></dt>
<dt><a name="index-mgl_005fpde_005fsolve_005fadv_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_pde_solve_adv_c</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>mreal</code> dz, <code>mreal</code> k0, <code>const char *</code>opt)</em></dt>
<dd><p>Решает уравнение в частных производных du/dz = i*k0*<var>ham</var>(p,q,x,y,z,|u|)[u], где p=-i/k0*d/dx, q=-i/k0*d/dy &ndash; псевдо-дифференциальные операторы. Параметры <var>ini_re</var>, <var>ini_im</var> задают начальное распределение поля. Координаты в уравнении и в решении полагаются в диапазоне осей координат. Замечу, что внутри этот диапазон увеличивается в 3/2 раза для уменьшения отражения от границ расчетного интервала. Параметр <var>dz</var> задает шаг по эволюционной координате z. Используется достаточно сложный и медленный алгоритм, способный учесть одновременное влияние пространственной дисперсии и неоднородности среды [см. А.А. Балакин, Е.Д. Господчиков, А.Г. Шалашов, Письма ЖЭТФ 104, 701 (2016)]. Переменная &lsquo;<samp>u</samp>&rsquo; используется для обозначения амплитуды поля |u|. Это позволяет решать нелинейные задачи &ndash; например, нелинейное уравнение Шредингера <code>ham='p^2+q^2-u^2'</code>. Также можно указать мнимую часть для поглощения (типа <code>ham = 'p^2+i*x*(x&gt;0)'</code>).  См. также <a href="#apde">apde</a>. См. раздел <a href="#PDE-solving-hints">PDE solving hints</a>, для примеров кода и графика.
</p></dd></dl>

<a name="ray"></a><dl>
<dt><a name="index-ray"></a>Команда MGL: <em></em> <strong>ray</strong> <em><small>RES</small> 'ham' <code>x0 y0 z0 p0 q0 v0 [dt=0.1 tmax=10]</code></em></dt>
<dt><a name="index-mglRay"></a>Общая функция: <em><code>mglData</code></em> <strong>mglRay</strong> <em>(<code>const char *</code>ham, <code>mglPoint</code> r0, <code>mglPoint</code> p0, <code>mreal</code> dt=<code>0.1</code>, <code>mreal</code> tmax=<code>10</code>)</em></dt>
<dt><a name="index-mgl_005fray_005ftrace"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_ray_trace</strong> <em>(<code>const char *</code>ham, <code>mreal</code> x0, <code>mreal</code> y0, <code>mreal</code> z0, <code>mreal</code> px, <code>mreal</code> py, <code>mreal</code> pz, <code>mreal</code> dt, <code>mreal</code> tmax)</em></dt>
<dd><p>Решает систему геометрооптических уравнений d<em>r</em>/dt = d <var>ham</var>/d<em>p</em>, d<em>p</em>/dt = -d <var>ham</var>/d<em>r</em>. Это гамильтоновы уравнения для траектории частицы в 3D случае. Гамильтониан <var>ham</var> может зависеть от координат &lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>y</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo;, импульсов &lsquo;<samp>p</samp>&rsquo;=px, &lsquo;<samp>q</samp>&rsquo;=py, &lsquo;<samp>v</samp>&rsquo;=pz и времени &lsquo;<samp>t</samp>&rsquo;: <em>ham = H(x,y,z,p,q,v,t)</em>. Начальная точка (при <code>t=0</code>) задается переменными {<var>x0</var>, <var>y0</var>, <var>z0</var>, <var>p0</var>, <var>q0</var>, <var>v0</var>}. Параметры <var>dt</var> и <var>tmax</var> задают шаг и максимальное время интегрирования. Результат &ndash; массив {x,y,z,p,q,v,t} с размером {7 * int(<var>tmax</var>/<var>dt</var>+1) }.
</p></dd></dl>

<a name="ode"></a><dl>
<dt><a name="index-ode"></a>Команда MGL: <em></em> <strong>ode</strong> <em><small>RES</small> 'df' 'var' ini [<code>dt=0.1 tmax=10</code>]</em></dt>
<dt><a name="index-mglODE"></a>Общая функция: <em><code>mglData</code></em> <strong>mglODE</strong> <em>(<code>const char *</code>df, <code>const char *</code>var, <code>const mglDataA &amp;</code>ini, <code>mreal</code> dt=<code>0.1</code>, <code>mreal</code> tmax=<code>10</code>)</em></dt>
<dt><a name="index-mglODEc"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglODEc</strong> <em>(<code>const char *</code>df, <code>const char *</code>var, <code>const mglDataA &amp;</code>ini, <code>mreal</code> dt=<code>0.1</code>, <code>mreal</code> tmax=<code>10</code>)</em></dt>
<dt><a name="index-mgl_005fode_005fsolve_005fstr"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_ode_solve_str</strong> <em>(<code>const char *</code>df, <code>const char *</code>var, <code>HCDT</code> ini, <code>mreal</code> dt, <code>mreal</code> tmax)</em></dt>
<dt><a name="index-mgl_005fode_005fsolve_005fstr_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_ode_solve_str_c</strong> <em>(<code>const char *</code>df, <code>const char *</code>var, <code>HCDT</code> ini, <code>mreal</code> dt, <code>mreal</code> tmax)</em></dt>
<dt><a name="index-mgl_005fode_005fsolve"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_ode_solve</strong> <em>(<code>void (*</code>df<code>)(const mreal *x, mreal *dx, void *par)</code>, <code>int</code> n, <code>const mreal *</code>ini, <code>mreal</code> dt, <code>mreal</code> tmax)</em></dt>
<dt><a name="index-mgl_005fode_005fsolve_005fex"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_ode_solve_ex</strong> <em>(<code>void (*</code>df<code>)(const mreal *x, mreal *dx, void *par)</code>, <code>int</code> n, <code>const mreal *</code>ini, <code>mreal</code> dt, <code>mreal</code> tmax, <code>void (*</code>bord<code>)(mreal *x, const mreal *xprev, void *par)</code>)</em></dt>
<dd><p>Решает систему обыкновенных дифференциальных уравнений dx/dt = df(x). Функции <var>df</var> могут быть заданны строкой с разделенными &rsquo;;&rsquo; формулами (аргумент <var>var</var> задает символы для переменных x[i]) или указателем на функцию, которая заполняет <code>dx</code> по заданным значениям <code>x</code>. Параметры <var>ini</var>, <var>dt</var>, <var>tmax</var> задают начальные значения, шаг и максимальное время интегрирования. Функция обрывает расчет при появлении значений <code>NAN</code> или <code>INF</code>. Результат &ndash; массив размером {<var>n</var> * <var>Nt</var>}, где <var>Nt</var> &lt;= int(<var>tmax</var>/<var>dt</var>+1).
</p></dd></dl>

<a name="qo2d"></a><dl>
<dt><a name="index-qo2d"></a>Команда MGL: <em></em> <strong>qo2d</strong> <em><small>RES</small> 'ham' ini_re ini_im ray [<code>r=1 k0=100</code> xx yy]</em></dt>
<dt><a name="index-mglQO2d"></a>Общая функция: <em><code>mglData</code></em> <strong>mglQO2d</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>, <code>mglData *</code>xx=<code>0</code>, <code>mglData *</code>yy=<code>0</code>)</em></dt>
<dt><a name="index-mglQO2d-1"></a>Общая функция: <em><code>mglData</code></em> <strong>mglQO2d</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mglData &amp;</code>xx, <code>mglData &amp;</code>yy, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mglQO2dc"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglQO2dc</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mglQO2dc-1"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglQO2dc</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mglData &amp;</code>xx, <code>mglData &amp;</code>yy, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mgl_005fqo2d_005fsolve"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_qo2d_solve</strong> <em>(<code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy)</em></dt>
<dt><a name="index-mgl_005fqo2d_005fsolve_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_qo2d_solve_c</strong> <em>(<code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy)</em></dt>
<dt><a name="index-mgl_005fqo2d_005ffunc"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_qo2d_func</strong> <em>(<code>dual (*</code>ham<code>)(mreal u, mreal x, mreal y, mreal px, mreal py, void *par)</code>, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy)</em></dt>
<dt><a name="index-mgl_005fqo2d_005ffunc_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_qo2d_func_c</strong> <em>(<code>dual (*</code>ham<code>)(mreal u, mreal x, mreal y, mreal px, mreal py, void *par)</code>, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy)</em></dt>
<dd><p>Решает уравнение в частных производных du/dt = i*k0*<var>ham</var>(p,q,x,y,|u|)[u] в сопровождающей системе координат, где p=-i/k0*d/dx, q=-i/k0*d/dy &ndash; псевдо-дифференциальные операторы. Параметры <var>ini_re</var>, <var>ini_im</var> задают начальное распределение поля. Параметр <var>ray</var> задает опорный луч для сопровождающей системы координат. Можно использовать луч найденный с помощью <a href="#ray">ray</a>. Опорный луч должен быть достаточно гладкий, чтобы система координат была однозначной и для исключения ошибок интегрирования. Если массивы <var>xx</var> и <var>yy</var> указаны, то в них записываются декартовы координаты для каждой точки найденного решения. См. также <a href="#pde">pde</a>, <a href="#qo3d">qo3d</a>. См. раздел <a href="#PDE-solving-hints">PDE solving hints</a>, для примеров кода и графика.
</p></dd></dl>

<a name="qo3d"></a><dl>
<dt><a name="index-qo3d"></a>Команда MGL: <em></em> <strong>qo3d</strong> <em><small>RES</small> 'ham' ini_re ini_im ray [<code>r=1 k0=100</code> xx yy zz]</em></dt>
<dt><a name="index-mglQO3d"></a>Общая функция: <em><code>mglData</code></em> <strong>mglQO3d</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mglQO3d-1"></a>Общая функция: <em><code>mglData</code></em> <strong>mglQO3d</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mglData &amp;</code>xx, <code>mglData &amp;</code>yy, <code>mglData &amp;</code>zz, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mglQO3dc"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglQO3dc</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mglQO3dc-1"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglQO3dc</strong> <em>(<code>const char *</code>ham, <code>const mglDataA &amp;</code>ini_re, <code>const mglDataA &amp;</code>ini_im, <code>const mglDataA &amp;</code>ray, <code>mglData &amp;</code>xx, <code>mglData &amp;</code>yy, <code>mglData &amp;</code>zz, <code>mreal</code> r=<code>1</code>, <code>mreal</code> k0=<code>100</code>)</em></dt>
<dt><a name="index-mgl_005fqo3d_005fsolve"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_qo3d_solve</strong> <em>(<code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy, <code>HMDT</code> zz)</em></dt>
<dt><a name="index-mgl_005fqo3d_005fsolve_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_qo3d_solve_c</strong> <em>(<code>const char *</code>ham, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy, <code>HMDT</code> zz)</em></dt>
<dt><a name="index-mgl_005fqo3d_005ffunc"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_qo3d_func</strong> <em>(<code>dual (*</code>ham<code>)(mreal u, mreal x, mreal y, mreal z, mreal px, mreal py, mreal pz, void *par)</code>, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy, <code>HMDT</code> zz)</em></dt>
<dt><a name="index-mgl_005fqo3d_005ffunc_005fc"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_qo3d_func_c</strong> <em>(<code>dual (*</code>ham<code>)(mreal u, mreal x, mreal y, mreal z, mreal px, mreal py, mreal pz, void *par)</code>, <code>HCDT</code> ini_re, <code>HCDT</code> ini_im, <code>HCDT</code> ray, <code>mreal</code> r, <code>mreal</code> k0, <code>HMDT</code> xx, <code>HMDT</code> yy, <code>HMDT</code> zz)</em></dt>
<dd><p>Решает уравнение в частных производных du/dt = i*k0*<var>ham</var>(p,q,v,x,y,z,|u|)[u] в сопровождающей системе координат, где p=-i/k0*d/dx, q=-i/k0*d/dy, v=-i/k0*d/dz &ndash; псевдо-дифференциальные операторы. Параметры <var>ini_re</var>, <var>ini_im</var> задают начальное распределение поля. Параметр <var>ray</var> задает опорный луч для сопровождающей системы координат. Можно использовать луч найденный с помощью <a href="#ray">ray</a>. Опорный луч должен быть достаточно гладкий, чтобы система координат была однозначной и для исключения ошибок интегрирования. Если массивы <var>xx</var>, <var>yy</var> и <var>zz</var> указаны, то в них записываются декартовы координаты для каждой точки найденного решения. См. также <a href="#pde">pde</a>, <a href="#qo2d">qo2d</a>.
</p></dd></dl>

<a name="jacobian"></a><dl>
<dt><a name="index-jacobian"></a>Команда MGL: <em></em> <strong>jacobian</strong> <em><small>RES</small> xdat ydat [zdat]</em></dt>
<dt><a name="index-mglJacobian"></a>Общая функция: <em><code>mglData</code></em> <strong>mglJacobian</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-mglJacobian-1"></a>Общая функция: <em><code>mglData</code></em> <strong>mglJacobian</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z)</em></dt>
<dt><a name="index-mgl_005fjacobian_005f2d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_jacobian_2d</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y)</em></dt>
<dt><a name="index-mgl_005fjacobian_005f3d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_jacobian_3d</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z)</em></dt>
<dd><p>Вычисляет якобиан преобразования {i,j,k} в {<var>x</var>,<var>y</var>,<var>z</var>}, где координаты {i,j,k} полагаются нормированными в интервал [0,1]. Якобиан находится по формуле det||<em>dr_\alpha/d\xi_\beta</em>||, где <em>r</em>={<var>x</var>,<var>y</var>,<var>z</var>} и <em>\xi</em>={i,j,k}. Все размерности всех массивов должны быть одинаковы. Данные должны быть трехмерными если указаны все 3 массива {<var>x</var>,<var>y</var>,<var>z</var>} или двумерными если только 2 массива {<var>x</var>,<var>y</var>}.
</p></dd></dl>

<a name="triangulation"></a><dl>
<dt><a name="index-triangulation"></a>Команда MGL: <em></em> <strong>triangulation</strong> <em><small>RES</small> xdat ydat [zdat]</em></dt>
<dt><a name="index-mglTriangulation-1"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTriangulation</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-mglTriangulation-2"></a>Общая функция: <em><code>mglData</code></em> <strong>mglTriangulation</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y, <code>const mglDataA &amp;</code>z)</em></dt>
<dt><a name="index-mgl_005ftriangulation_005f2d-1"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_triangulation_2d</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y)</em></dt>
<dt><a name="index-mgl_005ftriangulation_005f3d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_triangulation_3d</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y, <code>HCDT</code> z)</em></dt>
<dd><p>Выполняет триангуляцию для произвольно расположенных точек с координатами {<var>x</var>,<var>y</var>,<var>z</var>} (т.е. находит треугольники, соединяющие точки). Первая размерность всех массивов должна быть одинакова <code>x.nx=y.nx=z.nx</code>. Получившийся массив можно использовать в <a href="#triplot">triplot</a> или <a href="#tricont">tricont</a> для визуализации реконструированной поверхности. См. раздел <a href="#Making-regular-data">Making regular data</a>, для примеров кода и графика.
</p></dd></dl>



<dl>
<dt><a name="index-mglGSplineInit"></a>Общая функция: <em><code>mglData</code></em> <strong>mglGSplineInit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-mglGSplineCInit"></a>Общая функция: <em><code>mglDataC</code></em> <strong>mglGSplineCInit</strong> <em>(<code>const mglDataA &amp;</code>x, <code>const mglDataA &amp;</code>y)</em></dt>
<dt><a name="index-mgl_005fgspline_005finit"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_gspline_init</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y)</em></dt>
<dt><a name="index-mgl_005fgsplinec_005finit"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_gsplinec_init</strong> <em>(<code>HCDT</code> x, <code>HCDT</code> y)</em></dt>
<dd><p>Подготавливает коэффициенты для глобального кубического сплайна.
</p></dd></dl>

<dl>
<dt><a name="index-mglGSpline"></a>Общая функция: <em><code>mreal</code></em> <strong>mglGSpline</strong> <em>(<code>const mglDataA &amp;</code>coef, <code>mreal</code> dx, <code>mreal *</code>d1=<code>0</code>, <code>mreal *</code>d2=<code>0</code>)</em></dt>
<dt><a name="index-mglGSplineC"></a>Общая функция: <em><code>dual</code></em> <strong>mglGSplineC</strong> <em>(<code>const mglDataA &amp;</code>coef, <code>mreal</code> dx, <code>dual *</code>d1=<code>0</code>, <code>dual *</code>d2=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fgspline"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_gspline</strong> <em>(<code>HCDT</code> coef, <code>mreal</code> dx, <code>mreal *</code>d1, <code>mreal *</code>d2)</em></dt>
<dt><a name="index-mgl_005fgsplinec"></a>Функция С: <em><code>dual</code></em> <strong>mgl_gsplinec</strong> <em>(<code>HCDT</code> coef, <code>mreal</code> dx, <code>dual *</code>d1, <code>dual *</code>d2)</em></dt>
<dd><p>Вычисляет глобальный кубический сплайн (а также 1ую и 2ую производные <var>d1</var>, <var>d2</var> если они не <code>NULL</code>), используя коэффициенты <var>coef</var> в точке <var>dx</var>+<var>x0</var> (здесь <var>x0</var> &ndash; 1ый элемент массива <var>x</var> в функции <code>mglGSpline*Init()</code>).
</p></dd></dl>


<a name="ifs2d"></a><dl>
<dt><a name="index-ifs2d"></a>Команда MGL: <em></em> <strong>ifs2d</strong> <em><small>RES</small> dat <code>num</code> [<code>skip=20</code>]</em></dt>
<dt><a name="index-mglIFS2d"></a>Общая функция: <em><code>mglData</code></em> <strong>mglIFS2d</strong> <em>(<code>const mglDataA &amp;</code>dat, <code>long</code> num, <code>long</code> skip=<code>20</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fifs_005f2d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_ifs_2d</strong> <em>(<code>HCDT</code> dat, <code>long</code> num, <code>long</code> skip)</em></dt>
<dd><p>Находит <var>num</var> точек {x[i]=res[0,i], y[i]=res[1,i]} фрактала с использованием итерационной системы функций (IFS). Матрица <var>dat</var> используется для генерации в соответствии с формулами
</p><pre class="verbatim">x[i+1] = dat[0,i]*x[i] + dat[1,i]*y[i] + dat[4,i];
y[i+1] = dat[2,i]*x[i] + dat[3,i]*y[i] + dat[5,i];
</pre><p>Значение <code>dat[6,i]</code> &ndash; весовой коэффициент для i-ой строки матрицы <var>dat</var>. Первые <var>skip</var> итераций будут опущены. Массив <var>dat</var> должен иметь размер по x больше или равный 7. См. также <a href="#ifs3d">ifs3d</a>, <a href="#flame2d">flame2d</a>. См. раздел <a href="#ifs2d-sample">ifs2d sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="ifs3d"></a><dl>
<dt><a name="index-ifs3d"></a>Команда MGL: <em></em> <strong>ifs3d</strong> <em><small>RES</small> dat <code>num</code> [<code>skip=20</code>]</em></dt>
<dt><a name="index-mglIFS3d"></a>Общая функция: <em><code>mglData</code></em> <strong>mglIFS3d</strong> <em>(<code>const mglDataA &amp;</code>dat, <code>long</code> num, <code>long</code> skip=<code>20</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fifs_005f3d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_ifs_3d</strong> <em>(<code>HCDT</code> dat, <code>long</code> num, <code>long</code> skip)</em></dt>
<dd><p>Находит <var>num</var> точек {x[i]=res[0,i], y[i]=res[1,i], z[i]=res[2,i]} фрактала с использованием итерационной системы функций (IFS). Матрица <var>dat</var> используется для генерации в соответствии с формулами
</p><pre class="verbatim">x[i+1] = dat[0,i]*x[i] + dat[1,i]*y[i] + dat[2,i]*z[i] + dat[9,i];
y[i+1] = dat[3,i]*x[i] + dat[4,i]*y[i] + dat[5,i]*z[i] + dat[10,i];
z[i+1] = dat[6,i]*x[i] + dat[7,i]*y[i] + dat[8,i]*z[i] + dat[11,i];
</pre><p>Значение <code>dat[12,i]</code> &ndash; весовой коэффициент для i-ой строки матрицы <var>dat</var>. Первые <var>skip</var> итераций будут опущены. Массив <var>dat</var> должен иметь размер по x больше или равный 13. См. также <a href="#ifs2d">ifs2d</a>. См. раздел <a href="#ifs3d-sample">ifs3d sample</a>, для примеров кода и графика.
</p></dd></dl>

<a name="ifsfile"></a><dl>
<dt><a name="index-ifsfile"></a>Команда MGL: <em></em> <strong>ifsfile</strong> <em><small>RES</small> 'fname' 'name' <code>num</code> [<code>skip=20</code>]</em></dt>
<dt><a name="index-mglIFSfile"></a>Общая функция: <em><code>mglData</code></em> <strong>mglIFSfile</strong> <em>(<code>const char *</code>fname, <code>const char *</code>name, <code>long</code> num, <code>long</code> skip=<code>20</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fifs_005ffile"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_ifs_file</strong> <em>(<code>const char *</code>fname, <code>const char *</code>name, <code>long</code> num, <code>long</code> skip)</em></dt>
<dd><p>Считывает параметры фрактала <var>name</var> из файла <var>fname</var> и находит <var>num</var> точек для него. Первые <var>skip</var> итераций будут опущены. См. также <a href="#ifs2d">ifs2d</a>, <a href="#ifs3d">ifs3d</a>.
</p>
<p>Файл IFS может содержать несколько записей. Каждая запись содержит имя фрактала (&lsquo;<samp>binary</samp>&rsquo; в примере ниже) и тело в фигурных скобках {} с параметрами фрактала. Символ &lsquo;<samp>;</samp>&rsquo; начинает комментарий. Если имя содержит &lsquo;<samp>(3D)</samp>&rsquo; или &lsquo;<samp>(3d)</samp>&rsquo;, то определен 3d IFS фрактал. Пример содержит два фрактала: &lsquo;<samp>binary</samp>&rsquo; &ndash; обычный 2d фрактал, и &lsquo;<samp>3dfern (3D)</samp>&rsquo; &ndash; 3d фрактал. См. также <a href="#ifs2d">ifs2d</a>, <a href="#ifs3d">ifs3d</a>.
</p>
<pre class="verbatim"> binary
 { ; comment allowed here
  ; and here
  .5  .0 .0 .5 -2.563477 -0.000003 .333333   ; also comment allowed here
  .5  .0 .0 .5  2.436544 -0.000003 .333333
  .0 -.5 .5 .0  4.873085  7.563492 .333333
  }

 3dfern (3D) {
   .00  .00 0 .0 .18 .0 0  0.0 0.00 0 0.0 0 .01
   .85  .00 0 .0 .85 .1 0 -0.1 0.85 0 1.6 0 .85
   .20 -.20 0 .2 .20 .0 0  0.0 0.30 0 0.8 0 .07
  -.20  .20 0 .2 .20 .0 0  0.0 0.30 0 0.8 0 .07
  }
</pre></dd></dl>

<a name="flame2d"></a><dl>
<dt><a name="index-flame2d"></a>Команда MGL: <em></em> <strong>flame2d</strong> <em><small>RES</small> dat func <code>num</code> [<code>skip=20</code>]</em></dt>
<dt><a name="index-mglFlame2d"></a>Общая функция: <em><code>mglData</code></em> <strong>mglFlame2d</strong> <em>(<code>const mglDataA &amp;</code>dat, <code>const mglDataA &amp;</code>func, <code>long</code> num, <code>long</code> skip=<code>20</code>)</em></dt>
<dt><a name="index-mgl_005fdata_005fflame_005f2d"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_data_flame_2d</strong> <em>(<code>HCDT</code> dat, <code>HCDT</code> func, <code>long</code> num, <code>long</code> skip)</em></dt>
<dd><p>Находит <var>num</var> точек {x[i]=res[0,i], y[i]=res[1,i]} фрактала с использованием итерационной системы функций (IFS). Массив <var>func</var> задает идентификатор функции (<var>func</var>[0,i,j]), ее вес (<var>func</var>[0,i,j]) и аргументы (<var>func</var>[2 ... 5,i,j]). Матрица <var>dat</var> используется для преобразования координат для аргументов функции. Результирующее преобразование имеет вид:
</p><pre class="verbatim">xx = dat[0,i]*x[j] + dat[1,j]*y[i] + dat[4,j];
yy = dat[2,i]*x[j] + dat[3,j]*y[i] + dat[5,j];
x[j+1] = sum_i @var{func}[1,i,j]*@var{func}[0,i,j]_x(xx, yy; @var{func}[2,i,j],...,@var{func}[5,i,j]);
y[j+1] = sum_i @var{func}[1,i,j]*@var{func}[0,i,j]_y(xx, yy; @var{func}[2,i,j],...,@var{func}[5,i,j]);
</pre><p>Значение <code>dat[6,i]</code> &ndash; весовой коэффициент для i-ой строки матрицы <var>dat</var>. Первые <var>skip</var> итераций будут опущены. Массив <var>dat</var> должен иметь размер по x больше или равный 7.
Доступные идентификаторы функций: <code>mglFlame2d_linear=0,	mglFlame2d_sinusoidal,	mglFlame2d_spherical,	mglFlame2d_swirl,		mglFlame2d_horseshoe,
	mglFlame2d_polar,		mglFlame2d_handkerchief,mglFlame2d_heart,		mglFlame2d_disc,		mglFlame2d_spiral,
	mglFlame2d_hyperbolic,	mglFlame2d_diamond,		mglFlame2d_ex,			mglFlame2d_julia,		mglFlame2d_bent,
	mglFlame2d_waves,		mglFlame2d_fisheye,		mglFlame2d_popcorn,		mglFlame2d_exponential,	mglFlame2d_power,
	mglFlame2d_cosine,		mglFlame2d_rings,		mglFlame2d_fan,			mglFlame2d_blob,		mglFlame2d_pdj,
	mglFlame2d_fan2,		mglFlame2d_rings2,		mglFlame2d_eyefish,		mglFlame2d_bubble,		mglFlame2d_cylinder,
	mglFlame2d_perspective,	mglFlame2d_noise,		mglFlame2d_juliaN,		mglFlame2d_juliaScope,	mglFlame2d_blur,
	mglFlame2d_gaussian,	mglFlame2d_radialBlur,	mglFlame2d_pie,			mglFlame2d_ngon,		mglFlame2d_curl,
	mglFlame2d_rectangles,	mglFlame2d_arch,		mglFlame2d_tangent,		mglFlame2d_square,		mglFlame2d_blade,
	mglFlame2d_secant,		mglFlame2d_rays,		mglFlame2d_twintrian,	mglFlame2d_cross,		mglFlame2d_disc2,
	mglFlame2d_supershape,	mglFlame2d_flower,		mglFlame2d_conic,		mglFlame2d_parabola,	mglFlame2d_bent2,
	mglFlame2d_bipolar,		mglFlame2d_boarders,	mglFlame2d_butterfly,	mglFlame2d_cell,		mglFlame2d_cpow,
	mglFlame2d_curve,		mglFlame2d_edisc,		mglFlame2d_elliptic,	mglFlame2d_escher,		mglFlame2d_foci,
	mglFlame2d_lazySusan,	mglFlame2d_loonie,		mglFlame2d_preBlur,		mglFlame2d_modulus,		mglFlame2d_oscope,
	mglFlame2d_polar2,		mglFlame2d_popcorn2,	mglFlame2d_scry,		mglFlame2d_separation,	mglFlame2d_split,
	mglFlame2d_splits,		mglFlame2d_stripes,		mglFlame2d_wedge,		mglFlame2d_wedgeJulia,	mglFlame2d_wedgeSph,
	mglFlame2d_whorl,		mglFlame2d_waves2,		mglFlame2d_exp,			mglFlame2d_log,			mglFlame2d_sin,
	mglFlame2d_cos,			mglFlame2d_tan,			mglFlame2d_sec,			mglFlame2d_csc,			mglFlame2d_cot,
	mglFlame2d_sinh,		mglFlame2d_cosh,		mglFlame2d_tanh,		mglFlame2d_sech,		mglFlame2d_csch,
	mglFlame2d_coth,		mglFlame2d_auger,		mglFlame2d_flux.</code>
Значение <code>dat[6,i]</code> &ndash; весовой коэффициент для i-ой строки матрицы <var>dat</var>. Первые <var>skip</var> итераций будут опущены. Размеры массивов должны удовлетворять требованиям: <var>dat</var>.nx&gt;=7, <var>func</var>.nx&gt;=2 и <var>func</var>.nz=<var>dat</var>.ny. См. также <a href="#ifs2d">ifs2d</a>, <a href="#ifs3d">ifs3d</a>. См. раздел <a href="#flame2d-sample">flame2d sample</a>, для примеров кода и графика.
</p></dd></dl>




<hr>
<a name="Evaluate-expression"></a>
<div class="header">
<p>
Next: <a href="#Special-data-classes" accesskey="n" rel="next">Special data classes</a>, Previous: <a href="#Global-functions" accesskey="p" rel="prev">Global functions</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Vychislenie-vyrazhenii"></a>
<h3 class="section">6.12 Вычисление выражений</h3>



<p>В MathGL есть специальные классы <code>mglExpr</code> и <code>mglExprC</code> для вычисления формул заданных строкой для действительных и комплексных чисел соответственно. Классы определены в <code>#include &lt;mgl2/data.h&gt;</code> и <code>#include &lt;mgl2/datac.h&gt;</code> соответственно. При создании класса происходит разбор формулы в древовидную структуру. А при вычислении только выполняется достаточно быстрый обход по дереву. В данный момент нет различия между верхним и нижним регистром. Если аргумент какой-либо функции лежит вне её области определения, то возвращается NaN. See <a href="#Textual-formulas">Textual formulas</a>.
</p>
<dl>
<dt><a name="index-mglExpr"></a>Конструктор класса <code>mglExpr</code>: <em><code></code></em> <strong>mglExpr</strong> <em>(<code>const char *</code>expr)</em></dt>
<dt><a name="index-mglExprC"></a>Конструктор класса <code>mglExprC</code>: <em><code></code></em> <strong>mglExprC</strong> <em>(<code>const char *</code>expr)</em></dt>
<dt><a name="index-mgl_005fcreate_005fexpr"></a>Функция С: <em><code>HMEX</code></em> <strong>mgl_create_expr</strong> <em>(<code>const char *</code>expr)</em></dt>
<dt><a name="index-mgl_005fcreate_005fcexpr"></a>Функция С: <em><code>HAEX</code></em> <strong>mgl_create_cexpr</strong> <em>(<code>const char *</code>expr)</em></dt>
<dd><p>Разбирает формулу <var>expr</var> и создает древовидную структуру, содержащую последовательность вызова функций и операторов для последующего быстрого вычисления формулы с помощью функций <code>Calc()</code> и/или <code>CalcD()</code>.
</p></dd></dl>

<dl>
<dt><a name="index-_007emglExpr"></a>Destructor on <code>mglExpr</code>: <em><code></code></em> <strong>~mglExpr</strong> <em>()</em></dt>
<dt><a name="index-_007emglExprC"></a>Destructor on <code>mglExprC</code>: <em><code></code></em> <strong>~mglExprC</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdelete_005fexpr"></a>Функция С: <em><code>void</code></em> <strong>mgl_delete_expr</strong> <em>(<code>HMEX</code> ex)</em></dt>
<dt><a name="index-mgl_005fdelete_005fcexpr"></a>Функция С: <em><code>void</code></em> <strong>mgl_delete_cexpr</strong> <em>(<code>HAEX</code> ex)</em></dt>
<dd><p>Удаляет объект типа <code>mglExpr</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Eval"></a>Метод класса <code>mglExpr</code>: <em><code>mreal</code></em> <strong>Eval</strong> <em>(<code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-Eval-1"></a>Метод класса <code>mglExprC</code>: <em><code>dual</code></em> <strong>Eval</strong> <em>(<code>dual</code> x, <code>dual</code> y, <code>dual</code> z)</em></dt>
<dt><a name="index-mgl_005fexpr_005feval"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_expr_eval</strong> <em>(<code>HMEX</code> ex, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-mgl_005fcexpr_005feval"></a>Функция С: <em><code>dual</code></em> <strong>mgl_cexpr_eval</strong> <em>(<code>HAEX</code> ex, <code>dual</code> x, <code>dual</code> y, <code>dual</code> z)</em></dt>
<dd><p>Вычисляет значение формулы для <code>'x','r'</code>=<var>x</var>, <code>'y','n'</code>=<var>y</var>, <code>'z','t'</code>=<var>z</var>, <code>'a','u'</code>=<var>u</var>.
</p></dd></dl>

<dl>
<dt><a name="index-Eval-2"></a>Метод класса <code>mglExpr</code>: <em><code>mreal</code></em> <strong>Eval</strong> <em>(<code>mreal</code> var[26])</em></dt>
<dt><a name="index-Eval-3"></a>Метод класса <code>mglExprC</code>: <em><code>dual</code></em> <strong>Eval</strong> <em>(<code>dual</code> var[26])</em></dt>
<dt><a name="index-mgl_005fexpr_005feval_005fv"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_expr_eval_v</strong> <em>(<code>HMEX</code> ex, <code>mreal *</code>var)</em></dt>
<dt><a name="index-mgl_005fcexpr_005feval_005fv"></a>Функция С: <em><code>dual</code></em> <strong>mgl_cexpr_eval_v</strong> <em>(<code>HMEX</code> ex, <code>dual *</code>var)</em></dt>
<dd><p>Вычисляет значение формулы для переменных в массиве <var>var</var>[0,...,&rsquo;z&rsquo;-&rsquo;a&rsquo;].
</p></dd></dl>


<dl>
<dt><a name="index-Diff-9"></a>Метод класса <code>mglExpr</code>: <em><code>mreal</code></em> <strong>Diff</strong> <em>(<code>char</code> dir, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dt><a name="index-mgl_005fexpr_005fdiff"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_expr_diff</strong> <em>(<code>HMEX</code> ex, <code>char</code> dir, <code>mreal</code> x, <code>mreal</code> y, <code>mreal</code> z)</em></dt>
<dd><p>Вычисляет производную от формулы по переменной <var>dir</var> для <code>'x','r'</code>=<var>x</var>, <code>'y','n'</code>=<var>y</var>, <code>'z','t'</code>=<var>z</var>, <code>'a','u'</code>=<var>u</var>.
</p></dd></dl>

<dl>
<dt><a name="index-Diff-10"></a>Метод класса <code>mglExpr</code>: <em><code>mreal</code></em> <strong>Diff</strong> <em>(<code>char</code> dir, <code>mreal</code> var[26])</em></dt>
<dt><a name="index-mgl_005fexpr_005fdiff_005fv"></a>Функция С: <em><code>mreal</code></em> <strong>mgl_expr_diff_v</strong> <em>(<code>HMEX</code> ex, <code>char</code> dir, <code>mreal *</code>var)</em></dt>
<dd><p>Вычисляет производную от формулы по переменной <var>dir</var> для переменных в массиве <var>var</var>[0,...,&rsquo;z&rsquo;-&rsquo;a&rsquo;].
</p></dd></dl>



<hr>
<a name="Special-data-classes"></a>
<div class="header">
<p>
Previous: <a href="#Evaluate-expression" accesskey="p" rel="prev">Evaluate expression</a>, Up: <a href="#Data-processing" accesskey="u" rel="up">Data processing</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Special-data-classes-1"></a>
<h3 class="section">6.13 Special data classes</h3>



<p>Раздел описывает специальные классы данных <code>mglDataV</code>, <code>mglDataF</code>, <code>mglDataT</code> и <code>mglDataR</code>, которые могут заметно ускорить рисование и обработку данных. Классы определены в <code>#include &lt;mgl2/data.h&gt;</code>. Отмечу, что все функции рисования и обработки данных можно выполнить используя только основные классы <code>mglData</code> и/или <code>mglDataC</code>. Также специальные классы доступны только в коде на С++.
</p>
<a name="Klass-mglDataV"></a>
<h3 class="heading">Класс <code>mglDataV</code></h3>
<p>представляет переменную со значениями равнораспределенными в заданном интервале.
</p><dl>
<dt><a name="index-mglDataV"></a>Конструктор <code>mglDataV</code>: <em><code></code></em> <strong>mglDataV</strong> <em>(<code>const mglDataV &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataV-1"></a>Конструктор <code>mglDataV</code>: <em><code></code></em> <strong>mglDataV</strong> <em>(<code>long</code> nx=<code>1</code>, <code>long</code> ny=<code>1</code>, <code>long</code> nz=<code>1</code>, <code>mreal</code> v1=<code>0</code>, <code>mreal</code> v2=<code>NaN</code>, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dd><p>Создает переменную &quot;размером&quot; <var>nx</var>x<var>ny</var>x<var>nz</var>, изменяющуюся от <var>v1</var> до <var>v2</var> (или постоянную при <var>v2</var>=<code>NaN</code>) вдоль направления <var>dir</var>.
</p></dd></dl>
<dl>
<dt><a name="index-Create-3"></a>Метод класса <code>mglDataV</code>: <em><code>void</code></em> <strong>Create</strong> <em>(<code>long</code> nx=<code>1</code>, <code>long</code> ny=<code>1</code>, <code>long</code> nz=<code>1</code>)</em></dt>
<dd><p>Задает &quot;размеры&quot; переменной <var>nx</var>x<var>ny</var>x<var>nz</var>.
</p></dd></dl>
<dl>
<dt><a name="index-Fill-13"></a>Метод класса <code>mglDataV</code>: <em><code>void</code></em> <strong>Fill</strong> <em>(<code>mreal</code> x1, <code>mreal</code> x2=<code>NaN</code>, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dd><p>Задает диапазон изменения переменной.
</p></dd></dl>
<dl>
<dt><a name="index-Freq"></a>Метод класса <code>mglDataV</code>: <em><code>void</code></em> <strong>Freq</strong> <em>(<code>mreal</code> dp, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dd><p>Задает переменную для частоты с шагом <var>dp</var>.
</p></dd></dl>

<a name="Klass-mglDataF"></a>
<h3 class="heading">Класс <code>mglDataF</code></h3>
<p>представляет функцию, которая будет вызываться вместо обращения к элементам массива (как в классе <code>mglData</code>).
</p><dl>
<dt><a name="index-mglDataF"></a>Конструктор <code>mglDataF</code>: <em><code></code></em> <strong>mglDataF</strong> <em>(<code>const mglDataF &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataF-1"></a>Конструктор <code>mglDataF</code>: <em><code></code></em> <strong>mglDataF</strong> <em>(<code>long</code> nx=<code>1</code>, <code>long</code> ny=<code>1</code>, <code>long</code> nz=<code>1</code>)</em></dt>
<dd><p>Создает данные &quot;размером&quot; <var>nx</var>x<var>ny</var>x<var>nz</var> с нулевой функцией.
</p></dd></dl>
<dl>
<dt><a name="index-Create-4"></a>Метод класса <code>mglDataF</code>: <em><code>void</code></em> <strong>Create</strong> <em>(<code>long</code> nx=<code>1</code>, <code>long</code> ny=<code>1</code>, <code>long</code> nz=<code>1</code>)</em></dt>
<dd><p>Задает &quot;размеры&quot; данных <var>nx</var>x<var>ny</var>x<var>nz</var>.
</p></dd></dl>
<dl>
<dt><a name="index-SetRanges-6"></a>Метод класса <code>mglDataF</code>: <em><code>void</code></em> <strong>SetRanges</strong> <em>(<code>mglPoint</code> p1, <code>mglPoint</code> p2)</em></dt>
<dd><p>Задает диапазоны изменения внутренних переменных x,y,z.
</p></dd></dl>
<dl>
<dt><a name="index-SetFormula"></a>Метод класса <code>mglDataF</code>: <em><code>void</code></em> <strong>SetFormula</strong> <em>(<code>const char *</code>func)</em></dt>
<dd><p>Задает строку, которая будет разобрана в функцию. Это вариант более чем 10 раз медленнее в сравнении с <code>SetFunc</code>().
</p></dd></dl>
<dl>
<dt><a name="index-SetFunc-2"></a>Метод класса <code>mglDataF</code>: <em><code>void</code></em> <strong>SetFunc</strong> <em>(<code>mreal (*</code>f<code>)(mreal x,mreal y,mreal z,void *p)</code>, <code>void *</code>p=<code>NULL</code>)</em></dt>
<dd><p>Задает указатель на функцию, которая будет использована вместо доступа к элементам массива.
</p></dd></dl>

<a name="Klass-mglDataT"></a>
<h3 class="heading">Класс <code>mglDataT</code></h3>
<p>представляет именнованную ссылку на столбец в другом массиве данных.
</p><dl>
<dt><a name="index-mglDataT"></a>Конструктор <code>mglDataT</code>: <em><code></code></em> <strong>mglDataT</strong> <em>(<code>const mglDataT &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataT-1"></a>Конструктор <code>mglDataT</code>: <em><code></code></em> <strong>mglDataT</strong> <em>(<code>const mglDataA &amp;</code> d, <code>long</code> col=<code>0</code>)</em></dt>
<dd><p>Создает ссылку на <var>col</var>-ый столбец данных <var>d</var>.
</p></dd></dl>
<dl>
<dt><a name="index-SetInd"></a>Метод класса <code>mglDataT</code>: <em><code>void</code></em> <strong>SetInd</strong> <em>(<code>long</code> col, <code>wchar_t</code> name)</em></dt>
<dt><a name="index-SetInd-1"></a>Метод класса <code>mglDataT</code>: <em><code>void</code></em> <strong>SetInd</strong> <em>(<code>long</code> col, <code>const wchar_t *</code> name)</em></dt>
<dd><p>Задает ссылку на другой столбец того же массива данных.
</p></dd></dl>


<a name="Klass-mglDataR"></a>
<h3 class="heading">Класс <code>mglDataR</code></h3>
<p>представляет именнованную ссылку на строку в другом массиве данных.
</p><dl>
<dt><a name="index-mglDataR"></a>Конструктор <code>mglDataR</code>: <em><code></code></em> <strong>mglDataR</strong> <em>(<code>const mglDataR &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataR-1"></a>Конструктор <code>mglDataR</code>: <em><code></code></em> <strong>mglDataR</strong> <em>(<code>const mglDataA &amp;</code> d, <code>long</code> row=<code>0</code>)</em></dt>
<dd><p>Создает ссылку на <var>row</var>-ую строку данных <var>d</var>.
</p></dd></dl>
<dl>
<dt><a name="index-SetInd-2"></a>Метод класса <code>mglDataR</code>: <em><code>void</code></em> <strong>SetInd</strong> <em>(<code>long</code> row, <code>wchar_t</code> name)</em></dt>
<dt><a name="index-SetInd-3"></a>Метод класса <code>mglDataR</code>: <em><code>void</code></em> <strong>SetInd</strong> <em>(<code>long</code> row, <code>const wchar_t *</code> name)</em></dt>
<dd><p>Задает ссылку на другой столбец того же массива данных.
</p></dd></dl>


<a name="Class-mglDataW"></a>
<h3 class="heading">Class <code>mglDataW</code></h3>
<p>представляет часоту для FFT в виде массива данных.
</p><dl>
<dt><a name="index-mglDataW"></a>Конструктор <code>mglDataW</code>: <em><code></code></em> <strong>mglDataW</strong> <em>(<code>const mglDataW &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataW-1"></a>Конструктор <code>mglDataW</code>: <em><code></code></em> <strong>mglDataW</strong> <em>(<code>long</code> xx=<code>1</code>, <code>long</code> yy=<code>1</code>, <code>long</code> zz=<code>1</code>, <code>double</code> dp=<code>0</code>, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dd><p>Задает размеры, направление <var>dir</var> и шаг <var>dp</var> для частоты.
</p></dd></dl>
<dl>
<dt><a name="index-Freq-1"></a>Метод класса <code>mglDataR</code>: <em><code>void</code></em> <strong>Freq</strong> <em>(<code>double</code> dp, <code>char</code> dir=<code>'x'</code>)</em></dt>
<dd><p>Равномерно распределяет данные с шагом <var>dp</var> в направлении <var>dir</var>.
</p></dd></dl>


<a name="Class-mglDataS"></a>
<h3 class="heading">Class <code>mglDataS</code></h3>
<p>представляет std::vector в виде массива данных.
</p><dl>
<dt><a name="index-dat-of-mglDataS"></a>Variable of mglDataS: <em><code>std::vector&lt;mreal&gt;</code></em> <strong>dat</strong></dt>
<dd><p>Собственно данные.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataS"></a>Конструктор <code>mglDataS</code>: <em><code></code></em> <strong>mglDataS</strong> <em>(<code>const mglDataS &amp;</code> d)</em></dt>
<dd><p>Конструктор копирования.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataS-1"></a>Конструктор <code>mglDataS</code>: <em><code></code></em> <strong>mglDataS</strong> <em>(<code>const std::vector&lt;mreal&gt; &amp;</code> d)</em></dt>
<dd><p>Копирует данные из <var>d</var>.
</p></dd></dl>
<dl>
<dt><a name="index-mglDataS-2"></a>Конструктор <code>mglDataS</code>: <em><code></code></em> <strong>mglDataS</strong> <em>(<code>size_t</code> s)</em></dt>
<dd><p>Выделяет память для <var>s</var> элементов.
</p></dd></dl>
<dl>
<dt><a name="index-reserve"></a>Метод класса <code>mglDataS</code>: <em><code>void</code></em> <strong>reserve</strong> <em>(<code>size_t</code> num)</em></dt>
<dd><p>Резервирует место для <var>num</var> элементов.
</p></dd></dl>
<dl>
<dt><a name="index-push_005fback"></a>Метод класса <code>mglDataS</code>: <em><code>void</code></em> <strong>push_back</strong> <em>(<code>double</code> v)</em></dt>
<dd><p>Добавляет значение <var>v</var> к концу массива данных.
</p></dd></dl>





<hr>
<a name="MGL-scripts"></a>
<div class="header">
<p>
Next: <a href="#UDAV" accesskey="n" rel="next">UDAV</a>, Previous: <a href="#Data-processing" accesskey="p" rel="prev">Data processing</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>

<a name="Skripty-MGL"></a>
<h2 class="chapter">7 Скрипты MGL</h2>


<p>MathGL имеет встроенный скриптовый язык MGL для обработки и отображения данных. Скрипты MGL могут быть выполнены независимо (с помощью программ UDAV, mglconv, mglview и др.
, см. <a href="#Utilities">Utilities</a>) или с использованием вызовов библиотеки.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#MGL-definition" accesskey="1">MGL definition</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Program-flow-commands" accesskey="2">Program flow commands</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Special-comments" accesskey="3">Special comments</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#LaTeX-package" accesskey="4">LaTeX package</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mglParse-class" accesskey="5">mglParse class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<a name="MGL-definition"></a>
<div class="header">
<p>
Next: <a href="#Program-flow-commands" accesskey="n" rel="next">Program flow commands</a>, Up: <a href="#MGL-scripts" accesskey="u" rel="up">MGL scripts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Osnovy-MGL"></a>
<h3 class="section">7.1 Основы MGL</h3>


<p>Язык MGL достаточно простой. Каждая строка &ndash; отдельная команда. Первое слово &ndash; имя команды, а все остальные ее аргументы. Команда может иметь до 1000 аргументов (по крайней мере сейчас). Слова разделяются одно от другого пробелом или символом табуляции. Различий между верхним и нижним индексом нет, т.е. переменные <var>a</var> и <var>A</var> идентичны. Символ &lsquo;<samp>#</samp>&rsquo; начинает комментарий &ndash; все символы после него игнорируются до конца строки. Исключением является случай, когда &lsquo;<samp>#</samp>&rsquo; входит в строку. Опции команды указываются после символа &lsquo;<samp>;</samp>&rsquo; (see <a href="#Command-options">Command options</a>). Символ &lsquo;<samp>:</samp>&rsquo; начинает новую команду (подобно переводу строки) если он расположен не внутри скобок или строки.
</p>
<p>Если строка содержит ссылки на внешние параметры (&lsquo;<samp>$0</samp>&rsquo;, &lsquo;<samp>$1</samp>&rsquo; ... &lsquo;<samp>$9</samp>&rsquo;) или макроопределения (&lsquo;<samp>$a</samp>&rsquo;, &lsquo;<samp>$b</samp>&rsquo; ... &lsquo;<samp>$z</samp>&rsquo;), то текущие значения параметров/макроопределений подставляются в строку вместо ссылки до выполнением команды. Это позволяет использовать один и тот же скрипт при различных входных параметрах командной строки или вводить макроопределения по ходу исполнения команд скрипта.
</p>
<p>Аргументы команды могут быть строками, переменными или числами.
</p><ul>
<li> Строка &ndash; произвольный набор символов между метками &lsquo;<samp>'</samp>&rsquo;. Длинные строки могут быть соединены из нескольких линий файла символом &lsquo;<samp>\</samp>&rsquo;. Т.е. строки файла &lsquo;<samp>'a +'\&lt;br&gt;' b'</samp>&rsquo; дадут строку &lsquo;<samp>'a + b'</samp>&rsquo; (здесь &lsquo;<samp>&lt;br&gt;</samp>&rsquo; &ndash; перевод строки). MGL поддерживает несколько операций над строками:
<ul>
<li> Соединение строк и чисел, используя &lsquo;<samp>,</samp>&rsquo; без пробелов (например, &lsquo;<samp>'max(u)=',u.max,' a.u.'</samp>&rsquo; или &lsquo;<samp>'u=',!(1+i2)</samp>&rsquo; для комплексных чисел);
</li><li> Получение n-го символа строки, используя &lsquo;<samp>[]</samp>&rsquo; (например, &lsquo;<samp>'abc'[1]</samp>&rsquo; даст <code>'b'</code>);
</li><li> Инкремент последнего символа строки, используя &lsquo;<samp>+</samp>&rsquo; (например, &lsquo;<samp>'abc'+3</samp>&rsquo; даст <code>'abf'</code>).
</li></ul>

</li><li> Обычно переменная имеет имя, состоящее из букв и чисел (должно начинаться с буквы и не быть длиннее 64 символов). Если выражение или переменная начинается с символа &lsquo;<samp>!</samp>&rsquo;, то будут использованы комплексные значения. Например, код <code>new x 100 'x':copy !b !exp(1i*x)</code> создаст массив действительных чисел <var>x</var> и массив комплексных чисел <var>b</var>, который будет равен <em>exp(I*x)</em>, где <em>I^2=-1</em>. 
В качестве переменной можно использовать также и временные массивы, включающие в себя:
<ul>
<li> срезы (&ldquo;подмассивы&rdquo;) массивов данных (подобно команде <a href="#subdata">subdata</a>). Например, <code>a(1)</code> или <code>a(1,:)</code> или <code>a(1,:,:)</code> &ndash; вторая строка массива <var>a</var>, <code>a(:,2)</code> или <code>a(:,2,:)</code> &ndash; третий столбец, <code>a(:,:,0)</code> &ndash; первый срез и т.д. Также можно выделить часть массива с m-го по n-ый элемент <code>a(m:n,:,:)</code> или просто <code>a(m:n)</code>.

</li><li> произвольные комбинации столбцов данных (например, <code>a('n*w^2/exp(t)')</code>), если столбцы данных были именованы командой <a href="#idset">idset</a> или в файле данных (в строке начинающейся с <code>##</code>).

</li><li> произвольное выражение из существующих переменных и констант. Например, &lsquo;<samp>sqrt(dat(:,5)+1)</samp>&rsquo; даст временный массив данных с элементами равными <code>tmp[i,j] = sqrt(dat[i,5,j]+1)</code>. При этом символ &lsquo;<samp>`</samp>&rsquo; возвращает транспонированный массив: &lsquo;<samp>`sqrt(dat(:,5)+1)</samp>&rsquo; и &lsquo;<samp>sqrt(`dat(:,5)+1)</samp>&rsquo; оба дадут временный массив данных с элементами равными <code>tmp[i,j] = sqrt(dat[j,5,i]+1)</code>.

</li><li> массивы с элементами заданными в квадратных скобках [], разделенные &lsquo;<samp>,</samp>&rsquo;. При этом внутри выражения не должно быть пробелов! Например, &lsquo;<samp>[1,2,3]</samp>&rsquo; даст временный массив из 3 элементов {1, 2, 3}; &lsquo;<samp>[[11,12],[21,22]]</samp>&rsquo; даст матрицу 2*2 и т.д. Элементами такой конструкции могут быть и массивы если их размерности одинаковые, например &lsquo;<samp>[v1,v2,...,vn]</samp>&rsquo;.

</li><li> результат команд построения новых данных (see <a href="#Make-another-data">Make another data</a>), если они заключены в фигурные скобки {}. Например, &lsquo;<samp>{sum dat 'x'}</samp>&rsquo; даст временный массив, который есть результат суммирования <var>dat</var> вдоль &rsquo;x&rsquo;. Это такой же массив как и <var>tmp</var>, полученный командой &lsquo;<samp>sum tmp dat 'x'</samp>&rsquo;. При этом можно использовать вложенные конструкции, например &lsquo;<samp>{sum {max dat 'z'} 'x'}</samp>&rsquo;.
</li></ul>
<p>Временные массивы не могут стоять в качестве первого аргумента команд, создающих массивы (например, &lsquo;<samp>new</samp>&rsquo;, &lsquo;<samp>read</samp>&rsquo;, &lsquo;<samp>hist</samp>&rsquo; и т.д.).
</p>
</li><li> К скалярным переменным, кроме собственно чисел, относятся: специальные переменные <code>nan=#QNAN, inf=бесконечность, rnd=случайное число, pi=3.1415926..., on=1, off=0, all=-1, :=-1</code>, переменные с суффиксами (see <a href="#Data-information">Data information</a>), переменные определенные командой <a href="#define">define</a>, значения времени (в формате &quot;hh-mm-ss_DD.MM.YYYY&quot;, &quot;hh-mm-ss&quot; или &quot;DD.MM.YYYY&quot;) . Также массивы размером 1x1x1 считаются скалярами (например, &lsquo;<samp>pi/dat.nx</samp>&rsquo;).
</li></ul>
<p>Перед первым использованием все переменные должны быть определены с помощью команд, создающих массивы (<a href="#new">new</a>, <a href="#var">var</a>, <a href="#list">list</a>, <a href="#copy">copy</a>, <a href="#read">read</a>, <a href="#hist">hist</a>, <a href="#sum">sum</a> и др., см. <a href="#Data-constructor">Data constructor</a>, <a href="#Data-filling">Data filling</a> и <a href="#Make-another-data">Make another data</a>).
</p>
<p>Команды могут иметь несколько наборов аргументов (например, <code>plot ydat</code> и <code>plot xdat ydat</code>). Все аргументы команды для выбранного набора должны быть указаны, однако часть из них могут иметь значения по умолчанию. Такие аргументы в описании команд будут помещены в квадратные скобки [], например <code>plot ydat ['stl'='' zval=nan]</code>. При этом запись <code>[arg1 arg2 arg3 ...]</code> подразумевает <code>[arg1 [arg2 [arg3 ...]]]</code>, т.е. опускать можно только аргументы с конца, если вы согласны с их значениями по умолчанию. Например, <code>plot ydat '' 1</code> или <code>plot ydat ''</code> правильно, а <code>plot ydat 1</code> не правильно (аргумент <code>'stl'</code> пропущен).
</p>
<p>Можно предоставить несколько вариантов аргументов комманд при использовании символа &lsquo;<samp>?</samp>&rsquo; для их разделения. Конкретный вариант аргумента, используемый при выполнении команды, задается значением команды <a href="#variant">variant</a>. При этом будет использован последний вариант, если задано слишком большое значение. По умолчанию используется первый вариант (т.е. как при <code>variant 0</code>). Например в следующем коде будет сначала нарисован график синим цветом (первый аргумент &lsquo;<samp>b</samp>&rsquo;), а затем красным пунктиром &ndash; после <code>variant 1</code> будет использован второй аргумент &lsquo;<samp>r|</samp>&rsquo;:
</p><pre class="verbatim">fplot 'x' 'b'?'r'
variant 1
fplot 'x^3' 'b'?'r|'
</pre>

<hr>
<a name="Program-flow-commands"></a>
<div class="header">
<p>
Next: <a href="#Special-comments" accesskey="n" rel="next">Special comments</a>, Previous: <a href="#MGL-definition" accesskey="p" rel="prev">MGL definition</a>, Up: <a href="#MGL-scripts" accesskey="u" rel="up">MGL scripts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Upravlenie-khodom-vypolneniya"></a>
<h3 class="section">7.2 Управление ходом выполнения</h3>


<p>Ниже собраны команды, управляющие порядком выполнения других команд (условия, циклы, подпрограммы), (пере-)определяют аргументы скрипта и пр. Прочие команды могут быть найдены в главах <a href="#MathGL-core">MathGL core</a> и <a href="#Data-processing">Data processing</a>. Отмечу, что некоторые из команд (например, <a href="#define">define</a>, <a href="#ask">ask</a>, <a href="#call">call</a>, <a href="#for">for</a>, <a href="#func">func</a>) должны быть расположены на отдельной строке.
</p>
<a name="index-chdir"></a>
<a name="chdir"></a><dl>
<dt><a name="index-chdir-1"></a>Команда MGL: <em></em> <strong>chdir</strong> <em>'path'</em></dt>
<dd><p>Переходит в папку <var>path</var>.
</p></dd></dl>

<a name="index-ask"></a>
<a name="ask"></a><dl>
<dt><a name="index-ask-1"></a>Команда MGL: <em></em> <strong>ask</strong> <em>$N 'question'</em></dt>
<dd><p>Задает <var>N</var>-ый аргумент скрипта равным ответу пользователя на вопрос <var>question</var>. Обычно команда показывает диалог с вопросом и полем ввода текста ответа. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>

<a name="index-define"></a>
<a name="define"></a><dl>
<dt><a name="index-define-1"></a>Команда MGL: <em></em> <strong>define</strong> <em>$N smth</em></dt>
<dd><p>Задает <var>N</var>-ый аргумент скрипта равным <var>smth</var>. Отмечу, что <var>smth</var> используется как есть (с символами &lsquo;<samp>'</samp>&rsquo; если присутствуют). Выполняется только подстановка других макроопределений $0...$9, $a...$z. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>
<dl>
<dt><a name="index-define-2"></a>Команда MGL: <em></em> <strong>define</strong> <em>name smth</em></dt>
<dd><p>Определяет константу (скаляр) с именем <code>name</code> и числовым значением <code>smth</code>. Позднее она может быть использована как обычное число.
</p></dd></dl>
<a name="index-defchr"></a>
<a name="defchr"></a><dl>
<dt><a name="index-defchr-1"></a>Команда MGL: <em></em> <strong>defchr</strong> <em>$N smth</em></dt>
<dd><p>Задает <var>N</var>-ый аргумент скрипта равным символу с UTF кодом <var>smth</var>. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>
<a name="index-defnum"></a>
<a name="defnum"></a><dl>
<dt><a name="index-defnum-1"></a>Команда MGL: <em></em> <strong>defnum</strong> <em>$N smth</em></dt>
<dd><p>Задает <var>N</var>-ый аргумент скрипта равным числовому значению <var>smth</var>. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>


<a name="index-call"></a>
<a name="call"></a><dl>
<dt><a name="index-call-1"></a>Команда MGL: <em></em> <strong>call</strong> <em>'fname' [ARG1 ARG2 ... ARG9]</em></dt>
<dd><p>Переходит к выполнению (вызывает) подпрограммы <var>fname</var> (или внешнего скрипта, если функция не была найдена). Опциональные аргументы передаются в подпрограмму. См. также <a href="#func">func</a>.
</p></dd></dl>

<a name="index-func"></a>
<a name="func"></a><dl>
<dt><a name="index-func-1"></a>Команда MGL: <em></em> <strong>func</strong> <em>'fname' [narg=0]</em></dt>
<dd><p>Определяет подпрограмму с именем <var>fname</var> и задает число требуемых аргументов. Аргументы будут помещены в параметры скрипта $1, $2, ... $9. Отмечу, что выполнение основной программы будет остановлено при встрече <code>func</code> &ndash; действует аналогично комманде <a href="#stop">stop</a>. См. также <a href="#return">return</a>.
</p>
</dd></dl>
<a name="index-return"></a>
<a name="return"></a><dl>
<dt><a name="index-return-1"></a>Команда MGL: <em></em> <strong>return</strong></dt>
<dd><p>Возвращается из подпрограммы. См. также <a href="#func">func</a>.
</p></dd></dl>

<a name="index-load"></a>
<a name="load"></a><dl>
<dt><a name="index-load-1"></a>Команда MGL: <em></em> <strong>load</strong> <em>'filename'</em></dt>
<dd><p>Загружает дополнительные команды MGL из внешней динамической библиотеки <var>filename</var>. Данная библиотека должна содержать массив с именем <code>mgl_cmd_extra</code> типа  <code>mglCommand</code>, который содержит описание новых комманд.
</p></dd></dl>


<a name="index-if"></a>
<a name="if"></a><a name="then"></a><dl>
<dt><a name="index-if-1"></a>Команда MGL: <em></em> <strong>if</strong> <em><code>val</code> <strong>then</strong> <code>CMD</code></em></dt>
<dd><p>Выполняет команду <code>CMD</code> только если <code>val</code> не ноль.
</p></dd></dl>
<dl>
<dt><a name="index-if-2"></a>Команда MGL: <em></em> <strong>if</strong> <em><code>val</code></em></dt>
<dd><p>Начинает блок команд, выполняемый если <code>val</code> не ноль.
</p></dd></dl>
<dl>
<dt><a name="index-if-3"></a>Команда MGL: <em></em> <strong>if</strong> <em>dat 'cond'</em></dt>
<dd><p>Начинает блок команд, выполняемый если каждый элемент <var>dat</var> удовлетворяет условию <var>cond</var>.
</p></dd></dl>
<a name="index-elseif"></a>
<a name="elseif"></a><dl>
<dt><a name="index-elseif-1"></a>Команда MGL: <em></em> <strong>elseif</strong> <em>dat 'cond'</em></dt>
<dd><p>Начинает блок команд, выполняемый если предыдущий <code>if</code> или <code>elseif</code> не был выполнен и каждый элемент <var>dat</var> удовлетворяет условию <var>cond</var>.
</p></dd></dl>
<dl>
<dt><a name="index-elseif-2"></a>Команда MGL: <em></em> <strong>elseif</strong> <em><code>val</code></em></dt>
<dd><p>Начинает блок команд, выполняемый если предыдущий <code>if</code> или <code>elseif</code> не был выполнен и <code>val</code> не ноль.
</p></dd></dl>
<a name="index-else"></a>
<a name="else"></a><dl>
<dt><a name="index-else-1"></a>Команда MGL: <em></em> <strong>else</strong></dt>
<dd><p>Начинает блок команд, выполняемый если предыдущий <code>if</code> или <code>elseif</code> не был выполнен.
</p></dd></dl>
<a name="index-endif"></a>
<a name="endif"></a><dl>
<dt><a name="index-endif-1"></a>Команда MGL: <em></em> <strong>endif</strong></dt>
<dd><p>Заканчивает определение блока <code>if/elseif/else</code>.
</p></dd></dl>

<a name="index-for"></a>
<a name="for"></a><dl>
<dt><a name="index-for-1"></a>Команда MGL: <em></em> <strong>for</strong> <em>$N <code>v1 v2 [dv=1]</code></em></dt>
<dd><p>Начинает блок команд, выполняемый в цикле с $<var>N</var>-ым аргументом изменяющимся от <var>v1</var> до <var>v2</var> с шагом <var>dv</var>. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>
<dl>
<dt><a name="index-for-2"></a>Команда MGL: <em></em> <strong>for</strong> <em>$N dat</em></dt>
<dd><p>Начинает блок команд, выполняемый в цикле с $<var>N</var>-ым аргументом пробегающим значения массива <var>dat</var>. Здесь <var>N</var> это цифра (0...9) или буква (a...z).
</p></dd></dl>
<a name="index-next"></a>
<a name="next"></a><dl>
<dt><a name="index-next-1"></a>Команда MGL: <em></em> <strong>next</strong></dt>
<dd><p>Заканчивает блок цикла <code>for</code>.
</p></dd></dl>

<a name="index-do"></a>
<a name="do"></a><dl>
<dt><a name="index-do-1"></a>Команда MGL: <em></em> <strong>do</strong></dt>
<dd><p>Начинает бесконечный цикл.
</p></dd></dl>
<a name="index-while"></a>
<a name="while"></a><dl>
<dt><a name="index-while-1"></a>Команда MGL: <em></em> <strong>while</strong> <em><code>val</code></em></dt>
<dd><p>Переходит к следующей итерации цикла если <var>val</var> не ноль, в противном случае заканчивает цикл.
</p></dd></dl>
<dl>
<dt><a name="index-while-2"></a>Команда MGL: <em></em> <strong>while</strong> <em>dat 'cond'</em></dt>
<dd><p>Переходит к следующей итерации цикла если <var>dat</var> удовлетворяет условию <var>cond</var>, в противном случае заканчивает цикл.
</p></dd></dl>

<a name="index-once"></a>
<a name="once"></a><dl>
<dt><a name="index-once-1"></a>Команда MGL: <em></em> <strong>once</strong> <em><code>val</code></em></dt>
<dd><p>Определяет код (между <code>once on</code> и <code>once off</code>) который будет выполнен только один раз. Полезно для работы с большими данными в программах типа UDAV.
</p></dd></dl>
<a name="index-stop"></a>
<a name="stop"></a><dl>
<dt><a name="index-stop-2"></a>Команда MGL: <em></em> <strong>stop</strong></dt>
<dd><p>Останавливает выполнение скрипта.
</p></dd></dl>

<a name="index-variant"></a>
<a name="variant"></a><dl>
<dt><a name="index-variant-1"></a>Команда MGL: <em></em> <strong>variant</strong> <em><code>val</code></em></dt>
<dd><p>Задает вариант аргумента(ов), разделенных символом &lsquo;<samp>?</samp>&rsquo;, для всех последующих комманд.
</p></dd></dl>

<a name="index-rkstep"></a>
<a name="rkstep"></a><dl>
<dt><a name="index-rkstep-1"></a>Команда MGL: <em></em> <strong>rkstep</strong> <em>eq1;... var1;... [<code>dt=1</code>]</em></dt>
<dd><p>Выполняет один шаг решения системы обыкновенных дифференциальных уравнений {var1&rsquo; = eq1, ... } с временным шагом <var>dt</var>. Здесь переменные &lsquo;<samp>var1</samp>&rsquo;, ... &ndash; переменные, определенные в MGL скрипте ранее. При решении используется метод Рунге-Кутта 4-го порядка.
</p></dd></dl>




<hr>
<a name="Special-comments"></a>
<div class="header">
<p>
Next: <a href="#LaTeX-package" accesskey="n" rel="next">LaTeX package</a>, Previous: <a href="#Program-flow-commands" accesskey="p" rel="prev">Program flow commands</a>, Up: <a href="#MGL-scripts" accesskey="u" rel="up">MGL scripts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Specialxnye-kommentarii"></a>
<h3 class="section">7.3 Специальные комментарии</h3>


<p>There are number of special comments for MGL script, which set some global behavior (like, animation, dialog for parameters and so on). All these special comments starts with double sign <code>##</code>. Let consider them.
</p>
<dl compact="compact">
<dt>&lsquo;<samp><strong>##c</strong> <code>v1 v2 [dv=1]</code></samp>&rsquo;</dt>
<dd><p>Sets the parameter for animation loop relative to variable <code>$0</code>. Here <var>v1</var> and <var>v2</var> are initial and final values, <var>dv</var> is the increment.
</p>
</dd>
<dt>&lsquo;<samp><strong>##a</strong> val</samp>&rsquo;</dt>
<dd><p>Adds the parameter <var>val</var> to the list of animation relative to variable <code>$0</code>. You can use it several times (one parameter per line) or combine it with animation loop <strong>##c</strong>.
</p>
</dd>
<dt>&lsquo;<samp><strong>##d</strong> $I kind|label|par1|par2|...</samp>&rsquo;</dt>
<dd><p>Creates custom dialog for changing plot properties. Each line adds one widget to the dialog. Here <var>$I</var> is id ($0,$1...$9,$a,$b...$z), <var>label</var> is the label of widget, <var>kind</var> is the kind of the widget:
</p><ul>
<li> &rsquo;e&rsquo; for editor or input line (parameter is initial value) , 
</li><li> &rsquo;v&rsquo; for spinner or counter (parameters are &quot;ini|min|max|step|big_step&quot;), 
</li><li> &rsquo;s&rsquo; for slider (parameters are &quot;ini|min|max|step&quot;), 
</li><li> &rsquo;b&rsquo; for check box (parameter is &quot;ini&quot;; also understand &quot;on&quot;=1), 
</li><li> &rsquo;c&rsquo; for choice (parameters are possible choices).
</li></ul>
<p>Now, it work in FLTK-based <code>mgllab</code> and <code>mglview</code> only.
</p>
<p>You can make custom dialog in C/C++ code too by using one of following functions.
</p>
<dl>
<dt><a name="index-MakeDialog"></a>Method on <code>mglWnd</code>: <em><code>void</code></em> <strong>MakeDialog</strong> <em>(<code>const char *</code>ids, <code>char const * const *</code>args, <code>const char *</code>title)</em></dt>
<dt><a name="index-MakeDialog-1"></a>Method on <code>mglWnd</code>: <em><code>void</code></em> <strong>MakeDialog</strong> <em>(<code>const std::string &amp;</code>ids, <code>const std::vector&lt;std::string&gt; &amp;</code>args, <code>const char *</code>title)</em></dt>
<dt><a name="index-mgl_005fwnd_005fmake_005fdialog"></a>C function: <em><code>void</code></em> <strong>mgl_wnd_make_dialog</strong> <em>(<code>HMGL</code> gr, <code>const char *</code>ids, <code>char const * const *</code>args, <code>const char *</code>title)</em></dt>
<dd><p>Makes custom dialog for parameters ids of element properties defined by args.
</p></dd></dl>

<p>At this you need to provide callback function for setting up properties. You can do it by overloading <code>Param()</code> function of <code>mglDraw</code> class or set it manually.
</p>
<dl>
<dt><a name="index-Param"></a>Method on <code>mglDraw</code>: <em><code>void</code></em> <strong>Param</strong> <em>(<code>char</code> id, <code>const char *</code> val)</em></dt>
<dt><a name="index-SetPropFunc"></a>Method on <code>mglWnd</code>: <em><code>void</code></em> <strong>SetPropFunc</strong> <em>(<code>void (*</code>prop<code>)(char id, const char *val, void *p)</code>, <code>void *</code>par=<code>NULL</code>)</em></dt>
<dt><a name="index-mgl_005fwnd_005fset_005fprop"></a>C function: <em><code>void</code></em> <strong>mgl_wnd_set_prop</strong> <em>(<code>void (*</code>prop<code>)(char id, const char *val, void *p)</code>, <code>void *</code>par)</em></dt>
<dd><p>Set callback function for properties setup.
</p></dd></dl>


</dd>
</dl>


<hr>
<a name="LaTeX-package"></a>
<div class="header">
<p>
Next: <a href="#mglParse-class" accesskey="n" rel="next">mglParse class</a>, Previous: <a href="#Special-comments" accesskey="p" rel="prev">Special comments</a>, Up: <a href="#MGL-scripts" accesskey="u" rel="up">MGL scripts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="LaTeX-package-1"></a>
<h3 class="section">7.4 LaTeX package</h3>


<p>There is LaTeX package <code>mgltex</code> (was made by Diego Sejas Viscarra) which allow one to make figures directly from MGL script located in LaTeX file.
</p>
<p>For using this package you need to specify <code>--shell-escape</code> option for <em>latex/pdflatex</em> or manually run <em>mglconv</em> tool with produced MGL scripts for generation of images. Don&rsquo;t forgot to run <em>latex/pdflatex</em> second time to insert generated images into the output document. Also you need to run <em>pdflatex</em> third time to update converted from EPS images if you are using vector EPS output (default).
</p>
<p>The package may have following options: <code>draft</code>, <code>final</code> &mdash; the same as in the <em>graphicx</em> package; <code>on</code>, <code>off</code> &mdash; to activate/deactivate the creation of scripts and graphics; <code>comments</code>, <code>nocomments</code> &mdash; to make visible/invisible comments contained inside <code>mglcomment</code> environments; <code>jpg</code>, <code>jpeg</code>, <code>png</code> &mdash; to export graphics as JPEG/PNG images; <code>eps</code>, <code>epsz</code> &mdash; to export to uncompressed/compressed EPS format as primitives; <code>bps</code>, <code>bpsz</code> &mdash; to export to uncompressed/compressed EPS format as bitmap (doesn&rsquo;t work with <em>pdflatex</em>); <code>pdf</code> &mdash; to export to 3D PDF; <code>tex</code> &mdash; to export to <em>LaTeX/tikz</em> document.
</p>
<p>The package defines the following environments:
</p><dl compact="compact">
<dt>&lsquo;<samp>mgl</samp>&rsquo;</dt>
<dd><p>It writes its contents to a general script which has the same name as the LaTeX document, but its extension is <em>.mgl</em>. The code in this environment is compiled and the image produced is included. It takes exactly the same optional arguments as the <code>\includegraphics</code> command, plus an additional argument <var>imgext</var>, which specifies the extension to save the image.
</p>
<p>An example of usage of &lsquo;<samp>mgl</samp>&rsquo; environment would be:
</p><pre class="verbatim">\begin{mglfunc}{prepare2d}
  new a 50 40 '0.6*sin(pi*(x+1))*sin(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
  new b 50 40 '0.6*cos(pi*(x+1))*cos(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
\end{mglfunc}

\begin{figure}[!ht]
  \centering
  \begin{mgl}[width=0.85\textwidth,height=7.5cm]
    fog 0.5
    call 'prepare2d'
    subplot 2 2 0 : title 'Surf plot (default)' : rotate 50 60 : light on : box : surf a

    subplot 2 2 1 : title '&quot;\#&quot; style; meshnum 10' : rotate 50 60 : box
    surf a '#'; meshnum 10

    subplot 2 2 2 : title 'Mesh plot' : rotate 50 60 : box
    mesh a

    new x 50 40 '0.8*sin(pi*x)*sin(pi*(y+1)/2)'
    new y 50 40 '0.8*cos(pi*x)*sin(pi*(y+1)/2)'
    new z 50 40 '0.8*cos(pi*(y+1)/2)'
    subplot 2 2 3 : title 'parametric form' : rotate 50 60 : box
    surf x y z 'BbwrR'
  \end{mgl}
\end{figure}
</pre>
</dd>
<dt>&lsquo;<samp>mgladdon</samp>&rsquo;</dt>
<dd><p>It adds its contents to the general script, without producing any image.
</p></dd>
<dt>&lsquo;<samp>mglcode</samp>&rsquo;</dt>
<dd><p>Is exactly the same as &lsquo;<samp>mgl</samp>&rsquo;, but it writes its contents verbatim to its own file, whose name is specified as a mandatory argument.
</p></dd>
<dt>&lsquo;<samp>mglscript</samp>&rsquo;</dt>
<dd><p>Is exactly the same as &lsquo;<samp>mglcode</samp>&rsquo;, but it doesn&rsquo;t produce any image, nor accepts optional arguments. It is useful, for example, to create a MGL script, which can later be post processed by another package like &quot;listings&quot;.
</p></dd>
<dt>&lsquo;<samp>mglblock</samp>&rsquo;</dt>
<dd><p>It writes its contents verbatim to a file, specified as a mandatory argument, and to the LaTeX document, and numerates each line of code.
</p>
</dd>
<dt>&lsquo;<samp>mglverbatim</samp>&rsquo;</dt>
<dd><p>Exactly the same as &lsquo;<samp>mglblock</samp>&rsquo;, but it doesn&rsquo;t write to a file. This environment doesn&rsquo;t have arguments.
</p></dd>
<dt>&lsquo;<samp>mglfunc</samp>&rsquo;</dt>
<dd><p>Is used to define MGL functions. It takes one mandatory argument, which is the name of the function, plus one additional argument, which specifies the number of arguments of the function. The environment needs to contain only the body of the function, since the first and last lines are appended automatically, and the resulting code is written at the end of the general script, after the <a href="#stop">stop</a> command, which is also written automatically. The warning is produced if 2 or more function with the same name is defined.
</p></dd>
<dt>&lsquo;<samp>mglcomment</samp>&rsquo;</dt>
<dd><p>Is used to contain multiline comments. This comments will be visible/invisible in the output document, depending on the use of the package options <code>comments</code> and <code>nocomments</code> (see above), or the <code>\mglcomments</code> and <code>\mglnocomments</code> commands (see bellow).
</p></dd>
<dt>&lsquo;<samp>mglsetup</samp>&rsquo;</dt>
<dd><p>If many scripts with the same code are to be written, the repetitive code can be written inside this environment only once, then this code will be used automatically every time the &lsquo;<samp>\mglplot</samp>&rsquo; command is used (see below). It takes one optional argument, which is a name to be associated to the corresponding contents of the environment; this name can be passed to the &lsquo;<samp>\mglplot</samp>&rsquo; command to use the corresponding block of code automatically (see below).
</p></dd>
</dl>

<p>The package also defines the following commands:
</p><dl compact="compact">
<dt>&lsquo;<samp>\mglplot</samp>&rsquo;</dt>
<dd><p>It takes one mandatory argument, which is MGL instructions separated by the symbol &lsquo;<samp>:</samp>&rsquo; this argument can be more than one line long. It takes the same optional arguments as the &lsquo;<samp>mgl</samp>&rsquo; environment, plus an additional argument <var>setup</var>, which indicates the name associated to a block of code inside a &lsquo;<samp>mglsetup</samp>&rsquo; environment. The code inside the mandatory argument will be appended to the block of code specified, and the resulting code will be written to the general script.
</p>
<p>An example of usage of &lsquo;<samp>\mglplot</samp>&rsquo; command would be:
</p><pre class="verbatim">\begin{mglsetup}
    box '@{W9}' : axis
\end{mglsetup}
\begin{mglsetup}[2d]
  box : axis
  grid 'xy' ';k'
\end{mglsetup}
\begin{mglsetup}[3d]
  rotate 50 60
  box : axis : grid 'xyz' ';k'
\end{mglsetup}
\begin{figure}[!ht]
  \centering
  \mglplot[scale=0.5]{new a 200 'sin(pi*x)' : plot a '2B'}
\end{figure}
\begin{figure}[!ht]
  \centering
  \mglplot[scale=0.5,setup=2d]{
    fplot 'sin(pi*x)' '2B' :
    fplot 'cos(pi*x^2)' '2R'
  }
\end{figure}
\begin{figure}[!ht]
  \centering
  \mglplot[setup=3d]{fsurf 'sin(pi*x)+cos(pi*y)'}
\end{figure}
</pre>
</dd>
<dt>&lsquo;<samp>\mglgraphics</samp>&rsquo;</dt>
<dd><p>This command takes the same optional arguments as the &lsquo;<samp>mgl</samp>&rsquo; environment, and one mandatory argument, which is the name of a MGL script. This command will compile the corresponding script and include the resulting image. It is useful when you have a script outside the LaTeX document, and you want to include the image, but you don&rsquo;t want to type the script again.
</p></dd>
<dt>&lsquo;<samp>\mglinclude</samp>&rsquo;</dt>
<dd><p>This is like &lsquo;<samp>\mglgraphics</samp>&rsquo; but, instead of creating/including the corresponding image, it writes the contents of the MGL script to the LaTeX document, and numerates the lines.
</p></dd>
<dt>&lsquo;<samp>\mgldir</samp>&rsquo;</dt>
<dd><p>This command can be used in the preamble of the document to specify a directory where LaTeX will save the MGL scripts and generate the corresponding images. This directory is also where &lsquo;<samp>\mglgraphics</samp>&rsquo; and &lsquo;<samp>\mglinclude</samp>&rsquo; will look for scripts.
</p></dd>
<dt>&lsquo;<samp>\mglquality</samp>&rsquo;</dt>
<dd><p>Adjust the quality of the MGL graphics produced similarly to <a href="#quality">quality</a>.
</p></dd>
<dt>&lsquo;<samp>\mgltexon, \mgltexoff</samp>&rsquo;</dt>
<dd><p>Activate/deactivate the creation of MGL scripts and images. Notice these commands have local behavior in the sense that their effect is from the point they are called on.
</p></dd>
<dt>&lsquo;<samp>\mglcomment, \mglnocomment</samp>&rsquo;</dt>
<dd><p>Make visible/invisible the contents of the <code>mglcomment</code> environments. These commands have local effect too.
</p></dd>
<dt>&lsquo;<samp>\mglTeX</samp>&rsquo;</dt>
<dd><p>It just pretty prints the name of the package.
</p></dd>
</dl>

<p>As an additional feature, when an image is not found or cannot be included, instead of issuing an error, <code>mgltex</code> prints a box with the word &lsquo;<samp>MGL image not found</samp>&rsquo; in the LaTeX document.
</p>



<hr>
<a name="mglParse-class"></a>
<div class="header">
<p>
Previous: <a href="#LaTeX-package" accesskey="p" rel="prev">LaTeX package</a>, Up: <a href="#MGL-scripts" accesskey="u" rel="up">MGL scripts</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="mglParse-class-1"></a>
<h3 class="section">7.5 mglParse class</h3>

<a name="index-mglParse"></a>

<p>Класс разбирает и выполняет скрипты MGL. Он определен в <code>#include &lt;mgl2/mgl.h&gt;</code>.
</p>
<p>Основная функция класса mglParse &ndash; <code>Execute()</code>, выполняющая построчный разбор скрипта. Также есть вспомогательные функции для поиска и создания переменных MGL (объектов, производных от <code>mglDataA</code>). Эти функции полезны для отображения значений массивов во внешних объектах (например, в отдельном окне) или для предоставления доступа к внутренним массивам. Функция <code>AllowSetSize()</code> позволяет запретить изменение размера картинки (запрещает команду <code>setsize</code>). Функция <code>AllowFileIO()</code> позволяет запретить доступ к файлам на диске.
</p>

<dl>
<dt><a name="index-mglParse-1"></a>Конструктор класса <code>mglParse</code>: <em><code></code></em> <strong>mglParse</strong> <em>(<code>bool</code> setsize=<code>false</code>)</em></dt>
<dt><a name="index-mglParse-2"></a>Конструктор класса <code>mglParse</code>: <em><code></code></em> <strong>mglParse</strong> <em>(<code>HMPR</code> pr)</em></dt>
<dt><a name="index-mglParse-3"></a>Конструктор класса <code>mglParse</code>: <em><code></code></em> <strong>mglParse</strong> <em>(<code>mglParse &amp;</code>pr)</em></dt>
<dt><a name="index-mgl_005fcreate_005fparser"></a>Функция С: <em><code>HMPR</code></em> <strong>mgl_create_parser</strong> <em>()</em></dt>
<dd><p>Создает экземпляр класса <code>mglParse</code> и устанавливает значение <var>AllowSetSize</var>.
</p></dd></dl>

<dl>
<dt><a name="index-_007emglParse"></a>Деструктор класса <code>mglParse</code>: <em><code></code></em> <strong>~mglParse</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fdelete_005fparser"></a>Функция С: <em><code>void</code></em> <strong>mgl_delete_parser</strong> <em>(<code>HMPR</code> p)</em></dt>
<dd><p>Удаляет экземпляр класса.
</p></dd></dl>

<dl>
<dt><a name="index-Self-1"></a>Метод класса <code>mglParse</code>: <em><code>HMPR</code></em> <strong>Self</strong> <em>()</em></dt>
<dd><p>Возвращает указатель на используемый объект типа <code>HMPR</code>.
</p></dd></dl>

<dl>
<dt><a name="index-Execute"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>Execute</strong> <em>(<code>mglGraph *</code>gr, <code>const char *</code>text)</em></dt>
<dt><a name="index-Execute-1"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>Execute</strong> <em>(<code>mglGraph *</code>gr, <code>const wchar_t *</code>text)</em></dt>
<dt><a name="index-mgl_005fparse_005ftext"></a>Функция С: <em><code>void</code></em> <strong>mgl_parse_text</strong> <em>(<code>HMGL</code> gr, <code>HMPR</code> p, <code>const char *</code>text)</em></dt>
<dt><a name="index-mgl_005fparse_005ftextw"></a>Функция С: <em><code>void</code></em> <strong>mgl_parse_textw</strong> <em>(<code>HMGL</code> gr, <code>HMPR</code> p, <code>const wchar_t *</code>text)</em></dt>
<dd><p>Выполняет построчно скрипт MGL, содержащийся в <var>text</var>. Строки считаются разделенными символом &lsquo;<samp>\n</samp>&rsquo;. Это основная функция класса.
</p></dd></dl>

<dl>
<dt><a name="index-Execute-2"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>Execute</strong> <em>(<code>mglGraph *</code>gr, <code>FILE *</code>fp, <code>bool</code> print=<code>false</code>)</em></dt>
<dt><a name="index-mgl_005fparse_005ffile"></a>Функция С: <em><code>void</code></em> <strong>mgl_parse_file</strong> <em>(<code>HMGL</code> gr, <code>HMPR</code> p, <code>FILE *</code>fp, <code>int</code> print)</em></dt>
<dd><p>Аналогично предыдущему, но скрипт читается из файла <var>fp</var>. Если <var>print</var>=<code>true</code>, то предупреждения и информационные сообщения печатаются в stdout.
</p></dd></dl>

<dl>
<dt><a name="index-Parse"></a>Метод класса <code>mglParse</code>: <em><code>int</code></em> <strong>Parse</strong> <em>(<code>mglGraph *</code>gr, <code>const char *</code>str, <code>long</code> pos=<code>0</code>)</em></dt>
<dt><a name="index-Parse-1"></a>Метод класса <code>mglParse</code>: <em><code>int</code></em> <strong>Parse</strong> <em>(<code>mglGraph *</code>gr, <code>const wchar_t *</code>str, <code>long</code> pos=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fparse_005fline"></a>Функция С: <em><code>int</code></em> <strong>mgl_parse_line</strong> <em>(<code>HMGL</code> gr, <code>HMPR</code> p, <code>const char *</code>str, <code>int</code> pos)</em></dt>
<dt><a name="index-mgl_005fparse_005flinew"></a>Функция С: <em><code>int</code></em> <strong>mgl_parse_linew</strong> <em>(<code>HMGL</code> gr, <code>HMPR</code> p, <code>const wchar_t *</code>str, <code>int</code> pos)</em></dt>
<dd><p>Выполняет строку <var>str</var> с выводом графики на <var>gr</var>. Возвращает код ошибки: 0 &ndash; нет ошибок, 1 &ndash; неправильные аргументы, 2 &ndash; неизвестная команда, 3 &ndash; строка слишком длинная, 4 &ndash; нет закрывающей скобки или &lsquo;<samp>'</samp>&rsquo;. Аргумент <var>pos</var> задает позицию строки в документе/файле для использования в команде <a href="#for">for</a>.
</p></dd></dl>

<dl>
<dt><a name="index-Calc-1"></a>Метод класса <code>mglParse</code>: <em><code>mglData</code></em> <strong>Calc</strong> <em>(<code>const char *</code>formula)</em></dt>
<dt><a name="index-Calc-2"></a>Метод класса <code>mglParse</code>: <em><code>mglData</code></em> <strong>Calc</strong> <em>(<code>const wchar_t *</code>formula)</em></dt>
<dt><a name="index-mgl_005fparser_005fcalc"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_calc</strong> <em>(<code>HMPR</code> p, <code>const char *</code>formula)</em></dt>
<dt><a name="index-mgl_005fparser_005fcalcw"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_calcw</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>formula)</em></dt>
<dd><p>Разбирает строку <var>formula</var> и возвращает полученный массив. В отличие от <code>AddVar()</code> или <code>FindVar()</code>, это обычный массив данных, который следует удалить после использования.
</p></dd></dl>

<dl>
<dt><a name="index-CalcComplex"></a>Метод класса <code>mglParse</code>: <em><code>mglDataC</code></em> <strong>CalcComplex</strong> <em>(<code>const char *</code>formula)</em></dt>
<dt><a name="index-CalcComplex-1"></a>Метод класса <code>mglParse</code>: <em><code>mglDataC</code></em> <strong>CalcComplex</strong> <em>(<code>const wchar_t *</code>formula)</em></dt>
<dt><a name="index-mgl_005fparser_005fcalc_005fcomplex"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_parser_calc_complex</strong> <em>(<code>HMPR</code> p, <code>const char *</code>formula)</em></dt>
<dt><a name="index-mgl_005fparser_005fcalc_005fcomplexw"></a>Функция С: <em><code>HADT</code></em> <strong>mgl_parser_calc_complexw</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>formula)</em></dt>
<dd><p>Разбирает строку <var>formula</var> и возвращает полученный массив с комплексными значениями. В отличие от <code>AddVar()</code> или <code>FindVar()</code>, это обычный массив данных, который следует удалить после использования.
</p></dd></dl>


<dl>
<dt><a name="index-AddParam"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>AddParam</strong> <em>(<code>int</code> n, <code>const char *</code>str)</em></dt>
<dt><a name="index-AddParam-1"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>AddParam</strong> <em>(<code>int</code> n, <code>const wchar_t *</code>str)</em></dt>
<dt><a name="index-mgl_005fparser_005fadd_005fparam"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_add_param</strong> <em>(<code>HMPR</code> p, <code>int</code> id, <code>const char *</code>val)</em></dt>
<dt><a name="index-mgl_005fparser_005fadd_005fparamw"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_add_paramw</strong> <em>(<code>HMPR</code> p, <code>int</code> id, <code>const wchar_t *</code>val)</em></dt>
<dd><p>Устанавливает значение <var>n</var>-го параметра строкой <var>str</var> (<var>n</var>=0, 1 ... &rsquo;z&rsquo;-&rsquo;a&rsquo;+10). Строка <var>str</var> не должна содержать символ &lsquo;<samp>$</samp>&rsquo;.
</p></dd></dl>

<dl>
<dt><a name="index-FindVar"></a>Метод класса <code>mglParse</code>: <em><code>mglVar *</code></em> <strong>FindVar</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-FindVar-1"></a>Метод класса <code>mglParse</code>: <em><code>mglVar *</code></em> <strong>FindVar</strong> <em>(<code>const wchar_t *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005ffind_005fvar"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_find_var</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005ffind_005fvarw"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_find_varw</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>name)</em></dt>
<dd><p>Возвращает указатель на переменную с именем <var>name</var> или <code>NULL</code> если переменная отсутствует. Используйте эту функцию для добавления внешних массивов в скрипт. <strong>Не удаляйте</strong> полученный массив!
</p></dd></dl>
<dl>
<dt><a name="index-AddVar"></a>Метод класса <code>mglParse</code>: <em><code>mglVar *</code></em> <strong>AddVar</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-AddVar-1"></a>Метод класса <code>mglParse</code>: <em><code>mglVar *</code></em> <strong>AddVar</strong> <em>(<code>const wchar_t *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fadd_005fvar"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_add_var</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fadd_005fvarw"></a>Функция С: <em><code>HMDT</code></em> <strong>mgl_parser_add_varw</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>name)</em></dt>
<dd><p>Возвращает указатель на переменную с именем <var>name</var>. Если переменная отсутствует, то она будет создана. Используйте эту функцию для добавления внешних массивов в скрипт. <strong>Не удаляйте</strong> полученный массив!
</p></dd></dl>

<dl>
<dt><a name="index-OpenHDF-1"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>OpenHDF</strong> <em>(<code>const char *</code>fname)</em></dt>
<dt><a name="index-mgl_005fparser_005fopenhdf-1"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_openhdf</strong> <em>(<code>HMPR</code> pr, <code>const char *</code>fname)</em></dt>
<dd><p>Читает все массивы данных из HDF5 файла <var>fname</var> и создает переменные MGL с соответствующими именами. Если имя данных начинается с &lsquo;<samp>!</samp>&rsquo;, то будут созданы комплексные массивы.
</p></dd></dl>

<dl>
<dt><a name="index-DeleteVar"></a>Метод класса <code>mglParse</code> (C++): <em><code>void</code></em> <strong>DeleteVar</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-DeleteVar-1"></a>Метод класса <code>mglParse</code> (C++): <em><code>void</code></em> <strong>DeleteVar</strong> <em>(<code>const wchar_t *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fdel_005fvar"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_del_var</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fdel_005fvarw"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_del_varw</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>name)</em></dt>
<dd><p>Удаляет переменную по имени <var>name</var>.
</p></dd></dl>

<dl>
<dt><a name="index-DeleteAll"></a>Метод класса <code>mglParse</code> (C++): <em><code>void</code></em> <strong>DeleteAll</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fparser_005fdel_005fall"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_del_all</strong> <em>(<code>HMPR</code> p)</em></dt>
<dd><p>Удаляет все переменные и сбрасывает список команд к списку по умолчанию в данном классе.
</p></dd></dl>

<dl>
<dt><a name="index-RestoreOnce"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>RestoreOnce</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fparser_005frestore_005fonce"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_restore_once</strong> <em>(<code>HMPR</code> p)</em></dt>
<dd><p>Восстанавливает состояние флага Once.
</p></dd></dl>

<dl>
<dt><a name="index-AllowSetSize"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>AllowSetSize</strong> <em>(<code>bool</code> a)</em></dt>
<dt><a name="index-mgl_005fparser_005fallow_005fsetsize"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_allow_setsize</strong> <em>(<code>HMPR</code> p, <code>int</code> a)</em></dt>
<dd><p>Разрешает/запрещает команду <a href="#setsize">setsize</a>.
</p></dd></dl>

<dl>
<dt><a name="index-AllowFileIO"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>AllowFileIO</strong> <em>(<code>bool</code> a)</em></dt>
<dt><a name="index-mgl_005fparser_005fallow_005ffile_005fio"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_allow_file_io</strong> <em>(<code>HMPR</code> p, <code>int</code> a)</em></dt>
<dd><p>Разрешает/запрещает команды чтения файлов.
</p></dd></dl>

<dl>
<dt><a name="index-AllowDllCall"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>AllowDllCall</strong> <em>(<code>bool</code> a)</em></dt>
<dt><a name="index-mgl_005fparser_005fallow_005fdll_005fcall"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_allow_dll_call</strong> <em>(<code>HMPR</code> p, <code>int</code> a)</em></dt>
<dd><p>Разрешает/запрещает команду <a href="#load">load</a>.
</p></dd></dl>

<dl>
<dt><a name="index-Stop-2"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>Stop</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fparser_005fstop"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_stop</strong> <em>(<code>HMPR</code> p)</em></dt>
<dd><p>Посылает сигнал завершения выполнения для следующей команды.
</p></dd></dl>

<dl>
<dt><a name="index-SetVariant"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>SetVariant</strong> <em>(<code>int</code> var=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fparser_005fvariant"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_variant</strong> <em>(<code>HMPR</code> p, <code>int</code> var=<code>0</code>)</em></dt>
<dd><p>Задает вариант аргумента(ов), разделенных символом &lsquo;<samp>?</samp>&rsquo;, для всех последующих комманд.
</p></dd></dl>

<dl>
<dt><a name="index-StartID"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>StartID</strong> <em>(<code>int</code> id=<code>0</code>)</em></dt>
<dt><a name="index-mgl_005fparser_005fstart_005fid"></a>Функция С: <em><code>void</code></em> <strong>mgl_parser_start_id</strong> <em>(<code>HMPR</code> p, <code>int</code> id)</em></dt>
<dd><p>Задает начальный id (обычно это номер строки) первой строки при последующем выполнении скрипта.
</p></dd></dl>


<dl>
<dt><a name="index-GetCmdNum"></a>Метод класса <code>mglParse</code>: <em><code>long</code></em> <strong>GetCmdNum</strong> <em>()</em></dt>
<dt><a name="index-mgl_005fparser_005fcmd_005fnum"></a>Функция С: <em><code>long</code></em> <strong>mgl_parser_cmd_num</strong> <em>(<code>HMPR</code> p)</em></dt>
<dd><p>Возвращает число зарегистрированных команд MGL.
</p></dd></dl>

<dl>
<dt><a name="index-GetCmdName"></a>Метод класса <code>mglParse</code>: <em><code>const char *</code></em> <strong>GetCmdName</strong> <em>(<code>long</code> id)</em></dt>
<dt><a name="index-mgl_005fparser_005fcmd_005fname"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_parser_cmd_name</strong> <em>(<code>HMPR</code> p, <code>long</code> id)</em></dt>
<dd><p>Возвращает имя команды MGL с заданным номером <var>id</var>.
</p></dd></dl>

<dl>
<dt><a name="index-CmdType"></a>Метод класса <code>mglParse</code>: <em><code>int</code></em> <strong>CmdType</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fcmd_005ftype"></a>Функция С: <em><code>int</code></em> <strong>mgl_parser_cmd_type</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dd><p>Возвращает тип команды MGL с именем <var>name</var>. Типы команд: 0 &ndash; не команда, 1 - графики по данным, 2 - прочие графики, 3 - настройка, 4 - обработка данных, 5 - создание данных, 6 - трансформация, 7 - ход выполнения, 8 - 1d графики, 9 - 2d графики, 10 - 3d графики, 11 - двойные графики, 12 - векторные поля, 13 - оси координат, 14 - примитивы, 15 - настройка осей, 16 - текст/легенда, 17 - изменение данных.
</p></dd></dl>

<dl>
<dt><a name="index-CmdFormat"></a>Метод класса <code>mglParse</code>: <em><code>const char *</code></em> <strong>CmdFormat</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fcmd_005ffrmt"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_parser_cmd_frmt</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dd><p>Возвращает формат аргументов команды MGL с именем <var>name</var>.
</p></dd></dl>

<dl>
<dt><a name="index-CmdDesc"></a>Метод класса <code>mglParse</code>: <em><code>const char *</code></em> <strong>CmdDesc</strong> <em>(<code>const char *</code>name)</em></dt>
<dt><a name="index-mgl_005fparser_005fcmd_005fdesc"></a>Функция С: <em><code>const char *</code></em> <strong>mgl_parser_cmd_desc</strong> <em>(<code>HMPR</code> p, <code>const char *</code>name)</em></dt>
<dd><p>Возвращает описание команды MGL с именем <var>name</var>.
</p></dd></dl>

<dl>
<dt><a name="index-RK_005fStep"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>RK_Step</strong> <em>(<code>const char *</code>eqs, <code>const char *</code>vars, <code>mreal</code> dt=<code>1</code>)</em></dt>
<dt><a name="index-RK_005fStep-1"></a>Метод класса <code>mglParse</code>: <em><code>void</code></em> <strong>RK_Step</strong> <em>(<code>const wchar_t *</code>eqs, <code>const wchar_t *</code>vars, <code>mreal</code> dt=<code>1</code>)</em></dt>
<dt><a name="index-mgl_005frk_005fstep"></a>Функция С: <em><code>void</code></em> <strong>mgl_rk_step</strong> <em>(<code>HMPR</code> p, <code>const char *</code>eqs, <code>const char *</code>vars, <code>mreal</code> dt)</em></dt>
<dt><a name="index-mgl_005frk_005fstep_005fw"></a>Функция С: <em><code>void</code></em> <strong>mgl_rk_step_w</strong> <em>(<code>HMPR</code> p, <code>const wchar_t *</code>eqs, <code>const wchar_t *</code>vars, <code>mreal</code> dt)</em></dt>
<dd><p>Make one step for ordinary differential equation(s) {var1&rsquo; = eq1, ... } with time-step <var>dt</var>. Here strings <var>eqs</var> and <var>vars</var> contain the equations and variable names separated by symbol &lsquo;<samp>;</samp>&rsquo;. The variable(s) &lsquo;<samp>var1</samp>&rsquo;, ... are the ones, defined in MGL script previously. The Runge-Kutta 4-th order method is used.
</p></dd></dl>




<hr>
<a name="UDAV"></a>
<div class="header">
<p>
Next: <a href="#Other-classes" accesskey="n" rel="next">Other classes</a>, Previous: <a href="#MGL-scripts" accesskey="p" rel="prev">MGL scripts</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="UDAV-1"></a>
<h2 class="chapter">8 UDAV</h2>


<p>UDAV (Universal Data Array Visualizator) is cross-platform program for data arrays visualization based on MathGL library. It support wide spectrum of graphics, simple script language and visual data handling and editing. It has window interface for data viewing, changing and plotting. Also it can execute MGL scripts, setup and rotate graphics and so on. UDAV hot-keys can be found in the appendix <a href="#Hot_002dkeys-for-UDAV">Hot-keys for UDAV</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#UDAV-overview" accesskey="1">UDAV overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UDAV-dialogs" accesskey="2">UDAV dialogs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#UDAV-hints" accesskey="3">UDAV hints</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="UDAV-overview"></a>
<div class="header">
<p>
Next: <a href="#UDAV-dialogs" accesskey="n" rel="next">UDAV dialogs</a>, Up: <a href="#UDAV" accesskey="u" rel="up">UDAV</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="UDAV-overview-1"></a>
<h3 class="section">8.1 UDAV overview</h3>


<p>UDAV have main window divided by 2 parts in general case and optional bottom panel(s). Left side contain tabs for MGL script and data arrays. Right side contain tabs with graphics itself, with list of variables and with help on MGL. Bottom side may contain the panel with MGL messages and warnings, and the panel with calculator.
</p>
<div align="center"><img src="udav/udav_main.png" alt="Main window">
</div>
<p>Main window is shown on the figure above. You can see the script (at left) with current line highlighted by light-yellow, and result of its execution at right. Each panel have its own set of toolbuttons.
</p>
<p>Editor toolbuttons allow: open and save script from/to file; undo and redo changes; cut, copy and paste selection; find/replace text; show dialogs for command arguments and for plot setup; show calculator at bottom.
</p>
<p>Graphics toolbuttons allow: enable/disable additional transparency and lighting; show grid of absolute coordinates; enable mouse rotation; restore image view; refresh graphics (execute the script); stop calculation; copy graphics into clipboard; add primitives (line, curve, box, rhombus, ellipse, mark, text) to the image; change view angles manually. Vertical toolbuttons allow: shift and zoom in/out of image as whole; show next and previous frame of animation, or start animation (if one present).
</p>
<p>Graphics panel support plot editing by mouse.
</p><ul>
<li> Axis range can be changed by mouse wheel or by dragging image by middle mouse button. Right button show popup menu. Left button show the coordinates of mouse click. At this double click will highlight plot under mouse and jump to the corresponded string of the MGL script.
</li><li> Pressing &quot;mouse rotation&quot; toolbutton will change mouse actions: dragging by left button will rotate plot, middle button will shift the plot as whole, right button will zoom in/out plot as whole and add perspective, mouse wheel will zoom in/out plot as whole.
</li><li> Manual primitives can be added by pressing corresponding toolbutton. They can be shifted as whole at any time by mouse dragging. At this double click open dialog with its properties. If toolbutton &quot;grid of absolute coordinates&quot; is pressed then editing of active points for primitives is enabled.
</li></ul>

<div align="center"><img src="udav/udav_help.png" alt="Main window - help panel">
</div>
<p>Short command description and list of its arguments are shown at the status-bar, when you move cursor to the new line of code. You can press <tt class="key">F1</tt> to see more detailed help on special panel.
</p>
<div align="center"><img src="udav/udav_data.png" alt="Main window - data viewing">
</div>
<p>Also you can look the current list of variables, its dimensions and its size in the memory (right side of above figure). Toolbuttons allow: create new variable, edit variable, delete variable, preview variable plot and its properties, refresh list of variables. Pressing on any column will sort table according its contents. Double click on a variable will open panel with data cells of the variable, where you can view/edit each cell independently or apply a set of transformations.
</p>
<div align="center"><img src="udav/udav_calc.png" alt="Main window - calculator and messages">
</div>
<p>Finally, pressing <tt class="key">F2</tt> or <tt class="key">F4</tt> you can show/hide windows with messages/warnings and with calculator. Double click on a warning in message window will jump to corresponding line in editor. Calculator allow you type expression by keyboard as well as by toolbuttons. It know about all current variables, so you can use them in formulas.
</p>

<hr>
<a name="UDAV-dialogs"></a>
<div class="header">
<p>
Next: <a href="#UDAV-hints" accesskey="n" rel="next">UDAV hints</a>, Previous: <a href="#UDAV-overview" accesskey="p" rel="prev">UDAV overview</a>, Up: <a href="#UDAV" accesskey="u" rel="up">UDAV</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="UDAV-dialogs-1"></a>
<h3 class="section">8.2 UDAV dialogs</h3>


<p>There are a set of dialogs, which allow change/add a command, setup global plot properties, or setup UDAV itself.
</p>
<div align="center"><img src="udav/udav_cmd.png" alt="New command dialog">
</div>
<p>One of most interesting dialog (hotkey <tt class="key">Meta-C</tt> or <tt class="key">Win-C</tt>) is dialog which help to enter new command or change arguments of existed one. It allows consequently select the category of command, command name in category and appropriate set of command arguments. At this right side show detailed command description. Required argument(s) are denoted by bold text. Strings are placed in apostrophes, like <code>'txt'</code>. Buttons below table allow to call dialogs for changing style of command (if argument <code>'fmt'</code> is present in the list of command arguments); to set variable or expression for argument(s); to add options for command. Note, you can click on a cell to enter value, or double-click to call corresponding dialog.
</p>
<div align="center"><img src="udav/udav_pen.png" alt="Style dialog - pen style">
</div><div align="center"><img src="udav/udav_sch.png" alt="Style dialog - color scheme">
</div><div align="center"><img src="udav/udav_txt.png" alt="Style dialog - text style">
</div><div align="center"><img src="udav/udav_mask.png" alt="Style dialog - manual mask">
</div>
<p>Dialog for changing style can be called independently, but usually is called from <em>New command</em> dialog or by double click on primitive. It contain 3 tabs: one for pen style, one for color scheme, one for text style. You should select appropriate one. Resulting string of style and sample picture are shown at bottom of dialog. Usually it can be called from New command dialog.
</p>
<div align="center"><img src="udav/udav_var.png" alt="Variable dialog">
</div>
<p>Dialog for entering variable allow to select variable or expression which can be used as argument of a command. Here you can select the variable name; range of indexes in each directions; operation which will be applied (like, summation, finding minimal/maximal values and so on). Usually it can be called from New command dialog.
</p>
<div align="center"><img src="udav/udav_opt.png" alt="Dialog for options of a command">
</div>
<p>Dialog for command options allow to change <a href="#Command-options">Command options</a>. Usually it can be called from New command dialog.
</p>


<div align="center"><img src="udav/udav_inplot.png" alt="New inplot dialog">
</div>
<p>Another interesting dialog, which help to select and properly setup a <a href="#subplot">subplot</a>, <a href="#inplot">inplot</a>, <a href="#columnplot">columnplot</a>, <a href="#stickplot">stickplot</a> and similar commands.
</p>

<div align="center"><img src="udav/udav_gen_set.png" alt="Dialog for general properties">
</div><div align="center"><img src="udav/udav_light.png" alt="Dialog for light properties">
</div>
<p>There is dialog for setting general plot properties, including tab for setting lighting properties. It can be called by called by hotkey <tt class="key">???</tt> and put setup commands at the beginning of MGL script.
</p>
<div align="center"><img src="udav/udav_arg.png" alt="Dialog for script parameters">
</div>
<p>Also you can set or change script parameters (&lsquo;<samp>$0</samp>&rsquo; ... &lsquo;<samp>$9</samp>&rsquo;, see <a href="#MGL-definition">MGL definition</a>).
</p>
<div align="center"><img src="udav/udav_prop.png" alt="Dialog for UDAV settings">
</div>
<p>Finally, there is dialog for UDAV settings. It allow to change most of things in UDAV appearance and working, including colors of keywords and numbers, default font and image size, and so on (see figure above).
</p>
<p>There are also a set of dialogs for data handling, but they are too simple and clear. So, I will not put them here.
</p>

<hr>
<a name="UDAV-hints"></a>
<div class="header">
<p>
Previous: <a href="#UDAV-dialogs" accesskey="p" rel="prev">UDAV dialogs</a>, Up: <a href="#UDAV" accesskey="u" rel="up">UDAV</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="UDAV-hints-1"></a>
<h3 class="section">8.3 UDAV hints</h3>


<ul>
<li> You can shift axis range by pressing middle button and moving mouse. Also, you can zoom in/out axis range by using mouse wheel.
</li><li> You can rotate/shift/zoom whole plot by mouse. Just press &rsquo;Rotate&rsquo; toolbutton, click image and hold a mouse button: left button for rotation, right button for zoom/perspective, middle button for shift.
</li><li> You may quickly draw the data from file. Just use: udav &rsquo;filename.dat&rsquo; in command line.
</li><li> You can copy the current image to clipboard by pressing <tt class="key">Ctrl-Shift-C</tt>. Later you can paste it directly into yours document or presentation.
</li><li> You can export image into a set of format (EPS, SVG, PNG, JPEG) by pressing right mouse button inside image and selecting &rsquo;Export as ...&rsquo;.
</li><li> You can setup colors for script highlighting in Property dialog. Just select menu item &rsquo;Settings/Properties&rsquo;.
</li><li> You can save the parameter of animation inside MGL script by using comment started from &rsquo;##a &rsquo; or &rsquo;##c &rsquo; for loops.
</li><li> New drawing never clears things drawn already. For example, you can make a surface with contour lines by calling commands &rsquo;surf&rsquo; and &rsquo;cont&rsquo; one after another (in any order).
</li><li> You can put several plots in the same image by help of commands &rsquo;subplot&rsquo; or &rsquo;inplot&rsquo;.
</li><li> All indexes (of data arrays, subplots and so on) are always start from 0.
</li><li> You can edit MGL file in any text editor. Also you can run it in console by help of commands: <code>mglconv</code>, <code>mglview</code>.
</li><li> You can use command &rsquo;once on|off&rsquo; for marking the block which should be executed only once. For example, this can be the block of large data reading/creating/handling. Press <tt class="key">F9</tt> (or menu item &rsquo;Graphics/Reload&rsquo;) to re-execute this block.
</li><li> You can use command &rsquo;stop&rsquo; for terminating script parsing. It is useful if you don&rsquo;t want to execute a part of script.
</li><li> You can type arbitrary expression as input argument for data or number. In last case (for numbers), the first value of data array is used.
</li><li> There is powerful calculator with a lot of special functions. You can use buttons or keyboard to type the expression. Also you can use existed variables in the expression.
</li><li> The calculator can help you to put complex expression in the script. Just type the expression (which may depend on coordinates x,y,z and so on) and put it into the script.
</li><li> You can easily insert file or folder names, last fitted formula or numerical value of selection by using menu Edit|Insert.
</li><li> The special dialog (Edit|Insert|New Command) help you select the command, fill its arguments and put it into the script.
</li><li> You can put several plotting commands in the same line or in separate function, for highlighting all of them simultaneously.
</li></ul>



<hr>
<a name="Other-classes"></a>
<div class="header">
<p>
Next: <a href="#All-samples" accesskey="n" rel="next">All samples</a>, Previous: <a href="#UDAV" accesskey="p" rel="prev">UDAV</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-classes-1"></a>
<h2 class="chapter">9 Other classes</h2>


<p>There are few end-user classes: <code>mglGraph</code> (see <a href="#MathGL-core">MathGL core</a>), <code>mglWindow</code> and <code>mglGLUT</code> (see <a href="#Widget-classes">Widget classes</a>), <code>mglData</code> (see <a href="#Data-processing">Data processing</a>), <code>mglParse</code> (see <a href="#MGL-scripts">MGL scripts</a>). Exactly these classes I recommend to use in most of user programs. All methods in all of these classes are inline and have exact C/Fortran analogue functions. This give compiler independent binary libraries for MathGL.
</p>
<p>However, sometimes you may need to extend MathGL by writing yours own plotting functions or handling yours own data structures. In these cases you may need to use low-level API. This chapter describes it.
</p>
<div align="center"><img src="classes.png" alt="Class diagram for MathGL">
</div>
<p>The internal structure of MathGL is rather complicated. There are C++ classes <code>mglBase</code>, <code>mglCanvas</code>, ... for drawing primitives and positioning the plot (blue ones in the figure). There is a layer of C functions, which include interface for most important methods of these classes. Also most of plotting functions are implemented as C functions. After it, there are &ldquo;inline&rdquo; front-end classes which are created for user convenience (yellow ones in the figure). Also there are widgets for FLTK and Qt libraries (green ones in the figure).
</p>
<p>Below I show how this internal classes can be used.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#mglBase-class" accesskey="1">mglBase class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mglDataA-class" accesskey="2">mglDataA class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mglColor-class" accesskey="3">mglColor class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mglPoint-class" accesskey="4">mglPoint class</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<a name="mglBase-class"></a>
<div class="header">
<p>
Next: <a href="#mglDataA-class" accesskey="n" rel="next">mglDataA class</a>, Up: <a href="#Other-classes" accesskey="u" rel="up">Other classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Define-new-kind-of-plot-_0028mglBase-class_0029"></a>
<h3 class="section">9.1 Define new kind of plot (mglBase class)</h3>


<p>Basically most of new kinds of plot can be created using just MathGL primitives (see <a href="#Primitives">Primitives</a>). However the usage of <code>mglBase</code> methods can give you higher speed of drawing and better control of plot settings. 
</p>
<p>All plotting functions should use a pointer to <code>mglBase</code> class (or <code>HMGL</code> type in C functions) due to compatibility issues. Exactly such type of pointers are used in front-end classes (<code>mglGraph, mglWindow</code>) and in widgets (<code>QMathGL, Fl_MathGL</code>).
</p>
<p>MathGL tries to remember all vertexes and all primitives and plot creation stage, and to use them for making final picture by demand. Basically for making plot, you need to add vertexes by <code>AddPnt()</code> function, which return index for new vertex, and call one of primitive drawing function (like <code>mark_plot(), arrow_plot(), line_plot(), trig_plot(), quad_plot(), text_plot()</code>), using vertex indexes as argument(s). <code>AddPnt()</code> function use 2 mreal numbers for color specification. First one is positioning in textures &ndash; integer part is texture index, fractional part is relative coordinate in the texture. Second number is like a transparency of plot (or second coordinate in the 2D texture).
</p>
<p>I don&rsquo;t want to put here detailed description of <code>mglBase</code> class. It was rather well documented in <code>mgl2/base.h</code> file. I just show and example of its usage on the base of circle drawing.
</p>
<p>First, we should prototype new function <code>circle()</code> as C function.
</p><pre class="verbatim">#ifdef __cplusplus
extern &quot;C&quot; {
#endif
void circle(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt);
#ifdef __cplusplus
}
#endif
</pre><p>This is done for generating compiler independent binary. Because only C-functions have standard naming mechanism, the same for any compilers.
</p>
<p>Now, we create a C++ file and put the code of function. I&rsquo;ll write it line by line and try to comment all important points.
</p><pre class="verbatim">void circle(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt)
{
</pre><p>First, we need to check all input arguments and send warnings if something is wrong. In our case it is negative value of <var>r</var> argument. We just send warning, since it is not critical situation &ndash; other plot still can be drawn.
</p><pre class="verbatim">  if(r&lt;=0)  { gr-&gt;SetWarn(mglWarnNeg,&quot;Circle&quot;); return; }
</pre><p>Next step is creating a group. Group keep some general setting for plot (like options) and useful for export in 3d files.
</p><pre class="verbatim">  static int cgid=1;  gr-&gt;StartGroup(&quot;Circle&quot;,cgid++);
</pre><p>Now let apply options. Options are rather useful things, generally, which allow one easily redefine axis range(s), transparency and other settings (see <a href="#Command-options">Command options</a>).
</p><pre class="verbatim">  gr-&gt;SaveState(opt);
</pre><p>I use global setting for determining the number of points in circle approximation. Note, that user can change <code>MeshNum</code> by options easily.
</p><pre class="verbatim">  const int n = gr-&gt;MeshNum&gt;1?gr-&gt;MeshNum : 41;
</pre><p>Let try to determine plot specific flags. MathGL functions expect that most of flags will be sent in string. In our case it is symbol &lsquo;<samp>@</samp>&rsquo; which set to draw filled circle instead of border only (last will be default). Note, you have to handle <code>NULL</code> as string pointer.
</p><pre class="verbatim">  bool fill = mglchr(stl,'@');
</pre><p>Now, time for coloring. I use palette mechanism because circle have few colors: one for filling and another for border. <code>SetPenPal()</code> function parse input string and write resulting texture index in <var>pal</var>. Function return the character for marker, which can be specified in string <var>str</var>. Marker will be plotted at the center of circle. I&rsquo;ll show on next sample how you can use color schemes (smooth colors) too.
</p><pre class="verbatim">  long pal=0;
  char mk=gr-&gt;SetPenPal(stl,&amp;pal);
</pre><p>Next step, is determining colors for filling and for border. First one for filling.
</p><pre class="verbatim">  mreal c=gr-&gt;NextColor(pal), d;
</pre><p>Second one for border. I use black color (call <code>gr-&gt;AddTexture('k')</code>) if second color is not specified.
</p><pre class="verbatim">  mreal k=(gr-&gt;GetNumPal(pal)&gt;1)?gr-&gt;NextColor(pal):gr-&gt;AddTexture('k');
</pre><p>If user want draw only border (<code>fill=false</code>) then I use first color for border.
</p><pre class="verbatim">  if(!fill) k=c;
</pre><p>Now we should reserve space for vertexes. This functions need <code>n</code> for border, <code>n+1</code> for filling and <code>1</code> for marker. So, maximal number of vertexes is <code>2*n+2</code>. Note, that such reservation is not required for normal work but can sufficiently speed up the plotting.
</p><pre class="verbatim">  gr-&gt;Reserve(2*n+2);
</pre><p>We&rsquo;ve done with setup and ready to start drawing. First, we need to add vertex(es). Let define NAN as normals, since I don&rsquo;t want handle lighting for this plot,
</p><pre class="verbatim">  mglPoint q(NAN,NAN);
</pre><p>and start adding vertexes. First one for central point of filling. I use <code>-1</code> if I don&rsquo;t need this point. The arguments of <code>AddPnt()</code> function is: <code>mglPoint(x,y,z)</code> &ndash; coordinate of vertex, <code>c</code> &ndash; vertex color, <code>q</code> &ndash; normal at vertex, <code>-1</code> &ndash; vertex transparency (<code>-1</code> for default), <code>3</code> bitwise flag which show that coordinates will be scaled (<code>0x1</code>) and will not be cutted (<code>0x2</code>).
</p><pre class="verbatim">  long n0,n1,n2,m1,m2,i;
  n0 = fill ? gr-&gt;AddPnt(mglPoint(x,y,z),c,q,-1,3):-1;
</pre><p>Similar for marker, but we use different color <var>k</var>.
</p><pre class="verbatim">  n2 = mk ? gr-&gt;AddPnt(mglPoint(x,y,z),k,q,-1,3):-1;
</pre><p>Draw marker.
</p><pre class="verbatim">  if(mk)  gr-&gt;mark_plot(n2,mk);
</pre><p>Time for drawing circle itself. I use <code>-1</code> for <var>m1</var>, <var>n1</var> as sign that primitives shouldn&rsquo;t be drawn for first point <code>i=0</code>.
</p><pre class="verbatim">  for(i=0,m1=n1=-1;i&lt;n;i++)
  {
</pre><p>Each function should check <code>Stop</code> variable and return if it is non-zero. It is done for interrupting drawing for system which don&rsquo;t support multi-threading.
</p><pre class="verbatim">    if(gr-&gt;Stop)  return;
</pre><p>Let find coordinates of vertex.
</p><pre class="verbatim">    mreal t = i*2*M_PI/(n-1.);
    mglPoint p(x+r*cos(t), y+r*sin(t), z);
</pre><p>Save previous vertex and add next one
</p><pre class="verbatim">    n2 = n1;  n1 = gr-&gt;AddPnt(p,c,q,-1,3);
</pre><p>and copy it for border but with different color. Such copying is much faster than adding new vertex using <code>AddPnt()</code>.
</p><pre class="verbatim">    m2 = m1;  m1 = gr-&gt;CopyNtoC(n1,k);
</pre><p>Now draw triangle for filling internal part
</p><pre class="verbatim">    if(fill)  gr-&gt;trig_plot(n0,n1,n2);
</pre><p>and draw line for border.
</p><pre class="verbatim">    gr-&gt;line_plot(m1,m2);
  }
</pre><p>Drawing is done. Let close group and return.
</p><pre class="verbatim">  gr-&gt;EndGroup();
}
</pre>
<p>Another sample I want to show is exactly the same function but with smooth coloring using color scheme. So, I&rsquo;ll add comments only in the place of difference.
</p>
<pre class="verbatim">void circle_cs(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt)
{
</pre><p>In this case let allow negative radius too. Formally it is not the problem for plotting (formulas the same) and this allow us to handle all color range.
</p><pre class="verbatim">//if(r&lt;=0)  { gr-&gt;SetWarn(mglWarnNeg,&quot;Circle&quot;); return; }

  static int cgid=1;  gr-&gt;StartGroup(&quot;CircleCS&quot;,cgid++);
  gr-&gt;SaveState(opt);
  const int n = gr-&gt;MeshNum&gt;1?gr-&gt;MeshNum : 41;
  bool fill = mglchr(stl,'@');
</pre><p>Here is main difference. We need to create texture for color scheme specified by user
</p><pre class="verbatim">  long ss = gr-&gt;AddTexture(stl);
</pre><p>But we need also get marker and color for it (if filling is enabled). Let suppose that marker and color is specified after &lsquo;<samp>:</samp>&rsquo;. This is standard delimiter which stop color scheme entering. So, just lets find it and use for setting pen.
</p><pre class="verbatim">  const char *pen=0;
  if(stl) pen = strchr(stl,':');
  if(pen) pen++;
</pre><p>The substring is placed in <var>pen</var> and it will be used as line style.
</p><pre class="verbatim">  long pal=0;
  char mk=gr-&gt;SetPenPal(pen,&amp;pal);
</pre><p>Next step, is determining colors for filling and for border. First one for filling.
</p><pre class="verbatim">  mreal c=gr-&gt;GetC(ss,r);
</pre><p>Second one for border.
</p><pre class="verbatim">  mreal k=gr-&gt;NextColor(pal);
</pre><p>The rest part is the same as in previous function.
</p><pre class="verbatim">  if(!fill) k=c;

  gr-&gt;Reserve(2*n+2);
  mglPoint q(NAN,NAN);
  long n0,n1,n2,m1,m2,i;
  n0 = fill ? gr-&gt;AddPnt(mglPoint(x,y,z),c,q,-1,3):-1;
  n2 = mk ? gr-&gt;AddPnt(mglPoint(x,y,z),k,q,-1,3):-1;
  if(mk)  gr-&gt;mark_plot(n2,mk);
  for(i=0,m1=n1=-1;i&lt;n;i++)
  {
    if(gr-&gt;Stop)  return;
    mreal t = i*2*M_PI/(n-1.);
    mglPoint p(x+r*cos(t), y+r*sin(t), z);
    n2 = n1;  n1 = gr-&gt;AddPnt(p,c,q,-1,3);
    m2 = m1;  m1 = gr-&gt;CopyNtoC(n1,k);
    if(fill)  gr-&gt;trig_plot(n0,n1,n2);
    gr-&gt;line_plot(m1,m2);
  }
  gr-&gt;EndGroup();
}
</pre>
<p>The last thing which we can do is derive our own class with new plotting functions. Good idea is to derive it from <code>mglGraph</code> (if you don&rsquo;t need extended window), or from <code>mglWindow</code> (if you need to extend window). So, in our case it will be
</p><pre class="verbatim">class MyGraph : public mglGraph
{
public:
  inline void Circle(mglPoint p, mreal r, const char *stl=&quot;&quot;, const char *opt=&quot;&quot;)
  { circle(p.x,p.y,p.z, r, stl, opt); }
  inline void CircleCS(mglPoint p, mreal r, const char *stl=&quot;&quot;, const char *opt=&quot;&quot;)
  { circle_cs(p.x,p.y,p.z, r, stl, opt); }
};
</pre><p>Note, that I use <code>inline</code> modifier for using the same binary code with different compilers. 
</p>
<p>So, the complete sample will be
</p><pre class="verbatim">#include &lt;mgl2/mgl.h&gt;
//---------------------------------------------------------
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
void circle(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt);
void circle_cs(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt);
#ifdef __cplusplus
}
#endif
//---------------------------------------------------------
class MyGraph : public mglGraph
{
public:
  inline void CircleCF(mglPoint p, mreal r, const char *stl=&quot;&quot;, const char *opt=&quot;&quot;)
  { circle(p.x,p.y,p.z, r, stl, opt); }
  inline void CircleCS(mglPoint p, mreal r, const char *stl=&quot;&quot;, const char *opt=&quot;&quot;)
  { circle_cs(p.x,p.y,p.z, r, stl, opt); }
};
//---------------------------------------------------------
void circle(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt)
{
  if(r&lt;=0)  { gr-&gt;SetWarn(mglWarnNeg,&quot;Circle&quot;); return; }
  static int cgid=1;  gr-&gt;StartGroup(&quot;Circle&quot;,cgid++);
  gr-&gt;SaveState(opt);
  const int n = gr-&gt;MeshNum&gt;1?gr-&gt;MeshNum : 41;
  bool fill = mglchr(stl,'@');
  long pal=0;
  char mk=gr-&gt;SetPenPal(stl,&amp;pal);
  mreal c=gr-&gt;NextColor(pal), d;
  mreal k=(gr-&gt;GetNumPal(pal)&gt;1)?gr-&gt;NextColor(pal):gr-&gt;AddTexture('k');
  if(!fill) k=c;
  gr-&gt;Reserve(2*n+2);
  mglPoint q(NAN,NAN);
  long n0,n1,n2,m1,m2,i;
  n0 = fill ? gr-&gt;AddPnt(mglPoint(x,y,z),c,q,-1,3):-1;
  n2 = mk ? gr-&gt;AddPnt(mglPoint(x,y,z),k,q,-1,3):-1;
  if(mk)  gr-&gt;mark_plot(n2,mk);
  for(i=0,m1=n1=-1;i&lt;n;i++)
  {
    if(gr-&gt;Stop)  return;
    mreal t = i*2*M_PI/(n-1.);
    mglPoint p(x+r*cos(t), y+r*sin(t), z);
    n2 = n1;  n1 = gr-&gt;AddPnt(p,c,q,-1,3);
    m2 = m1;  m1 = gr-&gt;CopyNtoC(n1,k);
    if(fill)  gr-&gt;trig_plot(n0,n1,n2);
    gr-&gt;line_plot(m1,m2);
  }
  gr-&gt;EndGroup();
}
//---------------------------------------------------------
void circle_cs(HMGL gr, mreal x, mreal y, mreal z, mreal r, const char *stl, const char *opt)
{
  static int cgid=1;  gr-&gt;StartGroup(&quot;CircleCS&quot;,cgid++);
  gr-&gt;SaveState(opt);
  const int n = gr-&gt;MeshNum&gt;1?gr-&gt;MeshNum : 41;
  bool fill = mglchr(stl,'@');
  long ss = gr-&gt;AddTexture(stl);
  const char *pen=0;
  if(stl) pen = strchr(stl,':');
  if(pen) pen++;
  long pal=0;
  char mk=gr-&gt;SetPenPal(pen,&amp;pal);
  mreal c=gr-&gt;GetC(ss,r);
  mreal k=gr-&gt;NextColor(pal);
  if(!fill) k=c;

  gr-&gt;Reserve(2*n+2);
  mglPoint q(NAN,NAN);
  long n0,n1,n2,m1,m2,i;
  n0 = fill ? gr-&gt;AddPnt(mglPoint(x,y,z),c,q,-1,3):-1;
  n2 = mk ? gr-&gt;AddPnt(mglPoint(x,y,z),k,q,-1,3):-1;
  if(mk)  gr-&gt;mark_plot(n2,mk);
  for(i=0,m1=n1=-1;i&lt;n;i++)
  {
    if(gr-&gt;Stop)  return;
    mreal t = i*2*M_PI/(n-1.);
    mglPoint p(x+r*cos(t), y+r*sin(t), z);
    n2 = n1;  n1 = gr-&gt;AddPnt(p,c,q,-1,3);
    m2 = m1;  m1 = gr-&gt;CopyNtoC(n1,k);
    if(fill)  gr-&gt;trig_plot(n0,n1,n2);
    gr-&gt;line_plot(m1,m2);
  }
  gr-&gt;EndGroup();
}
//---------------------------------------------------------
int main()
{
  MyGraph gr;
  gr.Box();
  // first let draw circles with fixed colors
  for(int i=0;i&lt;10;i++)
    gr.CircleCF(mglPoint(2*mgl_rnd()-1, 2*mgl_rnd()-1), mgl_rnd());
  // now let draw circles with color scheme
  for(int i=0;i&lt;10;i++)
    gr.CircleCS(mglPoint(2*mgl_rnd()-1, 2*mgl_rnd()-1), 2*mgl_rnd()-1);
}
</pre>




<hr>
<a name="mglDataA-class"></a>
<div class="header">
<p>
Next: <a href="#mglColor-class" accesskey="n" rel="next">mglColor class</a>, Previous: <a href="#mglBase-class" accesskey="p" rel="prev">mglBase class</a>, Up: <a href="#Other-classes" accesskey="u" rel="up">Other classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="User-defined-types-_0028mglDataA-class_0029"></a>
<h3 class="section">9.2 User defined types (mglDataA class)</h3>


<p><code>mglData</code> class have abstract predecessor class <code>mglDataA</code>. Exactly the pointers to <code>mglDataA</code> instances are used in all plotting functions and some of data processing functions. This was done for taking possibility to define yours own class, which will handle yours own data (for example, complex numbers, or differently organized data). And this new class will be almost the same as <code>mglData</code> for plotting purposes.
</p>
<p>However, the most of data processing functions will be slower as if you used <code>mglData</code> instance. This is more or less understandable &ndash; I don&rsquo;t know how data in yours particular class will be organized, and couldn&rsquo;t optimize the these functions generally.
</p>
<p>There are few virtual functions which must be provided in derived classes. This functions give:
</p><ul>
<li> the sizes of the data (<code>GetNx</code>, <code>GetNy</code>, <code>GetNz</code>),
</li><li> give data value and numerical derivatives for selected cell (<code>v</code>, <code>dvx</code>, <code>dvy</code>, <code>dvz</code>),
</li><li> give maximal and minimal values (<code>Maximal</code>, <code>Minimal</code>) &ndash; you can use provided functions (like <code>mgl_data_max</code> and <code>mgl_data_min</code>), but yours own realization can be more efficient,
</li><li> give access to all element as in single array (<code>vthr</code>) &ndash; you need this only if you want using MathGL&rsquo;s data processing functions.
</li></ul>

<p>Let me, for example define class <code>mglComplex</code> which will handle complex number and draw its amplitude or phase, depending on flag <var>use_abs</var>:
</p><pre class="verbatim">#include &lt;complex&gt;
#include &lt;mgl2/mgl.h&gt;
#define dual std::complex&lt;double&gt;
class mglComplex : public mglDataA
{
public:
  long nx;      ///&lt; number of points in 1st dimensions ('x' dimension)
  long ny;      ///&lt; number of points in 2nd dimensions ('y' dimension)
  long nz;      ///&lt; number of points in 3d dimensions ('z' dimension)
  dual *a;      ///&lt; data array
  bool use_abs; ///&lt; flag to use abs() or arg()

  inline mglComplex(long xx=1,long yy=1,long zz=1)
  { a=0;  use_abs=true; Create(xx,yy,zz); }
  virtual ~mglComplex()  { if(a)  delete []a; }

  /// Get sizes
  inline long GetNx() const { return nx;  }
  inline long GetNy() const { return ny;  }
  inline long GetNz() const { return nz;  }
  /// Create or recreate the array with specified size and fill it by zero
  inline void Create(long mx,long my=1,long mz=1)
  { nx=mx;  ny=my;  nz=mz;  if(a) delete []a;
  a = new dual[nx*ny*nz]; }
  /// Get maximal value of the data
  inline mreal Maximal() const  { return mgl_data_max(this);  }
  /// Get minimal value of the data
  inline mreal Minimal() const  { return mgl_data_min(this);  }

protected:
  inline mreal v(long i,long j=0,long k=0) const
  { return use_abs ? abs(a[i+nx*(j+ny*k)]) : arg(a[i+nx*(j+ny*k)]);  }
  inline mreal vthr(long i) const
  { return use_abs ? abs(a[i]) : arg(a[i]);  }
  inline mreal dvx(long i,long j=0,long k=0) const
  { long i0=i+nx*(j+ny*k);
    std::complex&lt;double&gt; res=i&gt;0? (i&lt;nx-1? (a[i0+1]-a[i0-1])/2.:a[i0]-a[i0-1]) : a[i0+1]-a[i0];
    return use_abs? abs(res) : arg(res);  }
  inline mreal dvy(long i,long j=0,long k=0) const
  { long i0=i+nx*(j+ny*k);
    std::complex&lt;double&gt; res=j&gt;0? (j&lt;ny-1? (a[i0+nx]-a[i0-nx])/2.:a[i0]-a[i0-nx]) : a[i0+nx]-a[i0];
    return use_abs? abs(res) : arg(res);  }
  inline mreal dvz(long i,long j=0,long k=0) const
  { long i0=i+nx*(j+ny*k), n=nx*ny;
    std::complex&lt;double&gt; res=k&gt;0? (k&lt;nz-1? (a[i0+n]-a[i0-n])/2.:a[i0]-a[i0-n]) : a[i0+n]-a[i0];
    return use_abs? abs(res) : arg(res);  }
};
int main()
{
  mglComplex dat(20);
  for(long i=0;i&lt;20;i++)
    dat.a[i] = 3*exp(-0.05*(i-10)*(i-10))*dual(cos(M_PI*i*0.3), sin(M_PI*i*0.3));
  mglGraph gr;
  gr.SetRange('y', -M_PI, M_PI);  gr.Box();

  gr.Plot(dat,&quot;r&quot;,&quot;legend 'abs'&quot;);
  dat.use_abs=false;
  gr.Plot(dat,&quot;b&quot;,&quot;legend 'arg'&quot;);
  gr.Legend();
  gr.WritePNG(&quot;complex.png&quot;);
  return 0;
}
</pre>


<hr>
<a name="mglColor-class"></a>
<div class="header">
<p>
Next: <a href="#mglPoint-class" accesskey="n" rel="next">mglPoint class</a>, Previous: <a href="#mglDataA-class" accesskey="p" rel="prev">mglDataA class</a>, Up: <a href="#Other-classes" accesskey="u" rel="up">Other classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="mglColor-class-1"></a>
<h3 class="section">9.3 mglColor class</h3>

<a name="index-mglColor"></a>

<p>Structure for working with colors. This structure is defined in <code>#include &lt;mgl2/type.h&gt;</code>.
</p>
<p>There are two ways to set the color in MathGL. First one is using of mreal values of red, green and blue channels for precise color definition. The second way is the using of character id. There are a set of characters specifying frequently used colors. Normally capital letter gives more dark color than lowercase one. See <a href="#Line-styles">Line styles</a>.
</p>
<dl>
<dt><a name="index-r_002c-g_002c-b_002c-a-of-mglColor"></a>Parameter of mglColor: <em><code>mreal</code></em> <strong>r, g, b, a</strong></dt>
<dd><p>Reg, green and blue component of color.
</p></dd></dl>

<dl>
<dt><a name="index-mglColor-on-mglColor"></a>Method on mglColor: <em><code></code></em> <strong>mglColor</strong> <em>(<code>mreal</code> R, <code>mreal</code> G, <code>mreal</code> B, <code>mreal</code> A=<code>1</code>)</em></dt>
<dd><p>Constructor sets the color by mreal values of Red, Green, Blue and Alpha channels. These values should be in interval [0,1].
</p></dd></dl>
<dl>
<dt><a name="index-mglColor-on-mglColor-1"></a>Method on mglColor: <em><code></code></em> <strong>mglColor</strong> <em>(<code>char</code> c=<code>'k'</code>, <code>mreal</code> bright=<code>1</code>)</em></dt>
<dd><p>Constructor sets the color from character id. The black color is used by default. Parameter <var>br</var> set additional &ldquo;lightness&rdquo; of color.
</p></dd></dl>
<dl>
<dt><a name="index-Set-on-mglColor"></a>Method on mglColor: <em><code>void</code></em> <strong>Set</strong> <em>(<code>mreal</code> R, <code>mreal</code> G, <code>mreal</code> B, <code>mreal</code> A=<code>1</code>)</em></dt>
<dd><p>Sets color from values of Red, Green, Blue and Alpha channels. These values should be in interval [0,1].
</p></dd></dl>
<dl>
<dt><a name="index-Set-on-mglColor-1"></a>Method on mglColor: <em><code>void</code></em> <strong>Set</strong> <em>(<code>mglColor</code> c, <code>mreal</code> bright=<code>1</code>)</em></dt>
<dd><p>Sets color as &ldquo;lighted&rdquo; version of color <var>c</var>.
</p></dd></dl>
<dl>
<dt><a name="index-Set-on-mglColor-2"></a>Method on mglColor: <em><code>void</code></em> <strong>Set</strong> <em>(<code>char</code> p, <code>mreal</code> bright=<code>1</code>)</em></dt>
<dd><p>Sets color from symbolic id.
</p></dd></dl>
<dl>
<dt><a name="index-Valid-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>Valid</strong> <em>()</em></dt>
<dd><p>Checks correctness of the color.
</p></dd></dl>
<dl>
<dt><a name="index-Norm-on-mglColor"></a>Method on mglColor: <em><code>mreal</code></em> <strong>Norm</strong> <em>()</em></dt>
<dd><p>Gets maximal of spectral component.
</p></dd></dl>
<dl>
<dt><a name="index-operator_003d_003d-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>operator==</strong> <em>(<code>const mglColor &amp;</code>c)</em></dt>
<dt><a name="index-operator_0021_003d-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>operator!=</strong> <em>(<code>const mglColor &amp;</code>c)</em></dt>
<dd><p>Compare with another color
</p></dd></dl>

<dl>
<dt><a name="index-operator_002a_003d-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>operator*=</strong> <em>(<code>mreal</code> v)</em></dt>
<dd><p>Multiplies color components by number <var>v</var>.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002b_003d-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>operator+=</strong> <em>(<code>const mglColor &amp;</code>c)</em></dt>
<dd><p>Adds color <var>c</var> component by component.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002d_003d-on-mglColor"></a>Method on mglColor: <em><code>bool</code></em> <strong>operator-=</strong> <em>(<code>const mglColor &amp;</code>c)</em></dt>
<dd><p>Subtracts color <var>c</var> component by component.
</p></dd></dl>


<dl>
<dt><a name="index-operator_002b-3"></a>Library Function: <em>mglColor</em> <strong>operator+</strong> <em>(<code>const mglColor &amp;</code>a, <code>const mglColor &amp;</code>b)</em></dt>
<dd><p>Adds colors by its RGB values.
</p></dd></dl>
<dl>
<dt><a name="index-operator_002d-3"></a>Library Function: <em><code>mglColor</code></em> <strong>operator-</strong> <em>(<code>const mglColor &amp;</code>a, <code>const mglColor &amp;</code>b)</em></dt>
<dd><p>Subtracts colors by its RGB values.
</p></dd></dl>
<dl>
<dt><a name="index-operator_002a-3"></a>Library Function: <em><code>mglColor</code></em> <strong>operator*</strong> <em>(<code>const mglColor &amp;</code>a, <code>mreal</code> b)</em></dt>
<dt><a name="index-operator_002a-4"></a>Library Function: <em><code>mglColor</code></em> <strong>operator*</strong> <em>(<code>mreal</code> a, <code>const mglColor &amp;</code>b)</em></dt>
<dd><p>Multiplies color by number.
</p></dd></dl>
<dl>
<dt><a name="index-operator_002f-2"></a>Library Function: <em><code>mglColor</code></em> <strong>operator/</strong> <em>(<code>const mglColor &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Divide color by number.
</p></dd></dl>
<dl>
<dt><a name="index-operator_0021"></a>Library Function: <em><code>mglColor</code></em> <strong>operator!</strong> <em>(<code>const mglColor &amp;</code>a)</em></dt>
<dd><p>Return inverted color.
</p></dd></dl>


<hr>
<a name="mglPoint-class"></a>
<div class="header">
<p>
Previous: <a href="#mglColor-class" accesskey="p" rel="prev">mglColor class</a>, Up: <a href="#Other-classes" accesskey="u" rel="up">Other classes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="mglPoint-class-1"></a>
<h3 class="section">9.4 mglPoint class</h3>

<a name="index-mglPoint"></a>

<p>Structure describes point in space. This structure is defined in <code>#include &lt;mgl2/type.h&gt;</code>
</p>
<dl>
<dt><a name="index-x_002c-y_002c-z_002c-c-of-mglPoint"></a>Parameter of mglPoint: <em><code>mreal</code></em> <strong>x, y, z, c</strong></dt>
<dd><p>Point coordinates {x,y,z} and one extra value <var>c</var> used for amplitude, transparency and so on. By default all values are zero.
</p></dd></dl>

<dl>
<dt><a name="index-mglPoint-on-mglPoint"></a>Method on mglPoint: <em><code></code></em> <strong>mglPoint</strong> <em>(<code>mreal</code> X=<code>0</code>, <code>mreal</code> Y=<code>0</code>, <code>mreal</code> Z=<code>0</code>, <code>mreal</code> C=<code>0</code>)</em></dt>
<dd><p>Constructor sets the color by mreal values of Red, Green, Blue and Alpha channels. These values should be in interval [0,1].
</p></dd></dl>

<dl>
<dt><a name="index-IsNAN-on-mglPoint"></a>Method on mglPoint: <em><code>bool</code></em> <strong>IsNAN</strong> <em>()</em></dt>
<dd><p>Returns <code>true</code> if point contain NAN values.
</p></dd></dl>
<dl>
<dt><a name="index-norm-on-mglPoint"></a>Method on mglPoint: <em><code>mreal</code></em> <strong>norm</strong> <em>()</em></dt>
<dd><p>Returns the norm <em>\sqrt{x^2+y^2+z^2}</em> of vector.
</p></dd></dl>
<dl>
<dt><a name="index-Normalize-on-mglPoint"></a>Method on mglPoint: <em><code>void</code></em> <strong>Normalize</strong> <em>()</em></dt>
<dd><p>Normalizes vector to be unit vector.
</p></dd></dl>
<dl>
<dt><a name="index-val-on-mglPoint"></a>Method on mglPoint: <em><code>mreal</code></em> <strong>val</strong> <em>(<code>int</code> i)</em></dt>
<dd><p>Returns point component: <var>x</var> for <var>i</var>=0, <var>y</var> for <var>i</var>=1, <var>z</var> for <var>i</var>=2, <var>c</var> for <var>i</var>=3.
</p></dd></dl>


<dl>
<dt><a name="index-operator_002b-4"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator+</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Point of summation (summation of vectors).
</p></dd></dl>
<dl>
<dt><a name="index-operator_002d-4"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator-</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Point of difference (difference of vectors).
</p></dd></dl>
<dl>
<dt><a name="index-operator_002a-5"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator*</strong> <em>(<code>mreal</code> a, <code>const mglPoint &amp;</code>b)</em></dt>
<dt><a name="index-operator_002a-6"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator*</strong> <em>(<code>const mglPoint &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Multiplies (scale) points by number.
</p></dd></dl>
<dl>
<dt><a name="index-operator_002f-3"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator/</strong> <em>(<code>const mglPoint &amp;</code>a, <code>mreal</code> b)</em></dt>
<dd><p>Multiplies (scale) points by number 1/b.
</p></dd></dl>
<dl>
<dt><a name="index-operator_002a-7"></a>Library Function: <em><code>mreal</code></em> <strong>operator*</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Scalar product of vectors.
</p></dd></dl>

<dl>
<dt><a name="index-operator_002f-4"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator/</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Return vector of element-by-element product.
</p></dd></dl>

<dl>
<dt><a name="index-operator_005e"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator^</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Cross-product of vectors.
</p></dd></dl>
<dl>
<dt><a name="index-operator_0026"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator&amp;</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>The part of <var>a</var> which is perpendicular to vector <var>b</var>.
</p></dd></dl>
<dl>
<dt><a name="index-operator_007c"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator|</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>The part of <var>a</var> which is parallel to vector <var>b</var>.
</p></dd></dl>

<dl>
<dt><a name="index-operator_0021-1"></a>Library Function: <em><code>mglPoint</code></em> <strong>operator!</strong> <em>(<code>const mglPoint &amp;</code>a)</em></dt>
<dd><p>Return vector perpendicular to vector <var>a</var>.
</p></dd></dl>
<dl>
<dt><a name="index-mgl_005fnorm"></a>Library Function: <em><code>mreal</code></em> <strong>mgl_norm</strong> <em>(<code>const mglPoint &amp;</code>a)</em></dt>
<dd><p>Return the norm sqrt(|<var>a</var>|^2) of vector <var>a</var>.
</p></dd></dl>

<dl>
<dt><a name="index-operator_003d_003d"></a>Library Function: <em><code>bool</code></em> <strong>operator==</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Return true if points are the same.
</p></dd></dl>
<dl>
<dt><a name="index-operator_0021_003d"></a>Library Function: <em><code>bool</code></em> <strong>operator!=</strong> <em>(<code>const mglPoint &amp;</code>a, <code>const mglPoint &amp;</code>b)</em></dt>
<dd><p>Return true if points are different.
</p></dd></dl>




<hr>
<a name="All-samples"></a>
<div class="header">
<p>
Next: <a href="#Symbols-and-hot_002dkeys" accesskey="n" rel="next">Symbols and hot-keys</a>, Previous: <a href="#Other-classes" accesskey="p" rel="prev">Other classes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="All-samples-1"></a>
<h2 class="chapter">10 All samples</h2>


<p>This chapter contain alphabetical list of MGL and C++ samples for most of MathGL graphics and features.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#initialization-sample" accesskey="1">initialization sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t3wave-sample" accesskey="2">3wave sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#alpha-sample" accesskey="3">alpha sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#apde-sample" accesskey="4">apde sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#area-sample" accesskey="5">area sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#aspect-sample" accesskey="6">aspect sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#axial-sample" accesskey="7">axial sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#axis-sample" accesskey="8">axis sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#barh-sample" accesskey="9">barh sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bars-sample">bars sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#belt-sample">belt sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#bifurcation-sample">bifurcation sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#box-sample">box sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#boxplot-sample">boxplot sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#boxs-sample">boxs sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#candle-sample">candle sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#chart-sample">chart sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cloud-sample">cloud sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#colorbar-sample">colorbar sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#combined-sample">combined sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cones-sample">cones sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cont-sample">cont sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cont3-sample">cont3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cont_005fxyz-sample">cont_xyz sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#contd-sample">contd sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#contf-sample">contf sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#contf3-sample">contf3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#contf_005fxyz-sample">contf_xyz sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#contv-sample">contv sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#correl-sample">correl sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#curvcoor-sample">curvcoor sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#cut-sample">cut sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dat_005fdiff-sample">dat_diff sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dat_005fextra-sample">dat_extra sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#data1-sample">data1 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#data2-sample">data2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dens-sample">dens sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dens3-sample">dens3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dens_005fxyz-sample">dens_xyz sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#detect-sample">detect sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dew-sample">dew sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#diffract-sample">diffract sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dilate-sample">dilate sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#dots-sample">dots sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#earth-sample">earth sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#error-sample">error sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#error2-sample">error2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#export-sample">export sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#fall-sample">fall sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#fexport-sample">fexport sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#fit-sample">fit sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#flame2d-sample">flame2d sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#flow-sample">flow sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#flow3-sample">flow3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#fog-sample">fog sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#fonts-sample">fonts sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#grad-sample">grad sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#hist-sample">hist sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ifs2d-sample">ifs2d sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ifs3d-sample">ifs3d sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#indirect-sample">indirect sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#inplot-sample">inplot sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#iris-sample">iris sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#label-sample">label sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#lamerey-sample">lamerey sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#legend-sample">legend sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#light-sample">light sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#loglog-sample">loglog sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#map-sample">map sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mark-sample">mark sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mask-sample">mask sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mesh-sample">mesh sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#mirror-sample">mirror sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#molecule-sample">molecule sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ode-sample">ode sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ohlc-sample">ohlc sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#param1-sample">param1 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#param2-sample">param2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#param3-sample">param3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#paramv-sample">paramv sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#parser-sample">parser sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pde-sample">pde sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pendelta-sample">pendelta sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pipe-sample">pipe sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#plot-sample">plot sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pmap-sample">pmap sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#primitives-sample">primitives sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#projection-sample">projection sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#projection5-sample">projection5 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pulse-sample">pulse sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#qo2d-sample">qo2d sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality0-sample">quality0 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality1-sample">quality1 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality2-sample">quality2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality4-sample">quality4 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality5-sample">quality5 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality6-sample">quality6 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#quality8-sample">quality8 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#radar-sample">radar sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#refill-sample">refill sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#region-sample">region sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#scanfile-sample">scanfile sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#schemes-sample">schemes sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#section-sample">section sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#several_005flight-sample">several_light sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#solve-sample">solve sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#stem-sample">stem sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#step-sample">step sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#stereo-sample">stereo sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#stfa-sample">stfa sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#style-sample">style sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surf-sample">surf sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surf3-sample">surf3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surf3a-sample">surf3a sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surf3c-sample">surf3c sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surf3ca-sample">surf3ca sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surfa-sample">surfa sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surfc-sample">surfc sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#surfca-sample">surfca sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#table-sample">table sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tape-sample">tape sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tens-sample">tens sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ternary-sample">ternary sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#text-sample">text sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#text2-sample">text2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#textmark-sample">textmark sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ticks-sample">ticks sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tile-sample">tile sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tiles-sample">tiles sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#torus-sample">torus sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#traj-sample">traj sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#triangulation-sample">triangulation sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#triplot-sample">triplot sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tube-sample">tube sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#type0-sample">type0 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#type1-sample">type1 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#type2-sample">type2 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#vect-sample">vect sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#vect3-sample">vect3 sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#venn-sample">venn sample</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="initialization-sample"></a>
<div class="header">
<p>
Next: <a href="#g_t3wave-sample" accesskey="n" rel="next">3wave sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Functions-for-initialization"></a>
<h3 class="section">10.1 Functions for initialization</h3>


<p>This section contain functions for input data for most of further samples.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">
func 'prepare1d'
new y 50 3
modify y '0.7*sin(2*pi*x)+0.5*cos(3*pi*x)+0.2*sin(pi*x)'
modify y 'sin(2*pi*x)' 1
modify y 'cos(2*pi*x)' 2
new x1 50 'x'
new x2 50 '0.05-0.03*cos(pi*x)'
new y1 50 '0.5-0.3*cos(pi*x)'
new y2 50 '-0.3*sin(pi*x)'
return

func 'prepare2d'
new a 50 40 '0.6*sin(pi*(x+1))*sin(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
new b 50 40 '0.6*cos(pi*(x+1))*cos(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
return

func 'prepare3d'
new c 61 50 40 '-2*(x^2+y^2+z^4-z^2)+0.2'
new d 61 50 40 '1-2*tanh((x+y)*(x+y))'
return

func 'prepare2v'
new a 20 30 '0.6*sin(pi*(x+1))*sin(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
new b 20 30 '0.6*cos(pi*(x+1))*cos(1.5*pi*(y+1))+0.4*cos(0.75*pi*(x+1)*(y+1))'
return

func 'prepare3v'
define $1 pow(x*x+y*y+(z-0.3)*(z-0.3)+0.03,1.5)
define $2 pow(x*x+y*y+(z+0.3)*(z+0.3)+0.03,1.5)
new ex 10 10 10 '0.2*x/$1-0.2*x/$2'
new ey 10 10 10 '0.2*y/$1-0.2*y/$2'
new ez 10 10 10 '0.2*(z-0.3)/$1-0.2*(z+0.3)/$2'
return
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void mgls_prepare1d(mglData *y, mglData *y1, mglData *y2, mglData *x1, mglData *x2)
{
	long n=50;
	if(y)	y-&gt;Create(n,3);
	if(x1)	x1-&gt;Create(n);
	if(x2)	x2-&gt;Create(n);
	if(y1)	y1-&gt;Create(n);
	if(y2)	y2-&gt;Create(n);
	for(long i=0;i&lt;n;i++)
	{
		double xx = i/(n-1.);
		if(y)
		{
			y-&gt;a[i] = 0.7*sin(2*M_PI*xx) + 0.5*cos(3*M_PI*xx) + 0.2*sin(M_PI*xx);
			y-&gt;a[i+n] = sin(2*M_PI*xx);
			y-&gt;a[i+2*n] = cos(2*M_PI*xx);
		}
		if(y1)	y1-&gt;a[i] = 0.5+0.3*cos(2*M_PI*xx);
		if(y2)	y2-&gt;a[i] = 0.3*sin(2*M_PI*xx);
		if(x1)	x1-&gt;a[i] = xx*2-1;
		if(x2)	x2-&gt;a[i] = 0.05+0.03*cos(2*M_PI*xx);
	}
}
//-----------------------------------------------------------------------------
void mgls_prepare2d(mglData *a, mglData *b, mglData *v)
{
	long n=50,m=40;
	if(a)	a-&gt;Create(n,m);
	if(b)	b-&gt;Create(n,m);
	if(v)	{	v-&gt;Create(9);	v-&gt;Fill(-1,1);	}
	for(long j=0;j&lt;m;j++)	for(long i=0;i&lt;n;i++)
	{
		double x = i/(n-1.), y = j/(m-1.);
		long i0 = i+n*j;
		if(a)	a-&gt;a[i0] = 0.6*sin(2*M_PI*x)*sin(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
		if(b)	b-&gt;a[i0] = 0.6*cos(2*M_PI*x)*cos(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
	}
}
//-----------------------------------------------------------------------------
void mgls_prepare3d(mglData *a, mglData *b)
{
	long n=61,m=50,l=40;
	if(a)	a-&gt;Create(n,m,l);
	if(b)	b-&gt;Create(n,m,l);
	for(long k=0;k&lt;l;k++)	for(long j=0;j&lt;m;j++)	for(long i=0;i&lt;n;i++)
	{
		double x=2*i/(n-1.)-1, y=2*j/(m-1.)-1, z=2*k/(l-1.)-1;
		long i0 = i+n*(j+m*k);
		if(a)	a-&gt;a[i0] = -2*(x*x + y*y + z*z*z*z - z*z - 0.1);
		if(b)	b-&gt;a[i0] = 1-2*tanh((x+y)*(x+y));
	}
}
//-----------------------------------------------------------------------------
void mgls_prepare2v(mglData *a, mglData *b)
{
	long n=20,m=30;
	if(a)	a-&gt;Create(n,m);
	if(b)	b-&gt;Create(n,m);
	for(long j=0;j&lt;m;j++)	for(long i=0;i&lt;n;i++)
	{
		double x=i/(n-1.), y=j/(m-1.);
		long i0 = i+n*j;
		if(a)	a-&gt;a[i0] = 0.6*sin(2*M_PI*x)*sin(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
		if(b)	b-&gt;a[i0] = 0.6*cos(2*M_PI*x)*cos(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
	}
}
//-----------------------------------------------------------------------------
void mgls_prepare3v(mglData *ex, mglData *ey, mglData *ez)
{
	long n=10;
	double z0=0.3;
	if(!ex || !ey || !ez)	return;
	ex-&gt;Create(n,n,n);	ey-&gt;Create(n,n,n);	ez-&gt;Create(n,n,n);
	for(long k=0;k&lt;n;k++)	for(long j=0;j&lt;n;j++)	for(long i=0;i&lt;n;i++)
	{
		double x=2*i/(n-1.)-1, y=2*j/(n-1.)-1, z=2*k/(n-1.)-1;
		long i0 = i+n*(j+k*n);
		double r1 = pow(x*x+y*y+(z-z0)*(z-z0)+0.03,1.5);
		double r2 = pow(x*x+y*y+(z+z0)*(z+z0)+0.03,1.5);
		ex-&gt;a[i0]=0.2*x/r1 - 0.2*x/r2;
		ey-&gt;a[i0]=0.2*y/r1 - 0.2*y/r2;
		ez-&gt;a[i0]=0.2*(z-z0)/r1 - 0.2*(z+z0)/r2;
	}
}
//-----------------------------------------------------------------------------

</pre>

<hr>
<a name="g_t3wave-sample"></a>
<div class="header">
<p>
Next: <a href="#alpha-sample" accesskey="n" rel="next">alpha sample</a>, Previous: <a href="#initialization-sample" accesskey="p" rel="prev">initialization sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-3wave"></a>
<h3 class="section">10.2 Sample &lsquo;<samp>3wave</samp>&rsquo;</h3>


<p>Example of complex <a href="#ode">ode</a> on basis of 3-wave decay.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">define t 50
ode !r '-b*f;a*conj(f);a*conj(b)-0.1*f' 'abf' [1,1e-3,0] 0.1 t
ranges 0 t 0 r.max
plot r(0) 'b';legend 'a'
plot r(1) 'g';legend 'b'
plot r(2) 'r';legend 'f'
axis:box:legend
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_3wave(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Complex ODE sample&quot;);
	double t=50;
	mglData ini;	ini.SetList(3, 1., 1e-3, 0.);
	mglDataC r(mglODEc(&quot;-b*f;a*conj(f);a*conj(b)-0.1*f&quot;,&quot;abf&quot;,ini,0.1,t));
	gr-&gt;SetRanges(0, t, 0, r.Maximal());
	gr-&gt;Plot(r.SubData(0),&quot;b&quot;,&quot;legend 'a'&quot;);
	gr-&gt;Plot(r.SubData(1),&quot;g&quot;,&quot;legend 'b'&quot;);
	gr-&gt;Plot(r.SubData(2),&quot;r&quot;,&quot;legend 'f'&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Legend();
}
</pre><div align="center"><img src="png/3wave.png" alt="Sample 3wave">
</div>
<hr>
<a name="alpha-sample"></a>
<div class="header">
<p>
Next: <a href="#apde-sample" accesskey="n" rel="next">apde sample</a>, Previous: <a href="#g_t3wave-sample" accesskey="p" rel="prev">3wave sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-alpha"></a>
<h3 class="section">10.3 Sample &lsquo;<samp>alpha</samp>&rsquo;</h3>


<p>Example of <a href="#light">light</a> and <a href="#alpha">alpha</a> (transparency).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
subplot 2 2 0:title 'default':rotate 50 60:box
surf a
subplot 2 2 1:title 'light on':rotate 50 60:box
light on:surf a
subplot 2 2 3:title 'light on; alpha on':rotate 50 60:box
alpha on:surf a
subplot 2 2 2:title 'alpha on':rotate 50 60:box
light off:surf a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_alpha(mglGraph *gr)	// alpha and lighting
{
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;default&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;light on&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Light(true);	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;alpha on; light on&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Alpha(true);	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;alpha on&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Light(false);	gr-&gt;Surf(a);
}
</pre><div align="center"><img src="png/alpha.png" alt="Sample alpha">
</div>
<hr>
<a name="apde-sample"></a>
<div class="header">
<p>
Next: <a href="#area-sample" accesskey="n" rel="next">area sample</a>, Previous: <a href="#alpha-sample" accesskey="p" rel="prev">alpha sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-apde"></a>
<h3 class="section">10.4 Sample &lsquo;<samp>apde</samp>&rsquo;</h3>


<p>Comparison of advanced PDE solver (<a href="#apde">apde</a>) and ordinary one (<a href="#pde">pde</a>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">ranges -1 1 0 2 0 2
new ar 256 'exp(-2*(x+0.0)^2)'
new ai 256

apde res1 'exp(-x^2-p^2)' ar ai 0.01:transpose res1
pde res2 'exp(-x^2-p^2)' ar ai 0.01

subplot 1 2 0 '_':title 'Advanced PDE solver'
ranges 0 2 -1 1:crange res1
dens res1:box
axis:xlabel '\i z':ylabel '\i x'
text -0.5 0.2 'i\partial_z\i u = exp(-\i x^2+\partial_x^2)[\i u]' 'y'

subplot 1 2 1 '_':title 'Simplified PDE solver'
dens res2:box
axis:xlabel '\i z':ylabel '\i x'
text -0.5 0.2 'i\partial_z\i u \approx\ exp(-\i x^2)\i u+exp(\partial_x^2)[\i u]' 'y'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_apde(mglGraph *gr)
{
	gr-&gt;SetRanges(-1,1,0,2,0,2);
	mglData ar(256), ai(256);	gr-&gt;Fill(ar,&quot;exp(-2*(x+0.0)^2)&quot;);

	mglData res1(gr-&gt;APDE(&quot;exp(-x^2-p^2)&quot;,ar,ai,0.01));	res1.Transpose();
	mglData res2(gr-&gt;PDE(&quot;exp(-x^2-p^2)&quot;,ar,ai,0.01));

	gr-&gt;SubPlot(1,2,0,&quot;_&quot;);	gr-&gt;Title(&quot;Advanced PDE solver&quot;);
	gr-&gt;SetRanges(0,2,-1,1);	gr-&gt;SetRange('c',res1);
	gr-&gt;Dens(res1);	gr-&gt;Axis();	gr-&gt;Box();
	gr-&gt;Label('x',&quot;\\i z&quot;);	gr-&gt;Label('y',&quot;\\i x&quot;);
	gr-&gt;Puts(mglPoint(-0.5,0.2),&quot;i\\partial_z\\i u = exp(-\\i x^2+\\partial_x^2)[\\i u]&quot;,&quot;y&quot;);

	gr-&gt;SubPlot(1,2,1,&quot;_&quot;);	gr-&gt;Title(&quot;Simplified PDE solver&quot;);
	gr-&gt;Dens(res2);	gr-&gt;Axis();	gr-&gt;Box();
	gr-&gt;Label('x',&quot;\\i z&quot;);	gr-&gt;Label('y',&quot;\\i x&quot;);
	gr-&gt;Puts(mglPoint(-0.5,0.2),&quot;i\\partial_z\\i u \\approx\\ exp(-\\i x^2)\\i u+exp(\\partial_x^2)[\\i u]&quot;,&quot;y&quot;);
}
</pre><div align="center"><img src="png/apde.png" alt="Sample apde">
</div>
<hr>
<a name="area-sample"></a>
<div class="header">
<p>
Next: <a href="#aspect-sample" accesskey="n" rel="next">aspect sample</a>, Previous: <a href="#apde-sample" accesskey="p" rel="prev">apde sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-area"></a>
<h3 class="section">10.5 Sample &lsquo;<samp>area</samp>&rsquo;</h3>


<p>Function <a href="#area">area</a> fill the area between curve and axis plane. It support gradient filling if 2 colors per curve is specified.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
origin 0 0 0
subplot 2 2 0 '':title 'Area plot (default)':box:area y
subplot 2 2 1 '':title '2 colors':box:area y 'cbgGyr'
subplot 2 2 2 '':title '&quot;!&quot; style':box:area y '!'
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 2 2 3:title '3d variant':rotate 50 60:box
area xc yc z 'r'
area xc -yc z 'b#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_area(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Area plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Area(y);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;2 colors&quot;);	gr-&gt;Box();	gr-&gt;Area(y,&quot;cbgGyr&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'!' style&quot;);	gr-&gt;Box();	gr-&gt;Area(y,&quot;!&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	gr-&gt;Area(xc,yc,z,&quot;r&quot;);
	yc.Modify(&quot;-sin(pi*(2*x-1))&quot;);	gr-&gt;Area(xc,yc,z,&quot;b#&quot;);
}
</pre><div align="center"><img src="png/area.png" alt="Sample area">
</div>
<hr>
<a name="aspect-sample"></a>
<div class="header">
<p>
Next: <a href="#axial-sample" accesskey="n" rel="next">axial sample</a>, Previous: <a href="#area-sample" accesskey="p" rel="prev">area sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-aspect"></a>
<h3 class="section">10.6 Sample &lsquo;<samp>aspect</samp>&rsquo;</h3>


<p>Example of <a href="#subplot">subplot</a>, <a href="#inplot">inplot</a>, <a href="#rotate">rotate</a>, <a href="#aspect">aspect</a>, <a href="#shear">shear</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0:box:text -1 1.1 'Just box' ':L'
inplot 0.2 0.5 0.7 1 off:box:text 0 1.2 'InPlot example'
subplot 2 2 1:title 'Rotate only':rotate 50 60:box
subplot 2 2 2:title 'Rotate and Aspect':rotate 50 60:aspect 1 1 2:box
subplot 2 2 3:title 'Shear':box 'c':shear 0.2 0.1:box
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_aspect(mglGraph *gr)	// transformation
{
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Box();
	gr-&gt;Puts(mglPoint(-1,1.1),&quot;Just box&quot;,&quot;:L&quot;);
	gr-&gt;InPlot(0.2,0.5,0.7,1,false);	gr-&gt;Box();
	gr-&gt;Puts(mglPoint(0,1.2),&quot;InPlot example&quot;);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Rotate only&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Rotate and Aspect&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Aspect(1,1,2);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Shear&quot;);
	gr-&gt;Box(&quot;c&quot;);		gr-&gt;Shear(0.2,0.1);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/aspect.png" alt="Sample aspect">
</div>
<hr>
<a name="axial-sample"></a>
<div class="header">
<p>
Next: <a href="#axis-sample" accesskey="n" rel="next">axis sample</a>, Previous: <a href="#aspect-sample" accesskey="p" rel="prev">aspect sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-axial"></a>
<h3 class="section">10.7 Sample &lsquo;<samp>axial</samp>&rsquo;</h3>


<p>Function <a href="#axial">axial</a> draw surfaces of rotation for contour lines. You can draw wire surfaces (&lsquo;<samp>#</samp>&rsquo; style) or ones rotated in other directions (&lsquo;<samp>x</samp>&rsquo;, &lsquo;<samp>z</samp>&rsquo; styles).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
subplot 2 2 0:title 'Axial plot (default)':light on:alpha on:rotate 50 60:box:axial a
subplot 2 2 1:title '&quot;x&quot; style;&quot;.&quot; style':light on:rotate 50 60:box:axial a 'x.'
subplot 2 2 2:title '&quot;z&quot; style':light on:rotate 50 60:box:axial a 'z'
subplot 2 2 3:title '&quot;\#&quot; style':light on:rotate 50 60:box:axial a '#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_axial(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Axial plot (default)&quot;);	}
	gr-&gt;Light(true);	gr-&gt;Alpha(true);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Axial(a);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'x' style; '.'style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Axial(a,&quot;x.&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'z' style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Axial(a,&quot;z&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;'\\#' style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Axial(a,&quot;#&quot;);
}
</pre><div align="center"><img src="png/axial.png" alt="Sample axial">
</div>
<hr>
<a name="axis-sample"></a>
<div class="header">
<p>
Next: <a href="#barh-sample" accesskey="n" rel="next">barh sample</a>, Previous: <a href="#axial-sample" accesskey="p" rel="prev">axial sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-axis"></a>
<h3 class="section">10.8 Sample &lsquo;<samp>axis</samp>&rsquo;</h3>


<p>Different forms of <a href="#axis">axis</a> position.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0:title 'Axis origin, Grid':origin 0 0:axis:grid:fplot 'x^3'
subplot 2 2 1:title '2 axis':ranges -1 1 -1 1:origin -1 -1:axis:ylabel 'axis_1':fplot 'sin(pi*x)' 'r2'
ranges 0 1 0 1:origin 1 1:axis:ylabel 'axis_2':fplot 'cos(pi*x)'
subplot 2 2 3:title 'More axis':origin nan nan:xrange -1 1:axis:xlabel 'x' 0:ylabel 'y_1' 0:fplot 'x^2' 'k'
yrange -1 1:origin -1.3 -1:axis 'y' 'r':ylabel '#r{y_2}' 0.2:fplot 'x^3' 'r'

subplot 2 2 2:title '4 segments, inverted axis':origin 0 0:
inplot 0.5 1 0.5 1 on:ranges 0 10 0 2:axis
fplot 'sqrt(x/2)':xlabel 'W' 1:ylabel 'U' 1
inplot 0 0.5 0.5 1 on:ranges 1 0 0 2:axis 'x':fplot 'sqrt(x)+x^3':xlabel '\tau' 1
inplot 0.5 1 0 0.5 on:ranges 0 10 4 0:axis 'y':fplot 'x/4':ylabel 'L' -1
inplot 0 0.5 0 0.5 on:ranges 1 0 4 0:fplot '4*x^2'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_axis(mglGraph *gr)
{
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Axis origin, Grid&quot;);	gr-&gt;SetOrigin(0,0);
	gr-&gt;Axis();	gr-&gt;Grid();	gr-&gt;FPlot(&quot;x^3&quot;);

	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;2 axis&quot;);
	gr-&gt;SetRanges(-1,1,-1,1);	gr-&gt;SetOrigin(-1,-1,-1);	// first axis
	gr-&gt;Axis();	gr-&gt;Label('y',&quot;axis 1&quot;,0);	gr-&gt;FPlot(&quot;sin(pi*x)&quot;,&quot;r2&quot;);
	gr-&gt;SetRanges(0,1,0,1);		gr-&gt;SetOrigin(1,1,1);		// second axis
	gr-&gt;Axis();	gr-&gt;Label('y',&quot;axis 2&quot;,0);	gr-&gt;FPlot(&quot;cos(pi*x)&quot;);

	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;More axis&quot;);	gr-&gt;SetOrigin(NAN,NAN);	gr-&gt;SetRange('x',-1,1);
	gr-&gt;Axis();	gr-&gt;Label('x',&quot;x&quot;,0);	gr-&gt;Label('y',&quot;y_1&quot;,0);	gr-&gt;FPlot(&quot;x^2&quot;,&quot;k&quot;);
	gr-&gt;SetRanges(-1,1,-1,1);	gr-&gt;SetOrigin(-1.3,-1);	// second axis
	gr-&gt;Axis(&quot;y&quot;,&quot;r&quot;);	gr-&gt;Label('y',&quot;#r{y_2}&quot;,0.2);	gr-&gt;FPlot(&quot;x^3&quot;,&quot;r&quot;);

	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;4 segments, inverted axis&quot;);		gr-&gt;SetOrigin(0,0);
	gr-&gt;InPlot(0.5,1,0.5,1);	gr-&gt;SetRanges(0,10,0,2);	gr-&gt;Axis();
	gr-&gt;FPlot(&quot;sqrt(x/2)&quot;);		gr-&gt;Label('x',&quot;W&quot;,1);	gr-&gt;Label('y',&quot;U&quot;,1);
	gr-&gt;InPlot(0,0.5,0.5,1);	gr-&gt;SetRanges(1,0,0,2);	gr-&gt;Axis(&quot;x&quot;);
	gr-&gt;FPlot(&quot;sqrt(x)+x^3&quot;);	gr-&gt;Label('x',&quot;\\tau&quot;,-1);
	gr-&gt;InPlot(0.5,1,0,0.5);	gr-&gt;SetRanges(0,10,4,0);	gr-&gt;Axis(&quot;y&quot;);
	gr-&gt;FPlot(&quot;x/4&quot;);	gr-&gt;Label('y',&quot;L&quot;,-1);
	gr-&gt;InPlot(0,0.5,0,0.5);	gr-&gt;SetRanges(1,0,4,0);	gr-&gt;FPlot(&quot;4*x^2&quot;);
}
</pre><div align="center"><img src="png/axis.png" alt="Sample axis">
</div>
<hr>
<a name="barh-sample"></a>
<div class="header">
<p>
Next: <a href="#bars-sample" accesskey="n" rel="next">bars sample</a>, Previous: <a href="#axis-sample" accesskey="p" rel="prev">axis sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-barh"></a>
<h3 class="section">10.9 Sample &lsquo;<samp>barh</samp>&rsquo;</h3>


<p>Function <a href="#barh">barh</a> is the similar to <a href="#bars">bars</a> but draw horizontal bars.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ys 10 3 '0.8*sin(pi*(x+y/4+1.25))+0.2*rnd':origin 0 0 0
subplot 2 2 0 '':title 'Barh plot (default)':box:barh ys
subplot 2 2 1 '':title '2 colors':box:barh ys 'cbgGyr'
ranges -3 3 -1 1:subplot 2 2 2 '':title '&quot;a&quot; style':box:barh ys 'a'
subplot 2 2 3 '': title '&quot;f&quot; style':box:barh ys 'f'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_barh(mglGraph *gr)
{
	mglData ys(10,3);	ys.Modify(&quot;0.8*sin(pi*(2*x+y/2))+0.2*rnd&quot;);
	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Barh plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Barh(ys);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;2 colors&quot;);	gr-&gt;Box();	gr-&gt;Barh(ys,&quot;cbgGyr&quot;);
	gr-&gt;SetRanges(-3,3,-1,1);	// increase range since summation can exceed [-1,1]
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'a' style&quot;);	gr-&gt;Box();	gr-&gt;Barh(ys,&quot;a&quot;);
	gr-&gt;SubPlot(2,2,3,&quot;&quot;);	gr-&gt;Title(&quot;'f' style&quot;);	gr-&gt;Box();	gr-&gt;Barh(ys,&quot;f&quot;);
}
</pre><div align="center"><img src="png/barh.png" alt="Sample barh">
</div>
<hr>
<a name="bars-sample"></a>
<div class="header">
<p>
Next: <a href="#belt-sample" accesskey="n" rel="next">belt sample</a>, Previous: <a href="#barh-sample" accesskey="p" rel="prev">barh sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-bars"></a>
<h3 class="section">10.10 Sample &lsquo;<samp>bars</samp>&rsquo;</h3>


<p>Function <a href="#bars">bars</a> draw vertical bars. It have a lot of options: bar-above-bar (&lsquo;<samp>a</samp>&rsquo; style), fall like (&lsquo;<samp>f</samp>&rsquo; style), 2 colors for positive and negative values, wired bars (&lsquo;<samp>#</samp>&rsquo; style), 3D variant.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ys 10 3 '0.8*sin(pi*(x+y/4+1.25))+0.2*rnd':origin 0 0 0
subplot 3 2 0 '':title 'Bars plot (default)':box:bars ys
subplot 3 2 1 '':title '2 colors':box:bars ys 'cbgGyr'
subplot 3 2 4 '':title '&quot;\#&quot; style':box:bars ys '#'
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 3 2 5:title '3d variant':rotate 50 60:box:bars xc yc z 'r'
ranges -1 1 -3 3:subplot 3 2 2 '':title '&quot;a&quot; style':box:bars ys 'a'
subplot 3 2 3 '':title '&quot;f&quot; style':box:bars ys 'f'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_bars(mglGraph *gr)
{
	mglData ys(10,3);	ys.Modify(&quot;0.8*sin(pi*(2*x+y/2))+0.2*rnd&quot;);
	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(3,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Bars plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Bars(ys);
	if(big==3)	return;
	gr-&gt;SubPlot(3,2,1,&quot;&quot;);	gr-&gt;Title(&quot;2 colors&quot;);	gr-&gt;Box();	gr-&gt;Bars(ys,&quot;cbgGyr&quot;);
	gr-&gt;SubPlot(3,2,4,&quot;&quot;);	gr-&gt;Title(&quot;'\\#' style&quot;);	gr-&gt;Box();	gr-&gt;Bars(ys,&quot;#&quot;);
	gr-&gt;SubPlot(3,2,5);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	gr-&gt;Bars(xc,yc,z,&quot;r&quot;);
	gr-&gt;SetRanges(-1,1,-3,3);	// increase range since summation can exceed [-1,1]
	gr-&gt;SubPlot(3,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'a' style&quot;);	gr-&gt;Box();	gr-&gt;Bars(ys,&quot;a&quot;);
	gr-&gt;SubPlot(3,2,3,&quot;&quot;);	gr-&gt;Title(&quot;'f' style&quot;);	gr-&gt;Box();	gr-&gt;Bars(ys,&quot;f&quot;);
}
</pre><div align="center"><img src="png/bars.png" alt="Sample bars">
</div>
<hr>
<a name="belt-sample"></a>
<div class="header">
<p>
Next: <a href="#bifurcation-sample" accesskey="n" rel="next">bifurcation sample</a>, Previous: <a href="#bars-sample" accesskey="p" rel="prev">bars sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-belt"></a>
<h3 class="section">10.11 Sample &lsquo;<samp>belt</samp>&rsquo;</h3>


<p>Function <a href="#belt">belt</a> draw surface by belts. You can use &lsquo;<samp>x</samp>&rsquo; style for drawing lines in other direction.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Belt plot':rotate 50 60:box:belt a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_belt(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Belt plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Belt(a);
}
</pre><div align="center"><img src="png/belt.png" alt="Sample belt">
</div>
<hr>
<a name="bifurcation-sample"></a>
<div class="header">
<p>
Next: <a href="#box-sample" accesskey="n" rel="next">box sample</a>, Previous: <a href="#belt-sample" accesskey="p" rel="prev">belt sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-bifurcation"></a>
<h3 class="section">10.12 Sample &lsquo;<samp>bifurcation</samp>&rsquo;</h3>


<p>Function <a href="#bifurcation">bifurcation</a> draw Bifurcation diagram for multiple stationary points of the map (like logistic map).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_':title 'Bifurcation sample'
ranges 0 4 0 1:axis
bifurcation 0.005 'x*y*(1-y)' 'r'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_bifurcation(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Bifurcation sample&quot;);
	gr-&gt;SetRanges(0,4,0,1);	gr-&gt;Axis();
	gr-&gt;Bifurcation(0.005,&quot;x*y*(1-y)&quot;,&quot;r&quot;);
}
</pre><div align="center"><img src="png/bifurcation.png" alt="Sample bifurcation">
</div>
<hr>
<a name="box-sample"></a>
<div class="header">
<p>
Next: <a href="#boxplot-sample" accesskey="n" rel="next">boxplot sample</a>, Previous: <a href="#bifurcation-sample" accesskey="p" rel="prev">bifurcation sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-box"></a>
<h3 class="section">10.13 Sample &lsquo;<samp>box</samp>&rsquo;</h3>


<p>Different styles of bounding <a href="#box">box</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0:title 'Box (default)':rotate 50 60:box
subplot 2 2 1:title 'colored':rotate 50 60:box 'r'
subplot 2 2 2:title 'with faces':rotate 50 60:box '@'
subplot 2 2 3:title 'both':rotate 50 60:box '@cm'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_boxplot(mglGraph *gr)	// flow threads and density plot
{
	mglData a(10,7);	a.Modify(&quot;(2*rnd-1)^3/2&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Boxplot plot&quot;);	}
	gr-&gt;Box();	gr-&gt;BoxPlot(a);
}
</pre><div align="center"><img src="png/box.png" alt="Sample box">
</div>
<hr>
<a name="boxplot-sample"></a>
<div class="header">
<p>
Next: <a href="#boxs-sample" accesskey="n" rel="next">boxs sample</a>, Previous: <a href="#box-sample" accesskey="p" rel="prev">box sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-boxplot"></a>
<h3 class="section">10.14 Sample &lsquo;<samp>boxplot</samp>&rsquo;</h3>


<p>Function <a href="#boxplot">boxplot</a> draw box-and-whisker diagram.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 10 7 '(2*rnd-1)^3/2'
subplot 1 1 0 '':title 'Boxplot plot':box:boxplot a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_boxplot(mglGraph *gr)	// flow threads and density plot
{
	mglData a(10,7);	a.Modify(&quot;(2*rnd-1)^3/2&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Boxplot plot&quot;);	}
	gr-&gt;Box();	gr-&gt;BoxPlot(a);
}
</pre><div align="center"><img src="png/boxplot.png" alt="Sample boxplot">
</div>
<hr>
<a name="boxs-sample"></a>
<div class="header">
<p>
Next: <a href="#candle-sample" accesskey="n" rel="next">candle sample</a>, Previous: <a href="#boxplot-sample" accesskey="p" rel="prev">boxplot sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-boxs"></a>
<h3 class="section">10.15 Sample &lsquo;<samp>boxs</samp>&rsquo;</h3>


<p>Function <a href="#boxs">boxs</a> draw surface by boxes. You can use &lsquo;<samp>#</samp>&rsquo; for drawing wire plot.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
origin 0 0 0
subplot 2 2 0:title 'Boxs plot (default)':rotate 40 60:light on:box:boxs a
subplot 2 2 1:title '&quot;\@&quot; style':rotate 50 60:box:boxs a '@'
subplot 2 2 2:title '&quot;\#&quot; style':rotate 50 60:box:boxs a '#'
subplot 2 2 3:title 'compare with Tile':rotate 50 60:box:tile a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_boxs(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Light(true);
	if(big!=3)	{gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Boxs plot (default)&quot;);}
	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Boxs(a);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'\\@' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Boxs(a,&quot;@&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'\\#' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Boxs(a,&quot;#&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;compare with Tile&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Tile(a);
}
</pre><div align="center"><img src="png/boxs.png" alt="Sample boxs">
</div>
<hr>
<a name="candle-sample"></a>
<div class="header">
<p>
Next: <a href="#chart-sample" accesskey="n" rel="next">chart sample</a>, Previous: <a href="#boxs-sample" accesskey="p" rel="prev">boxs sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-candle"></a>
<h3 class="section">10.16 Sample &lsquo;<samp>candle</samp>&rsquo;</h3>


<p>Function <a href="#candle">candle</a> draw candlestick chart. This is a combination of a line-chart and a bar-chart, in that each bar represents the range of price movement over a given time interval.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new y 30 'sin(pi*x/2)^2'
subplot 1 1 0 '':title 'Candle plot (default)'
yrange 0 1:box
candle y y/2 (y+1)/2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_candle(mglGraph *gr)
{
	mglData y(30);	gr-&gt;Fill(y,&quot;sin(pi*x/2)^2&quot;);
	mglData y1(30);	gr-&gt;Fill(y1,&quot;v/2&quot;,y);
	mglData y2(30);	gr-&gt;Fill(y2,&quot;(1+v)/2&quot;,y);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Candle plot (default)&quot;);	}
	gr-&gt;SetRange('y',0,1);	gr-&gt;Box();	gr-&gt;Candle(y,y1,y2);
}
</pre><div align="center"><img src="png/candle.png" alt="Sample candle">
</div>
<hr>
<a name="chart-sample"></a>
<div class="header">
<p>
Next: <a href="#cloud-sample" accesskey="n" rel="next">cloud sample</a>, Previous: <a href="#candle-sample" accesskey="p" rel="prev">candle sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-chart"></a>
<h3 class="section">10.17 Sample &lsquo;<samp>chart</samp>&rsquo;</h3>


<p>Function <a href="#chart">chart</a> draw colored boxes with width proportional to data values. Use &lsquo;<samp> </samp>&rsquo; for empty box. It produce well known pie chart if drawn in polar coordinates.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ch 7 2 'rnd+0.1':light on
subplot 2 2 0:title 'Chart plot (default)':rotate 50 60:box:chart ch
subplot 2 2 1:title '&quot;\#&quot; style':rotate 50 60:box:chart ch '#'
subplot 2 2 2:title 'Pie chart; &quot; &quot; color':rotate 50 60:
axis '(y+1)/2*cos(pi*x)' '(y+1)/2*sin(pi*x)' '':box:chart ch 'bgr cmy#'
subplot 2 2 3:title 'Ring chart; &quot; &quot; color':rotate 50 60:
axis '(y+2)/3*cos(pi*x)' '(y+2)/3*sin(pi*x)' '':box:chart ch 'bgr cmy#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_chart(mglGraph *gr)
{
	mglData ch(7,2);	for(int i=0;i&lt;7*2;i++)	ch.a[i]=mgl_rnd()+0.1;
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Chart plot (default)&quot;);	}
	gr-&gt;Light(true);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Chart(ch);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'\\#' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Chart(ch,&quot;#&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Pie chart; ' ' color&quot;);
	gr-&gt;SetFunc(&quot;(y+1)/2*cos(pi*x)&quot;,&quot;(y+1)/2*sin(pi*x)&quot;,&quot;&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Chart(ch,&quot;bgr cmy#&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Ring chart; ' ' color&quot;);
	gr-&gt;SetFunc(&quot;(y+2)/3*cos(pi*x)&quot;,&quot;(y+2)/3*sin(pi*x)&quot;,&quot;&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Chart(ch,&quot;bgr cmy#&quot;);
}
</pre><div align="center"><img src="png/chart.png" alt="Sample chart">
</div>
<hr>
<a name="cloud-sample"></a>
<div class="header">
<p>
Next: <a href="#colorbar-sample" accesskey="n" rel="next">colorbar sample</a>, Previous: <a href="#chart-sample" accesskey="p" rel="prev">chart sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cloud"></a>
<h3 class="section">10.18 Sample &lsquo;<samp>cloud</samp>&rsquo;</h3>


<p>Function <a href="#cloud">cloud</a> draw cloud-like object which is less transparent for higher data values. Similar plot can be created using many (about 10...20 &ndash; <code>surf3a a a;value 10</code>) isosurfaces <a href="#surf3a">surf3a</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
subplot 2 2 0:title 'Cloud plot':rotate 50 60:alpha on:box:cloud c 'wyrRk'
subplot 2 2 1:title '&quot;i&quot; style':rotate 50 60:box:cloud c 'iwyrRk'
subplot 2 2 2:title '&quot;.&quot; style':rotate 50 60:box:cloud c '.wyrRk'
subplot 2 2 3:title 'meshnum 10':rotate 50 60:box:cloud c 'wyrRk'; meshnum 10
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cloud(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Cloud plot&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Cloud(c,&quot;wyrRk&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'i' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cloud(c,&quot;iwyrRk&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'.' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cloud(c,&quot;.wyrRk&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;meshnum 10&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cloud(c,&quot;wyrRk&quot;,&quot;meshnum 10&quot;);
}
</pre><div align="center"><img src="png/cloud.png" alt="Sample cloud">
</div>
<hr>
<a name="colorbar-sample"></a>
<div class="header">
<p>
Next: <a href="#combined-sample" accesskey="n" rel="next">combined sample</a>, Previous: <a href="#cloud-sample" accesskey="p" rel="prev">cloud sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-colorbar"></a>
<h3 class="section">10.19 Sample &lsquo;<samp>colorbar</samp>&rsquo;</h3>


<p>Example of <a href="#colorbar">colorbar</a> position and styles.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
new v 9 'x'
subplot 2 2 0:title 'Colorbar out of box':box
colorbar '&lt;':colorbar '&gt;':colorbar '_':colorbar '^'
subplot 2 2 1:title 'Colorbar near box':box
colorbar '&lt;I':colorbar '&gt;I':colorbar '_I':colorbar '^I'
subplot 2 2 2:title 'manual colors':box:contd v a
colorbar v '&lt;':colorbar v '&gt;':colorbar v '_':colorbar v '^'
subplot 2 2 3:title '':text -0.5 1.55 'Color positions' ':C' -2
colorbar 'bwr&gt;' 0.25 0:text -0.9 1.2 'Default'
colorbar 'b{w,0.3}r&gt;' 0.5 0:text -0.1 1.2 'Manual'
crange 0.01 1e3
colorbar '&gt;' 0.75 0:text 0.65 1.2 'Normal scale':colorbar '&gt;':text 1.35 1.2 'Log scale'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_colorbar(mglGraph *gr)
{
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Colorbar out of box&quot;);	gr-&gt;Box();
	gr-&gt;Colorbar(&quot;&lt;&quot;);	gr-&gt;Colorbar(&quot;&gt;&quot;);	gr-&gt;Colorbar(&quot;_&quot;);	gr-&gt;Colorbar(&quot;^&quot;);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Colorbar near box&quot;);		gr-&gt;Box();
	gr-&gt;Colorbar(&quot;&lt;I&quot;);	gr-&gt;Colorbar(&quot;&gt;I&quot;);	gr-&gt;Colorbar(&quot;_I&quot;);	gr-&gt;Colorbar(&quot;^I&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;manual colors&quot;);
	mglData a,v;	mgls_prepare2d(&amp;a,0,&amp;v);
	gr-&gt;Box();	gr-&gt;ContD(v,a);
	gr-&gt;Colorbar(v,&quot;&lt;&quot;);	gr-&gt;Colorbar(v,&quot;&gt;&quot;);	gr-&gt;Colorbar(v,&quot;_&quot;);	gr-&gt;Colorbar(v,&quot;^&quot;);

	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot; &quot;);
	gr-&gt;Puts(mglPoint(-0.5,1.55),&quot;Color positions&quot;,&quot;:C&quot;,-2);
	gr-&gt;Colorbar(&quot;bwr&gt;&quot;,0.25,0);	gr-&gt;Puts(mglPoint(-0.9,1.2),&quot;Default&quot;);
	gr-&gt;Colorbar(&quot;b{w,0.3}r&gt;&quot;,0.5,0);	gr-&gt;Puts(mglPoint(-0.1,1.2),&quot;Manual&quot;);

	gr-&gt;Puts(mglPoint(1,1.55),&quot;log-scale&quot;,&quot;:C&quot;,-2);
	gr-&gt;SetRange('c',0.01,1e3);
	gr-&gt;Colorbar(&quot;&gt;&quot;,0.75,0);	gr-&gt;Puts(mglPoint(0.65,1.2),&quot;Normal scale&quot;);
	gr-&gt;SetFunc(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;lg(c)&quot;);
	gr-&gt;Colorbar(&quot;&gt;&quot;);		gr-&gt;Puts(mglPoint(1.35,1.2),&quot;Log scale&quot;);
}
</pre><div align="center"><img src="png/colorbar.png" alt="Sample colorbar">
</div>
<hr>
<a name="combined-sample"></a>
<div class="header">
<p>
Next: <a href="#cones-sample" accesskey="n" rel="next">cones sample</a>, Previous: <a href="#colorbar-sample" accesskey="p" rel="prev">colorbar sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-combined"></a>
<h3 class="section">10.20 Sample &lsquo;<samp>combined</samp>&rsquo;</h3>


<p>Example of several plots in the same axis.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2v'
call 'prepare3d'
new v 10:fill v -0.5 1:copy d sqrt(a^2+b^2)
subplot 2 2 0:title 'Surf + Cont':rotate 50 60:light on:box:surf a:cont a 'y'
subplot 2 2 1 '':title 'Flow + Dens':light off:box:flow a b 'br':dens d
subplot 2 2 2:title 'Mesh + Cont':rotate 50 60:box:mesh a:cont a '_'
subplot 2 2 3:title 'Surf3 + ContF3':rotate 50 60:light on
box:contf3 v c 'z' 0:contf3 v c 'x':contf3 v c
cut 0 -1 -1 1 0 1.1
contf3 v c 'z' c.nz-1:surf3 c -0.5
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_combined(mglGraph *gr)	// flow threads and density plot
{
	mglData a,b,d;	mgls_prepare2v(&amp;a,&amp;b);	d = a;
	for(int i=0;i&lt;a.nx*a.ny;i++)	d.a[i] = hypot(a.a[i],b.a[i]);
	mglData c;	mgls_prepare3d(&amp;c);
	mglData v(10);	v.Fill(-0.5,1);
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;Flow + Dens&quot;);
	gr-&gt;Flow(a,b,&quot;br&quot;);	gr-&gt;Dens(d);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Surf + Cont&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Light(true);	gr-&gt;Surf(a);	gr-&gt;Cont(a,&quot;y&quot;);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Mesh + Cont&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Mesh(a);	gr-&gt;Cont(a,&quot;_&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Surf3 + ContF3&quot;);gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;ContF3(v,c,&quot;z&quot;,0);	gr-&gt;ContF3(v,c,&quot;x&quot;);	gr-&gt;ContF3(v,c);
	gr-&gt;SetCutBox(mglPoint(0,-1,-1), mglPoint(1,0,1.1));
	gr-&gt;ContF3(v,c,&quot;z&quot;,c.nz-1);	gr-&gt;Surf3(-0.5,c);
}
</pre><div align="center"><img src="png/combined.png" alt="Sample combined">
</div>
<hr>
<a name="cones-sample"></a>
<div class="header">
<p>
Next: <a href="#cont-sample" accesskey="n" rel="next">cont sample</a>, Previous: <a href="#combined-sample" accesskey="p" rel="prev">combined sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cones"></a>
<h3 class="section">10.21 Sample &lsquo;<samp>cones</samp>&rsquo;</h3>


<p>Function <a href="#cones">cones</a> is similar to <a href="#bars">bars</a> but draw cones.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ys 10 3 '0.8*sin(pi*(x+y/4+1.25))+0.2*rnd'
light on:origin 0 0 0
subplot 3 2 0:title 'Cones plot':rotate 50 60:box:cones ys
subplot 3 2 1:title '2 colors':rotate 50 60:box:cones ys 'cbgGyr'
subplot 3 2 2:title '&quot;\#&quot; style':rotate 50 60:box:cones ys '#'
subplot 3 2 3:title '&quot;a&quot; style':rotate 50 60:zrange -2 2:box:cones ys 'a'
subplot 3 2 4:title '&quot;t&quot; style':rotate 50 60:box:cones ys 't'
subplot 3 2 5:title '&quot;4&quot; style':rotate 50 60:box:cones ys '4'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cones(mglGraph *gr)
{
	mglData ys(10,3);	ys.Modify(&quot;0.8*sin(pi*(2*x+y/2))+0.2*rnd&quot;);
	gr-&gt;Light(true);	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(3,2,0);	gr-&gt;Title(&quot;Cones plot&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys);
	if(big==3)	return;
	gr-&gt;SubPlot(3,2,1);	gr-&gt;Title(&quot;2 colors&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys,&quot;cbgGyr&quot;);
	gr-&gt;SubPlot(3,2,2);	gr-&gt;Title(&quot;'\\#' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys,&quot;#&quot;);
	gr-&gt;SubPlot(3,2,3);	gr-&gt;Title(&quot;'a' style&quot;);
	gr-&gt;SetRange('z',-2,2);	// increase range since summation can exceed [-1,1]
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys,&quot;a&quot;);
	gr-&gt;SubPlot(3,2,4);	gr-&gt;Title(&quot;'t' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys,&quot;t&quot;);
	gr-&gt;SubPlot(3,2,5);	gr-&gt;Title(&quot;'4' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Cones(ys,&quot;4&quot;);
}
</pre><div align="center"><img src="png/cones.png" alt="Sample cones">
</div>
<hr>
<a name="cont-sample"></a>
<div class="header">
<p>
Next: <a href="#cont3-sample" accesskey="n" rel="next">cont3 sample</a>, Previous: <a href="#cones-sample" accesskey="p" rel="prev">cones sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cont"></a>
<h3 class="section">10.22 Sample &lsquo;<samp>cont</samp>&rsquo;</h3>


<p>Function <a href="#cont">cont</a> draw contour lines for surface. You can select automatic (default) or manual levels for contours, print contour labels, draw it on the surface (default) or at plane (as <code>Dens</code>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
list v -0.5 -0.15 0 0.15 0.5
subplot 2 2 0:title 'Cont plot (default)':rotate 50 60:box:cont a
subplot 2 2 1:title 'manual levels':rotate 50 60:box:cont v a
subplot 2 2 2:title '&quot;\_&quot; and &quot;.&quot; styles':rotate 50 60:box:cont a '_':cont a '_.2k'
subplot 2 2 3 '':title '&quot;t&quot; style':box:cont a 't'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cont3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Cont3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	gr-&gt;Cont3(c,&quot;x&quot;);	gr-&gt;Cont3(c);	gr-&gt;Cont3(c,&quot;z&quot;);
}
</pre><div align="center"><img src="png/cont.png" alt="Sample cont">
</div>
<hr>
<a name="cont3-sample"></a>
<div class="header">
<p>
Next: <a href="#cont_005fxyz-sample" accesskey="n" rel="next">cont_xyz sample</a>, Previous: <a href="#cont-sample" accesskey="p" rel="prev">cont sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cont3"></a>
<h3 class="section">10.23 Sample &lsquo;<samp>cont3</samp>&rsquo;</h3>


<p>Function <a href="#contf3">contf3</a> draw ordinary contour lines but at slices of 3D data. 
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Cont3 sample':rotate 50 60:box
cont3 c 'x':cont3 c:cont3 c 'z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cont3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Cont3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	gr-&gt;Cont3(c,&quot;x&quot;);	gr-&gt;Cont3(c);	gr-&gt;Cont3(c,&quot;z&quot;);
}
</pre><div align="center"><img src="png/cont3.png" alt="Sample cont3">
</div>
<hr>
<a name="cont_005fxyz-sample"></a>
<div class="header">
<p>
Next: <a href="#contd-sample" accesskey="n" rel="next">contd sample</a>, Previous: <a href="#cont3-sample" accesskey="p" rel="prev">cont3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cont_005fxyz"></a>
<h3 class="section">10.24 Sample &lsquo;<samp>cont_xyz</samp>&rsquo;</h3>


<p>Functions <a href="#contz">contz</a>, <a href="#conty">conty</a>, <a href="#contx">contx</a> draw contour lines on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Cont[XYZ] sample':rotate 50 60:box
contx {sum c 'x'} '' -1:conty {sum c 'y'} '' 1:contz {sum c 'z'} '' -1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cont_xyz(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Cont[XYZ] sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContX(c.Sum(&quot;x&quot;),&quot;&quot;,-1);
	gr-&gt;ContY(c.Sum(&quot;y&quot;),&quot;&quot;,1);		gr-&gt;ContZ(c.Sum(&quot;z&quot;),&quot;&quot;,-1);
}
</pre><div align="center"><img src="png/cont_xyz.png" alt="Sample cont_xyz">
</div>
<hr>
<a name="contd-sample"></a>
<div class="header">
<p>
Next: <a href="#contf-sample" accesskey="n" rel="next">contf sample</a>, Previous: <a href="#cont_005fxyz-sample" accesskey="p" rel="prev">cont_xyz sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-contd"></a>
<h3 class="section">10.25 Sample &lsquo;<samp>contd</samp>&rsquo;</h3>


<p>Function <a href="#contd">contd</a> is similar to <a href="#contf">contf</a> but with manual contour colors.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
list v -0.5 -0.15 0 0.15 0.5
new a1 30 40 3 '0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)'
subplot 2 2 0:title 'ContD plot (default)':rotate 50 60:box:contd a
subplot 2 2 1:title 'manual levels':rotate 50 60:box:contd v a
subplot 2 2 2:title '&quot;\_&quot; style':rotate 50 60:box:contd a '_'
subplot 2 2 3:title 'several slices':rotate 50 60:box:contd a1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_contd(mglGraph *gr)
{
	mglData a,v(5),a1(30,40,3);	mgls_prepare2d(&amp;a);	v.a[0]=-0.5;
	v.a[1]=-0.15;	v.a[2]=0;	v.a[3]=0.15;	v.a[4]=0.5;
	gr-&gt;Fill(a1,&quot;0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)&quot;);

	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;ContD plot (default)&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContD(a);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;manual levels&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContD(v,a);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'\\_' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContD(a,&quot;_&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;several slices&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContD(a1);
}
</pre><div align="center"><img src="png/contd.png" alt="Sample contd">
</div>
<hr>
<a name="contf-sample"></a>
<div class="header">
<p>
Next: <a href="#contf3-sample" accesskey="n" rel="next">contf3 sample</a>, Previous: <a href="#contd-sample" accesskey="p" rel="prev">contd sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-contf"></a>
<h3 class="section">10.26 Sample &lsquo;<samp>contf</samp>&rsquo;</h3>


<p>Function <a href="#contf">contf</a> draw filled contours.  You can select automatic (default) or manual levels for contours.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
list v -0.5 -0.15 0 0.15 0.5
new a1 30 40 3 '0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)'
subplot 2 2 0:title 'ContF plot (default)':rotate 50 60:box:contf a
subplot 2 2 1:title 'manual levels':rotate 50 60:box:contf v a
subplot 2 2 2:title '&quot;\_&quot; style':rotate 50 60:box:contf a '_'
subplot 2 2 3:title 'several slices':rotate 50 60:box:contf a1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_contf3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;ContF3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Box();
	gr-&gt;ContF3(c,&quot;x&quot;);	gr-&gt;ContF3(c);		gr-&gt;ContF3(c,&quot;z&quot;);
	gr-&gt;Cont3(c,&quot;kx&quot;);	gr-&gt;Cont3(c,&quot;k&quot;);	gr-&gt;Cont3(c,&quot;kz&quot;);
}
</pre><div align="center"><img src="png/contf.png" alt="Sample contf">
</div>
<hr>
<a name="contf3-sample"></a>
<div class="header">
<p>
Next: <a href="#contf_005fxyz-sample" accesskey="n" rel="next">contf_xyz sample</a>, Previous: <a href="#contf-sample" accesskey="p" rel="prev">contf sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-contf3"></a>
<h3 class="section">10.27 Sample &lsquo;<samp>contf3</samp>&rsquo;</h3>


<p>Function <a href="#contf3">contf3</a> draw ordinary filled contours but at slices of 3D data. 
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Cont3 sample':rotate 50 60:box:light on
contf3 c 'x':contf3 c:contf3 c 'z'
cont3 c 'xk':cont3 c 'k':cont3 c 'zk'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_contf3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;ContF3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Box();
	gr-&gt;ContF3(c,&quot;x&quot;);	gr-&gt;ContF3(c);		gr-&gt;ContF3(c,&quot;z&quot;);
	gr-&gt;Cont3(c,&quot;kx&quot;);	gr-&gt;Cont3(c,&quot;k&quot;);	gr-&gt;Cont3(c,&quot;kz&quot;);
}
</pre><div align="center"><img src="png/contf3.png" alt="Sample contf3">
</div>
<hr>
<a name="contf_005fxyz-sample"></a>
<div class="header">
<p>
Next: <a href="#contv-sample" accesskey="n" rel="next">contv sample</a>, Previous: <a href="#contf3-sample" accesskey="p" rel="prev">contf3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-contf_005fxyz"></a>
<h3 class="section">10.28 Sample &lsquo;<samp>contf_xyz</samp>&rsquo;</h3>


<p>Functions <a href="#contfz">contfz</a>, <a href="#contfy">contfy</a>, <a href="#contfx">contfx</a>, draw filled contours on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'ContF[XYZ] sample':rotate 50 60:box
contfx {sum c 'x'} '' -1:contfy {sum c 'y'} '' 1:contfz {sum c 'z'} '' -1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_contf_xyz(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;ContF[XYZ] sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContFX(c.Sum(&quot;x&quot;),&quot;&quot;,-1);
	gr-&gt;ContFY(c.Sum(&quot;y&quot;),&quot;&quot;,1);	gr-&gt;ContFZ(c.Sum(&quot;z&quot;),&quot;&quot;,-1);
}
</pre><div align="center"><img src="png/contf_xyz.png" alt="Sample contf_xyz">
</div>
<hr>
<a name="contv-sample"></a>
<div class="header">
<p>
Next: <a href="#correl-sample" accesskey="n" rel="next">correl sample</a>, Previous: <a href="#contf_005fxyz-sample" accesskey="p" rel="prev">contf_xyz sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-contv"></a>
<h3 class="section">10.29 Sample &lsquo;<samp>contv</samp>&rsquo;</h3>


<p>Function <a href="#contv">contv</a> draw vertical cylinders (belts) at contour lines.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
list v -0.5 -0.15 0 0.15 0.5
subplot 2 2 0:title 'ContV plot (default)':rotate 50 60:box:contv a
subplot 2 2 1:title 'manual levels':rotate 50 60:box:contv v a
subplot 2 2 2:title '&quot;\_&quot; style':rotate 50 60:box:contv a '_'
subplot 2 2 3:title 'ContV and ContF':rotate 50 60:light on:box
contv a:contf a:cont a 'k'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_contv(mglGraph *gr)
{
	mglData a,v(5);	mgls_prepare2d(&amp;a);	v.a[0]=-0.5;
	v.a[1]=-0.15;	v.a[2]=0;	v.a[3]=0.15;	v.a[4]=0.5;
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;ContV plot (default)&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContV(a);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;manual levels&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContV(v,a);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'\\_' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;ContV(a,&quot;_&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;ContV and ContF&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Light(true);
	gr-&gt;ContV(a);	gr-&gt;ContF(a);	gr-&gt;Cont(a,&quot;k&quot;);
}
</pre><div align="center"><img src="png/contv.png" alt="Sample contv">
</div>
<hr>
<a name="correl-sample"></a>
<div class="header">
<p>
Next: <a href="#curvcoor-sample" accesskey="n" rel="next">curvcoor sample</a>, Previous: <a href="#contv-sample" accesskey="p" rel="prev">contv sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-correl"></a>
<h3 class="section">10.30 Sample &lsquo;<samp>correl</samp>&rsquo;</h3>


<p>Test of correlation function (<a href="#correl">correl</a>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 100 'exp(-10*x^2)'
new b 100 'exp(-10*(x+0.5)^2)'
yrange 0 1
subplot 1 2 0 '_':title 'Input fields'
plot a:plot b:box:axis
correl r a b 'x'
norm r 0 1:swap r 'x' # make it human readable
subplot 1 2 1 '_':title 'Correlation of a and b'
plot r 'r':axis:box
line 0.5 0 0.5 1 'B|'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_correl(mglGraph *gr)
{
	mglData a(100),b(100);
	gr-&gt;Fill(a,&quot;exp(-10*x^2)&quot;);	gr-&gt;Fill(b,&quot;exp(-10*(x+0.5)^2)&quot;);
	gr-&gt;SetRange('y',0,1);
	gr-&gt;SubPlot(1,2,0,&quot;_&quot;);	gr-&gt;Title(&quot;Input fields&quot;);
	gr-&gt;Plot(a);	gr-&gt;Plot(b);	gr-&gt;Axis();	gr-&gt;Box();
	mglData r = a.Correl(b,&quot;x&quot;);
	r.Norm(0,1);	r.Swap(&quot;x&quot;);	// make it human readable
	gr-&gt;SubPlot(1,2,1,&quot;_&quot;);	gr-&gt;Title(&quot;Correlation of a and b&quot;);
	gr-&gt;Plot(r,&quot;r&quot;);	gr-&gt;Axis();	gr-&gt;Box();
	gr-&gt;Line(mglPoint(0.5,0),mglPoint(0.5,1),&quot;B|&quot;);
}
</pre><div align="center"><img src="png/correl.png" alt="Sample correl">
</div>
<hr>
<a name="curvcoor-sample"></a>
<div class="header">
<p>
Next: <a href="#cut-sample" accesskey="n" rel="next">cut sample</a>, Previous: <a href="#correl-sample" accesskey="p" rel="prev">correl sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-curvcoor"></a>
<h3 class="section">10.31 Sample &lsquo;<samp>curvcoor</samp>&rsquo;</h3>


<p>Some common curvilinear coordinates.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">origin -1 1 -1
subplot 2 2 0:title 'Cartesian':rotate 50 60:fplot '2*t-1' '0.5' '0' '2r':axis:grid
axis 'y*sin(pi*x)' 'y*cos(pi*x)' '':subplot 2 2 1:title 'Cylindrical':rotate 50 60:fplot '2*t-1' '0.5' '0' '2r':axis:grid
axis '2*y*x' 'y*y - x*x' '':subplot 2 2 2:title 'Parabolic':rotate 50 60:fplot '2*t-1' '0.5' '0' '2r':axis:grid
axis 'y*sin(pi*x)' 'y*cos(pi*x)' 'x+z':subplot 2 2 3:title 'Spiral':rotate 50 60:fplot '2*t-1' '0.5' '0' '2r':axis:grid
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_curvcoor(mglGraph *gr)	// curvilinear coordinates
{
	gr-&gt;SetOrigin(-1,1,-1);

	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Cartesian&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();

	gr-&gt;SetFunc(&quot;y*sin(pi*x)&quot;,&quot;y*cos(pi*x)&quot;,0);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Cylindrical&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();

	gr-&gt;SetFunc(&quot;2*y*x&quot;,&quot;y*y - x*x&quot;,0);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Parabolic&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();

	gr-&gt;SetFunc(&quot;y*sin(pi*x)&quot;,&quot;y*cos(pi*x)&quot;,&quot;x+z&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Spiral&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;FPlot(&quot;2*t-1&quot;,&quot;0.5&quot;,&quot;0&quot;,&quot;r2&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();
	gr-&gt;SetFunc(0,0,0);	// set to default Cartesian
}
</pre><div align="center"><img src="png/curvcoor.png" alt="Sample curvcoor">
</div>
<hr>
<a name="cut-sample"></a>
<div class="header">
<p>
Next: <a href="#dat_005fdiff-sample" accesskey="n" rel="next">dat_diff sample</a>, Previous: <a href="#curvcoor-sample" accesskey="p" rel="prev">curvcoor sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-cut"></a>
<h3 class="section">10.32 Sample &lsquo;<samp>cut</samp>&rsquo;</h3>


<p>Example of point cutting (<a href="#cut">cut</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
call 'prepare3d'
subplot 2 2 0:title 'Cut on (default)':rotate 50 60:light on:box:surf a; zrange -1 0.5
subplot 2 2 1:title 'Cut off':rotate 50 60:box:surf a; zrange -1 0.5; cut off
subplot 2 2 2:title 'Cut in box':rotate 50 60:box:alpha on
cut 0 -1 -1 1 0 1.1:surf3 c
cut 0 0 0 0 0 0	# restore back
subplot 2 2 3:title 'Cut by formula':rotate 50 60:box
cut '(z&gt;(x+0.5*y-1)^2-1) &amp; (z&gt;(x-0.5*y-1)^2-1)':surf3 c
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_cut(mglGraph *gr)	// cutting
{
	mglData a,c,v(1);	mgls_prepare2d(&amp;a);	mgls_prepare3d(&amp;c);	v.a[0]=0.5;
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Cut on (default)&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);
	gr-&gt;Box();	gr-&gt;Surf(a,&quot;&quot;,&quot;zrange -1 0.5&quot;);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Cut off&quot;);		gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Surf(a,&quot;&quot;,&quot;zrange -1 0.5; cut off&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Cut in box&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;SetCutBox(mglPoint(0,-1,-1), mglPoint(1,0,1.1));
	gr-&gt;Alpha(true);	gr-&gt;Box();	gr-&gt;Surf3(c);
	gr-&gt;SetCutBox(mglPoint(0), mglPoint(0));	// switch it off
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Cut by formula&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;CutOff(&quot;(z&gt;(x+0.5*y-1)^2-1) &amp; (z&gt;(x-0.5*y-1)^2-1)&quot;);
	gr-&gt;Box();	gr-&gt;Surf3(c);	gr-&gt;CutOff(&quot;&quot;);	// switch it off
}
</pre><div align="center"><img src="png/cut.png" alt="Sample cut">
</div>
<hr>
<a name="dat_005fdiff-sample"></a>
<div class="header">
<p>
Next: <a href="#dat_005fextra-sample" accesskey="n" rel="next">dat_extra sample</a>, Previous: <a href="#cut-sample" accesskey="p" rel="prev">cut sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dat_005fdiff"></a>
<h3 class="section">10.33 Sample &lsquo;<samp>dat_diff</samp>&rsquo;</h3>


<p>Example of <a href="#diff">diff</a> and <a href="#integrate">integrate</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">ranges 0 1 0 1 0 1:new a 30 40 'x*y'
subplot 2 2 0:title 'a(x,y)':rotate 60 40:surf a:box
subplot 2 2 1:title 'da/dx':rotate 60 40:diff a 'x':surf a:box
subplot 2 2 2:title '\int da/dx dxdy':rotate 60 40:integrate a 'xy':surf a:box
subplot 2 2 3:title '\int {d^2}a/dxdy dx':rotate 60 40:diff2 a 'y':surf a:box
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dat_diff(mglGraph *gr)	// differentiate
{
	gr-&gt;SetRanges(0,1,0,1,0,1);
	mglData a(30,40);	a.Modify(&quot;x*y&quot;);
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;a(x,y)&quot;);	gr-&gt;Rotate(60,40);
	gr-&gt;Surf(a);		gr-&gt;Box();
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;da/dx&quot;);		gr-&gt;Rotate(60,40);
	a.Diff(&quot;x&quot;);		gr-&gt;Surf(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;\\int da/dx dxdy&quot;);	gr-&gt;Rotate(60,40);
	a.Integral(&quot;xy&quot;);	gr-&gt;Surf(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;\\int {d^2}a/dxdy dx&quot;);	gr-&gt;Rotate(60,40);
	a.Diff2(&quot;y&quot;);	gr-&gt;Surf(a);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/dat_diff.png" alt="Sample dat_diff">
</div>
<hr>
<a name="dat_005fextra-sample"></a>
<div class="header">
<p>
Next: <a href="#data1-sample" accesskey="n" rel="next">data1 sample</a>, Previous: <a href="#dat_005fdiff-sample" accesskey="p" rel="prev">dat_diff sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dat_005fextra"></a>
<h3 class="section">10.34 Sample &lsquo;<samp>dat_extra</samp>&rsquo;</h3>


<p>Example of <a href="#envelop">envelop</a>, <a href="#sew">sew</a>, <a href="#smooth">smooth</a> and <a href="#resize">resize</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0 '':title 'Envelop sample':new d1 1000 'exp(-8*x^2)*sin(10*pi*x)'
axis:plot d1 'b':envelop d1 'x':plot d1 'r'
subplot 2 2 1 '':title 'Smooth sample':ranges 0 1 0 1
new y0 30 '0.4*sin(pi*x) + 0.3*cos(1.5*pi*x) - 0.4*sin(2*pi*x)+0.5*rnd'
copy y1 y0:smooth y1 'x3':plot y1 'r';legend '&quot;3&quot; style'
copy y2 y0:smooth y2 'x5':plot y2 'g';legend '&quot;5&quot; style'
copy y3 y0:smooth y3 'x':plot y3 'b';legend 'default'
plot y0 '{m7}:s';legend 'none'
legend:box
subplot 2 2 2:title 'Sew sample':rotate 50 60:light on:alpha on
new d2 100 100 'mod((y^2-(1-x)^2)/2,0.1)'
box:surf d2 'b':sew d2 'xy' 0.1:surf d2 'r'
subplot 2 2 3:title 'Resize sample (interpolation)'
new x0 10 'rnd':new v0 10 'rnd'
resize x1 x0 100:resize v1 v0 100
plot x0 v0 'b+ ':plot x1 v1 'r-':label x0 v0 '%n'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dat_extra(mglGraph *gr)	// differentiate
{
	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Envelop sample&quot;);
	mglData d1(1000);	gr-&gt;Fill(d1,&quot;exp(-8*x^2)*sin(10*pi*x)&quot;);
	gr-&gt;Axis();			gr-&gt;Plot(d1, &quot;b&quot;);
	d1.Envelop('x');	gr-&gt;Plot(d1, &quot;r&quot;);

	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;Smooth sample&quot;);
	mglData y0(30),y1,y2,y3;
	gr-&gt;SetRanges(0,1,0,1);
	gr-&gt;Fill(y0, &quot;0.4*sin(pi*x) + 0.3*cos(1.5*pi*x) - 0.4*sin(2*pi*x)+0.5*rnd&quot;);

	y1=y0;	y1.Smooth(&quot;x3&quot;);
	y2=y0;	y2.Smooth(&quot;x5&quot;);
	y3=y0;	y3.Smooth(&quot;x&quot;);

	gr-&gt;Plot(y0,&quot;{m7}:s&quot;, &quot;legend 'none'&quot;);	//gr-&gt;AddLegend(&quot;none&quot;,&quot;k&quot;);
	gr-&gt;Plot(y1,&quot;r&quot;, &quot;legend ''3' style'&quot;);
	gr-&gt;Plot(y2,&quot;g&quot;, &quot;legend ''5' style'&quot;);
	gr-&gt;Plot(y3,&quot;b&quot;, &quot;legend 'default'&quot;);
	gr-&gt;Legend();		gr-&gt;Box();

	gr-&gt;SubPlot(2,2,2);		gr-&gt;Title(&quot;Sew sample&quot;);
	mglData d2(100, 100);	gr-&gt;Fill(d2, &quot;mod((y^2-(1-x)^2)/2,0.1)&quot;);
	gr-&gt;Rotate(50, 60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();			gr-&gt;Surf(d2, &quot;b&quot;);
	d2.Sew(&quot;xy&quot;, 0.1);	gr-&gt;Surf(d2, &quot;r&quot;);

	gr-&gt;SubPlot(2,2,3);		gr-&gt;Title(&quot;Resize sample (interpolation)&quot;);
	mglData x0(10), v0(10), x1, v1;
	gr-&gt;Fill(x0,&quot;rnd&quot;);		gr-&gt;Fill(v0,&quot;rnd&quot;);
	x1 = x0.Resize(100);	v1 = v0.Resize(100);
	gr-&gt;Plot(x0,v0,&quot;b+ &quot;);	gr-&gt;Plot(x1,v1,&quot;r-&quot;);
	gr-&gt;Label(x0,v0,&quot;%n&quot;);
}
</pre><div align="center"><img src="png/dat_extra.png" alt="Sample dat_extra">
</div>
<hr>
<a name="data1-sample"></a>
<div class="header">
<p>
Next: <a href="#data2-sample" accesskey="n" rel="next">data2 sample</a>, Previous: <a href="#dat_005fextra-sample" accesskey="p" rel="prev">dat_extra sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-data1"></a>
<h3 class="section">10.35 Sample &lsquo;<samp>data1</samp>&rsquo;</h3>




<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 40 50 60 'exp(-x^2-4*y^2-16*z^2)'
light on:alpha on
copy b a:diff b 'x':subplot 5 3 0:call 'splot'
copy b a:diff2 b 'x':subplot 5 3 1:call 'splot'
copy b a:cumsum b 'x':subplot 5 3 2:call 'splot'
copy b a:integrate b 'x':subplot 5 3 3:call 'splot'
mirror b 'x':subplot 5 3 4:call 'splot'
copy b a:diff b 'y':subplot 5 3 5:call 'splot'
copy b a:diff2 b 'y':subplot 5 3 6:call 'splot'
copy b a:cumsum b 'y':subplot 5 3 7:call 'splot'
copy b a:integrate b 'y':subplot 5 3 8:call 'splot'
mirror b 'y':subplot 5 3 9:call 'splot'
copy b a:diff b 'z':subplot 5 3 10:call 'splot'
copy b a:diff2 b 'z':subplot 5 3 11:call 'splot'
copy b a:cumsum b 'z':subplot 5 3 12:call 'splot'
copy b a:integrate b 'z':subplot 5 3 13:call 'splot'
mirror b 'z':subplot 5 3 14:call 'splot'
stop
func splot 0
title 'max=',b.max:norm b -1 1 on:rotate 70 60:box:surf3 b
return
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_data1(mglGraph *gr)	// basic data operations
{
	mglData a(40,50,60),b;	gr-&gt;Fill(a,&quot;exp(-x^2-4*y^2-16*z^2)&quot;);
	gr-&gt;Light(true);		gr-&gt;Alpha(true);
	b.Set(a);	b.Diff(&quot;x&quot;);	gr-&gt;SubPlot(5,3,0);	splot1(gr,b);
	b.Set(a);	b.Diff2(&quot;x&quot;);	gr-&gt;SubPlot(5,3,1);	splot1(gr,b);
	b.Set(a);	b.CumSum(&quot;x&quot;);	gr-&gt;SubPlot(5,3,2);	splot1(gr,b);
	b.Set(a);	b.Integral(&quot;x&quot;);gr-&gt;SubPlot(5,3,3);	splot1(gr,b);
	b.Mirror(&quot;x&quot;);	gr-&gt;SubPlot(5,3,4);	splot1(gr,b);
	b.Set(a);	b.Diff(&quot;y&quot;);	gr-&gt;SubPlot(5,3,5);	splot1(gr,b);
	b.Set(a);	b.Diff2(&quot;y&quot;);	gr-&gt;SubPlot(5,3,6);	splot1(gr,b);
	b.Set(a);	b.CumSum(&quot;y&quot;);	gr-&gt;SubPlot(5,3,7);	splot1(gr,b);
	b.Set(a);	b.Integral(&quot;y&quot;);gr-&gt;SubPlot(5,3,8);	splot1(gr,b);
	b.Mirror(&quot;y&quot;);	gr-&gt;SubPlot(5,3,9);	splot1(gr,b);
	b.Set(a);	b.Diff(&quot;z&quot;);	gr-&gt;SubPlot(5,3,10);splot1(gr,b);
	b.Set(a);	b.Diff2(&quot;z&quot;);	gr-&gt;SubPlot(5,3,11);splot1(gr,b);
	b.Set(a);	b.CumSum(&quot;z&quot;);	gr-&gt;SubPlot(5,3,12);splot1(gr,b);
	b.Set(a);	b.Integral(&quot;z&quot;);gr-&gt;SubPlot(5,3,13);splot1(gr,b);
	b.Mirror(&quot;z&quot;);	gr-&gt;SubPlot(5,3,14);splot1(gr,b);
}
</pre><div align="center"><img src="png/data1.png" alt="Sample data1">
</div>
<hr>
<a name="data2-sample"></a>
<div class="header">
<p>
Next: <a href="#dens-sample" accesskey="n" rel="next">dens sample</a>, Previous: <a href="#data1-sample" accesskey="p" rel="prev">data1 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-data2"></a>
<h3 class="section">10.36 Sample &lsquo;<samp>data2</samp>&rsquo;</h3>




<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 40 50 60 'exp(-x^2-4*y^2-16*z^2)'
light on:alpha on
copy b a:sinfft b 'x':subplot 5 3 0:call 'splot'
copy b a:cosfft b 'x':subplot 5 3 1:call 'splot'
copy b a:hankel b 'x':subplot 5 3 2:call 'splot'
copy b a:swap b 'x':subplot 5 3 3:call 'splot'
copy b a:smooth b 'x':subplot 5 3 4:call 'splot'
copy b a:sinfft b 'y':subplot 5 3 5:call 'splot'
copy b a:cosfft b 'y':subplot 5 3 6:call 'splot'
copy b a:hankel b 'y':subplot 5 3 7:call 'splot'
copy b a:swap b 'y':subplot 5 3 8:call 'splot'
copy b a:smooth b 'y':subplot 5 3 9:call 'splot'
copy b a:sinfft b 'z':subplot 5 3 10:call 'splot'
copy b a:cosfft b 'z':subplot 5 3 11:call 'splot'
copy b a:hankel b 'z':subplot 5 3 12:call 'splot'
copy b a:swap b 'z':subplot 5 3 13:call 'splot'
copy b a:smooth b 'z':subplot 5 3 14:call 'splot'
stop
func splot 0
title 'max=',b.max:norm b -1 1 on:rotate 70 60:box
surf3 b 0.5:surf3 b -0.5
return
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_data2(mglGraph *gr)	// data transforms
{
	mglData a(40,50,60),b;	gr-&gt;Fill(a,&quot;exp(-x^2-4*y^2-16*z^2)&quot;);
	gr-&gt;Light(true);		gr-&gt;Alpha(true);
	b.Set(a);	b.SinFFT(&quot;x&quot;);	gr-&gt;SubPlot(5,3,0);	splot2(gr,b);
	b.Set(a);	b.CosFFT(&quot;x&quot;);	gr-&gt;SubPlot(5,3,1);	splot2(gr,b);
	b.Set(a);	b.Hankel(&quot;x&quot;);	gr-&gt;SubPlot(5,3,2);	splot2(gr,b);
	b.Set(a);	b.Swap(&quot;x&quot;);	gr-&gt;SubPlot(5,3,3);	splot2(gr,b);
	b.Set(a);	b.Smooth(&quot;x&quot;);	gr-&gt;SubPlot(5,3,4);	splot2(gr,b);
	b.Set(a);	b.SinFFT(&quot;y&quot;);	gr-&gt;SubPlot(5,3,5);	splot2(gr,b);
	b.Set(a);	b.CosFFT(&quot;y&quot;);	gr-&gt;SubPlot(5,3,6);	splot2(gr,b);
	b.Set(a);	b.Hankel(&quot;y&quot;);	gr-&gt;SubPlot(5,3,7);	splot2(gr,b);
	b.Set(a);	b.Swap(&quot;y&quot;);	gr-&gt;SubPlot(5,3,8);	splot2(gr,b);
	b.Set(a);	b.Smooth(&quot;y&quot;);	gr-&gt;SubPlot(5,3,9);	splot2(gr,b);
	b.Set(a);	b.SinFFT(&quot;z&quot;);	gr-&gt;SubPlot(5,3,10);splot2(gr,b);
	b.Set(a);	b.CosFFT(&quot;z&quot;);	gr-&gt;SubPlot(5,3,11);splot2(gr,b);
	b.Set(a);	b.Hankel(&quot;z&quot;);	gr-&gt;SubPlot(5,3,12);splot2(gr,b);
	b.Set(a);	b.Swap(&quot;z&quot;);	gr-&gt;SubPlot(5,3,13);splot2(gr,b);
	b.Set(a);	b.Smooth(&quot;z&quot;);	gr-&gt;SubPlot(5,3,14);splot2(gr,b);
}
</pre><div align="center"><img src="png/data2.png" alt="Sample data2">
</div>
<hr>
<a name="dens-sample"></a>
<div class="header">
<p>
Next: <a href="#dens3-sample" accesskey="n" rel="next">dens3 sample</a>, Previous: <a href="#data2-sample" accesskey="p" rel="prev">data2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dens"></a>
<h3 class="section">10.37 Sample &lsquo;<samp>dens</samp>&rsquo;</h3>


<p>Function <a href="#dens">dens</a> draw density plot (also known as color-map) for surface.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
new a1 30 40 3 '0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)'
subplot 2 2 0 '':title 'Dens plot (default)':box:dens a
subplot 2 2 1:title '3d variant':rotate 50 60:box:dens a
subplot 2 2 2 '':title '&quot;\#&quot; style; meshnum 10':box:dens a '#'; meshnum 10
subplot 2 2 3:title 'several slices':rotate 50 60:box:dens a1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dens3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Dens3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Alpha(true);	gr-&gt;SetAlphaDef(0.7);
	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Dens3(c,&quot;x&quot;);	gr-&gt;Dens3(c);	gr-&gt;Dens3(c,&quot;z&quot;);
}
</pre><div align="center"><img src="png/dens.png" alt="Sample dens">
</div>
<hr>
<a name="dens3-sample"></a>
<div class="header">
<p>
Next: <a href="#dens_005fxyz-sample" accesskey="n" rel="next">dens_xyz sample</a>, Previous: <a href="#dens-sample" accesskey="p" rel="prev">dens sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dens3"></a>
<h3 class="section">10.38 Sample &lsquo;<samp>dens3</samp>&rsquo;</h3>


<p>Function <a href="#dens3">dens3</a> draw ordinary density plots but at slices of 3D data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Dens3 sample':rotate 50 60:alpha on:alphadef 0.7
origin 0 0 0:box:axis '_xyz'
dens3 c 'x':dens3 c ':y':dens3 c 'z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dens3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Dens3 sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Alpha(true);	gr-&gt;SetAlphaDef(0.7);
	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Dens3(c,&quot;x&quot;);	gr-&gt;Dens3(c);	gr-&gt;Dens3(c,&quot;z&quot;);
}
</pre><div align="center"><img src="png/dens3.png" alt="Sample dens3">
</div>
<hr>
<a name="dens_005fxyz-sample"></a>
<div class="header">
<p>
Next: <a href="#detect-sample" accesskey="n" rel="next">detect sample</a>, Previous: <a href="#dens3-sample" accesskey="p" rel="prev">dens3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dens_005fxyz"></a>
<h3 class="section">10.39 Sample &lsquo;<samp>dens_xyz</samp>&rsquo;</h3>


<p>Functions <a href="#densz">densz</a>, <a href="#densy">densy</a>, <a href="#densx">densx</a> draw density plot on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Dens[XYZ] sample':rotate 50 60:box
densx {sum c 'x'} '' -1:densy {sum c 'y'} '' 1:densz {sum c 'z'} '' -1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dens_xyz(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	gr-&gt;Title(&quot;Dens[XYZ] sample&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;DensX(c.Sum(&quot;x&quot;),0,-1);
	gr-&gt;DensY(c.Sum(&quot;y&quot;),0,1);		gr-&gt;DensZ(c.Sum(&quot;z&quot;),0,-1);
}
</pre><div align="center"><img src="png/dens_xyz.png" alt="Sample dens_xyz">
</div>
<hr>
<a name="detect-sample"></a>
<div class="header">
<p>
Next: <a href="#dew-sample" accesskey="n" rel="next">dew sample</a>, Previous: <a href="#dens_005fxyz-sample" accesskey="p" rel="prev">dens_xyz sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-detect"></a>
<h3 class="section">10.40 Sample &lsquo;<samp>detect</samp>&rsquo;</h3>


<p>Example of curve <a href="#detect">detect</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '':title 'Detect sample'
new a 200 100 'exp(-30*(y-0.5*sin(pi*x))^2-rnd/10)+exp(-30*(y+0.5*sin(pi*x))^2-rnd/10)+exp(-30*(x+y)^2-rnd/10)'
ranges 0 a.nx 0 a.ny:box
alpha on:crange a:dens a

detect r a 0.1 5
plot r(0) r(1) '.'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_detect(mglGraph *gr)
{
	mglData a(200, 100);
	gr-&gt;Fill(a,&quot;exp(-30*(y-0.5*sin(pi*x))^2-rnd/10)+exp(-30*(y+0.5*sin(pi*x))^2-rnd/10)+exp(-30*(x+y)^2-rnd/10)&quot;);
	gr-&gt;SubPlot(1,1,0,&quot;&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Detect sample&quot;);
	gr-&gt;SetRanges(0,a.nx,0,a.ny);	gr-&gt;SetRange('c',a);
	gr-&gt;Alpha(true);	gr-&gt;Box();	gr-&gt;Dens(a);
	mglData r(a.Detect(0.1,5));
	gr-&gt;Plot(r.SubData(0), r.SubData(1), &quot;.&quot;);
}
</pre><div align="center"><img src="png/detect.png" alt="Sample detect">
</div>
<hr>
<a name="dew-sample"></a>
<div class="header">
<p>
Next: <a href="#diffract-sample" accesskey="n" rel="next">diffract sample</a>, Previous: <a href="#detect-sample" accesskey="p" rel="prev">detect sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dew"></a>
<h3 class="section">10.41 Sample &lsquo;<samp>dew</samp>&rsquo;</h3>


<p>Function <a href="#dew">dew</a> is similar to <a href="#vect">vect</a> but use drops instead of arrows.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2v'
subplot 1 1 0 '':title 'Dew plot':light on:box:dew a b
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dew(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2v(&amp;a,&amp;b);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Dew plot&quot;);}
	gr-&gt;Box();	gr-&gt;Light(true);	gr-&gt;Dew(a,b);
}
</pre><div align="center"><img src="png/dew.png" alt="Sample dew">
</div>
<hr>
<a name="diffract-sample"></a>
<div class="header">
<p>
Next: <a href="#dilate-sample" accesskey="n" rel="next">dilate sample</a>, Previous: <a href="#dew-sample" accesskey="p" rel="prev">dew sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-diffract"></a>
<h3 class="section">10.42 Sample &lsquo;<samp>diffract</samp>&rsquo;</h3>




<p><strong>MGL code:</strong>
</p><pre class="verbatim">define n 32	#number of points
define m 20 # number of iterations
define dt 0.01 # time step
new res n m+1
ranges -1 1 0 m*dt 0 1

#tridmat periodic variant
new !a n 'i',dt*(n/2)^2/2
copy !b !(1-2*a)

new !u n 'exp(-6*x^2)'
put res u all 0
for $i 0 m
tridmat u a b a u 'xdc'
put res u all $i+1
next
subplot 2 2 0 '&lt;_':title 'Tridmat, periodic b.c.'
axis:box:dens res

#fourier variant
new k n:fillsample k 'xk'
copy !e !exp(-i1*dt*k^2)

new !u n 'exp(-6*x^2)'
put res u all 0
for $i 0 m
fourier u 'x'
multo u e
fourier u 'ix'
put res u all $i+1
next
subplot 2 2 1 '&lt;_':title 'Fourier method'
axis:box:dens res

#tridmat zero variant
new !u n 'exp(-6*x^2)'
put res u all 0
for $i 0 m
tridmat u a b a u 'xd'
put res u all $i+1
next
subplot 2 2 2 '&lt;_':title 'Tridmat, zero b.c.'
axis:box:dens res

#diffract exp variant
new !u n 'exp(-6*x^2)'
define q dt*(n/2)^2/8 # need q&lt;0.4 !!!
put res u all 0
for $i 0 m
for $j 1 8	# due to smaller dt
diffract u 'xe' q
next
put res u all $i+1
next
subplot 2 2 3 '&lt;_':title 'Diffract, exp b.c.'
axis:box:dens res
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_diffract(mglGraph *gr)
{
	long n=32;	// number of points
	long m=20;	// number of iterations
	double dt=0.01;	// time step
	mglData res(n,m+1);
	gr-&gt;SetRanges(-1,1, 0,m*dt, 0,1);

	// tridmat periodic variant
	mglDataC a(n), b(n);	a = dual(0,dt*n*n/8);
	for(long i=0;i&lt;n;i++)	b.a[i] = mreal(1)-mreal(2)*a.a[i];
	mglDataC u(n);	gr-&gt;Fill(u,&quot;exp(-6*x^2)&quot;);	res.Put(u,-1,0);
	for(long i=0;i&lt;m;i++)
	{
		u = mglTridMatC(a,b,a,u,&quot;xdc&quot;);
		res.Put(u,-1,i+1);
	}
	gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Tridmat, periodic b.c.&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Dens(res);

	// fourier variant
	mglData k(n);	k.FillSample(&quot;xk&quot;);
	mglDataC e(n);	for(long i=0;i&lt;n;i++)	e.a[i] = exp(-dual(0,dt*k.a[i]*k.a[i]));
	gr-&gt;Fill(u,&quot;exp(-6*x^2)&quot;);	res.Put(u,-1,0);
	for(long i=0;i&lt;m;i++)
	{
		u.FFT(&quot;x&quot;);	u *= e;	u.FFT(&quot;ix&quot;);
		res.Put(u,-1,i+1);
	}
	gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Fourier method&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Dens(res);

	// tridmat zero variant
	gr-&gt;Fill(u,&quot;exp(-6*x^2)&quot;);	res.Put(u,-1,0);
	for(long i=0;i&lt;m;i++)
	{
		u = mglTridMatC(a,b,a,u,&quot;xd&quot;);
		res.Put(u,-1,i+1);
	}
	gr-&gt;SubPlot(2,2,2,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Tridmat, zero b.c.&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Dens(res);
	
	// diffract exp variant
	gr-&gt;Fill(u,&quot;exp(-6*x^2)&quot;);	res.Put(u,-1,0);
	double q=dt*n*n/4/8;	// NOTE: need q&lt;0.4 !!!
	for(long i=0;i&lt;m;i++)
	{
		for(long j=0;j&lt;8;j++)	// due to smaller dt
			u.Diffraction(&quot;xe&quot;,q);
		res.Put(u,-1,i+1);
	}
	gr-&gt;SubPlot(2,2,3,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Diffract, exp b.c.&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Dens(res);
}
</pre><div align="center"><img src="png/diffract.png" alt="Sample diffract">
</div>
<hr>
<a name="dilate-sample"></a>
<div class="header">
<p>
Next: <a href="#dots-sample" accesskey="n" rel="next">dots sample</a>, Previous: <a href="#diffract-sample" accesskey="p" rel="prev">diffract sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dilate"></a>
<h3 class="section">10.43 Sample &lsquo;<samp>dilate</samp>&rsquo;</h3>


<p>Example of <a href="#dilate">dilate</a> and <a href="#erode">erode</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0:title 'Dilate&amp;Erode 1D sample'
new y 11:put y 1 5
ranges 0 10 0 1:axis:box
plot y 'b*'
dilate y 0.5 2
plot y 'rs'
erode y 0.5 1
plot y 'g#o'

subplot 2 2 1:title 'Dilate&amp;Erode 2D sample':rotate 40 60
ranges 0 10 0 10 0 3
axis:box
new z 11 11:put z 3 5 5
boxs z 'b':boxs z 'k#'
dilate z 1 2
boxs z 'r':boxs z 'k#'
erode z 1 1
boxs 2*z 'g':boxs 2*z 'k#'

subplot 2 2 2
text 0.5 0.7 'initial' 'ba';size -2
text 0.5 0.5 'dilate=2' 'ra';size -2
text 0.5 0.3 'erode=1' 'ga';size -2

subplot 2 2 3:title 'Dilate&amp;Erode 3D sample'
rotate 60 50:light on:alpha on
ranges 0 10 0 10 0 10:crange 0 3
axis:box
new a 11 11 11:put a 3 5 5 5
surf3a a a 1.5 'b'
dilate a 1 2
surf3a a a 0.5 'r'
erode a 1 1
surf3a 2*a 2*a 1 'g'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dilate(mglGraph *gr)
{
	mglData y(11),	z(11,11), a(11,11,11);
	y.a[5]=1;	z.a[5+11*5]=a.a[5+11*(5+11*5)] = 3;

	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Dilate&amp;Erode 1D sample&quot;);	}
	else	gr-&gt;SubPlot(1,1,0,&quot;&quot;);
	gr-&gt;SetRanges(0,10,0,1);	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Plot(y,&quot;b*&quot;);
	y.Dilate(1,2);	gr-&gt;Plot(y,&quot;rs&quot;);
	y.Erode(1,1);	gr-&gt;Plot(y,&quot;g#o&quot;);
	if(big==3)	return;
	
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Dilate&amp;Erode 2D sample&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;SetRanges(0,10,0,10,0,3);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Boxs(z,&quot;b&quot;);	gr-&gt;Boxs(z,&quot;k#&quot;);
	z.Dilate(1,2);			gr-&gt;Boxs(z,&quot;r&quot;);	gr-&gt;Boxs(z,&quot;k#&quot;);
	z.Erode(1,1);	z*=2;	gr-&gt;Boxs(z,&quot;g&quot;);	gr-&gt;Boxs(z,&quot;k#&quot;);
	
	gr-&gt;SubPlot(2,2,2);
	gr-&gt;Puts(0.5,0.7,&quot;initial&quot;,&quot;ba&quot;,-2);
	gr-&gt;Puts(0.5,0.5,&quot;dilate=2&quot;,&quot;ra&quot;,-2);
	gr-&gt;Puts(0.5,0.3,&quot;erode=1&quot;,&quot;ga&quot;,-2);
	
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Dilate&amp;Erode 3D sample&quot;);
	gr-&gt;Rotate(60,50);	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	gr-&gt;SetRanges(0,10,0,10,0,10);	gr-&gt;SetRange('c',0,3);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Surf3A(1.5,a,a,&quot;b&quot;);
	a.Dilate(1,2);			gr-&gt;Surf3A(0.5,a,a,&quot;r&quot;);
	a.Erode(1,1);	a*=2;	gr-&gt;Surf3A(1,a,a,&quot;g&quot;);
}
</pre><div align="center"><img src="png/dilate.png" alt="Sample dilate">
</div>
<hr>
<a name="dots-sample"></a>
<div class="header">
<p>
Next: <a href="#earth-sample" accesskey="n" rel="next">earth sample</a>, Previous: <a href="#dilate-sample" accesskey="p" rel="prev">dilate sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-dots"></a>
<h3 class="section">10.44 Sample &lsquo;<samp>dots</samp>&rsquo;</h3>


<p>Function <a href="#dots">dots</a> is another way to draw irregular points. <code>Dots</code> use color scheme for coloring (see <a href="#Color-scheme">Color scheme</a>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new t 2000 'pi*(rnd-0.5)':new f 2000 '2*pi*rnd'
copy x 0.9*cos(t)*cos(f):copy y 0.9*cos(t)*sin(f):copy z 0.6*sin(t):copy c cos(2*t)
subplot 2 2 0:title 'Dots sample':rotate 50 60
box:dots x y z
alpha on
subplot 2 2 1:title 'add transparency':rotate 50 60
box:dots x y z c
subplot 2 2 2:title 'add colorings':rotate 50 60
box:dots x y z x c
subplot 2 2 3:title 'Only coloring':rotate 50 60
box:tens x y z x ' .'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_dots(mglGraph *gr)
{
	int i, n=1000;
	mglData x(n),y(n),z(n),c(n);
	for(i=0;i&lt;n;i++)
	{
		double t=M_PI*(mgl_rnd()-0.5), f=2*M_PI*mgl_rnd();
		x.a[i] = 0.9*cos(t)*cos(f);
		y.a[i] = 0.9*cos(t)*sin(f);
		z.a[i] = 0.6*sin(t);
		c.a[i] = cos(2*t);
	}
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Dots sample&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Dots(x,y,z);
	if(big==3)	return;
	gr-&gt;Alpha(true);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;add transparency&quot;);		gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Dots(x,y,z,c);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;add coloring&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Dots(x,y,z,x,c);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Only coloring&quot;);		gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Tens(x,y,z,x,&quot; .&quot;);
}
</pre><div align="center"><img src="png/dots.png" alt="Sample dots">
</div>
<hr>
<a name="earth-sample"></a>
<div class="header">
<p>
Next: <a href="#error-sample" accesskey="n" rel="next">error sample</a>, Previous: <a href="#dots-sample" accesskey="p" rel="prev">dots sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-earth"></a>
<h3 class="section">10.45 Sample &lsquo;<samp>earth</samp>&rsquo;</h3>


<p>Example of Earth map by using <a href="#import">import</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">import dat 'Equirectangular-projection.jpg' 'BbGYw' -1 1
subplot 1 1 0 '&lt;&gt;':title 'Earth in 3D':rotate 40 60
copy phi dat 'pi*x':copy tet dat 'pi*y/2'
copy x cos(tet)*cos(phi)
copy y cos(tet)*sin(phi)
copy z sin(tet)

light on
surfc x y z dat 'BbGYw'
contp [-0.51,-0.51] x y z dat 'y'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_earth(mglGraph *gr)
{
	mglData dat;	dat.Import(&quot;Equirectangular-projection.jpg&quot;,&quot;BbGYw&quot;,-1,1);
	// Calc proper 3d coordinates from projection
	mglData phi(dat.nx,dat.ny);	phi.Fill(-M_PI,M_PI);
	mglData tet(dat.nx,dat.ny);	tet.Fill(-M_PI/2,M_PI/2,'y');
	mglData x(dat.nx,dat.ny), y(dat.nx,dat.ny), z(dat.nx,dat.ny);
#pragma omp parallel for
	for(long i=0;i&lt;dat.nx*dat.ny;i++)
	{	x.a[i] = cos(tet.a[i])*cos(phi.a[i]);
		y.a[i] = cos(tet.a[i])*sin(phi.a[i]);
		z.a[i] = sin(tet.a[i]);	}

	gr-&gt;SubPlot(1,1,0,&quot;&lt;&gt;&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Earth in 3D&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;Light(true);
	gr-&gt;SurfC(x,y,z,dat,&quot;BbGYw&quot;);
	mglData vals(1);	vals.a[0]=-0.51;
	gr-&gt;ContP(vals, x,y,z,dat,&quot;y&quot;);
}
</pre><div align="center"><img src="png/earth.png" alt="Sample earth">
</div>
<hr>
<a name="error-sample"></a>
<div class="header">
<p>
Next: <a href="#error2-sample" accesskey="n" rel="next">error2 sample</a>, Previous: <a href="#earth-sample" accesskey="p" rel="prev">earth sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-error"></a>
<h3 class="section">10.46 Sample &lsquo;<samp>error</samp>&rsquo;</h3>


<p>Function <a href="#error">error</a> draw error boxes around the points. You can draw default boxes or semi-transparent symbol (like marker, see <a href="#Line-styles">Line styles</a>). Also you can set individual color for each box. See also <a href="#error2-sample">error2 sample</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
new y 50 '0.7*sin(pi*x-pi) + 0.5*cos(3*pi*(x+1)/2) + 0.2*sin(pi*(x+1)/2)'
new x0 10 'x + 0.1*rnd-0.05':new ex 10 '0.1':new ey 10 '0.2'
new y0 10 '0.7*sin(pi*x-pi) + 0.5*cos(3*pi*(x+1)/2) + 0.2*sin(pi*(x+1)/2) + 0.2*rnd-0.1'
subplot 2 2 0 '':title 'Error plot (default)':box:plot y:error x0 y0 ex ey 'k'
subplot 2 2 1 '':title '&quot;!&quot; style; no e_x':box:plot y:error x0 y0 ey 'o!rgb'
subplot 2 2 2 '':title '&quot;\@&quot; style':alpha on:box:plot y:error x0 y0 ex ey '@'; alpha 0.5
subplot 2 2 3:title '3d variant':rotate 50 60:axis
for $1 0 9
	errbox 2*rnd-1 2*rnd-1 2*rnd-1 0.2 0.2 0.2 'bo'
next
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_error2(mglGraph *gr)
{
	mglData x0(10), y0(10), ex(10), ey(10);
	for(int i=0;i&lt;10;i++)
	{	x0.a[i] = mgl_rnd();	y0.a[i] = mgl_rnd();	ey.a[i] = ex.a[i] = 0.1;	}
	gr-&gt;SetRanges(0,1,0,1);	gr-&gt;Alpha(true);
	gr-&gt;SubPlot(4,3,0,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#+@&quot;);
	gr-&gt;SubPlot(4,3,1,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#x@&quot;);
	gr-&gt;SubPlot(4,3,2,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#s@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,3,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;s@&quot;);
	gr-&gt;SubPlot(4,3,4,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;d@&quot;);
	gr-&gt;SubPlot(4,3,5,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#d@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,6,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;+@&quot;);
	gr-&gt;SubPlot(4,3,7,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;x@&quot;);
	gr-&gt;SubPlot(4,3,8,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;o@&quot;);
	gr-&gt;SubPlot(4,3,9,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#o@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,10,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#.@&quot;);
	gr-&gt;SubPlot(4,3,11,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey);
}
</pre><div align="center"><img src="png/error.png" alt="Sample error">
</div>
<hr>
<a name="error2-sample"></a>
<div class="header">
<p>
Next: <a href="#export-sample" accesskey="n" rel="next">export sample</a>, Previous: <a href="#error-sample" accesskey="p" rel="prev">error sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-error2"></a>
<h3 class="section">10.47 Sample &lsquo;<samp>error2</samp>&rsquo;</h3>


<p>Example of <a href="#error">error</a> kinds.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x0 10 'rnd':new ex 10 '0.1'
new y0 10 'rnd':new ey 10 '0.1'
ranges 0 1 0 1
subplot 4 3 0 '':box:error x0 y0 ex ey '#+@'
subplot 4 3 1 '':box:error x0 y0 ex ey '#x@'
subplot 4 3 2 '':box:error x0 y0 ex ey '#s@'; alpha 0.5
subplot 4 3 3 '':box:error x0 y0 ex ey 's@'
subplot 4 3 4 '':box:error x0 y0 ex ey 'd@'
subplot 4 3 5 '':box:error x0 y0 ex ey '#d@'; alpha 0.5
subplot 4 3 6 '':box:error x0 y0 ex ey '+@'
subplot 4 3 7 '':box:error x0 y0 ex ey 'x@'
subplot 4 3 8 '':box:error x0 y0 ex ey 'o@'
subplot 4 3 9 '':box:error x0 y0 ex ey '#o@'; alpha 0.5
subplot 4 3 10 '':box:error x0 y0 ex ey '#.@'
subplot 4 3 11 '':box:error x0 y0 ex ey; alpha 0.5
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_error2(mglGraph *gr)
{
	mglData x0(10), y0(10), ex(10), ey(10);
	for(int i=0;i&lt;10;i++)
	{	x0.a[i] = mgl_rnd();	y0.a[i] = mgl_rnd();	ey.a[i] = ex.a[i] = 0.1;	}
	gr-&gt;SetRanges(0,1,0,1);	gr-&gt;Alpha(true);
	gr-&gt;SubPlot(4,3,0,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#+@&quot;);
	gr-&gt;SubPlot(4,3,1,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#x@&quot;);
	gr-&gt;SubPlot(4,3,2,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#s@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,3,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;s@&quot;);
	gr-&gt;SubPlot(4,3,4,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;d@&quot;);
	gr-&gt;SubPlot(4,3,5,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#d@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,6,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;+@&quot;);
	gr-&gt;SubPlot(4,3,7,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;x@&quot;);
	gr-&gt;SubPlot(4,3,8,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;o@&quot;);
	gr-&gt;SubPlot(4,3,9,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#o@&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,3,10,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey,&quot;#.@&quot;);
	gr-&gt;SubPlot(4,3,11,&quot;&quot;);	gr-&gt;Box();	gr-&gt;Error(x0,y0,ex,ey);
}
</pre><div align="center"><img src="png/error2.png" alt="Sample error2">
</div>
<hr>
<a name="export-sample"></a>
<div class="header">
<p>
Next: <a href="#fall-sample" accesskey="n" rel="next">fall sample</a>, Previous: <a href="#error2-sample" accesskey="p" rel="prev">error2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-export"></a>
<h3 class="section">10.48 Sample &lsquo;<samp>export</samp>&rsquo;</h3>


<p>Example of data <a href="#export">export</a> and <a href="#import">import</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 100 100 'x^2*y':new b 100 100
export a 'test_data.png' 'BbcyrR' -1 1
import b 'test_data.png' 'BbcyrR' -1 1
subplot 2 1 0 '':title 'initial':box:dens a
subplot 2 1 1 '':title 'imported':box:dens b
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_export(mglGraph *gr)	// basic data operations
{
	mglData a(100,100), b; gr-&gt;Fill(a,&quot;x^2*y&quot;);
	a.Export(&quot;test_data.png&quot;,&quot;BbcyrR&quot;);
	b.Import(&quot;test_data.png&quot;,&quot;BbcyrR&quot;,-1,1);
	gr-&gt;SubPlot(2,1,0,&quot;&quot;);	gr-&gt;Title(&quot;initial&quot;);	gr-&gt;Box();	gr-&gt;Dens(a);
	gr-&gt;SubPlot(2,1,1,&quot;&quot;);	gr-&gt;Title(&quot;imported&quot;);	gr-&gt;Box();	gr-&gt;Dens(b);
}
</pre><div align="center"><img src="png/export.png" alt="Sample export">
</div>
<hr>
<a name="fall-sample"></a>
<div class="header">
<p>
Next: <a href="#fexport-sample" accesskey="n" rel="next">fexport sample</a>, Previous: <a href="#export-sample" accesskey="p" rel="prev">export sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-fall"></a>
<h3 class="section">10.49 Sample &lsquo;<samp>fall</samp>&rsquo;</h3>


<p>Function <a href="#fall">fall</a> draw waterfall surface. You can use <a href="#meshnum">meshnum</a> for changing number of lines to be drawn. Also you can use &lsquo;<samp>x</samp>&rsquo; style for drawing lines in other direction.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Fall plot':rotate 50 60:box:fall a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_fall(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Fall plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Fall(a);
}
</pre><div align="center"><img src="png/fall.png" alt="Sample fall">
</div>
<hr>
<a name="fexport-sample"></a>
<div class="header">
<p>
Next: <a href="#fit-sample" accesskey="n" rel="next">fit sample</a>, Previous: <a href="#fall-sample" accesskey="p" rel="prev">fall sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-fexport"></a>
<h3 class="section">10.50 Sample &lsquo;<samp>fexport</samp>&rsquo;</h3>


<p>Example of <a href="#write">write</a> to different file formats.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'
write 'fexport.jpg':#write 'fexport.png'
write 'fexport.bmp':write 'fexport.tga'
write 'fexport.eps':write 'fexport.svg'
write 'fexport.gif':write 'fexport.xyz'
write 'fexport.stl':write 'fexport.off'
write 'fexport.tex':write 'fexport.obj'
write 'fexport.prc':write 'fexport.json'
write 'fexport.mgld'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_fexport(mglGraph *gr)	// test file export
{
	all_prims(gr);
	gr-&gt;WriteJPEG(&quot;fexport.jpg&quot;);
//	gr-&gt;WritePNG(&quot;fexport.png&quot;);
	gr-&gt;WriteBMP(&quot;fexport.bmp&quot;);
	gr-&gt;WriteTGA(&quot;fexport.tga&quot;);
	gr-&gt;WriteEPS(&quot;fexport.eps&quot;);
	gr-&gt;WriteSVG(&quot;fexport.svg&quot;);
	gr-&gt;WriteGIF(&quot;fexport.gif&quot;);

	gr-&gt;WriteXYZ(&quot;fexport.xyz&quot;);
	gr-&gt;WriteSTL(&quot;fexport.stl&quot;);
	gr-&gt;WriteOFF(&quot;fexport.off&quot;);
	gr-&gt;WriteTEX(&quot;fexport.tex&quot;);
	gr-&gt;WriteOBJ(&quot;fexport.obj&quot;);
	gr-&gt;WritePRC(&quot;fexport.prc&quot;);
	gr-&gt;WriteJSON(&quot;fexport.json&quot;);

	gr-&gt;ExportMGLD(&quot;fexport.mgld&quot;);
	gr-&gt;Clf();
	gr-&gt;ImportMGLD(&quot;fexport.mgld&quot;);
}
</pre><div align="center"><img src="png/fexport.png" alt="Sample fexport">
</div>
<hr>
<a name="fit-sample"></a>
<div class="header">
<p>
Next: <a href="#flame2d-sample" accesskey="n" rel="next">flame2d sample</a>, Previous: <a href="#fexport-sample" accesskey="p" rel="prev">fexport sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-fit"></a>
<h3 class="section">10.51 Sample &lsquo;<samp>fit</samp>&rsquo;</h3>


<p>Example of nonlinear <a href="#fit">fit</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new dat 100 '0.4*rnd+0.1+sin(2*pi*x)'
new in 100 '0.3+sin(2*pi*x)'
list ini 1 1 3:fit res dat 'a+b*sin(c*x)' 'abc' ini
title 'Fitting sample':yrange -2 2:box:axis:plot dat 'k. '
plot res 'r':plot in 'b'
text -0.9 -1.3 'fitted:' 'r:L'
putsfit 0 -1.8 'y = ' 'r':text 0 2.2 'initial: y = 0.3+sin(2\pi x)' 'b'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_fit(mglGraph *gr)	// nonlinear fitting
{
	mglData dat(100), in(100), res;
	gr-&gt;Fill(dat,&quot;0.4*rnd+0.1+sin(2*pi*x)&quot;);
	gr-&gt;Fill(in,&quot;0.3+sin(2*pi*x)&quot;);
	double ini[3] = {1,1,3};
	mglData Ini(3,ini);
	res = gr-&gt;Fit(dat, &quot;a+b*sin(c*x)&quot;, &quot;abc&quot;, Ini);
	if(big!=3)	gr-&gt;Title(&quot;Fitting sample&quot;);
	gr-&gt;SetRange('y',-2,2);	gr-&gt;Box();	gr-&gt;Plot(dat, &quot;k. &quot;);
	gr-&gt;Axis();		gr-&gt;Plot(res, &quot;r&quot;);	gr-&gt;Plot(in, &quot;b&quot;);
	gr-&gt;Puts(mglPoint(-0.9, -1.3), &quot;fitted:&quot;, &quot;r:L&quot;);
	gr-&gt;PutsFit(mglPoint(0, -1.8), &quot;y = &quot;, &quot;r&quot;);
	gr-&gt;Puts(mglPoint(0, 2.2), &quot;initial: y = 0.3+sin(2\\pi x)&quot;, &quot;b&quot;);
//	gr-&gt;SetRanges(mglPoint(-1,-1,-1),mglPoint(1,1,1));	gr-&gt;SetOrigin(0,0,0);
}
</pre><div align="center"><img src="png/fit.png" alt="Sample fit">
</div>
<hr>
<a name="flame2d-sample"></a>
<div class="header">
<p>
Next: <a href="#flow-sample" accesskey="n" rel="next">flow sample</a>, Previous: <a href="#fit-sample" accesskey="p" rel="prev">fit sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-flame2d"></a>
<h3 class="section">10.52 Sample &lsquo;<samp>flame2d</samp>&rsquo;</h3>


<p>Function <a href="#flame2d">flame2d</a> generate points for flame fractals in 2d case.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">list A [0.33,0,0,0.33,0,0,0.2] [0.33,0,0,0.33,0.67,0,0.2] [0.33,0,0,0.33,0.33,0.33,0.2]\
	[0.33,0,0,0.33,0,0.67,0.2] [0.33,0,0,0.33,0.67,0.67,0.2]
new B 2 3 A.ny '0.3'
put B 3 0 0 -1
put B 3 0 1 -1
put B 3 0 2 -1
flame2d fx fy A B 1000000
subplot 1 1 0 '&lt;_':title 'Flame2d sample'
ranges fx fy:box:axis
plot fx fy 'r#o ';size 0.05
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_flame2d(mglGraph *gr)
{
	mglData A, B(2,3,5);
	A.SetList(35, 0.33,0.,0.,0.33,0.,0.,0.2, 0.33,0.,0.,0.33,0.67,0.,0.2, 0.33,0.,0.,0.33,0.33,0.33,0.2,
			0.33,0.,0.,0.33,0.,0.67,0.2, 0.33,0.,0.,0.33,0.67,0.67,0.2);
	A.Rearrange(7);
	for(long i=0;i&lt;2*3*5;i++)	B.a[i] = 0.3;
	for(long i=0;i&lt;5;i++)	B.a[2*3*i] = B.a[2*3*i+1*2] = B.a[2*3*i+2*2] = 3;
	mglData f(mglFlame2d(A,B,1000000));
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Flame2d sample&quot;);
	gr-&gt;SetRanges(f.SubData(0), f.SubData(1));
	gr-&gt;Axis();	gr-&gt;Box();
	gr-&gt;Plot(f.SubData(0), f.SubData(1),&quot;r#o &quot;,&quot;size 0.05&quot;);
}
</pre><div align="center"><img src="png/flame2d.png" alt="Sample flame2d">
</div>
<hr>
<a name="flow-sample"></a>
<div class="header">
<p>
Next: <a href="#flow3-sample" accesskey="n" rel="next">flow3 sample</a>, Previous: <a href="#flame2d-sample" accesskey="p" rel="prev">flame2d sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-flow"></a>
<h3 class="section">10.53 Sample &lsquo;<samp>flow</samp>&rsquo;</h3>


<p>Function <a href="#flow">flow</a> is another standard way to visualize vector fields &ndash; it draw lines (threads) which is tangent to local vector field direction. MathGL draw threads from edges of bounding box and from central slices. Sometimes it is not most appropriate variant &ndash; you may want to use <code>flowp</code> to specify manual position of threads. The color scheme is used for coloring (see <a href="#Color-scheme">Color scheme</a>). At this warm color corresponds to normal flow (like attractor), cold one corresponds to inverse flow (like source).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2v'
call 'prepare3v'
subplot 2 2 0 '':title 'Flow plot (default)':box:flow a b
subplot 2 2 1 '':title '&quot;v&quot; style':box:flow a b 'v'
subplot 2 2 2 '':title '&quot;#&quot; and &quot;.&quot; styles':box:flow a b '#':flow a b '.2k'
subplot 2 2 3:title '3d variant':rotate 50 60:box:flow ex ey ez
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_flow(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2v(&amp;a,&amp;b);
	if(big!=3)	{gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Flow plot (default)&quot;);}
	gr-&gt;Box();	gr-&gt;Flow(a,b);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;'v' style&quot;);
	gr-&gt;Box();	gr-&gt;Flow(a,b,&quot;v&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'\\#' and '.' styles&quot;);
	gr-&gt;Box();	gr-&gt;Flow(a,b,&quot;#&quot;);	gr-&gt;Flow(a,b,&quot;.2k&quot;);
	mglData ex,ey,ez;	mgls_prepare3v(&amp;ex,&amp;ey,&amp;ez);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Flow(ex,ey,ez);
}
</pre><div align="center"><img src="png/flow.png" alt="Sample flow">
</div>
<hr>
<a name="flow3-sample"></a>
<div class="header">
<p>
Next: <a href="#fog-sample" accesskey="n" rel="next">fog sample</a>, Previous: <a href="#flow-sample" accesskey="p" rel="prev">flow sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-flow3"></a>
<h3 class="section">10.54 Sample &lsquo;<samp>flow3</samp>&rsquo;</h3>


<p>Function <a href="#flow3">flow3</a> draw flow threads, which start from given plane.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3v'
subplot 2 2 0:title 'Flow3 plot (default)':rotate 50 60:box
flow3 ex ey ez
subplot 2 2 1:title '&quot;v&quot; style, from boundary':rotate 50 60:box
flow3 ex ey ez 'v' 0
subplot 2 2 2:title '&quot;t&quot; style':rotate 50 60:box
flow3 ex ey ez 't' 0
subplot 2 2 3:title 'from \i z planes':rotate 50 60:box
flow3 ex ey ez 'z' 0
flow3 ex ey ez 'z' 9
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_flow3(mglGraph *gr)
{
	mglData ex,ey,ez;	mgls_prepare3v(&amp;ex,&amp;ey,&amp;ez);
	if(big!=3)	{gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Flow3 plot (default)&quot;);}
	gr-&gt;Rotate(50,60);	gr-&gt;Box();		gr-&gt;Flow3(ex,ey,ez);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'v' style, from boundary&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Flow3(ex,ey,ez,&quot;v&quot;,0);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'t' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Flow3(ex,ey,ez,&quot;t&quot;,0);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;from \\i z planes&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Flow3(ex,ey,ez,&quot;z&quot;,0);	gr-&gt;Flow3(ex,ey,ez,&quot;z&quot;,9);
}
</pre><div align="center"><img src="png/flow3.png" alt="Sample flow3">
</div>
<hr>
<a name="fog-sample"></a>
<div class="header">
<p>
Next: <a href="#fonts-sample" accesskey="n" rel="next">fonts sample</a>, Previous: <a href="#flow3-sample" accesskey="p" rel="prev">flow3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-fog"></a>
<h3 class="section">10.55 Sample &lsquo;<samp>fog</samp>&rsquo;</h3>


<p>Example of <a href="#fog">fog</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Fog sample':rotate 50 60:light on:fog 1
box:surf a:cont a 'y'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_fog(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Fog sample&quot;);
	gr-&gt;Light(true);	gr-&gt;Rotate(50,60);	gr-&gt;Fog(1);	gr-&gt;Box();
	gr-&gt;Surf(a);	gr-&gt;Cont(a,&quot;y&quot;);
}
</pre><div align="center"><img src="png/fog.png" alt="Sample fog">
</div>
<hr>
<a name="fonts-sample"></a>
<div class="header">
<p>
Next: <a href="#grad-sample" accesskey="n" rel="next">grad sample</a>, Previous: <a href="#fog-sample" accesskey="p" rel="prev">fog sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-fonts"></a>
<h3 class="section">10.56 Sample &lsquo;<samp>fonts</samp>&rsquo;</h3>


<p>Example of <a href="#font">font</a> typefaces.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">define d 0.25
loadfont 'STIX':text 0 1.1 'default font (STIX)'
loadfont 'adventor':text 0 1.1-d 'adventor font'
loadfont 'bonum':text 0 1.1-2*d 'bonum font'
loadfont 'chorus':text 0 1.1-3*d 'chorus font'
loadfont 'cursor':text 0 1.1-4*d 'cursor font'
loadfont 'heros':text 0 1.1-5*d 'heros font'
loadfont 'heroscn':text 0 1.1-6*d 'heroscn font'
loadfont 'pagella':text 0 1.1-7*d 'pagella font'
loadfont 'schola':text 0 1.1-8*d 'schola font'
loadfont 'termes':text 0 1.1-9*d 'termes font'
loadfont ''
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_fonts(mglGraph *gr)	// font typefaces
{
	double h=1.1, d=0.25;
	gr-&gt;LoadFont(&quot;STIX&quot;);		gr-&gt;Puts(mglPoint(0,h), &quot;default font (STIX)&quot;);
	gr-&gt;LoadFont(&quot;adventor&quot;);	gr-&gt;Puts(mglPoint(0,h-d), &quot;adventor font&quot;);
	gr-&gt;LoadFont(&quot;bonum&quot;);		gr-&gt;Puts(mglPoint(0,h-2*d), &quot;bonum font&quot;);
	gr-&gt;LoadFont(&quot;chorus&quot;);		gr-&gt;Puts(mglPoint(0,h-3*d), &quot;chorus font&quot;);
	gr-&gt;LoadFont(&quot;cursor&quot;);		gr-&gt;Puts(mglPoint(0,h-4*d), &quot;cursor font&quot;);
	gr-&gt;LoadFont(&quot;heros&quot;);		gr-&gt;Puts(mglPoint(0,h-5*d), &quot;heros font&quot;);
	gr-&gt;LoadFont(&quot;heroscn&quot;);	gr-&gt;Puts(mglPoint(0,h-6*d), &quot;heroscn font&quot;);
	gr-&gt;LoadFont(&quot;pagella&quot;);	gr-&gt;Puts(mglPoint(0,h-7*d), &quot;pagella font&quot;);
	gr-&gt;LoadFont(&quot;schola&quot;);		gr-&gt;Puts(mglPoint(0,h-8*d), &quot;schola font&quot;);
	gr-&gt;LoadFont(&quot;termes&quot;);		gr-&gt;Puts(mglPoint(0,h-9*d), &quot;termes font&quot;);
	gr-&gt;LoadFont(&quot;&quot;);
}
</pre><div align="center"><img src="png/fonts.png" alt="Sample fonts">
</div>
<hr>
<a name="grad-sample"></a>
<div class="header">
<p>
Next: <a href="#hist-sample" accesskey="n" rel="next">hist sample</a>, Previous: <a href="#fonts-sample" accesskey="p" rel="prev">fonts sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-grad"></a>
<h3 class="section">10.57 Sample &lsquo;<samp>grad</samp>&rsquo;</h3>


<p>Function <a href="#grad">grad</a> draw gradient lines for matrix.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
subplot 1 1 0 '':title 'Grad plot':box:grad a:dens a '{u8}w{q8}'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_grad(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Grad plot&quot;);}
	gr-&gt;Box();	gr-&gt;Grad(a);	gr-&gt;Dens(a,&quot;{u8}w{q8}&quot;);
}
</pre><div align="center"><img src="png/grad.png" alt="Sample grad">
</div>
<hr>
<a name="hist-sample"></a>
<div class="header">
<p>
Next: <a href="#ifs2d-sample" accesskey="n" rel="next">ifs2d sample</a>, Previous: <a href="#grad-sample" accesskey="p" rel="prev">grad sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-hist"></a>
<h3 class="section">10.58 Sample &lsquo;<samp>hist</samp>&rsquo;</h3>


<p>Example of <a href="#hist">hist</a> (histogram).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 10000 '2*rnd-1':new y 10000 '2*rnd-1':copy z exp(-6*(x^2+y^2))
hist xx x z:norm xx 0 1:hist yy y z:norm yy 0 1
multiplot 3 3 3 2 2 '':ranges -1 1 -1 1 0 1:box:dots x y z 'wyrRk'
multiplot 3 3 0 2 1 '':ranges -1 1 0 1:box:bars xx
multiplot 3 3 5 1 2 '':ranges 0 1 -1 1:box:barh yy
subplot 3 3 2:text 0.5 0.5 'Hist and\n{}MultiPlot\n{}sample' 'a' -3
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_hist(mglGraph *gr)
{
	mglData x(10000), y(10000), z(10000);	gr-&gt;Fill(x,&quot;2*rnd-1&quot;);	gr-&gt;Fill(y,&quot;2*rnd-1&quot;);	gr-&gt;Fill(z,&quot;exp(-6*(v^2+w^2))&quot;,x,y);
	mglData xx=gr-&gt;Hist(x,z), yy=gr-&gt;Hist(y,z);	xx.Norm(0,1);	yy.Norm(0,1);
	gr-&gt;MultiPlot(3,3,3,2,2,&quot;&quot;);	gr-&gt;SetRanges(-1,1,-1,1,0,1);	gr-&gt;Box();	gr-&gt;Dots(x,y,z,&quot;wyrRk&quot;);
	gr-&gt;MultiPlot(3,3,0,2,1,&quot;&quot;);	gr-&gt;SetRanges(-1,1,0,1);	gr-&gt;Box();	gr-&gt;Bars(xx);
	gr-&gt;MultiPlot(3,3,5,1,2,&quot;&quot;);	gr-&gt;SetRanges(0,1,-1,1);	gr-&gt;Box();	gr-&gt;Barh(yy);
	gr-&gt;SubPlot(3,3,2);		gr-&gt;Puts(mglPoint(0.5,0.5),&quot;Hist and\nMultiPlot\nsample&quot;,&quot;a&quot;,-3);
}
</pre><div align="center"><img src="png/hist.png" alt="Sample hist">
</div>
<hr>
<a name="ifs2d-sample"></a>
<div class="header">
<p>
Next: <a href="#ifs3d-sample" accesskey="n" rel="next">ifs3d sample</a>, Previous: <a href="#hist-sample" accesskey="p" rel="prev">hist sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ifs2d"></a>
<h3 class="section">10.59 Sample &lsquo;<samp>ifs2d</samp>&rsquo;</h3>


<p>Function <a href="#ifs2d">ifs2d</a> generate points for fractals using iterated function system in 2d case.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">list A [0.33,0,0,0.33,0,0,0.2] [0.33,0,0,0.33,0.67,0,0.2] [0.33,0,0,0.33,0.33,0.33,0.2]\
	[0.33,0,0,0.33,0,0.67,0.2] [0.33,0,0,0.33,0.67,0.67,0.2]
ifs2d fx fy A 100000
subplot 1 1 0 '&lt;_':title 'IFS 2d sample'
ranges fx fy:axis
plot fx fy 'r#o ';size 0.05
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ifs2d(mglGraph *gr)
{
	mglData A;
	A.SetList(35, 0.33,0.,0.,0.33,0.,0.,0.2, 0.33,0.,0.,0.33,0.67,0.,0.2, 0.33,0.,0.,0.33,0.33,0.33,0.2, 0.33,0.,0.,0.33,0.,0.67,0.2, 0.33,0.,0.,0.33,0.67,0.67,0.2);
	A.Rearrange(7);
	mglData f(mglIFS2d(A,100000));
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;IFS 2d sample&quot;);
	gr-&gt;SetRanges(f.SubData(0), f.SubData(1));
	gr-&gt;Axis();	gr-&gt;Plot(f.SubData(0), f.SubData(1),&quot;r#o &quot;,&quot;size 0.05&quot;);
}
</pre><div align="center"><img src="png/ifs2d.png" alt="Sample ifs2d">
</div>
<hr>
<a name="ifs3d-sample"></a>
<div class="header">
<p>
Next: <a href="#indirect-sample" accesskey="n" rel="next">indirect sample</a>, Previous: <a href="#ifs2d-sample" accesskey="p" rel="prev">ifs2d sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ifs3d"></a>
<h3 class="section">10.60 Sample &lsquo;<samp>ifs3d</samp>&rsquo;</h3>


<p>Function <a href="#ifs3d">ifs3d</a> generate points for fractals using iterated function system in 3d case.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">list A [0,0,0,0,.18,0,0,0,0,0,0,0,.01] [.85,0,0,0,.85,.1,0,-0.1,0.85,0,1.6,0,.85]\
	[.2,-.2,0,.2,.2,0,0,0,0.3,0,0.8,0,.07] [-.2,.2,0,.2,.2,0,0,0,0.3,0,0.8,0,.07]
ifs3d f A 100000
title 'IFS 3d sample':rotate 50 60
ranges f(0) f(1) f(2):axis:box
dots f(0) f(1) f(2) 'G#o';size 0.05
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ifs3d(mglGraph *gr)
{
	mglData A;
	A.SetList(52, 0.,0.,0.,0.,.18,0.,0.,0.,0.,0.,0.,0.,.01, .85,0.,0.,0.,.85,.1,0.,-0.1,0.85,0.,1.6,0.,.85,
			.2,-.2,0.,.2,.2,0.,0.,0.,0.3,0.,0.8,0.,.07, -.2,.2,0.,.2,.2,0.,0.,0.,0.3,0.,0.8,0.,.07);
	A.Rearrange(13);
	mglData f(mglIFS3d(A,100000));
	if(big!=3)	gr-&gt;Title(&quot;IFS 3d sample&quot;);
	gr-&gt;SetRanges(f.SubData(0), f.SubData(1), f.SubData(2));
	gr-&gt;Rotate(50,60);	gr-&gt;Axis();	gr-&gt;Box();
	gr-&gt;Dots(f.SubData(0), f.SubData(1), f.SubData(2),&quot;G#o&quot;,&quot;size 0.05&quot;);
}
</pre><div align="center"><img src="png/ifs3d.png" alt="Sample ifs3d">
</div>
<hr>
<a name="indirect-sample"></a>
<div class="header">
<p>
Next: <a href="#inplot-sample" accesskey="n" rel="next">inplot sample</a>, Previous: <a href="#ifs3d-sample" accesskey="p" rel="prev">ifs3d sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-indirect"></a>
<h3 class="section">10.61 Sample &lsquo;<samp>indirect</samp>&rsquo;</h3>


<p>Comparison of <a href="#subdata">subdata</a> vs <a href="#evaluate">evaluate</a>/
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '':title 'SubData vs Evaluate'
new in 9 'x^3/1.1':plot in 'ko ':box
new arg 99 '4*x+4'
evaluate e in arg off:plot e 'b.'; legend 'Evaluate'
subdata s in arg:plot s 'r.';legend 'SubData'
legend 2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_indirect(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;SubData vs Evaluate&quot;);
	mglData in(9), arg(99), e, s;
	gr-&gt;Fill(in,&quot;x^3/1.1&quot;);	gr-&gt;Fill(arg,&quot;4*x+4&quot;);
	gr-&gt;Plot(in,&quot;ko &quot;);		gr-&gt;Box();
	e = in.Evaluate(arg,false);	gr-&gt;Plot(e,&quot;b.&quot;,&quot;legend 'Evaluate'&quot;);
	s = in.SubData(arg);	gr-&gt;Plot(s,&quot;r.&quot;,&quot;legend 'SubData'&quot;);
	gr-&gt;Legend(2);
}
</pre><div align="center"><img src="png/indirect.png" alt="Sample indirect">
</div>
<hr>
<a name="inplot-sample"></a>
<div class="header">
<p>
Next: <a href="#iris-sample" accesskey="n" rel="next">iris sample</a>, Previous: <a href="#indirect-sample" accesskey="p" rel="prev">indirect sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-inplot"></a>
<h3 class="section">10.62 Sample &lsquo;<samp>inplot</samp>&rsquo;</h3>


<p>Example of <a href="#inplot">inplot</a>, <a href="#multiplot">multiplot</a>, <a href="#columnplot">columnplot</a>, <a href="#gridplot">gridplot</a>, <a href="#shearplot">shearplot</a>, <a href="#stickplot">stickplot</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 3 2 0:title 'StickPlot'
stickplot 3 0 20 30:box 'r':text 0 0 0 '0' 'r'
stickplot 3 1 20 30:box 'g':text 0 0 0 '1' 'g'
stickplot 3 2 20 30:box 'b':text 0 9 0 '2' 'b'
subplot 3 2 3 '':title 'ColumnPlot'
columnplot 3 0:box 'r':text 0 0 '0' 'r'
columnplot 3 1:box 'g':text 0 0 '1' 'g'
columnplot 3 2:box 'b':text 0 0 '2' 'b'
subplot 3 2 4 '':title 'GridPlot'
gridplot 2 2 0:box 'r':text 0 0 '0' 'r'
gridplot 2 2 1:box 'g':text 0 0 '1' 'g'
gridplot 2 2 2:box 'b':text 0 0 '2' 'b'
gridplot 2 2 3:box 'm':text 0 0 '3' 'm'
subplot 3 2 5 '':title 'InPlot':box
inplot 0.4 1 0.6 1 on:box 'r'
multiplot 3 2 1 2 1 '':title 'MultiPlot and ShearPlot':box
shearplot 3 0 0.2 0.1:box 'r':text 0 0 '0' 'r'
shearplot 3 1 0.2 0.1:box 'g':text 0 0 '1' 'g'
shearplot 3 2 0.2 0.1:box 'b':text 0 0 '2' 'b'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_inplot(mglGraph *gr)
{
	gr-&gt;SubPlot(3,2,0);	gr-&gt;Title(&quot;StickPlot&quot;);
	gr-&gt;StickPlot(3, 0, 20, 30);	gr-&gt;Box(&quot;r&quot;);	gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
	gr-&gt;StickPlot(3, 1, 20, 30);	gr-&gt;Box(&quot;g&quot;);	gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
	gr-&gt;StickPlot(3, 2, 20, 30);	gr-&gt;Box(&quot;b&quot;);	gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
	gr-&gt;SubPlot(3,2,3,&quot;&quot;);	gr-&gt;Title(&quot;ColumnPlot&quot;);
	gr-&gt;ColumnPlot(3, 0);	gr-&gt;Box(&quot;r&quot;);	gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
	gr-&gt;ColumnPlot(3, 1);	gr-&gt;Box(&quot;g&quot;);	gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
	gr-&gt;ColumnPlot(3, 2);	gr-&gt;Box(&quot;b&quot;);	gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
	gr-&gt;SubPlot(3,2,4,&quot;&quot;);	gr-&gt;Title(&quot;GridPlot&quot;);
	gr-&gt;GridPlot(2, 2, 0);	gr-&gt;Box(&quot;r&quot;);	gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
	gr-&gt;GridPlot(2, 2, 1);	gr-&gt;Box(&quot;g&quot;);	gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
	gr-&gt;GridPlot(2, 2, 2);	gr-&gt;Box(&quot;b&quot;);	gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
	gr-&gt;GridPlot(2, 2, 3);	gr-&gt;Box(&quot;m&quot;);	gr-&gt;Puts(mglPoint(0),&quot;3&quot;,&quot;m&quot;);
	gr-&gt;SubPlot(3,2,5,&quot;&quot;);	gr-&gt;Title(&quot;InPlot&quot;);	gr-&gt;Box();
	gr-&gt;InPlot(0.4, 1, 0.6, 1, true);	gr-&gt;Box(&quot;r&quot;);
	gr-&gt;MultiPlot(3,2,1, 2, 1,&quot;&quot;);	gr-&gt;Title(&quot;MultiPlot and ShearPlot&quot;);	gr-&gt;Box();
	gr-&gt;ShearPlot(3, 0, 0.2, 0.1);	gr-&gt;Box(&quot;r&quot;);	gr-&gt;Puts(mglPoint(0),&quot;0&quot;,&quot;r&quot;);
	gr-&gt;ShearPlot(3, 1, 0.2, 0.1);	gr-&gt;Box(&quot;g&quot;);	gr-&gt;Puts(mglPoint(0),&quot;1&quot;,&quot;g&quot;);
	gr-&gt;ShearPlot(3, 2, 0.2, 0.1);	gr-&gt;Box(&quot;b&quot;);	gr-&gt;Puts(mglPoint(0),&quot;2&quot;,&quot;b&quot;);
}
</pre><div align="center"><img src="png/inplot.png" alt="Sample inplot">
</div>
<hr>
<a name="iris-sample"></a>
<div class="header">
<p>
Next: <a href="#label-sample" accesskey="n" rel="next">label sample</a>, Previous: <a href="#inplot-sample" accesskey="p" rel="prev">inplot sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-iris"></a>
<h3 class="section">10.63 Sample &lsquo;<samp>iris</samp>&rsquo;</h3>


<p>Function <a href="#iris">iris</a> draw Iris plot for columns of data array.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">read a 'iris.dat'
crop a 0 4 'x':rearrange a a.nx 50
subplot 1 1 0 '':title 'Iris plot'
iris a 'sepal\n length;sepal\n width;petal\n length;petal\n width' '. ';value -1.5;size -2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_iris(mglGraph *gr)
{
	mglData a(&quot;iris.dat&quot;);	a.Crop(0,4,'x');	a.Rearrange(4,50);
	gr-&gt;SubPlot(1,1,0,&quot;&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Iris sample&quot;);
	gr-&gt;Iris(a, &quot;sepal\nlength;sepal\nwidth;petal\nlength;petal\nwidth&quot;, &quot;. &quot;, &quot;value -1.5;size -2&quot;);
}
</pre><div align="center"><img src="png/iris.png" alt="Sample iris">
</div>
<hr>
<a name="label-sample"></a>
<div class="header">
<p>
Next: <a href="#lamerey-sample" accesskey="n" rel="next">lamerey sample</a>, Previous: <a href="#iris-sample" accesskey="p" rel="prev">iris sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-label"></a>
<h3 class="section">10.64 Sample &lsquo;<samp>label</samp>&rsquo;</h3>


<p>Function <a href="#label">label</a> print text at data points. The string may contain &lsquo;<samp>%x</samp>&rsquo;, &lsquo;<samp>%y</samp>&rsquo;, &lsquo;<samp>%z</samp>&rsquo; for x-, y-, z-coordinates of points, &lsquo;<samp>%n</samp>&rsquo; for point index.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ys 10 '0.2*rnd-0.8*sin(pi*x)'
subplot 1 1 0 '':title 'Label plot':box:plot ys ' *':label ys 'y=%y'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_label(mglGraph *gr)
{
	mglData ys(10);	ys.Modify(&quot;0.8*sin(pi*2*x)+0.2*rnd&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Label plot&quot;);	}
	gr-&gt;Box();	gr-&gt;Plot(ys,&quot; *&quot;);	gr-&gt;Label(ys,&quot;y=%y&quot;);
}
</pre><div align="center"><img src="png/label.png" alt="Sample label">
</div>
<hr>
<a name="lamerey-sample"></a>
<div class="header">
<p>
Next: <a href="#legend-sample" accesskey="n" rel="next">legend sample</a>, Previous: <a href="#label-sample" accesskey="p" rel="prev">label sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-lamerey"></a>
<h3 class="section">10.65 Sample &lsquo;<samp>lamerey</samp>&rsquo;</h3>


<p>Function <a href="#lamerey">lamerey</a> draw Lamerey diagram.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_':title 'Lamerey sample'
axis:xlabel '\i x':ylabel '\bar{\i x} = 2 \i{x}'
fplot 'x' 'k='
fplot '2*x' 'b'
lamerey 0.00097 '2*x' 'rv~';size 2
lamerey -0.00097 '2*x' 'rv~';size 2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_lamerey(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Lamerey sample&quot;);
	gr-&gt;Axis();	gr-&gt;Label('x',&quot;\\i x&quot;);	gr-&gt;Label('y',&quot;\\bar{\\i x} = 2 \\i{x}&quot;);
	gr-&gt;FPlot(&quot;x&quot;,&quot;k=&quot;);	gr-&gt;FPlot(&quot;2*x&quot;,&quot;b&quot;);
	gr-&gt;Lamerey( 0.00097,&quot;2*x&quot;,&quot;rv~&quot;);
	gr-&gt;Lamerey(-0.00097,&quot;2*x&quot;,&quot;rv~&quot;);
}
</pre><div align="center"><img src="png/lamerey.png" alt="Sample lamerey">
</div>
<hr>
<a name="legend-sample"></a>
<div class="header">
<p>
Next: <a href="#light-sample" accesskey="n" rel="next">light sample</a>, Previous: <a href="#lamerey-sample" accesskey="p" rel="prev">lamerey sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-legend"></a>
<h3 class="section">10.66 Sample &lsquo;<samp>legend</samp>&rsquo;</h3>


<p>Example of <a href="#legend">legend</a> styles.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">addlegend 'sin(\pi {x^2})' 'b':addlegend 'sin(\pi x)' 'g*'
addlegend 'sin(\pi \sqrt{x})' 'rd':addlegend 'jsut text' ' ':addlegend 'no indent for this' ''
subplot 2 2 0 '':title 'Legend (default)':box:legend
legend 1 0.5 '^':text 0.49 0.88 'Style &quot;\^&quot;' 'A:L'
legend 3 'A#':text 0.75 0.65 'Absolute position' 'A'
subplot 2 2 2 '':title 'coloring':box:legend 0 'r#':legend 1 'Wb#':legend 2 'ygr#'
subplot 2 2 3 '':title 'manual position':box
legend 0.5 1:text 0.5 0.5 'at x=0.5, y=1' 'a'
legend 1 '#-':text 0.75 0.25 'Horizontal legend' 'a'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_legend(mglGraph *gr)
{
	gr-&gt;AddLegend(&quot;sin(\\pi {x^2})&quot;,&quot;b&quot;);
	gr-&gt;AddLegend(&quot;sin(\\pi x)&quot;,&quot;g*&quot;);
	gr-&gt;AddLegend(&quot;sin(\\pi \\sqrt{x})&quot;,&quot;rd&quot;);
	gr-&gt;AddLegend(&quot;just text&quot;,&quot; &quot;);
	gr-&gt;AddLegend(&quot;no indent for this&quot;,&quot;&quot;);
	if(big!=3)	{gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Legend (default)&quot;);}
	gr-&gt;Box();	gr-&gt;Legend();
	if(big==3)	return;
	gr-&gt;Legend(1,0.5,&quot;^&quot;);	gr-&gt;Puts(0.49, 0.88, &quot;Style '\\^'&quot;,&quot;A:L&quot;);
	gr-&gt;Legend(3,&quot;A#&quot;);
	gr-&gt;Puts(mglPoint(0.75,0.65),&quot;Absolute position&quot;,&quot;A&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;coloring&quot;);	gr-&gt;Box();
	gr-&gt;Legend(0,&quot;r#&quot;);	gr-&gt;Legend(1,&quot;Wb#&quot;);	gr-&gt;Legend(2,&quot;ygr#&quot;);
	gr-&gt;SubPlot(2,2,3,&quot;&quot;);	gr-&gt;Title(&quot;manual position&quot;);	gr-&gt;Box();
	gr-&gt;Legend(0.5,1);
	gr-&gt;Puts(mglPoint(0.5,0.5),&quot;at x=0.5, y=1&quot;,&quot;a&quot;);
	gr-&gt;Legend(1,&quot;#-&quot;);
	gr-&gt;Puts(mglPoint(0.75,0.25),&quot;Horizontal legend&quot;,&quot;a&quot;);
}
</pre><div align="center"><img src="png/legend.png" alt="Sample legend">
</div>
<hr>
<a name="light-sample"></a>
<div class="header">
<p>
Next: <a href="#loglog-sample" accesskey="n" rel="next">loglog sample</a>, Previous: <a href="#legend-sample" accesskey="p" rel="prev">legend sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-light"></a>
<h3 class="section">10.67 Sample &lsquo;<samp>light</samp>&rsquo;</h3>


<p>Example of <a href="#light">light</a> with different types.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">light on:attachlight on
call 'prepare2d'
subplot 2 2 0:title 'Default':rotate 50 60:box:surf a
line -1 -0.7 1.7 -1 -0.7 0.7 'BA'

subplot 2 2 1:title 'Local':rotate 50 60
light 0 1 0 1 -2 -1 -1
line 1 0 1 -1 -1 0 'BAO':box:surf a

subplot 2 2 2:title 'no diffuse':rotate 50 60
diffuse 0
line 1 0 1 -1 -1 0 'BAO':box:surf a

subplot 2 2 3:title 'diffusive only':rotate 50 60
diffuse 0.5:light 0 1 0 1 -2 -1 -1 'w' 0
line 1 0 1 -1 -1 0 'BAO':box:surf a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_light(mglGraph *gr)	// local light sources
{
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;Light(true);	gr-&gt;AttachLight(true);
	if(big==3)
	{	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Surf(a);	return;	}
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Default&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Line(mglPoint(-1,-0.7,1.7),mglPoint(-1,-0.7,0.7),&quot;BA&quot;);	gr-&gt;Box();	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Local&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;AddLight(0,mglPoint(1,0,1),mglPoint(-2,-1,-1));
	gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);	gr-&gt;Box();	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;no diffuse&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;SetDiffuse(0);
	gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);	gr-&gt;Box();	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;diffusive only&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;SetDiffuse(0.5);
	gr-&gt;AddLight(0,mglPoint(1,0,1),mglPoint(-2,-1,-1),'w',0);
	gr-&gt;Line(mglPoint(1,0,1),mglPoint(-1,-1,0),&quot;BAO&quot;);	gr-&gt;Box();	gr-&gt;Surf(a);
}
</pre><div align="center"><img src="png/light.png" alt="Sample light">
</div>
<hr>
<a name="loglog-sample"></a>
<div class="header">
<p>
Next: <a href="#map-sample" accesskey="n" rel="next">map sample</a>, Previous: <a href="#light-sample" accesskey="p" rel="prev">light sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-loglog"></a>
<h3 class="section">10.68 Sample &lsquo;<samp>loglog</samp>&rsquo;</h3>


<p>Example of log- and log-log- axis labels.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0 '&lt;_':title 'Semi-log axis':ranges 0.01 100 -1 1:axis 'lg(x)' '' ''
axis:grid 'xy' 'g':fplot 'sin(1/x)':xlabel 'x' 0:ylabel 'y = sin 1/x' 0
subplot 2 2 1 '&lt;_':title 'Log-log axis':ranges 0.01 100 0.1 100:axis 'lg(x)' 'lg(y)' ''
axis:grid '!' 'h=':grid:fplot 'sqrt(1+x^2)'
xlabel 'x' 0:ylabel 'y = \sqrt{1+x^2}' 0
subplot 2 2 2 '&lt;_':title 'Minus-log axis':ranges -100 -0.01 -100 -0.1:axis '-lg(-x)' '-lg(-y)' ''
axis:fplot '-sqrt(1+x^2)':xlabel 'x' 0:ylabel 'y = -\sqrt{1+x^2}' 0
subplot 2 2 3 '&lt;_':title 'Log-ticks':ranges 0.01 100 0 100:axis 'sqrt(x)' '' ''
axis:fplot 'x':xlabel 'x' 1:ylabel 'y = x' 0
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_loglog(mglGraph *gr)	// log-log axis
{
	gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Semi-log axis&quot;);	gr-&gt;SetRanges(0.01,100,-1,1);	gr-&gt;SetFunc(&quot;lg(x)&quot;,&quot;&quot;);
	gr-&gt;Axis();	gr-&gt;Grid(&quot;xy&quot;,&quot;g&quot;);	gr-&gt;FPlot(&quot;sin(1/x)&quot;);	gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y', &quot;y = sin 1/x&quot;,0);
	gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Log-log axis&quot;);	gr-&gt;SetRanges(0.01,100,0.1,100);	gr-&gt;SetFunc(&quot;lg(x)&quot;,&quot;lg(y)&quot;);
	gr-&gt;Axis();	gr-&gt;Grid(&quot;!&quot;,&quot;h=&quot;);	gr-&gt;Grid();	gr-&gt;FPlot(&quot;sqrt(1+x^2)&quot;);	gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y', &quot;y = \\sqrt{1+x^2}&quot;,0);
	gr-&gt;SubPlot(2,2,2,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Minus-log axis&quot;);	gr-&gt;SetRanges(-100,-0.01,-100,-0.1);	gr-&gt;SetFunc(&quot;-lg(-x)&quot;,&quot;-lg(-y)&quot;);
	gr-&gt;Axis();	gr-&gt;FPlot(&quot;-sqrt(1+x^2)&quot;);	gr-&gt;Label('x',&quot;x&quot;,0); gr-&gt;Label('y', &quot;y = -\\sqrt{1+x^2}&quot;,0);
	gr-&gt;SubPlot(2,2,3,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Log-ticks&quot;);	gr-&gt;SetRanges(0.1,100,0,100);	gr-&gt;SetFunc(&quot;sqrt(x)&quot;,&quot;&quot;);
	gr-&gt;Axis();	gr-&gt;FPlot(&quot;x&quot;);	gr-&gt;Label('x',&quot;x&quot;,1); gr-&gt;Label('y', &quot;y = x&quot;,0);
}
</pre><div align="center"><img src="png/loglog.png" alt="Sample loglog">
</div>
<hr>
<a name="map-sample"></a>
<div class="header">
<p>
Next: <a href="#mark-sample" accesskey="n" rel="next">mark sample</a>, Previous: <a href="#loglog-sample" accesskey="p" rel="prev">loglog sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-map"></a>
<h3 class="section">10.69 Sample &lsquo;<samp>map</samp>&rsquo;</h3>


<p>Example of <a href="#map">map</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 50 40 'x':new b 50 40 'y':zrange -2 2:text 0 0 '\to'
subplot 2 1 0:text 0 1.1 '\{x, y\}' '' -2:box:map a b 'brgk'
subplot 2 1 1:text 0 1.1 '\{\frac{x^3+y^3}{2}, \frac{x-y}{2}\}' '' -2
box:fill a '(x^3+y^3)/2':fill b '(x-y)/2':map a b 'brgk'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_map(mglGraph *gr)	// example of mapping
{
	mglData a(50, 40), b(50, 40);
	gr-&gt;Puts(mglPoint(0, 0), &quot;\\to&quot;, &quot;:C&quot;, -1.4);
	gr-&gt;SetRanges(-1,1,-1,1,-2,2);

	gr-&gt;SubPlot(2, 1, 0);
	gr-&gt;Fill(a,&quot;x&quot;);	gr-&gt;Fill(b,&quot;y&quot;);
	gr-&gt;Puts(mglPoint(0, 1.1), &quot;\\{x, y\\}&quot;, &quot;:C&quot;, -2);		gr-&gt;Box();
	gr-&gt;Map(a, b, &quot;brgk&quot;);

	gr-&gt;SubPlot(2, 1, 1);
	gr-&gt;Fill(a,&quot;(x^3+y^3)/2&quot;);	gr-&gt;Fill(b,&quot;(x-y)/2&quot;);
	gr-&gt;Puts(mglPoint(0, 1.1), &quot;\\{\\frac{x^3+y^3}{2}, \\frac{x-y}{2}\\}&quot;, &quot;:C&quot;, -2);
	gr-&gt;Box();
	gr-&gt;Map(a, b, &quot;brgk&quot;);
}
</pre><div align="center"><img src="png/map.png" alt="Sample map">
</div>
<hr>
<a name="mark-sample"></a>
<div class="header">
<p>
Next: <a href="#mask-sample" accesskey="n" rel="next">mask sample</a>, Previous: <a href="#map-sample" accesskey="p" rel="prev">map sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-mark"></a>
<h3 class="section">10.70 Sample &lsquo;<samp>mark</samp>&rsquo;</h3>


<p>Example of <a href="#mark">mark</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 1 1 0 '':title 'Mark plot (default)':box:mark y y1 's'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_mark(mglGraph *gr)
{
	mglData y,y1;	mgls_prepare1d(&amp;y,&amp;y1);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Mark plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Mark(y,y1,&quot;s&quot;);
}
</pre><div align="center"><img src="png/mark.png" alt="Sample mark">
</div>
<hr>
<a name="mask-sample"></a>
<div class="header">
<p>
Next: <a href="#mesh-sample" accesskey="n" rel="next">mesh sample</a>, Previous: <a href="#mark-sample" accesskey="p" rel="prev">mark sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-mask"></a>
<h3 class="section">10.71 Sample &lsquo;<samp>mask</samp>&rsquo;</h3>


<p>Example of <a href="#mask">mask</a> kinds.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 10 10 'x'
subplot 5 4 0 '':title '&quot;-&quot; mask':dens a '3-'
subplot 5 4 1 '':title '&quot;+&quot; mask':dens a '3+'
subplot 5 4 2 '':title '&quot;=&quot; mask':dens a '3='
subplot 5 4 3 '':title '&quot;;&quot; mask':dens a '3;'
subplot 5 4 4 '':title '&quot;;I&quot; mask':dens a '3;I'
subplot 5 4 5 '':title '&quot;o&quot; mask':dens a '3o'
subplot 5 4 6 '':title '&quot;O&quot; mask':dens a '3O'
subplot 5 4 7 '':title '&quot;s&quot; mask':dens a '3s'
subplot 5 4 8 '':title '&quot;S&quot; mask':dens a '3S'
subplot 5 4 9 '':title '&quot;;/&quot; mask':dens a '3;/'
subplot 5 4 10 '':title '&quot;~&quot; mask':dens a '3~'
subplot 5 4 11 '':title '&quot;&lt;&quot; mask':dens a '3&lt;'
subplot 5 4 12 '':title '&quot;&gt;&quot; mask':dens a '3&gt;'
subplot 5 4 13 '':title '&quot;j&quot; mask':dens a '3j'
subplot 5 4 14 '':title '&quot;-;\&quot; mask':dens a '3\;'
subplot 5 4 15 '':title '&quot;d&quot; mask':dens a '3d'
subplot 5 4 16 '':title '&quot;D&quot; mask':dens a '3D'
subplot 5 4 17 '':title '&quot;*&quot; mask':dens a '3*'
subplot 5 4 18 '':title '&quot;\^&quot; mask':dens a '3^'
subplot 5 4 19 '':title 'manual mask'
mask '+' '24242424FF0101FF':dens a '3+'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_mask(mglGraph *gr)
{
	mglData a(10,10);	a.Fill(-1,1);
	gr-&gt;SubPlot(5,4,0,&quot;&quot;);	gr-&gt;Title(&quot;'-' mask&quot;);	gr-&gt;Dens(a,&quot;3-&quot;);
	gr-&gt;SubPlot(5,4,1,&quot;&quot;);	gr-&gt;Title(&quot;'+' mask&quot;);	gr-&gt;Dens(a,&quot;3+&quot;);
	gr-&gt;SubPlot(5,4,2,&quot;&quot;);	gr-&gt;Title(&quot;'=' mask&quot;);	gr-&gt;Dens(a,&quot;3=&quot;);
	gr-&gt;SubPlot(5,4,3,&quot;&quot;);	gr-&gt;Title(&quot;';' mask&quot;);	gr-&gt;Dens(a,&quot;3;&quot;);
	gr-&gt;SubPlot(5,4,4,&quot;&quot;);	gr-&gt;Title(&quot;';I' mask&quot;);	gr-&gt;Dens(a,&quot;3;I&quot;);
	gr-&gt;SubPlot(5,4,5,&quot;&quot;);	gr-&gt;Title(&quot;'o' mask&quot;);	gr-&gt;Dens(a,&quot;3o&quot;);
	gr-&gt;SubPlot(5,4,6,&quot;&quot;);	gr-&gt;Title(&quot;'O' mask&quot;);	gr-&gt;Dens(a,&quot;3O&quot;);
	gr-&gt;SubPlot(5,4,7,&quot;&quot;);	gr-&gt;Title(&quot;'s' mask&quot;);	gr-&gt;Dens(a,&quot;3s&quot;);
	gr-&gt;SubPlot(5,4,8,&quot;&quot;);	gr-&gt;Title(&quot;'S' mask&quot;);	gr-&gt;Dens(a,&quot;3S&quot;);
	gr-&gt;SubPlot(5,4,9,&quot;&quot;);	gr-&gt;Title(&quot;';/' mask&quot;);	gr-&gt;Dens(a,&quot;3;/&quot;);
	gr-&gt;SubPlot(5,4,10,&quot;&quot;);	gr-&gt;Title(&quot;'~' mask&quot;);	gr-&gt;Dens(a,&quot;3~&quot;);
	gr-&gt;SubPlot(5,4,11,&quot;&quot;);	gr-&gt;Title(&quot;'&lt;' mask&quot;);	gr-&gt;Dens(a,&quot;3&lt;&quot;);
	gr-&gt;SubPlot(5,4,12,&quot;&quot;);	gr-&gt;Title(&quot;'&gt;' mask&quot;);	gr-&gt;Dens(a,&quot;3&gt;&quot;);
	gr-&gt;SubPlot(5,4,13,&quot;&quot;);	gr-&gt;Title(&quot;'j' mask&quot;);	gr-&gt;Dens(a,&quot;3j&quot;);
	gr-&gt;SubPlot(5,4,14,&quot;&quot;);	gr-&gt;Title(&quot;';\\\\' mask&quot;);	gr-&gt;Dens(a,&quot;3;\\&quot;);
	gr-&gt;SubPlot(5,4,15,&quot;&quot;);	gr-&gt;Title(&quot;'d' mask&quot;);	gr-&gt;Dens(a,&quot;3d&quot;);
	gr-&gt;SubPlot(5,4,16,&quot;&quot;);	gr-&gt;Title(&quot;'D' mask&quot;);	gr-&gt;Dens(a,&quot;3D&quot;);
	gr-&gt;SubPlot(5,4,17,&quot;&quot;);	gr-&gt;Title(&quot;'*' mask&quot;);	gr-&gt;Dens(a,&quot;3*&quot;);
	gr-&gt;SubPlot(5,4,18,&quot;&quot;);	gr-&gt;Title(&quot;'\\^' mask&quot;);	gr-&gt;Dens(a,&quot;3^&quot;);
	gr-&gt;SubPlot(5,4,19,&quot;&quot;);	gr-&gt;Title(&quot;manual mask&quot;);
	gr-&gt;SetMask('+', &quot;24242424FF0101FF&quot;);	gr-&gt;Dens(a,&quot;3+&quot;);
}
</pre><div align="center"><img src="png/mask.png" alt="Sample mask">
</div>
<hr>
<a name="mesh-sample"></a>
<div class="header">
<p>
Next: <a href="#mirror-sample" accesskey="n" rel="next">mirror sample</a>, Previous: <a href="#mask-sample" accesskey="p" rel="prev">mask sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-mesh"></a>
<h3 class="section">10.72 Sample &lsquo;<samp>mesh</samp>&rsquo;</h3>


<p>Function <a href="#mesh">mesh</a> draw wired surface. You can use <a href="#meshnum">meshnum</a> for changing number of lines to be drawn.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Mesh plot':rotate 50 60:box:mesh a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_mesh(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Mesh plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Mesh(a);
}
</pre><div align="center"><img src="png/mesh.png" alt="Sample mesh">
</div>
<hr>
<a name="mirror-sample"></a>
<div class="header">
<p>
Next: <a href="#molecule-sample" accesskey="n" rel="next">molecule sample</a>, Previous: <a href="#mesh-sample" accesskey="p" rel="prev">mesh sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-mirror"></a>
<h3 class="section">10.73 Sample &lsquo;<samp>mirror</samp>&rsquo;</h3>


<p>Example of using options.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 31 41 '-pi*x*exp(-(y+1)^2-4*x^2)'
subplot 2 2 0:title 'Options for coordinates':alpha on:light on:rotate 40 60:box
surf a 'r';yrange 0 1:surf a 'b';yrange 0 -1
subplot 2 2 1:title 'Option &quot;meshnum&quot;':rotate 40 60:box
mesh a 'r'; yrange 0 1:mesh a 'b';yrange 0 -1; meshnum 5
subplot 2 2 2:title 'Option &quot;alpha&quot;':rotate 40 60:box
surf a 'r';yrange 0 1; alpha 0.7:surf a 'b';yrange 0 -1; alpha 0.3
subplot 2 2 3 '&lt;_':title 'Option &quot;legend&quot;'
fplot 'x^3' 'r'; legend 'y = x^3':fplot 'cos(pi*x)' 'b'; legend 'y = cos \pi x'
box:axis:legend 2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_mirror(mglGraph *gr)	// flag #
{
	mglData a(31,41);
	gr-&gt;Fill(a,&quot;-pi*x*exp(-(y+1)^2-4*x^2)&quot;);

	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Options for coordinates&quot;);	}
	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Surf(a,&quot;r&quot;,&quot;yrange 0 1&quot;); gr-&gt;Surf(a,&quot;b&quot;,&quot;yrange 0 -1&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Option 'meshnum'&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Mesh(a,&quot;r&quot;,&quot;yrange 0 1&quot;); gr-&gt;Mesh(a,&quot;b&quot;,&quot;yrange 0 -1; meshnum 5&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Option 'alpha'&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Surf(a,&quot;r&quot;,&quot;yrange 0 1; alpha 0.7&quot;); gr-&gt;Surf(a,&quot;b&quot;,&quot;yrange 0 -1; alpha 0.3&quot;);
	gr-&gt;SubPlot(2,2,3,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Option 'legend'&quot;);
	gr-&gt;FPlot(&quot;x^3&quot;,&quot;r&quot;,&quot;legend 'y = x^3'&quot;); gr-&gt;FPlot(&quot;cos(pi*x)&quot;,&quot;b&quot;,&quot;legend 'y = cos \\pi x'&quot;);
	gr-&gt;Box();	gr-&gt;Axis();	gr-&gt;Legend(2,&quot;&quot;);
}
</pre><div align="center"><img src="png/mirror.png" alt="Sample mirror">
</div>
<hr>
<a name="molecule-sample"></a>
<div class="header">
<p>
Next: <a href="#ode-sample" accesskey="n" rel="next">ode sample</a>, Previous: <a href="#mirror-sample" accesskey="p" rel="prev">mirror sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-molecule"></a>
<h3 class="section">10.74 Sample &lsquo;<samp>molecule</samp>&rsquo;</h3>


<p>Example of drawing molecules.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">alpha on:light on
subplot 2 2 0 '':title 'Methane, CH_4':rotate 60 120
sphere 0 0 0 0.25 'k':drop 0 0 0 0 0 1 0.35 'h' 1 2:sphere 0 0 0.7 0.25 'g'
drop 0 0 0 -0.94 0 -0.33 0.35 'h' 1 2:sphere -0.66 0 -0.23 0.25 'g'
drop 0 0 0 0.47 0.82 -0.33 0.35 'h' 1 2:sphere 0.33 0.57 -0.23 0.25 'g'
drop 0 0 0 0.47 -0.82 -0.33 0.35 'h' 1 2:sphere 0.33 -0.57 -0.23 0.25 'g'
subplot 2 2 1 '':title 'Water, H{_2}O':rotate 60 100
sphere 0 0 0 0.25 'r':drop 0 0 0 0.3 0.5 0 0.3 'm' 1 2:sphere 0.3 0.5 0 0.25 'g'
drop 0 0 0 0.3 -0.5 0 0.3 'm' 1 2:sphere 0.3 -0.5 0 0.25 'g'
subplot 2 2 2 '':title 'Oxygen, O_2':rotate 60 120
drop 0 0.5 0 0 -0.3 0 0.3 'm' 1 2:sphere 0 0.5 0 0.25 'r'
drop 0 -0.5 0 0 0.3 0 0.3 'm' 1 2:sphere 0 -0.5 0 0.25 'r'
subplot 2 2 3 '':title 'Ammonia, NH_3':rotate 60 120
sphere 0 0 0 0.25 'b':drop 0 0 0 0.33 0.57 0 0.32 'n' 1 2
sphere 0.33 0.57 0 0.25 'g':drop 0 0 0 0.33 -0.57 0 0.32 'n' 1 2
sphere 0.33 -0.57 0 0.25 'g':drop 0 0 0 -0.65 0 0 0.32 'n' 1 2
sphere -0.65 0 0 0.25 'g'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_molecule(mglGraph *gr)	// example of moleculas
{
	gr-&gt;VertexColor(false);	gr-&gt;Compression(false); // per-vertex colors and compression are detrimental to transparency
	gr-&gt;DoubleSided(false); // we do not get into atoms, while rendering internal surface has negative impact on trasparency
	gr-&gt;Alpha(true);	gr-&gt;Light(true);

	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Methane, CH_4&quot;);
	gr-&gt;StartGroup(&quot;Methane&quot;);
	gr-&gt;Rotate(60,120);
	gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;k&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0,0,1),0.35,&quot;h&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0,0,0.7),0.25,&quot;g&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(-0.94,0,-0.33),0.35,&quot;h&quot;,1,2);
	gr-&gt;Sphere(mglPoint(-0.66,0,-0.23),0.25,&quot;g&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.47,0.82,-0.33),0.35,&quot;h&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0.33,0.57,-0.23),0.25,&quot;g&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.47,-0.82,-0.33),0.35,&quot;h&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0.33,-0.57,-0.23),0.25,&quot;g&quot;);
	gr-&gt;EndGroup();

	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;Water, H_{2}O&quot;);
	gr-&gt;StartGroup(&quot;Water&quot;);
	gr-&gt;Rotate(60,100);
	gr-&gt;StartGroup(&quot;Water_O&quot;);
	gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;r&quot;);
	gr-&gt;EndGroup();
	gr-&gt;StartGroup(&quot;Water_Bond_1&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.3,0.5,0),0.3,&quot;m&quot;,1,2);
	gr-&gt;EndGroup();
	gr-&gt;StartGroup(&quot;Water_H_1&quot;);
	gr-&gt;Sphere(mglPoint(0.3,0.5,0),0.25,&quot;g&quot;);
	gr-&gt;EndGroup();
	gr-&gt;StartGroup(&quot;Water_Bond_2&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.3,-0.5,0),0.3,&quot;m&quot;,1,2);
	gr-&gt;EndGroup();
	gr-&gt;StartGroup(&quot;Water_H_2&quot;);
	gr-&gt;Sphere(mglPoint(0.3,-0.5,0),0.25,&quot;g&quot;);
	gr-&gt;EndGroup();
	gr-&gt;EndGroup();

	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;Oxygen, O_2&quot;);
	gr-&gt;StartGroup(&quot;Oxygen&quot;);
	gr-&gt;Rotate(60,120);
	gr-&gt;Drop(mglPoint(0,0.5,0),mglPoint(0,-0.3,0),0.3,&quot;m&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0,0.5,0),0.25,&quot;r&quot;);
	gr-&gt;Drop(mglPoint(0,-0.5,0),mglPoint(0,0.3,0),0.3,&quot;m&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0,-0.5,0),0.25,&quot;r&quot;);
	gr-&gt;EndGroup();

	gr-&gt;SubPlot(2,2,3,&quot;&quot;);	gr-&gt;Title(&quot;Ammonia, NH_3&quot;);
	gr-&gt;StartGroup(&quot;Ammonia&quot;);
	gr-&gt;Rotate(60,120);
	gr-&gt;Sphere(mglPoint(0,0,0),0.25,&quot;b&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.33,0.57,0),0.32,&quot;n&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0.33,0.57,0),0.25,&quot;g&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(0.33,-0.57,0),0.32,&quot;n&quot;,1,2);
	gr-&gt;Sphere(mglPoint(0.33,-0.57,0),0.25,&quot;g&quot;);
	gr-&gt;Drop(mglPoint(0,0,0),mglPoint(-0.65,0,0),0.32,&quot;n&quot;,1,2);
	gr-&gt;Sphere(mglPoint(-0.65,0,0),0.25,&quot;g&quot;);
	gr-&gt;EndGroup();
	gr-&gt;DoubleSided( true ); // put back
}
</pre><div align="center"><img src="png/molecule.png" alt="Sample molecule">
</div>
<hr>
<a name="ode-sample"></a>
<div class="header">
<p>
Next: <a href="#ohlc-sample" accesskey="n" rel="next">ohlc sample</a>, Previous: <a href="#molecule-sample" accesskey="p" rel="prev">molecule sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ode"></a>
<h3 class="section">10.75 Sample &lsquo;<samp>ode</samp>&rsquo;</h3>


<p>Example of phase plain created by <a href="#ode">ode</a> solving, contour lines (<a href="#cont">cont</a>) and <a href="#flow">flow</a> threads.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0 '&lt;_':title 'Cont':box
axis:xlabel 'x':ylabel '\dot{x}'
new f 100 100 'y^2+2*x^3-x^2-0.5':cont f

subplot 2 2 1 '&lt;_':title 'Flow':box
axis:xlabel 'x':ylabel '\dot{x}'
new fx 100 100 'x-3*x^2'
new fy 100 100 'y'
flow fy fx 'v';value 7

subplot 2 2 2 '&lt;_':title 'ODE':box
axis:xlabel 'x':ylabel '\dot{x}'
for $x -1 1 0.1
  ode r 'y;x-3*x^2' 'xy' [$x,0]
  plot r(0) r(1)
  ode r '-y;-x+3*x^2' 'xy' [$x,0]
  plot r(0) r(1)
next
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ode(mglGraph *gr)
{
	gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Cont&quot;);	gr-&gt;Box();
	gr-&gt;Axis();	gr-&gt;Label('x',&quot;x&quot;);	gr-&gt;Label('y',&quot;\\dot{x}&quot;);
	mglData f(100,100);	gr-&gt;Fill(f,&quot;y^2+2*x^3-x^2-0.5&quot;);
	gr-&gt;Cont(f);
	gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Flow&quot;);	gr-&gt;Box();
	gr-&gt;Axis();	gr-&gt;Label('x',&quot;x&quot;);	gr-&gt;Label('y',&quot;\\dot{x}&quot;);
	mglData fx(100,100), fy(100,100);	gr-&gt;Fill(fx,&quot;x-3*x^2&quot;);	gr-&gt;Fill(fy,&quot;y&quot;);
	gr-&gt;Flow(fy,fx,&quot;v&quot;,&quot;value 7&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;ODE&quot;);	gr-&gt;Box();
	gr-&gt;Axis();	gr-&gt;Label('x',&quot;x&quot;);	gr-&gt;Label('y',&quot;\\dot{x}&quot;);
	for(double x=-1;x&lt;1;x+=0.1)
	{
		mglData in(2), r;	in.a[0]=x;
		r = mglODE(&quot;y;x-3*x^2&quot;,&quot;xy&quot;,in);
		gr-&gt;Plot(r.SubData(0), r.SubData(1));
		r = mglODE(&quot;-y;-x+3*x^2&quot;,&quot;xy&quot;,in);
		gr-&gt;Plot(r.SubData(0), r.SubData(1));
	}
}
</pre><div align="center"><img src="png/ode.png" alt="Sample ode">
</div>
<hr>
<a name="ohlc-sample"></a>
<div class="header">
<p>
Next: <a href="#param1-sample" accesskey="n" rel="next">param1 sample</a>, Previous: <a href="#ode-sample" accesskey="p" rel="prev">ode sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ohlc"></a>
<h3 class="section">10.76 Sample &lsquo;<samp>ohlc</samp>&rsquo;</h3>


<p>Function <a href="#ohlc">ohlc</a> draw Open-High-Low-Close diagram. This diagram show vertical line for between maximal(high) and minimal(low) values, as well as horizontal lines before/after vertical line for initial(open)/final(close) values of some process.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new o 10 '0.5*sin(pi*x)'
new c 10 '0.5*sin(pi*(x+2/9))'
new l 10 '0.3*rnd-0.8'
new h 10 '0.3*rnd+0.5'
subplot 1 1 0 '':title 'OHLC plot':box:ohlc o h l c
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ohlc(mglGraph *gr)	// flow threads and density plot
{
	mglData o(10), h(10), l(10), c(10);
	gr-&gt;Fill(o,&quot;0.5*sin(pi*x)&quot;);	gr-&gt;Fill(c,&quot;0.5*sin(pi*(x+2/9))&quot;);
	gr-&gt;Fill(l,&quot;0.3*rnd-0.8&quot;);		gr-&gt;Fill(h,&quot;0.3*rnd+0.5&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;OHLC plot&quot;);	}
	gr-&gt;Box();	gr-&gt;OHLC(o,h,l,c);
}
</pre><div align="center"><img src="png/ohlc.png" alt="Sample ohlc">
</div>
<hr>
<a name="param1-sample"></a>
<div class="header">
<p>
Next: <a href="#param2-sample" accesskey="n" rel="next">param2 sample</a>, Previous: <a href="#ohlc-sample" accesskey="p" rel="prev">ohlc sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-param1"></a>
<h3 class="section">10.77 Sample &lsquo;<samp>param1</samp>&rsquo;</h3>


<p>Example of parametric plots for 1D data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 100 'sin(pi*x)'
new y 100 'cos(pi*x)'
new z 100 'sin(2*pi*x)'
new c 100 'cos(2*pi*x)'

subplot 4 3 0:rotate 40 60:box:plot x y z
subplot 4 3 1:rotate 40 60:box:area x y z
subplot 4 3 2:rotate 40 60:box:tens x y z c
subplot 4 3 3:rotate 40 60:box:bars x y z
subplot 4 3 4:rotate 40 60:box:stem x y z
subplot 4 3 5:rotate 40 60:box:textmark x y z c*2 '\alpha'
subplot 4 3 6:rotate 40 60:box:tube x y z c/10
subplot 4 3 7:rotate 40 60:box:mark x y z c 's'
subplot 4 3 8:box:error x y z/10 c/10
subplot 4 3 9:rotate 40 60:box:step x y z
subplot 4 3 10:rotate 40 60:box:torus x z 'z';light on
subplot 4 3 11:rotate 40 60:box:label x y z '%z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_param1(mglGraph *gr)	// 1d parametric plots
{
	mglData x(100), y(100), z(100), c(100);
	gr-&gt;Fill(x,&quot;sin(pi*x)&quot;);	gr-&gt;Fill(y,&quot;cos(pi*x)&quot;);
	gr-&gt;Fill(z,&quot;sin(2*pi*x)&quot;);	gr-&gt;Fill(c,&quot;cos(2*pi*x)&quot;);

	gr-&gt;SubPlot(4,3,0);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Plot(x,y,z);
	gr-&gt;SubPlot(4,3,1);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Area(x,y,z);
	gr-&gt;SubPlot(4,3,2);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Tens(x,y,z,c);
	gr-&gt;SubPlot(4,3,3);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Bars(x,y,z);
	gr-&gt;SubPlot(4,3,4);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Stem(x,y,z);
	gr-&gt;SubPlot(4,3,5);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;TextMark(x,y,z,c*2,&quot;\\alpha&quot;);
	gr-&gt;SubPlot(4,3,6);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Tube(x,y,z,c/10,&quot;&quot;,&quot;light on&quot;);
	gr-&gt;SubPlot(4,3,7);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Mark(x,y,z,c,&quot;s&quot;);
	gr-&gt;SubPlot(4,3,8);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Error(x,y,z/10,c/10);
	gr-&gt;SubPlot(4,3,9);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Step(x,y,z);
	gr-&gt;SubPlot(4,3,10);gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Torus(x,z,&quot;z&quot;,&quot;light on&quot;);
	gr-&gt;SubPlot(4,3,11);gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Label(x,y,z,&quot;%z&quot;);
}
</pre><div align="center"><img src="png/param1.png" alt="Sample param1">
</div>
<hr>
<a name="param2-sample"></a>
<div class="header">
<p>
Next: <a href="#param3-sample" accesskey="n" rel="next">param3 sample</a>, Previous: <a href="#param1-sample" accesskey="p" rel="prev">param1 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-param2"></a>
<h3 class="section">10.78 Sample &lsquo;<samp>param2</samp>&rsquo;</h3>


<p>Example of parametric plots for 2D data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 100 100 'sin(pi*(x+y)/2)*cos(pi*y/2)'
new y 100 100 'cos(pi*(x+y)/2)*cos(pi*y/2)'
new z 100 100 'sin(pi*y/2)'
new c 100 100 'cos(pi*x)'

subplot 4 4 0:rotate 40 60:box:surf x y z
subplot 4 4 1:rotate 40 60:box:surfc x y z c
subplot 4 4 2:rotate 40 60:box:surfa x y z c;alpha 1
subplot 4 4 3:rotate 40 60:box:mesh x y z;meshnum 10
subplot 4 4 4:rotate 40 60:box:tile x y z;meshnum 10
subplot 4 4 5:rotate 40 60:box:tiles x y z c;meshnum 10
subplot 4 4 6:rotate 40 60:box:axial x y z;alpha 0.5;light on
subplot 4 4 7:rotate 40 60:box:cont x y z
subplot 4 4 8:rotate 40 60:box:contf x y z;light on:contv x y z;light on
subplot 4 4 9:rotate 40 60:box:belt x y z 'x';meshnum 10;light on
subplot 4 4 10:rotate 40 60:box:dens x y z;alpha 0.5
subplot 4 4 11:rotate 40 60:box
fall x y z 'g';meshnum 10:fall x y z 'rx';meshnum 10
subplot 4 4 12:rotate 40 60:box:belt x y z '';meshnum 10;light on
subplot 4 4 13:rotate 40 60:box:boxs x y z '';meshnum 10;light on
subplot 4 4 14:rotate 40 60:box:boxs x y z '#';meshnum 10;light on
subplot 4 4 15:rotate 40 60:box:boxs x y z '@';meshnum 10;light on
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_param2(mglGraph *gr)	// 2d parametric plots
{
	mglData x(100,100), y(100,100), z(100,100), c(100,100);
	gr-&gt;Fill(x,&quot;sin(pi*(x+y)/2)*cos(pi*y/2)&quot;);	gr-&gt;Fill(y,&quot;cos(pi*(x+y)/2)*cos(pi*y/2)&quot;);
	gr-&gt;Fill(z,&quot;sin(pi*y/2)&quot;);	gr-&gt;Fill(c,&quot;cos(pi*x)&quot;);

	gr-&gt;SubPlot(4,4,0);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Surf(x,y,z);
	gr-&gt;SubPlot(4,4,1);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;SurfC(x,y,z,c);
	gr-&gt;SubPlot(4,4,2);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;SurfA(x,y,z,c,&quot;&quot;,&quot;alpha 1&quot;);
	gr-&gt;SubPlot(4,4,3);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Mesh(x,y,z,&quot;&quot;,&quot;meshnum 10&quot;);
	gr-&gt;SubPlot(4,4,4);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Tile(x,y,z,&quot;&quot;,&quot;meshnum 10&quot;);
	gr-&gt;SubPlot(4,4,5);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;TileS(x,y,z,c,&quot;&quot;,&quot;meshnum 10&quot;);
	gr-&gt;SubPlot(4,4,6);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Axial(x,y,z,&quot;&quot;,&quot;alpha 0.5;light on&quot;);
	gr-&gt;SubPlot(4,4,7);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Cont(x,y,z);
	gr-&gt;SubPlot(4,4,8);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;ContF(x,y,z,&quot;&quot;,&quot;light on&quot;);	gr-&gt;ContV(x,y,z,&quot;&quot;,&quot;light on&quot;);
	gr-&gt;SubPlot(4,4,9);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Belt(x,y,z,&quot;x&quot;,&quot;meshnum 10;light on&quot;);
	gr-&gt;SubPlot(4,4,10);gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Dens(x,y,z,&quot;&quot;,&quot;alpha 0.5&quot;);
	gr-&gt;SubPlot(4,4,11);gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Fall(x,y,z,&quot;g&quot;,&quot;meshnum 10&quot;);	gr-&gt;Fall(x,y,z,&quot;rx&quot;,&quot;meshnum 10&quot;);
	gr-&gt;SubPlot(4,4,12);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Belt(x,y,z,&quot;&quot;,&quot;meshnum 10;light on&quot;);
	gr-&gt;SubPlot(4,4,13);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Boxs(x,y,z,&quot;&quot;,&quot;meshnum 10;light on&quot;);
	gr-&gt;SubPlot(4,4,14);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Boxs(x,y,z,&quot;#&quot;,&quot;meshnum 10&quot;);
	gr-&gt;SubPlot(4,4,15);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Boxs(x,y,z,&quot;@&quot;,&quot;meshnum 10;light on&quot;);
}
</pre><div align="center"><img src="png/param2.png" alt="Sample param2">
</div>
<hr>
<a name="param3-sample"></a>
<div class="header">
<p>
Next: <a href="#paramv-sample" accesskey="n" rel="next">paramv sample</a>, Previous: <a href="#param2-sample" accesskey="p" rel="prev">param2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-param3"></a>
<h3 class="section">10.79 Sample &lsquo;<samp>param3</samp>&rsquo;</h3>


<p>Example of parametric plots for 3D data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 50 50 50 '(x+2)/3*sin(pi*y/2)'
new y 50 50 50 '(x+2)/3*cos(pi*y/2)'
new z 50 50 50 'z'
new c 50 50 50 '-2*(x^2+y^2+z^4-z^2)+0.2'
new d 50 50 50 '1-2*tanh(2*(x+y)^2)'

alpha on:light on
subplot 4 3 0:rotate 40 60:box:surf3 x y z c
subplot 4 3 1:rotate 40 60:box:surf3c x y z c d
subplot 4 3 2:rotate 40 60:box:surf3a x y z c d
subplot 4 3 3:rotate 40 60:box:cloud x y z c
subplot 4 3 4:rotate 40 60:box:cont3 x y z c:cont3 x y z c 'x':cont3 x y z c 'z'
subplot 4 3 5:rotate 40 60:box:contf3 x y z c:contf3 x y z c 'x':contf3 x y z c 'z'
subplot 4 3 6:rotate 40 60:box:dens3 x y z c:dens3 x y z c 'x':dens3 x y z c 'z'
subplot 4 3 7:rotate 40 60:box:dots x y z c;meshnum 15
subplot 4 3 8:rotate 40 60:box:densx c '' 0:densy c '' 0:densz c '' 0
subplot 4 3 9:rotate 40 60:box:contx c '' 0:conty c '' 0:contz c '' 0
subplot 4 3 10:rotate 40 60:box:contfx c '' 0:contfy c '' 0:contfz c '' 0
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_param3(mglGraph *gr)	// 3d parametric plots
{
	mglData x(50,50,50), y(50,50,50), z(50,50,50), c(50,50,50), d(50,50,50);
	gr-&gt;Fill(x,&quot;(x+2)/3*sin(pi*y/2)&quot;);	gr-&gt;Fill(y,&quot;(x+2)/3*cos(pi*y/2)&quot;);	gr-&gt;Fill(z,&quot;z&quot;);
	gr-&gt;Fill(c,&quot;-2*(x^2+y^2+z^4-z^2)+0.2&quot;);	gr-&gt;Fill(d,&quot;1-2*tanh(2*(x+y)^2)&quot;);

	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;SubPlot(4,3,0);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Surf3(x,y,z,c);
	gr-&gt;SubPlot(4,3,1);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Surf3C(x,y,z,c,d);
	gr-&gt;SubPlot(4,3,2);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Surf3A(x,y,z,c,d);
	gr-&gt;SubPlot(4,3,3);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Cloud(x,y,z,c);
	gr-&gt;SubPlot(4,3,4);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Cont3(x,y,z,c);	gr-&gt;Cont3(x,y,z,c,&quot;x&quot;);	gr-&gt;Cont3(x,y,z,c,&quot;z&quot;);
	gr-&gt;SubPlot(4,3,5);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;ContF3(x,y,z,c);gr-&gt;ContF3(x,y,z,c,&quot;x&quot;);gr-&gt;ContF3(x,y,z,c,&quot;z&quot;);
	gr-&gt;SubPlot(4,3,6);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Dens3(x,y,z,c);	gr-&gt;Dens3(x,y,z,c,&quot;x&quot;);	gr-&gt;Dens3(x,y,z,c,&quot;z&quot;);
	gr-&gt;SubPlot(4,3,7);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Dots(x,y,z,c,&quot;&quot;,&quot;meshnum 15&quot;);
	gr-&gt;SubPlot(4,3,8);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;DensX(c,&quot;&quot;,0);	gr-&gt;DensY(c,&quot;&quot;,0);	gr-&gt;DensZ(c,&quot;&quot;,0);
	gr-&gt;SubPlot(4,3,9);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;ContX(c,&quot;&quot;,0);	gr-&gt;ContY(c,&quot;&quot;,0);	gr-&gt;ContZ(c,&quot;&quot;,0);
	gr-&gt;SubPlot(4,3,10);gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;ContFX(c,&quot;&quot;,0);	gr-&gt;ContFY(c,&quot;&quot;,0);	gr-&gt;ContFZ(c,&quot;&quot;,0);
}
</pre><div align="center"><img src="png/param3.png" alt="Sample param3">
</div>
<hr>
<a name="paramv-sample"></a>
<div class="header">
<p>
Next: <a href="#parser-sample" accesskey="n" rel="next">parser sample</a>, Previous: <a href="#param3-sample" accesskey="p" rel="prev">param3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-paramv"></a>
<h3 class="section">10.80 Sample &lsquo;<samp>paramv</samp>&rsquo;</h3>


<p>Example of parametric plots for vector fields.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 20 20 20 '(x+2)/3*sin(pi*y/2)'
new y 20 20 20 '(x+2)/3*cos(pi*y/2)'
new z 20 20 20 'z+x'
new ex 20 20 20 'x'
new ey 20 20 20 'x^2+y'
new ez 20 20 20 'y^2+z'

new x1 50 50 '(x+2)/3*sin(pi*y/2)'
new y1 50 50 '(x+2)/3*cos(pi*y/2)'
new e1 50 50 'x'
new e2 50 50 'x^2+y'

subplot 3 3 0:rotate 40 60:box:vect x1 y1 e1 e2
subplot 3 3 1:rotate 40 60:box:flow x1 y1 e1 e2
subplot 3 3 2:rotate 40 60:box:pipe x1 y1 e1 e2
subplot 3 3 3:rotate 40 60:box:dew x1 y1 e1 e2
subplot 3 3 4:rotate 40 60:box:vect x y z ex ey ez
subplot 3 3 5:rotate 40 60:box
vect3 x y z ex ey ez:vect3 x y z ex ey ez 'x':vect3 x y z ex ey ez 'z'
grid3 x y z z '{r9}':grid3 x y z z '{g9}x':grid3 x y z z '{b9}z'
subplot 3 3 6:rotate 40 60:box:flow x y z ex ey ez
subplot 3 3 7:rotate 40 60:box:pipe x y z ex ey ez
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_paramv(mglGraph *gr)	// parametric plots for vector field
{
	mglData x(20,20,20), y(20,20,20), z(20,20,20), ex(20,20,20), ey(20,20,20), ez(20,20,20);
	gr-&gt;Fill(x,&quot;(x+2)/3*sin(pi*y/2)&quot;);	gr-&gt;Fill(y,&quot;(x+2)/3*cos(pi*y/2)&quot;);	gr-&gt;Fill(z,&quot;x+z&quot;);
	gr-&gt;Fill(ex,&quot;x&quot;);	gr-&gt;Fill(ey,&quot;x^2+y&quot;);	gr-&gt;Fill(ez,&quot;y^2+z&quot;);
	mglData x1(20,20), y1(20,20), e1(20,20), e2(20,20);
	gr-&gt;Fill(x1,&quot;(x+2)/3*sin(pi*y/2)&quot;);	gr-&gt;Fill(y1,&quot;(x+2)/3*cos(pi*y/2)&quot;);
	gr-&gt;Fill(e1,&quot;x&quot;);	gr-&gt;Fill(e2,&quot;x^2+y&quot;);

	gr-&gt;SubPlot(3,3,0);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Vect(x1,y1,e1,e2);
	gr-&gt;SubPlot(3,3,1);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Flow(x1,y1,e1,e2);
	gr-&gt;SubPlot(3,3,2);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Pipe(x1,y1,e1,e2);
	gr-&gt;SubPlot(3,3,3);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Dew(x1,y1,e1,e2);
	gr-&gt;SubPlot(3,3,4);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Vect(x,y,z,ex,ey,ez);
	gr-&gt;SubPlot(3,3,5);	gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Vect3(x,y,z,ex,ey,ez);	gr-&gt;Vect3(x,y,z,ex,ey,ez,&quot;x&quot;);	gr-&gt;Vect3(x,y,z,ex,ey,ez,&quot;z&quot;);
	gr-&gt;Grid3(x,y,z,z,&quot;{r9}&quot;);	gr-&gt;Grid3(x,y,z,z,&quot;{g9}x&quot;);		gr-&gt;Grid3(x,y,z,z,&quot;{b9}z&quot;);
	gr-&gt;SubPlot(3,3,6);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Flow(x,y,z,ex,ey,ez);
	gr-&gt;SubPlot(3,3,7);	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Pipe(x,y,z,ex,ey,ez);
}
</pre><div align="center"><img src="png/paramv.png" alt="Sample paramv">
</div>
<hr>
<a name="parser-sample"></a>
<div class="header">
<p>
Next: <a href="#pde-sample" accesskey="n" rel="next">pde sample</a>, Previous: <a href="#paramv-sample" accesskey="p" rel="prev">paramv sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-parser"></a>
<h3 class="section">10.81 Sample &lsquo;<samp>parser</samp>&rsquo;</h3>


<p>Basic MGL script.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">title 'MGL parser sample'
# call function
call 'sample'

# ordinary for-loop
for $0 -1 1 0.1
if $0&lt;0:line 0 0 1 $0 'r':else:line 0 0 1 $0 'g':endif
next

# if-elseif-else
for $i -1 1 0.5
if $i&lt;0
text 1.1 $i '$i' 'b'
elseif $i&gt;0
text 1.1 $i '$i' 'r'
else
text 1.1 $i '$i'
endif
next

# ordinary do-while
do
defnum $i $i-0.2
line 0 0 $i 1 'b'
while $i&gt;0

# do-next-break
do
defnum $i $i-0.2
if $i&lt;-1 then break
line 0 0 $i 1 'm'
next

# for-while-continue
for $i -5 10
text $i/5 1.1 'a'+($i+5)
if $i&lt;0
text $i/5-0.06 1.1 '--' 'b'
elseif mod($i,2)=0
text $i/5-0.06 1.1 '~' 'r'
else
# NOTE: 'continue' bypass the 'while'!
continue
endif
# NOTE: 'while' limit the actual number of iterations
while $i&lt;5

# nested loops
for $i 0 1 0.1
for $j 0 1 0.1
ball $i $j
if $j&gt;0.5 then continue
ball $i $j 'b+'
next
next

func 'sample'
new dat 100 'sin(2*pi*(i/99+1))'
plot dat;xrange -1 0
box:axis
xlabel 'x':ylabel 'y'
return
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_parser(mglGraph *gr)	// example of MGL parsing
{	// NOTE: MGL version show much more variants of loops and conditions.
	gr-&gt;Title(&quot;MGL parser sample&quot;);
	double a[100];   // let a_i = sin(4*pi*x), x=0...1
	for(int i=0;i&lt;100;i++)a[i]=sin(2*M_PI*i/99);
	mglParse *parser = new mglParse;
	// Add MGL variable and set yours data to it.
	mglData *d = dynamic_cast&lt;mglData*&gt;(parser-&gt;AddVar(&quot;dat&quot;));
	if(d)	d-&gt;Set(a,100);
	parser-&gt;Execute(gr, &quot;plot dat; xrange -1 0\nbox\naxis&quot;);
	// You may break script at any line do something
	// and continue after that.
	parser-&gt;Execute(gr, &quot;xlabel 'x'\nylabel 'y'\nbox&quot;);
	// Also you may use cycles or conditions in script.
	parser-&gt;Execute(gr, &quot;for $0 -1 1 0.1\nif $0&lt;0\n&quot;
		&quot;line 0 0 1 $0 'r':else:line 0 0 1 $0 'g'\n&quot;
		&quot;endif\nnext&quot;);
	// You may use for or do-while loops as C/C++ one
	double i=1;
	do	{
		char buf[64];	sprintf(buf,&quot;line 0 0 %g 1 'b'&quot;,i);
		parser-&gt;Execute(gr, buf);	i=i-0.2;
	} while(i&gt;0);
	// or as MGL one.
	parser-&gt;Execute(gr, &quot;for $i -1 1 0.5\n&quot;
		&quot;if $i&lt;0\ntext 1.1 $i '$i' 'b'\n&quot;
		&quot;elseif $i&gt;0\ntext 1.1 $i '$i' 'r'\n&quot;
		&quot;else\ntext 1.1 $i '$i'\nendif\nnext\n&quot;);
	// There are 'break' and 'continue' commands in MGL too.
	// NOTE: 'next' act as &quot;while(1)&quot; in do-while loops.
	parser-&gt;Execute(gr, &quot;do\ndefnum $i $i-0.2\n&quot;
		&quot;if $i&lt;-1 then break\nline 0 0 $i 1 'm'\nnext\n&quot;);
	// One issue with 'continue' -- it bypass 'while' checking
	parser-&gt;Execute(gr, &quot;for $i -5 10\ntext $i/5 1.1 'a'+($i+5)\nif $i&lt;0\n&quot;
		&quot;text $i/5-0.06 1.1 '--' 'b'\n&quot;
		&quot;elseif mod($i,2)=0\ntext $i/5-0.06 1.1 '~' 'r'\n&quot;
		&quot;else\ncontinue\nendif\n&quot;
		// NOTE: 'while' limit the actual number of iterations in for-loop.
		&quot;while $i&lt;5\n&quot;);
	// Finally, MGL support nested loops too.
	parser-&gt;Execute(gr, &quot;for $i 0 1 0.1\nfor $j 0 1 0.1\nball $i $j\n&quot;
		&quot;if $j&gt;0.5 then continue\nball $i $j 'b+'\nnext\nnext\n&quot;);
	// Clean up memory.
	delete parser;
}
</pre><div align="center"><img src="png/parser.png" alt="Sample parser">
</div>
<hr>
<a name="pde-sample"></a>
<div class="header">
<p>
Next: <a href="#pendelta-sample" accesskey="n" rel="next">pendelta sample</a>, Previous: <a href="#parser-sample" accesskey="p" rel="prev">parser sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-pde"></a>
<h3 class="section">10.82 Sample &lsquo;<samp>pde</samp>&rsquo;</h3>


<p>Example of <a href="#pde">pde</a> solver.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new re 128 'exp(-48*(x+0.7)^2)':new im 128
pde a 'p^2+q^2-x-1+i*0.5*(z+x)*(z&gt;-x)' re im 0.01 30
transpose a
subplot 1 1 0 '&lt;_':title 'PDE solver'
axis:xlabel '\i x':ylabel '\i z'
crange 0 1:dens a 'wyrRk'
fplot '-x' 'k|'
text 0 0.95 'Equation: ik_0\partial_zu + \Delta u + x\cdot u + i \frac{x+z}{2}\cdot u = 0\n{}absorption: (x+z)/2 for x+z&gt;0'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_pde(mglGraph *gr)	// PDE sample
{
	mglData a,re(128),im(128);
	gr-&gt;Fill(re,&quot;exp(-48*(x+0.7)^2)&quot;);
	a = gr-&gt;PDE(&quot;p^2+q^2-x-1+i*0.5*(z+x)*(z&gt;-x)&quot;, re, im, 0.01, 30);
	a.Transpose(&quot;yxz&quot;);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;PDE solver&quot;);	}
	gr-&gt;SetRange('c',0,1);	gr-&gt;Dens(a,&quot;wyrRk&quot;);
	gr-&gt;Axis();	gr-&gt;Label('x', &quot;\\i x&quot;);	gr-&gt;Label('y', &quot;\\i z&quot;);
	gr-&gt;FPlot(&quot;-x&quot;, &quot;k|&quot;);
	gr-&gt;Puts(mglPoint(0, 0.95), &quot;Equation: ik_0\\partial_zu + \\Delta u + x\\cdot u + i \\frac{x+z}{2}\\cdot u = 0\nabsorption: (x+z)/2 for x+z&gt;0&quot;);
}
</pre><div align="center"><img src="png/pde.png" alt="Sample pde">
</div>
<hr>
<a name="pendelta-sample"></a>
<div class="header">
<p>
Next: <a href="#pipe-sample" accesskey="n" rel="next">pipe sample</a>, Previous: <a href="#pde-sample" accesskey="p" rel="prev">pde sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-pendelta"></a>
<h3 class="section">10.83 Sample &lsquo;<samp>pendelta</samp>&rsquo;</h3>


<p>Example of <a href="#pendelta">pendelta</a> for lines and glyphs smoothing.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 6
list a 0.25 0.5 1 2 4
for $0 0 4
pendelta a($0)
define $1 0.5*$0-1
line -1 $1 1 $1 'r'
text 0 $1 'delta=',a($0)
next
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_pendelta(mglGraph *gr)
{
	double a[5]={0.25,0.5,1,2,4};
	gr-&gt;SetQuality(6);
	char buf[64];
	for(int i=0;i&lt;5;i++)
	{
		gr-&gt;SetPenDelta(a[i]);
		gr-&gt;Line(mglPoint(-1,0.5*i-1), mglPoint(1,0.5*i-1),&quot;r&quot;);
		sprintf(buf,&quot;delta=%g&quot;,a[i]);
		gr-&gt;Puts(mglPoint(0,0.5*i-1),buf);
	}
}
</pre><div align="center"><img src="png/pendelta.png" alt="Sample pendelta">
</div>
<hr>
<a name="pipe-sample"></a>
<div class="header">
<p>
Next: <a href="#plot-sample" accesskey="n" rel="next">plot sample</a>, Previous: <a href="#pendelta-sample" accesskey="p" rel="prev">pendelta sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-pipe"></a>
<h3 class="section">10.84 Sample &lsquo;<samp>pipe</samp>&rsquo;</h3>


<p>Function <a href="#pipe">pipe</a> is similar to <a href="#flow">flow</a> but draw pipes (tubes) which radius is proportional to the amplitude of vector field. The color scheme is used for coloring (see <a href="#Color-scheme">Color scheme</a>). At this warm color corresponds to normal flow (like attractor), cold one corresponds to inverse flow (like source).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2v'
call 'prepare3v'
subplot 2 2 0 '':title 'Pipe plot (default)':light on:box:pipe a b
subplot 2 2 1 '':title '&quot;i&quot; style':box:pipe a b 'i'
subplot 2 2 2 '':title 'from edges only':box:pipe a b '#'
subplot 2 2 3:title '3d variant':rotate 50 60:box:pipe ex ey ez '' 0.1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_pipe(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2v(&amp;a,&amp;b);
	if(big!=3)	{gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Pipe plot (default)&quot;);}
	gr-&gt;Light(true);	gr-&gt;Box();	gr-&gt;Pipe(a,b);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;'i' style&quot;);	gr-&gt;Box();	gr-&gt;Pipe(a,b,&quot;i&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'\\#' style&quot;);	gr-&gt;Box();	gr-&gt;Pipe(a,b,&quot;#&quot;);
	mglData ex,ey,ez;	mgls_prepare3v(&amp;ex,&amp;ey,&amp;ez);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Pipe(ex,ey,ez,&quot;&quot;,0.1);
}
</pre><div align="center"><img src="png/pipe.png" alt="Sample pipe">
</div>
<hr>
<a name="plot-sample"></a>
<div class="header">
<p>
Next: <a href="#pmap-sample" accesskey="n" rel="next">pmap sample</a>, Previous: <a href="#pipe-sample" accesskey="p" rel="prev">pipe sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-plot"></a>
<h3 class="section">10.85 Sample &lsquo;<samp>plot</samp>&rsquo;</h3>


<p>Function <a href="#plot">plot</a> is most standard way to visualize 1D data array. By default, <code>Plot</code> use colors from palette. However, you can specify manual color/palette, and even set to use new color for each points by using &lsquo;<samp>!</samp>&rsquo; style. Another feature is &lsquo;<samp> </samp>&rsquo; style which draw only markers without line between points.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 2 2 0 '':title 'Plot plot (default)':box:plot y
subplot 2 2 2 '':title ''!' style; 'rgb' palette':box:plot y 'o!rgb'
subplot 2 2 3 '':title 'just markers':box:plot y ' +'
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 2 2 1:title '3d variant':rotate 50 60:box:plot xc yc z 'rs'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_plot(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Plot plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Plot(y);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'!' style; 'rgb' palette&quot;);	gr-&gt;Box();	gr-&gt;Plot(y,&quot;o!rgb&quot;);
	gr-&gt;SubPlot(2,2,3,&quot;&quot;);	gr-&gt;Title(&quot;just markers&quot;);	gr-&gt;Box();	gr-&gt;Plot(y,&quot; +&quot;);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	gr-&gt;Plot(xc,yc,z,&quot;rs&quot;);
}
</pre><div align="center"><img src="png/plot.png" alt="Sample plot">
</div>
<hr>
<a name="pmap-sample"></a>
<div class="header">
<p>
Next: <a href="#primitives-sample" accesskey="n" rel="next">primitives sample</a>, Previous: <a href="#plot-sample" accesskey="p" rel="prev">plot sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-pmap"></a>
<h3 class="section">10.86 Sample &lsquo;<samp>pmap</samp>&rsquo;</h3>


<p>Function <a href="#pmap">pmap</a> draw Poincare map &ndash; show intersections of the curve and the surface.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_^':title 'Poincare map sample'
ode r 'cos(y)+sin(z);cos(z)+sin(x);cos(x)+sin(y)' 'xyz' [0.1,0,0] 0.1 100
rotate 40 60:copy x r(0):copy y r(1):copy z r(2)
ranges x y z
axis:plot x y z 'b'
xlabel '\i x' 0:ylabel '\i y' 0:zlabel '\i z'
pmap x y z z 'b#o'
fsurf '0'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_pmap(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_^&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Poincare map sample&quot;);
	mglData ini(3);	ini[0]=0.1;
	mglData r(mglODE(&quot;cos(y)+sin(z);cos(z)+sin(x);cos(x)+sin(y)&quot;,&quot;xyz&quot;,ini,0.1,100));
	mglData x(r.SubData(0)),y(r.SubData(1)), z(r.SubData(2));
	gr-&gt;Rotate(40,60);	gr-&gt;SetRanges(x,y,z);
	gr-&gt;Axis();	gr-&gt;FSurf(&quot;0&quot;);	gr-&gt;Plot(x,y,z,&quot;b&quot;);
	gr-&gt;Label('x',&quot;\\i x&quot;,0);	gr-&gt;Label('y',&quot;\\i y&quot;,0);	gr-&gt;Label('z',&quot;\\i z&quot;,0);
	gr-&gt;Pmap(x,y,z,z, &quot;b#o&quot;);
}
</pre><div align="center"><img src="png/pmap.png" alt="Sample pmap">
</div>
<hr>
<a name="primitives-sample"></a>
<div class="header">
<p>
Next: <a href="#projection-sample" accesskey="n" rel="next">projection sample</a>, Previous: <a href="#pmap-sample" accesskey="p" rel="prev">pmap sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-primitives"></a>
<h3 class="section">10.87 Sample &lsquo;<samp>primitives</samp>&rsquo;</h3>


<p>Example of primitives: <a href="#line">line</a>, <a href="#curve">curve</a>, <a href="#rhomb">rhomb</a>, <a href="#ellipse">ellipse</a>, <a href="#face">face</a>, <a href="#sphere">sphere</a>, <a href="#drop">drop</a>, <a href="#cone">cone</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 2 2 0 '':title 'Line, Curve, Rhomb, Ellipse' '' -1.5
line -1 -1 -0.5 1 'qAI'
curve -0.6 -1 1 1 0 1 1 1 'rA'
ball 0 -0.5 '*':ball 1 -0.1 '*'
rhomb 0 0.4 1 0.9 0.2 'b#'
rhomb 0 0 1 0.4 0.2 'cg@'
ellipse 0 -0.5 1 -0.1 0.2 'u#'
ellipse 0 -1 1 -0.6 0.2 'm@'

subplot 2 3 1 '':title 'Arc, Polygon, Symbol';size -1.2
arc -0.6 0 -0.6 0.3 180 '2kA':ball -0.6 0
polygon 0 0 0 0.4 6 'r'
new x 50 'cos(3*pi*x)':new y 50 'sin(pi*x)'
addsymbol 'a' x y
symbol 0.7 0 'a'

light on
subplot 2 3 3 '&lt;^&gt;' 0 -0.2:title 'Face[xyz]';size -1.5:rotate 50 60:box
facex 1 0 -1 1 1 'r':facey -1 -1 -1 1 1 'g':facez 1 -1 -1 -1 1 'b'
face -1 -1 1 -1 1 1 1 -1 0 1 1 1 'bmgr'

subplot 2 3 5 '':title 'Cone';size -1.5
cone -0.7 -0.3 0 -0.7 0.7 0.5 0.2 0.1 'b':text -0.7 -0.7 'no edges\n(default)';size -1.5
cone 0 -0.3 0 0 0.7 0.5 0.2 0.1 'g@':text 0 -0.7 'with edges\n(&quot;\@&quot; style)';size -1.5
cone 0.7 -0.3 0 0.7 0.7 0.5 0.2 0 'Ggb':text 0.7 -0.7 '&quot;arrow&quot; with\n{}gradient';size -1.5
subplot 2 2 2 '':title 'Sphere and Drop'
line -0.9 0 1 0.9 0 1
text -0.9 0.4 'sh=0':drop -0.9 0 0 1 0.5 'r' 0:ball -0.9 0 1 'k'
text -0.3 0.6 'sh=0.33':drop -0.3 0 0 1 0.5 'r' 0.33:ball -0.3 0 1 'k'
text 0.3 0.8 'sh=0.67':drop 0.3 0 0 1 0.5 'r' 0.67:ball 0.3 0 1 'k'
text 0.9 1. 'sh=1':drop 0.9 0 0 1 0.5 'r' 1:ball 0.9 0 1 'k'

text -0.9 -1.1 'asp=0.33':drop -0.9 -0.7 0 1 0.5 'b' 0 0.33
text -0.3 -1.1 'asp=0.67':drop -0.3 -0.7 0 1 0.5 'b' 0 0.67
text 0.3 -1.1 'asp=1':drop 0.3 -0.7 0 1 0.5 'b' 0 1
text 0.9 -1.1 'asp=1.5':drop 0.9 -0.7 0 1 0.5 'b' 0 1.5
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_primitives(mglGraph *gr)	// flag #
{
	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Line, Curve, Rhomb, Ellipse&quot;,&quot;&quot;,-1.5);
	gr-&gt;Line(mglPoint(-1,-1),mglPoint(-0.5,1),&quot;qAI&quot;);
	gr-&gt;Curve(mglPoint(-0.6,-1),mglPoint(1,1),mglPoint(0,1),mglPoint(1,1),&quot;rA&quot;);
	gr-&gt;Rhomb(mglPoint(0,0.4),mglPoint(1,0.9),0.2,&quot;b#&quot;);
	gr-&gt;Rhomb(mglPoint(0,0),mglPoint(1,0.4),0.2,&quot;cg@&quot;);
	gr-&gt;Ellipse(mglPoint(0,-0.5),mglPoint(1,-0.1),0.2,&quot;u#&quot;);
	gr-&gt;Ellipse(mglPoint(0,-1),mglPoint(1,-0.6),0.2,&quot;m@&quot;);
	gr-&gt;Mark(mglPoint(0,-0.5),&quot;*&quot;);	gr-&gt;Mark(mglPoint(1,-0.1),&quot;*&quot;);

	gr-&gt;SubPlot(2,3,1,&quot;&quot;);	gr-&gt;Title(&quot;Arc, Polygon, Symbol&quot;,&quot;&quot;, -1.2*2);
	gr-&gt;Arc(mglPoint(-0.6,0), mglPoint(-0.6,0.3), 180, &quot;2kA&quot;);	gr-&gt;Ball(-0.6,0);
	gr-&gt;Polygon(mglPoint(), mglPoint(0,0.4), 6, &quot;r&quot;);
	mglData x(50), y(50);	gr-&gt;Fill(x,&quot;cos(3*pi*x)&quot;);	gr-&gt;Fill(y,&quot;sin(pi*x)&quot;);
	gr-&gt;DefineSymbol('a',x,y);	gr-&gt;Symbol(mglPoint(0.7),'a');

	gr-&gt;Light(true);
	gr-&gt;SubPlot(2,3,3,&quot;&lt;^&gt;&quot;,0,-0.2);	gr-&gt;Title(&quot;Face[xyz]&quot;, &quot;&quot;, -1.5*2);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	gr-&gt;FaceX(mglPoint(1,0,-1),1,1,&quot;r&quot;);
	gr-&gt;FaceY(mglPoint(-1,-1,-1),1,1,&quot;g&quot;);
	gr-&gt;FaceZ(mglPoint(1,-1,-1),-1,1,&quot;b&quot;);
	gr-&gt;Face(mglPoint(-1,-1,1),mglPoint(-1,1,1),mglPoint(1,-1,0),mglPoint(1,1,1),&quot;bmgr&quot;);

	gr-&gt;SubPlot(2,3,5,&quot;&quot;);	gr-&gt;Title(&quot;Cone&quot;, &quot;&quot;, -1.5*2);
	gr-&gt;Cone(mglPoint(-0.7,-0.3),mglPoint(-0.7,0.7,0.5),0.2,0.1,&quot;b&quot;);
	gr-&gt;Puts(mglPoint(-0.7,-0.7),&quot;no edges\n(default)&quot;,&quot;&quot;, -1.5);
	gr-&gt;Cone(mglPoint(0,-0.3),mglPoint(0,0.7,0.5),0.2,0.1,&quot;g@&quot;);
	gr-&gt;Puts(mglPoint(0,-0.7),&quot;with edges\n('\\@' style)&quot;,&quot;&quot;, -1.5);
	gr-&gt;Cone(mglPoint(0.7,-0.3),mglPoint(0.7,0.7,0.5),0.2,0,&quot;ry&quot;);
	gr-&gt;Puts(mglPoint(0.7,-0.7),&quot;'arrow' with\ngradient&quot;,&quot;&quot;, -1.5);

	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;Sphere and Drop&quot;);	gr-&gt;Alpha(false);
	gr-&gt;Puts(mglPoint(-0.9,0.4),&quot;sh=0&quot;);		gr-&gt;Ball(mglPoint(-0.9,0,1),'k');
	gr-&gt;Drop(mglPoint(-0.9,0),mglPoint(0,1),0.5,&quot;r&quot;,0);
	gr-&gt;Puts(mglPoint(-0.3,0.6),&quot;sh=0.33&quot;);	gr-&gt;Ball(mglPoint(-0.3,0,1),'k');
	gr-&gt;Drop(mglPoint(-0.3,0),mglPoint(0,1),0.5,&quot;r&quot;,0.33);
	gr-&gt;Puts(mglPoint(0.3,0.8),&quot;sh=0.67&quot;);		gr-&gt;Ball(mglPoint(0.3,0,1),'k');
	gr-&gt;Drop(mglPoint(0.3,0),mglPoint(0,1),0.5,&quot;r&quot;,0.67);
	gr-&gt;Puts(mglPoint(0.9,1),&quot;sh=1&quot;);			gr-&gt;Ball(mglPoint(0.9,0,1),'k');
	gr-&gt;Drop(mglPoint(0.9,0),mglPoint(0,1),0.5,&quot;r&quot;,1);
	gr-&gt;Line(mglPoint(-0.9,0,1),mglPoint(0.9,0,1),&quot;b&quot;);

	gr-&gt;Puts(mglPoint(-0.9,-1.1),&quot;asp=0.33&quot;);
	gr-&gt;Drop(mglPoint(-0.9,-0.7),mglPoint(0,1),0.5,&quot;b&quot;,0,0.33);
	gr-&gt;Puts(mglPoint(-0.3,-1.1),&quot;asp=0.67&quot;);
	gr-&gt;Drop(mglPoint(-0.3,-0.7),mglPoint(0,1),0.5,&quot;b&quot;,0,0.67);
	gr-&gt;Puts(mglPoint(0.3,-1.1),&quot;asp=1&quot;);
	gr-&gt;Drop(mglPoint(0.3,-0.7),mglPoint(0,1),0.5,&quot;b&quot;,0,1);
	gr-&gt;Puts(mglPoint(0.9,-1.1),&quot;asp=1.5&quot;);
	gr-&gt;Drop(mglPoint(0.9,-0.7),mglPoint(0,1),0.5,&quot;b&quot;,0,1.5);
}
</pre><div align="center"><img src="png/primitives.png" alt="Sample primitives">
</div>
<hr>
<a name="projection-sample"></a>
<div class="header">
<p>
Next: <a href="#projection5-sample" accesskey="n" rel="next">projection5 sample</a>, Previous: <a href="#primitives-sample" accesskey="p" rel="prev">primitives sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-projection"></a>
<h3 class="section">10.88 Sample &lsquo;<samp>projection</samp>&rsquo;</h3>


<p>Example of plot projection (<a href="#ternary">ternary</a>=4).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">ranges 0 1 0 1 0 1
new x 50 '0.25*(1+cos(2*pi*x))'
new y 50 '0.25*(1+sin(2*pi*x))'
new z 50 'x'
new a 20 30 '30*x*y*(1-x-y)^2*(x+y&lt;1)'
new rx 10 'rnd':new ry 10:fill ry '(1-v)*rnd' rx
light on

title 'Projection sample':ternary 4:rotate 50 60
box:axis:grid
plot x y z 'r2':surf a '#'
xlabel 'X':ylabel 'Y':zlabel 'Z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_projection(mglGraph *gr)	// flag #
{
	gr-&gt;SetRanges(0,1,0,1,0,1);
	mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
	a.Modify(&quot;30*x*y*(1-x-y)^2*(x+y&lt;1)&quot;);
	x.Modify(&quot;0.25*(1+cos(2*pi*x))&quot;);
	y.Modify(&quot;0.25*(1+sin(2*pi*x))&quot;);
	rx.Modify(&quot;rnd&quot;); ry.Modify(&quot;(1-v)*rnd&quot;,rx);
	z.Modify(&quot;x&quot;);

	if(big!=3)	gr-&gt;Title(&quot;Projection sample&quot;);
	gr-&gt;Ternary(4);
	gr-&gt;Rotate(50,60);		gr-&gt;Light(true);
	gr-&gt;Plot(x,y,z,&quot;r2&quot;);	gr-&gt;Surf(a,&quot;#&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();	gr-&gt;Box();
	gr-&gt;Label('x',&quot;X&quot;,1);	gr-&gt;Label('y',&quot;Y&quot;,1);	gr-&gt;Label('z',&quot;Z&quot;,1);
}
</pre><div align="center"><img src="png/projection.png" alt="Sample projection">
</div>
<hr>
<a name="projection5-sample"></a>
<div class="header">
<p>
Next: <a href="#pulse-sample" accesskey="n" rel="next">pulse sample</a>, Previous: <a href="#projection-sample" accesskey="p" rel="prev">projection sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-projection5"></a>
<h3 class="section">10.89 Sample &lsquo;<samp>projection5</samp>&rsquo;</h3>


<p>Example of plot projection in ternary coordinates (<a href="#ternary">ternary</a>=5).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">ranges 0 1 0 1 0 1
new x 50 '0.25*(1+cos(2*pi*x))'
new y 50 '0.25*(1+sin(2*pi*x))'
new z 50 'x'
new a 20 30 '30*x*y*(1-x-y)^2*(x+y&lt;1)'
new rx 10 'rnd':new ry 10:fill ry '(1-v)*rnd' rx
light on

title 'Projection sample (ternary)':ternary 5:rotate 50 60
box:axis:grid
plot x y z 'r2':surf a '#'
xlabel 'X':ylabel 'Y':zlabel 'Z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_projection5(mglGraph *gr)	// flag #
{
	gr-&gt;SetRanges(0,1,0,1,0,1);
	mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
	a.Modify(&quot;30*x*y*(1-x-y)^2*(x+y&lt;1)&quot;);
	x.Modify(&quot;0.25*(1+cos(2*pi*x))&quot;);
	y.Modify(&quot;0.25*(1+sin(2*pi*x))&quot;);
	rx.Modify(&quot;rnd&quot;); ry.Modify(&quot;(1-v)*rnd&quot;,rx);
	z.Modify(&quot;x&quot;);

	if(big!=3)	gr-&gt;Title(&quot;Projection sample (ternary)&quot;);
	gr-&gt;Ternary(5);
	gr-&gt;Rotate(50,60);		gr-&gt;Light(true);
	gr-&gt;Plot(x,y,z,&quot;r2&quot;);	gr-&gt;Surf(a,&quot;#&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();	gr-&gt;Box();
	gr-&gt;Label('x',&quot;X&quot;,1);	gr-&gt;Label('y',&quot;Y&quot;,1);	gr-&gt;Label('z',&quot;Z&quot;,1);
}
</pre><div align="center"><img src="png/projection5.png" alt="Sample projection5">
</div>
<hr>
<a name="pulse-sample"></a>
<div class="header">
<p>
Next: <a href="#qo2d-sample" accesskey="n" rel="next">qo2d sample</a>, Previous: <a href="#projection5-sample" accesskey="p" rel="prev">projection5 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-pulse"></a>
<h3 class="section">10.90 Sample &lsquo;<samp>pulse</samp>&rsquo;</h3>


<p>Example of <a href="#pulse">pulse</a> parameter determining.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_':title 'Pulse sample'
new a 100 'exp(-6*x^2)':ranges 0 a.nx-1 0 1
axis:plot a

pulse b a 'x'

define m a.max

line b(1) 0 b(1) m 'r='
line b(1)-b(3)/2 0  b(1)-b(3)/2 m 'm|'
line b(1)+b(3)/2 0  b(1)+b(3)/2 m 'm|'
line 0 0.5*m a.nx-1 0.5*m 'h'
new x 100 'x'
plot b(0)*(1-((x-b(1))/b(2))^2) 'g'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_pulse(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Pulse sample&quot;);
	mglData a(100);	gr-&gt;Fill(a,&quot;exp(-6*x^2)&quot;);
	gr-&gt;SetRanges(0, a.nx-1, 0, 1);
	gr-&gt;Axis();	gr-&gt;Plot(a);
	mglData b(a.Pulse('x'));
	double m = b[0];
	gr-&gt;Line(mglPoint(b[1],0), mglPoint(b[1],m),&quot;r=&quot;);
	gr-&gt;Line(mglPoint(b[1]-b[3]/2,0), mglPoint(b[1]-b[3]/2,m),&quot;m|&quot;);
	gr-&gt;Line(mglPoint(b[1]+b[3]/2,0), mglPoint(b[1]+b[3]/2,m),&quot;m|&quot;);
	gr-&gt;Line(mglPoint(0,m/2), mglPoint(a.nx-1,m/2),&quot;h&quot;);
	char func[128];	sprintf(func,&quot;%g*(1-((x-%g)/%g)^2)&quot;,b[0],b[1],b[2]);
	gr-&gt;FPlot(func,&quot;g&quot;);
}
</pre><div align="center"><img src="png/pulse.png" alt="Sample pulse">
</div>
<hr>
<a name="qo2d-sample"></a>
<div class="header">
<p>
Next: <a href="#quality0-sample" accesskey="n" rel="next">quality0 sample</a>, Previous: <a href="#pulse-sample" accesskey="p" rel="prev">pulse sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-qo2d"></a>
<h3 class="section">10.91 Sample &lsquo;<samp>qo2d</samp>&rsquo;</h3>


<p>Example of PDE solving by quasioptical approach <a href="#qo2d">qo2d</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">define $1 'p^2+q^2-x-1+i*0.5*(y+x)*(y&gt;-x)'
subplot 1 1 0 '&lt;_':title 'Beam and ray tracing'
ray r $1 -0.7 -1 0 0 0.5 0 0.02 2:plot r(0) r(1) 'k'
axis:xlabel '\i x':ylabel '\i z'
new re 128 'exp(-48*x^2)':new im 128
new xx 1:new yy 1
qo2d a $1 re im r 1 30 xx yy
crange 0 1:dens xx yy a 'wyrRk':fplot '-x' 'k|'
text 0 0.85 'absorption: (x+y)/2 for x+y&gt;0'
text 0.7 -0.05 'central ray'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_qo2d(mglGraph *gr)
{
	mglData r, xx, yy, a, im(128), re(128);
	const char *ham = &quot;p^2+q^2-x-1+i*0.5*(y+x)*(y&gt;-x)&quot;;
	r = mglRay(ham, mglPoint(-0.7, -1), mglPoint(0, 0.5), 0.02, 2);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Beam and ray tracing&quot;);}
	gr-&gt;Plot(r.SubData(0), r.SubData(1), &quot;k&quot;);
	gr-&gt;Axis();	gr-&gt;Label('x', &quot;\\i x&quot;);	gr-&gt;Label('y', &quot;\\i y&quot;);
	// now start beam tracing
	gr-&gt;Fill(re,&quot;exp(-48*x^2)&quot;);
	a = mglQO2d(ham, re, im, r, xx, yy, 1, 30);
	gr-&gt;SetRange('c',0, 1);
	gr-&gt;Dens(xx, yy, a, &quot;wyrRk&quot;);
	gr-&gt;FPlot(&quot;-x&quot;, &quot;k|&quot;);
	gr-&gt;Puts(mglPoint(0, 0.85), &quot;absorption: (x+y)/2 for x+y&gt;0&quot;);
	gr-&gt;Puts(mglPoint(0.7, -0.05), &quot;central ray&quot;);
}
</pre><div align="center"><img src="png/qo2d.png" alt="Sample qo2d">
</div>
<hr>
<a name="quality0-sample"></a>
<div class="header">
<p>
Next: <a href="#quality1-sample" accesskey="n" rel="next">quality1 sample</a>, Previous: <a href="#qo2d-sample" accesskey="p" rel="prev">qo2d sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality0"></a>
<h3 class="section">10.92 Sample &lsquo;<samp>quality0</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=0.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 0
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality0(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(0);	all_prims(gr);
}
</pre><div align="center"><img src="png/quality0.png" alt="Sample quality0">
</div>
<hr>
<a name="quality1-sample"></a>
<div class="header">
<p>
Next: <a href="#quality2-sample" accesskey="n" rel="next">quality2 sample</a>, Previous: <a href="#quality0-sample" accesskey="p" rel="prev">quality0 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality1"></a>
<h3 class="section">10.93 Sample &lsquo;<samp>quality1</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=1.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 1
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality1(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(1);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality1.png" alt="Sample quality1">
</div>
<hr>
<a name="quality2-sample"></a>
<div class="header">
<p>
Next: <a href="#quality4-sample" accesskey="n" rel="next">quality4 sample</a>, Previous: <a href="#quality1-sample" accesskey="p" rel="prev">quality1 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality2"></a>
<h3 class="section">10.94 Sample &lsquo;<samp>quality2</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=2.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 2
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality2(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(2);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality2.png" alt="Sample quality2">
</div>
<hr>
<a name="quality4-sample"></a>
<div class="header">
<p>
Next: <a href="#quality5-sample" accesskey="n" rel="next">quality5 sample</a>, Previous: <a href="#quality2-sample" accesskey="p" rel="prev">quality2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality4"></a>
<h3 class="section">10.95 Sample &lsquo;<samp>quality4</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=4.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 4
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality4(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(4);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality4.png" alt="Sample quality4">
</div>
<hr>
<a name="quality5-sample"></a>
<div class="header">
<p>
Next: <a href="#quality6-sample" accesskey="n" rel="next">quality6 sample</a>, Previous: <a href="#quality4-sample" accesskey="p" rel="prev">quality4 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality5"></a>
<h3 class="section">10.96 Sample &lsquo;<samp>quality5</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=5.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 5
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality5(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(5);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality5.png" alt="Sample quality5">
</div>
<hr>
<a name="quality6-sample"></a>
<div class="header">
<p>
Next: <a href="#quality8-sample" accesskey="n" rel="next">quality8 sample</a>, Previous: <a href="#quality5-sample" accesskey="p" rel="prev">quality5 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality6"></a>
<h3 class="section">10.97 Sample &lsquo;<samp>quality6</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=6.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 6
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality6(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(6);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality6.png" alt="Sample quality6">
</div>
<hr>
<a name="quality8-sample"></a>
<div class="header">
<p>
Next: <a href="#radar-sample" accesskey="n" rel="next">radar sample</a>, Previous: <a href="#quality6-sample" accesskey="p" rel="prev">quality6 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-quality8"></a>
<h3 class="section">10.98 Sample &lsquo;<samp>quality8</samp>&rsquo;</h3>


<p>Show all kind of primitives in <a href="#quality">quality</a>=8.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">quality 8
subplot 3 2 0:define y 0.95
define d 0.3:define x0 0.2:define x1 0.5:define x2 0.6
line x0 1-0*d x1 1-0*d 'k-':text x2 y-0*d 'Solid `-`' ':rL'
line x0 1-1*d x1 1-1*d 'k|':text x2 y-1*d 'Long Dash `|`' ':rL'
line x0 1-2*d x1 1-2*d 'k;':text x2 y-2*d 'Dash 1;`' ':rL'
line x0 1-3*d x1 1-3*d 'k=':text x2 y-3*d 'Small dash `=`' ':rL'
line x0 1-4*d x1 1-4*d 'kj':text x2 y-4*d 'Dash-dot `j`' ':rL'
line x0 1-5*d x1 1-5*d 'ki':text x2 y-5*d 'Small dash-dot `i`' ':rL'
line x0 1-6*d x1 1-6*d 'k:':text x2 y-6*d 'Dots `:`' ':rL'
line x0 1-7*d x1 1-7*d 'k ':text x2 y-7*d 'None ``' ':rL'
define d 0.25:define x0 -0.8:define x1 -1:define x2 -0.05
ball x1 5*d 'k.':text x0 5*d '.' ':rL'
ball x1 4*d 'k+':text x0 4*d '+' ':rL'
ball x1 3*d 'kx':text x0 3*d 'x' ':rL'
ball x1 2*d 'k*':text x0 2*d '*' ':rL'
ball x1 d 'ks':text x0 d 's' ':rL'
ball x1 0 'kd':text x0 0 'd' ':rL'
ball x1 -d 0 'ko':text x0 y-d 'o' ':rL'
ball x1 -2*d 0 'k^':text x0 -2*d '\^' ':rL'
ball x1 -3*d 0 'kv':text x0 -3*d 'v' ':rL'
ball x1 -4*d 0 'k&lt;':text x0 -4*d '&lt;' ':rL'
ball x1 -5*d 0 'k&gt;':text x0 -5*d '&gt;' ':rL'

define x0 -0.3:define x1 -0.5
ball x1 5*d 'k#.':text x0 5*d '\#.' ':rL'
ball x1 4*d 'k#+':text x0 4*d '\#+' ':rL'
ball x1 3*d 'k#x':text x0 3*d '\#x' ':rL'
ball x1 2*d 'k#*':text x0 2*d '\#*' ':rL'
ball x1 d 'k#s':text x0 d '\#s' ':rL'
ball x1 0 'k#d':text x0 0 '\#d' ':rL'
ball x1 -d 0 'k#o':text x0 -d '\#o' ':rL'
ball x1 -2*d 0 'k#^':text x0 -2*d '\#\^' ':rL'
ball x1 -3*d 0 'k#v':text x0 -3*d '\#v' ':rL'
ball x1 -4*d 0 'k#&lt;':text x0 -4*d '\#&lt;' ':rL'
ball x1 -5*d 0 'k#&gt;':text x0 -5*d '\#&gt;' ':rL'

subplot 3 2 1
define a 0.1:define b 0.4:define c 0.5
line a 1 b 1 'k-A':text c 1 'Style `A` or `A\_`' ':rL'
line a 0.8 b 0.8 'k-V':text c 0.8 'Style `V` or `V\_`' ':rL'
line a 0.6 b 0.6 'k-K':text c 0.6 'Style `K` or `K\_`' ':rL'
line a 0.4 b 0.4 'k-I':text c 0.4 'Style `I` or `I\_`' ':rL'
line a 0.2 b 0.2 'k-D':text c 0.2 'Style `D` or `D\_`' ':rL'
line a 0 b 0 'k-S':text c 0 'Style `S` or `S\_`' ':rL'
line a -0.2 b -0.2 'k-O':text c -0.2 'Style `O` or `O\_`' ':rL'
line a -0.4 b -0.4 'k-T':text c -0.4 'Style `T` or `T\_`' ':rL'
line a -0.6 b -0.6 'k-_':text c -0.6 'Style `\_` or none' ':rL'
line a -0.8 b -0.8 'k-AS':text c -0.8 'Style `AS`' ':rL'
line a -1 b -1 'k-_A':text c -1 'Style `\_A`' ':rL'

define a -1:define b -0.7:define c -0.6
line a 1 b 1 'kAA':text c 1 'Style `AA`' ':rL'
line a 0.8 b 0.8 'kVV':text c 0.8 'Style `VV`' ':rL'
line a 0.6 b 0.6 'kKK':text c 0.6 'Style `KK`' ':rL'
line a 0.4 b 0.4 'kII':text c 0.4 'Style `II`' ':rL'
line a 0.2 b 0.2 'kDD':text c 0.2 'Style `DD`' ':rL'
line a 0 b 0 'kSS':text c 0 'Style `SS`' ':rL'
line a -0.2 b -0.2 'kOO':text c -0.2 'Style `OO`' ':rL'
line a -0.4 b -0.4 'kTT':text c -0.4 'Style `TT`' ':rL'
line a -0.6 b -0.6 'k-__':text c -0.6 'Style `\_\_`' ':rL'
line a -0.8 b -0.8 'k-VA':text c -0.8 'Style `VA`' ':rL'
line a -1 b -1 'k-AV':text c -1 'Style `AV`' ':rL'

subplot 3 2 2
#LENUQ

facez -1 -1 0 0.4 0.3 'L#':text -0.8 -0.9 'L' 'w:C' -1.4
facez -0.6 -1 0 0.4 0.3 'E#':text -0.4 -0.9 'E' 'w:C' -1.4
facez -0.2 -1 0 0.4 0.3 'N#':text 0 -0.9 'N' 'w:C' -1.4
facez 0.2 -1 0 0.4 0.3 'U#':text 0.4 -0.9 'U' 'w:C' -1.4
facez 0.6 -1 0 0.4 0.3 'Q#':text 0.8 -0.9 'Q' 'w:C' -1.4
#lenuq
facez -1 -0.7 0 0.4 0.3 'l#':text -0.8 -0.6 'l' 'k:C' -1.4
facez -0.6 -0.7 0 0.4 0.3 'e#':text -0.4 -0.6 'e' 'k:C' -1.4
facez -0.2 -0.7 0 0.4 0.3 'n#':text 0 -0.6 'n' 'k:C' -1.4
facez 0.2 -0.7 0 0.4 0.3 'u#':text 0.4 -0.6 'u' 'k:C' -1.4
facez 0.6 -0.7 0 0.4 0.3 'q#':text 0.8 -0.6 'q' 'k:C' -1.4
#CMYkP
facez -1 -0.4 0 0.4 0.3 'C#':text -0.8 -0.3 'C' 'w:C' -1.4
facez -0.6 -0.4 0 0.4 0.3 'M#':text -0.4 -0.3 'M' 'w:C' -1.4
facez -0.2 -0.4 0 0.4 0.3 'Y#':text 0 -0.3 'Y' 'w:C' -1.4
facez 0.2 -0.4 0 0.4 0.3 'k#':text 0.4 -0.3 'k' 'w:C' -1.4
facez 0.6 -0.4 0 0.4 0.3 'P#':text 0.8 -0.3 'P' 'w:C' -1.4
#cmywp
facez -1 -0.1 0 0.4 0.3 'c#':text -0.8 0 'c' 'k:C' -1.4
facez -0.6 -0.1 0 0.4 0.3 'm#':text -0.4 0 'm' 'k:C' -1.4
facez -0.2 -0.1 0 0.4 0.3 'y#':text 0 0 'y' 'k:C' -1.4
facez 0.2 -0.1 0 0.4 0.3 'w#':text 0.4 0 'w' 'k:C' -1.4
facez 0.6 -0.1 0 0.4 0.3 'p#':text 0.8 0 'p' 'k:C' -1.4
#BGRHW
facez -1 0.2 0 0.4 0.3 'B#':text -0.8 0.3 'B' 'w:C' -1.4
facez -0.6 0.2 0 0.4 0.3 'G#':text -0.4 0.3 'G' 'w:C' -1.4
facez -0.2 0.2 0 0.4 0.3 'R#':text 0 0.3 'R' 'w:C' -1.4
facez 0.2 0.2 0 0.4 0.3 'H#':text 0.4 0.3 'H' 'w:C' -1.4
facez 0.6 0.2 0 0.4 0.3 'W#':text 0.8 0.3 'W' 'w:C' -1.4
#bgrhw
facez -1 0.5 0 0.4 0.3 'b#':text -0.8 0.6 'b' 'k:C' -1.4
facez -0.6 0.5 0 0.4 0.3 'g#':text -0.4 0.6 'g' 'k:C' -1.4
facez -0.2 0.5 0 0.4 0.3 'r#':text 0 0.6 'r' 'k:C' -1.4
facez 0.2 0.5 0 0.4 0.3 'h#':text 0.4 0.6 'h' 'k:C' -1.4
facez 0.6 0.5 0 0.4 0.3 'w#':text 0.8 0.6 'w' 'k:C' -1.4
#brighted
facez -1 0.8 0 0.4 0.3 '{r1}#':text -0.8 0.9 '\{r1\}' 'w:C' -1.4
facez -0.6 0.8 0 0.4 0.3 '{r3}#':text -0.4 0.9 '\{r3\}' 'w:C' -1.4
facez -0.2 0.8 0 0.4 0.3 '{r5}#':text 0 0.9 '\{r5\}' 'k:C' -1.4
facez 0.2 0.8 0 0.4 0.3 '{r7}#':text 0.4 0.9 '\{r7\}' 'k:C' -1.4
facez 0.6 0.8 0 0.4 0.3 '{r9}#':text 0.8 0.9 '\{r9\}' 'k:C' -1.4
# HEX
facez -1 -1.3 0 1 0.3 '{xff9966}#':text -0.5 -1.2 '\{xff9966\}' 'k:C' -1.4
facez 0 -1.3 0 1 0.3 '{x83CAFF}#':text 0.5 -1.2 '\{x83caff\}' 'k:C' -1.4

subplot 3 2 3
for $i 0 9
line -1 0.2*$i-1 1 0.2*$i-1 'r','0'+$i
text 1.05 0.2*$i-1 '0'+$i ':L'
next

subplot 3 2 4:title 'TriPlot sample':rotate 50 60
list tt 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0:list yt -1 -1 1 0:list zt -1 -1 -1 1:light on
triplot tt xt yt zt 'b':triplot tt xt yt zt 'k#'

subplot 3 2 5:new r 4 'i+1':ranges 1 4 1 4
axis:mark r r 's':plot r 'b'

</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_quality8(mglGraph *gr)	// test file export
{
	gr-&gt;SetQuality(8);	all_prims(gr);	
}
</pre><div align="center"><img src="png/quality8.png" alt="Sample quality8">
</div>
<hr>
<a name="radar-sample"></a>
<div class="header">
<p>
Next: <a href="#refill-sample" accesskey="n" rel="next">refill sample</a>, Previous: <a href="#quality8-sample" accesskey="p" rel="prev">quality8 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-radar"></a>
<h3 class="section">10.99 Sample &lsquo;<samp>radar</samp>&rsquo;</h3>


<p>The <a href="#radar">radar</a> plot is variant of <a href="#plot">plot</a>, which make plot in polar coordinates and draw radial rays in point directions. If you just need a plot in polar coordinates then I recommend to use <a href="#Curvilinear-coordinates">Curvilinear coordinates</a> or <a href="#plot">plot</a> in parametric form with <code>x=r*cos(fi); y=r*sin(fi);</code>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new yr 10 3 '0.4*sin(pi*(x+1.5+y/2)+0.1*rnd)'
subplot 1 1 0 '':title 'Radar plot (with grid, &quot;\#&quot;)':radar yr '#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_radar(mglGraph *gr)
{
	mglData yr(10,3);	yr.Modify(&quot;0.4*sin(pi*(2*x+y))+0.1*rnd&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Radar plot (with grid, '\\#')&quot;);	}
	gr-&gt;Radar(yr,&quot;#&quot;);
}
</pre><div align="center"><img src="png/radar.png" alt="Sample radar">
</div>
<hr>
<a name="refill-sample"></a>
<div class="header">
<p>
Next: <a href="#region-sample" accesskey="n" rel="next">region sample</a>, Previous: <a href="#radar-sample" accesskey="p" rel="prev">radar sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-refill"></a>
<h3 class="section">10.100 Sample &lsquo;<samp>refill</samp>&rsquo;</h3>


<p>Example of <a href="#refill">refill</a> and <a href="#gspline">gspline</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 10 '0.5+rnd':cumsum x 'x':norm x -1 1
copy y sin(pi*x)/1.5
subplot 2 2 0 '&lt;_':title 'Refill sample'
box:axis:plot x y 'o ':fplot 'sin(pi*x)/1.5' 'B:'
new r 100:refill r x y:plot r 'r'

subplot 2 2 1 '&lt;_':title 'Global spline'
box:axis:plot x y 'o ':fplot 'sin(pi*x)/1.5' 'B:'
new r 100:gspline r x y:plot r 'r'

new y 10 '0.5+rnd':cumsum y 'x':norm y -1 1
copy xx x:extend xx 10
copy yy y:extend yy 10:transpose yy
copy z sin(pi*xx*yy)/1.5
alpha on:light on
subplot 2 2 2:title '2d regular':rotate 40 60
box:axis:mesh xx yy z 'k'
new rr 100 100:refill rr x y z:surf rr

new xx 10 10 '(x+1)/2*cos(y*pi/2-1)':new yy 10 10 '(x+1)/2*sin(y*pi/2-1)'
copy z sin(pi*xx*yy)/1.5
subplot 2 2 3:title '2d non-regular':rotate 40 60
box:axis:plot xx yy z 'ko '
new rr 100 100:refill rr xx yy z:surf rr
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_refill(mglGraph *gr)
{
	mglData x(10), y(10), r(100);
	x.Modify(&quot;0.5+rnd&quot;);	x.CumSum(&quot;x&quot;);	x.Norm(-1,1);
	y.Modify(&quot;sin(pi*v)/1.5&quot;,x);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Refill sample&quot;);	}
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Plot(x,y,&quot;o &quot;);
	gr-&gt;Refill(r,x,y);	// or you can use r.Refill(x,y,-1,1);
	gr-&gt;Plot(r,&quot;r&quot;);	gr-&gt;FPlot(&quot;sin(pi*x)/1.5&quot;,&quot;B:&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Global spline&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Plot(x,y,&quot;o &quot;);
	r.RefillGS(x,y,-1,1);	gr-&gt;Plot(r,&quot;r&quot;);
	gr-&gt;FPlot(&quot;sin(pi*x)/1.5&quot;,&quot;B:&quot;);

	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	mglData z(10,10), xx(10,10), yy(10,10), rr(100,100);
	y.Modify(&quot;0.5+rnd&quot;);	y.CumSum(&quot;x&quot;);	y.Norm(-1,1);
	for(int i=0;i&lt;10;i++)	for(int j=0;j&lt;10;j++)
		z.a[i+10*j] = sin(M_PI*x.a[i]*y.a[j])/1.5;
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;2d regular&quot;);	gr-&gt;Rotate(40,60);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Mesh(x,y,z,&quot;k&quot;);
	gr-&gt;Refill(rr,x,y,z);	gr-&gt;Surf(rr);

	gr-&gt;Fill(xx,&quot;(x+1)/2*cos(y*pi/2-1)&quot;);
	gr-&gt;Fill(yy,&quot;(x+1)/2*sin(y*pi/2-1)&quot;);
	for(int i=0;i&lt;10*10;i++)
		z.a[i] = sin(M_PI*xx.a[i]*yy.a[i])/1.5;
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;2d non-regular&quot;);	gr-&gt;Rotate(40,60);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Plot(xx,yy,z,&quot;ko &quot;);
	gr-&gt;Refill(rr,xx,yy,z);	gr-&gt;Surf(rr);
}
</pre><div align="center"><img src="png/refill.png" alt="Sample refill">
</div>
<hr>
<a name="region-sample"></a>
<div class="header">
<p>
Next: <a href="#scanfile-sample" accesskey="n" rel="next">scanfile sample</a>, Previous: <a href="#refill-sample" accesskey="p" rel="prev">refill sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-region"></a>
<h3 class="section">10.101 Sample &lsquo;<samp>region</samp>&rsquo;</h3>


<p>Function <a href="#region">region</a> fill the area between 2 curves. It support gradient filling if 2 colors per curve is specified. Also it can fill only the region y1&lt;y&lt;y2 if style &lsquo;<samp>i</samp>&rsquo; is used.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
copy y1 y(:,1):copy y2 y(:,2)
subplot 2 2 0 '':title 'Region plot (default)':box:region y1 y2:plot y1 'k2':plot y2 'k2'
subplot 2 2 1 '':title '2 colors':box:region y1 y2 'yr':plot y1 'k2':plot y2 'k2'
subplot 2 2 2 '':title '&quot;i&quot; style':box:region y1 y2 'ir':plot y1 'k2':plot y2 'k2'
subplot 2 2 3 '^_':title '3d variant':rotate 40 60:box
new x1 100 'sin(pi*x)':new y1 100 'cos(pi*x)':new z 100 'x'
new x2 100 'sin(pi*x+pi/3)':new y2 100 'cos(pi*x+pi/3)'
plot x1 y1 z 'r2':plot x2 y2 z 'b2'
region x1 y1 z x2 y2 z 'cmy!'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_region(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);
	mglData y1 = y.SubData(-1,1), y2 = y.SubData(-1,2);	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Region plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Region(y1,y2);	gr-&gt;Plot(y1,&quot;k2&quot;);	gr-&gt;Plot(y2,&quot;k2&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;2 colors&quot;);	gr-&gt;Box();	gr-&gt;Region(y1,y2,&quot;yr&quot;);	gr-&gt;Plot(y1,&quot;k2&quot;);	gr-&gt;Plot(y2,&quot;k2&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'i' style&quot;);	gr-&gt;Box();	gr-&gt;Region(y1,y2,&quot;ir&quot;);	gr-&gt;Plot(y1,&quot;k2&quot;);	gr-&gt;Plot(y2,&quot;k2&quot;);
	gr-&gt;SubPlot(2,2,3,&quot;^_&quot;);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(40,60);	gr-&gt;Box();
	gr-&gt;Fill(y1,&quot;cos(pi*x)&quot;);	gr-&gt;Fill(y2,&quot;cos(pi*x+pi/3)&quot;);
	mglData x1(y1.nx), x2(y1.nx), z(y1.nx);
	gr-&gt;Fill(x1,&quot;sin(pi*x)&quot;);	gr-&gt;Fill(x2,&quot;sin(pi*x+pi/3)&quot;);	gr-&gt;Fill(z,&quot;x&quot;);
	gr-&gt;Plot(x1,y1,z,&quot;r2&quot;);		gr-&gt;Plot(x2,y2,z,&quot;b2&quot;);
	gr-&gt;Region(x1,y1,z,x2,y2,z,&quot;cmy!&quot;);
}
</pre><div align="center"><img src="png/region.png" alt="Sample region">
</div>
<hr>
<a name="scanfile-sample"></a>
<div class="header">
<p>
Next: <a href="#schemes-sample" accesskey="n" rel="next">schemes sample</a>, Previous: <a href="#region-sample" accesskey="p" rel="prev">region sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-scanfile"></a>
<h3 class="section">10.102 Sample &lsquo;<samp>scanfile</samp>&rsquo;</h3>


<p>Example of <a href="#scanfile">scanfile</a> for reading &rsquo;named&rsquo; data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_':title 'Save and scanfile sample'
list a 1 -1 0
save 'This is test: 0 -&gt; ',a(0),' q' 'test.txt' 'w'
save 'This is test: 1 -&gt; ',a(1),' q' 'test.txt'
save 'This is test: 2 -&gt; ',a(2),' q' 'test.txt'

scanfile a 'test.txt' 'This is test: %g -&gt; %g'
ranges a(0) a(1):axis:plot a(0) a(1) 'o'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_scanfile(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Save and scanfile sample&quot;);
	FILE *fp=fopen(&quot;test.txt&quot;,&quot;w&quot;);
	fprintf(fp,&quot;This is test: 0 -&gt; 1 q\n&quot;);
	fprintf(fp,&quot;This is test: 1 -&gt; -1 q\n&quot;);
	fprintf(fp,&quot;This is test: 2 -&gt; 0 q\n&quot;);
	fclose(fp);

	mglData a;
	a.ScanFile(&quot;test.txt&quot;,&quot;This is test: %g -&gt; %g&quot;);
	gr-&gt;SetRanges(a.SubData(0), a.SubData(1));
	gr-&gt;Axis();	gr-&gt;Plot(a.SubData(0),a.SubData(1),&quot;o&quot;);
}
</pre><div align="center"><img src="png/scanfile.png" alt="Sample scanfile">
</div>
<hr>
<a name="schemes-sample"></a>
<div class="header">
<p>
Next: <a href="#section-sample" accesskey="n" rel="next">section sample</a>, Previous: <a href="#scanfile-sample" accesskey="p" rel="prev">scanfile sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-schemes"></a>
<h3 class="section">10.103 Sample &lsquo;<samp>schemes</samp>&rsquo;</h3>


<p>Example of popular color schemes.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 100 100 'x':new y 100 100 'y'
call 'sch' 0 'kw'
call 'sch' 1 '%gbrw'
call 'sch' 2 'kHCcw'
call 'sch' 3 'kBbcw'
call 'sch' 4 'kRryw'
call 'sch' 5 'kGgew'
call 'sch' 6 'BbwrR'
call 'sch' 7 'BbwgG'
call 'sch' 8 'GgwmM'
call 'sch' 9 'UuwqR'
call 'sch' 10 'QqwcC'
call 'sch' 11 'CcwyY'
call 'sch' 12 'bcwyr'
call 'sch' 13 'bwr'
call 'sch' 14 'wUrqy'
call 'sch' 15 'UbcyqR'
call 'sch' 16 'BbcyrR'
call 'sch' 17 'bgr'
call 'sch' 18 'BbcyrR|'
call 'sch' 19 'b{g,0.3}r'
stop
func 'sch' 2
subplot 2 10 $1 '&lt;&gt;_^' 0.2 0:surfa x y $2
text 0.07+0.5*mod($1,2) 0.92-0.1*int($1/2) $2 'A'
return
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_schemes(mglGraph *gr)	// Color table
{
	mglData a(256,2), b(256,2);	a.Fill(-1,1);	b.Fill(-1,1,'y');
	gr-&gt;SubPlot(2,10,0,NULL,0.2);	gr-&gt;Dens(a,&quot;kw&quot;);		gr-&gt;Puts(0.07, 0.92, &quot;kw&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,1,NULL,0.2);	gr-&gt;SurfA(a,b,&quot;%gbrw&quot;);	gr-&gt;Puts(0.57, 0.92, &quot;%gbrw&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,2,NULL,0.2);	gr-&gt;Dens(a,&quot;kHCcw&quot;);	gr-&gt;Puts(0.07, 0.82, &quot;kHCcw&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,3,NULL,0.2);	gr-&gt;Dens(a,&quot;kBbcw&quot;);	gr-&gt;Puts(0.57, 0.82, &quot;kBbcw&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,4,NULL,0.2);	gr-&gt;Dens(a,&quot;kRryw&quot;);	gr-&gt;Puts(0.07, 0.72, &quot;kRryw&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,5,NULL,0.2);	gr-&gt;Dens(a,&quot;kGgew&quot;);	gr-&gt;Puts(0.57, 0.72, &quot;kGgew&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,6,NULL,0.2);	gr-&gt;Dens(a,&quot;BbwrR&quot;);	gr-&gt;Puts(0.07, 0.62, &quot;BbwrR&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,7,NULL,0.2);	gr-&gt;Dens(a,&quot;BbwgG&quot;);	gr-&gt;Puts(0.57, 0.62, &quot;BbwgG&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,8,NULL,0.2);	gr-&gt;Dens(a,&quot;GgwmM&quot;);	gr-&gt;Puts(0.07, 0.52, &quot;GgwmM&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,9,NULL,0.2);	gr-&gt;Dens(a,&quot;UuwqR&quot;);	gr-&gt;Puts(0.57, 0.52, &quot;UuwqR&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,10,NULL,0.2);	gr-&gt;Dens(a,&quot;QqwcC&quot;);	gr-&gt;Puts(0.07, 0.42, &quot;QqwcC&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,11,NULL,0.2);	gr-&gt;Dens(a,&quot;CcwyY&quot;);	gr-&gt;Puts(0.57, 0.42, &quot;CcwyY&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,12,NULL,0.2);	gr-&gt;Dens(a,&quot;bcwyr&quot;);	gr-&gt;Puts(0.07, 0.32, &quot;bcwyr&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,13,NULL,0.2);	gr-&gt;Dens(a,&quot;bwr&quot;);		gr-&gt;Puts(0.57, 0.32, &quot;bwr&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,14,NULL,0.2);	gr-&gt;Dens(a,&quot;wUrqy&quot;);	gr-&gt;Puts(0.07, 0.22, &quot;wUrqy&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,15,NULL,0.2);	gr-&gt;Dens(a,&quot;UbcyqR&quot;);	gr-&gt;Puts(0.57, 0.22, &quot;UbcyqR&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,16,NULL,0.2);	gr-&gt;Dens(a,&quot;BbcyrR&quot;);	gr-&gt;Puts(0.07, 0.12, &quot;BbcyrR&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,17,NULL,0.2);	gr-&gt;Dens(a,&quot;bgr&quot;);		gr-&gt;Puts(0.57, 0.12, &quot;bgr&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,18,NULL,0.2);	gr-&gt;Dens(a,&quot;BbcyrR|&quot;);	gr-&gt;Puts(0.07, 0.02, &quot;BbcyrR|&quot;, &quot;A&quot;);
	gr-&gt;SubPlot(2,10,19,NULL,0.2);	gr-&gt;Dens(a,&quot;b{g,0.3}r&quot;);		gr-&gt;Puts(0.57, 0.02, &quot;b\\{g,0.3\\}r&quot;, &quot;A&quot;);
}
</pre><div align="center"><img src="png/schemes.png" alt="Sample schemes">
</div>
<hr>
<a name="section-sample"></a>
<div class="header">
<p>
Next: <a href="#several_005flight-sample" accesskey="n" rel="next">several_light sample</a>, Previous: <a href="#schemes-sample" accesskey="p" rel="prev">schemes sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-section"></a>
<h3 class="section">10.104 Sample &lsquo;<samp>section</samp>&rsquo;</h3>


<p>Example of <a href="#section">section</a> to separate data and <a href="#join">join</a> it back.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 1 1 0 '&lt;_':title 'Section&amp;Join sample'
axis:box:line -1 0 1 0 'h:'
# first lets demonstrate 'join'
new aa 11 'x^2':new a1 3 '-x':new a2 15 'x^3'
join aa a1:join aa a2
# add x-coordinate
new xx aa.nx 'x':join aa xx
plot aa(:,1) aa(:,0) '2y'
# now select 1-st (id=0) section between zeros
section b1 aa 0 'x' 0
plot b1(:,1) b1(:,0) 'bo'
# next, select 3-d (id=2) section between zeros
section b3 aa 2 'x' 0
plot b3(:,1) b3(:,0) 'gs'
# finally, select 2-nd (id=-2) section from the end
section b4 aa -2 'x' 0
plot b4(:,1) b4(:,0) 'r#o'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_section(mglGraph *gr)
{
	gr-&gt;SubPlot(1,1,0,&quot;&lt;_&quot;);
	if(big!=3)	gr-&gt;Title(&quot;Section&amp;Join sample&quot;);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Line(mglPoint(-1,0),mglPoint(1,0),&quot;h:&quot;);
	// first lets demonstrate 'join'
	mglData aa(11), a1(3), a2(15);
	gr-&gt;Fill(aa,&quot;x^2&quot;);	gr-&gt;Fill(a1,&quot;-x&quot;);	gr-&gt;Fill(a2,&quot;x^3&quot;);
	aa.Join(a1);	aa.Join(a2);
	// add x-coordinate
	mglData xx(aa.nx);	gr-&gt;Fill(xx,&quot;x&quot;);	aa.Join(xx);
	gr-&gt;Plot(aa.SubData(-1,1), aa.SubData(-1,0), &quot;2y&quot;);
	// now select 1-st (id=0) section between zeros
	mglData b1(aa.Section(0,'x',0));
	gr-&gt;Plot(b1.SubData(-1,1), b1.SubData(-1,0), &quot;bo&quot;);
	// next, select 3-d (id=2) section between zeros
	mglData b2(aa.Section(2,'x',0));
	gr-&gt;Plot(b2.SubData(-1,1), b2.SubData(-1,0), &quot;gs&quot;);
	// finally, select 2-nd (id=-2) section from the end
	mglData b3(aa.Section(-2,'x',0));
	gr-&gt;Plot(b3.SubData(-1,1), b3.SubData(-1,0), &quot;r#o&quot;);
}
</pre><div align="center"><img src="png/section.png" alt="Sample section">
</div>
<hr>
<a name="several_005flight-sample"></a>
<div class="header">
<p>
Next: <a href="#solve-sample" accesskey="n" rel="next">solve sample</a>, Previous: <a href="#section-sample" accesskey="p" rel="prev">section sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-several_005flight"></a>
<h3 class="section">10.105 Sample &lsquo;<samp>several_light</samp>&rsquo;</h3>


<p>Example of using several <a href="#light">light</a> sources.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Several light sources':rotate 50 60:light on
light 1 0 1 0 'c':light 2 1 0 0 'y':light 3 0 -1 0 'm'
box:surf a 'h'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_several_light(mglGraph *gr)	// several light sources
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Several light sources&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;AddLight(1,mglPoint(0,1,0),'c');
	gr-&gt;AddLight(2,mglPoint(1,0,0),'y');	gr-&gt;AddLight(3,mglPoint(0,-1,0),'m');
	gr-&gt;Box();	gr-&gt;Surf(a,&quot;h&quot;);
}
</pre><div align="center"><img src="png/several_light.png" alt="Sample several_light">
</div>
<hr>
<a name="solve-sample"></a>
<div class="header">
<p>
Next: <a href="#stem-sample" accesskey="n" rel="next">stem sample</a>, Previous: <a href="#several_005flight-sample" accesskey="p" rel="prev">several_light sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-solve"></a>
<h3 class="section">10.106 Sample &lsquo;<samp>solve</samp>&rsquo;</h3>


<p>Example of <a href="#solve">solve</a> for root finding.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">zrange 0 1
new x 20 30 '(x+2)/3*cos(pi*y)'
new y 20 30 '(x+2)/3*sin(pi*y)'
new z 20 30 'exp(-6*x^2-2*sin(pi*y)^2)'

subplot 2 1 0:title 'Cartesian space':rotate 30 -40
axis 'xyzU':box
xlabel 'x':ylabel 'y'
origin 1 1:grid 'xy'
mesh x y z

# section along 'x' direction
solve u x 0.5 'x'
var v u.nx 0 1
evaluate yy y u v
evaluate xx x u v
evaluate zz z u v
plot xx yy zz 'k2o'

# 1st section along 'y' direction
solve u1 x -0.5 'y'
var v1 u1.nx 0 1
evaluate yy y v1 u1
evaluate xx x v1 u1
evaluate zz z v1 u1
plot xx yy zz 'b2^'

# 2nd section along 'y' direction
solve u2 x -0.5 'y' u1
evaluate yy y v1 u2
evaluate xx x v1 u2
evaluate zz z v1 u2
plot xx yy zz 'r2v'

subplot 2 1 1:title 'Accompanied space'
ranges 0 1 0 1:origin 0 0
axis:box:xlabel 'i':ylabel 'j':grid2 z 'h'

plot u v 'k2o':line 0.4 0.5 0.8 0.5 'kA'
plot v1 u1 'b2^':line 0.5 0.15 0.5 0.3 'bA'
plot v1 u2 'r2v':line 0.5 0.7 0.5 0.85 'rA'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_solve(mglGraph *gr)	// solve and evaluate
{
	gr-&gt;SetRange('z',0,1);
	mglData x(20,30), y(20,30), z(20,30), xx,yy,zz;
	gr-&gt;Fill(x,&quot;(x+2)/3*cos(pi*y)&quot;);
	gr-&gt;Fill(y,&quot;(x+2)/3*sin(pi*y)&quot;);
	gr-&gt;Fill(z,&quot;exp(-6*x^2-2*sin(pi*y)^2)&quot;);

	gr-&gt;SubPlot(2,1,0);	gr-&gt;Title(&quot;Cartesian space&quot;);	gr-&gt;Rotate(30,-40);
	gr-&gt;Axis(&quot;xyzU&quot;);	gr-&gt;Box();	gr-&gt;Label('x',&quot;x&quot;);	gr-&gt;Label('y',&quot;y&quot;);
	gr-&gt;SetOrigin(1,1);	gr-&gt;Grid(&quot;xy&quot;);
	gr-&gt;Mesh(x,y,z);

	// section along 'x' direction
	mglData u = x.Solve(0.5,'x');
	mglData v(u.nx);	v.Fill(0,1);
	xx = x.Evaluate(u,v);	yy = y.Evaluate(u,v);	zz = z.Evaluate(u,v);
	gr-&gt;Plot(xx,yy,zz,&quot;k2o&quot;);

	// 1st section along 'y' direction
	mglData u1 = x.Solve(-0.5,'y');
	mglData v1(u1.nx);	v1.Fill(0,1);
	xx = x.Evaluate(v1,u1);	yy = y.Evaluate(v1,u1);	zz = z.Evaluate(v1,u1);
	gr-&gt;Plot(xx,yy,zz,&quot;b2^&quot;);

	// 2nd section along 'y' direction
	mglData u2 = x.Solve(-0.5,'y',u1);
	xx = x.Evaluate(v1,u2);	yy = y.Evaluate(v1,u2);	zz = z.Evaluate(v1,u2);
	gr-&gt;Plot(xx,yy,zz,&quot;r2v&quot;);

	gr-&gt;SubPlot(2,1,1);	gr-&gt;Title(&quot;Accompanied space&quot;);
	gr-&gt;SetRanges(0,1,0,1);	gr-&gt;SetOrigin(0,0);
	gr-&gt;Axis();	gr-&gt;Box();	gr-&gt;Label('x',&quot;i&quot;);	gr-&gt;Label('y',&quot;j&quot;);
	gr-&gt;Grid(z,&quot;h&quot;);

	gr-&gt;Plot(u,v,&quot;k2o&quot;);	gr-&gt;Line(mglPoint(0.4,0.5),mglPoint(0.8,0.5),&quot;kA&quot;);
	gr-&gt;Plot(v1,u1,&quot;b2^&quot;);	gr-&gt;Line(mglPoint(0.5,0.15),mglPoint(0.5,0.3),&quot;bA&quot;);
	gr-&gt;Plot(v1,u2,&quot;r2v&quot;);	gr-&gt;Line(mglPoint(0.5,0.7),mglPoint(0.5,0.85),&quot;rA&quot;);
}
</pre><div align="center"><img src="png/solve.png" alt="Sample solve">
</div>
<hr>
<a name="stem-sample"></a>
<div class="header">
<p>
Next: <a href="#step-sample" accesskey="n" rel="next">step sample</a>, Previous: <a href="#solve-sample" accesskey="p" rel="prev">solve sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-stem"></a>
<h3 class="section">10.107 Sample &lsquo;<samp>stem</samp>&rsquo;</h3>


<p>Function <a href="#stem">stem</a> draw vertical bars. It is most attractive if markers are drawn too.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
origin 0 0 0:subplot 2 2 0 '':title 'Stem plot (default)':box:stem y
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 2 2 1:title '3d variant':rotate 50 60:box:stem xc yc z 'rx'
subplot 2 2 2 '':title '&quot;!&quot; style':box:stem y 'o!rgb'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_stem(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);	gr-&gt;SetOrigin(0,0,0);
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Stem plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Stem(y);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Stem(xc,yc,z,&quot;rx&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'!' style&quot;);	gr-&gt;Box();	gr-&gt;Stem(y,&quot;o!rgb&quot;);
}
</pre><div align="center"><img src="png/stem.png" alt="Sample stem">
</div>
<hr>
<a name="step-sample"></a>
<div class="header">
<p>
Next: <a href="#stereo-sample" accesskey="n" rel="next">stereo sample</a>, Previous: <a href="#stem-sample" accesskey="p" rel="prev">stem sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-step"></a>
<h3 class="section">10.108 Sample &lsquo;<samp>step</samp>&rsquo;</h3>


<p>Function <a href="#step">step</a> plot data as stairs. At this stairs can be centered if sizes are differ by 1.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
origin 0 0 0:subplot 2 2 0 '':title 'Step plot (default)':box:step y
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 2 2 1:title '3d variant':rotate 50 60:box:step xc yc z 'r'
subplot 2 2 2 '':title '&quot;!&quot; style':box:step y 's!rgb'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_step(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);	gr-&gt;SetOrigin(0,0,0);
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Step plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Step(y);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Step(xc,yc,z,&quot;r&quot;);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'!' style&quot;);	gr-&gt;Box();	gr-&gt;Step(y,&quot;s!rgb&quot;);
}
</pre><div align="center"><img src="png/step.png" alt="Sample step">
</div>
<hr>
<a name="stereo-sample"></a>
<div class="header">
<p>
Next: <a href="#stfa-sample" accesskey="n" rel="next">stfa sample</a>, Previous: <a href="#step-sample" accesskey="p" rel="prev">step sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-stereo"></a>
<h3 class="section">10.109 Sample &lsquo;<samp>stereo</samp>&rsquo;</h3>


<p>Example of stereo image of <a href="#surf">surf</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
light on
subplot 2 1 0:rotate 50 60+1:box:surf a
subplot 2 1 1:rotate 50 60-1:box:surf a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_stereo(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;Light(true);
	gr-&gt;SubPlot(2,1,0);	gr-&gt;Rotate(50,60+1);
	gr-&gt;Box();	gr-&gt;Surf(a);
	gr-&gt;SubPlot(2,1,1);	gr-&gt;Rotate(50,60-1);
	gr-&gt;Box();	gr-&gt;Surf(a);
}
</pre><div align="center"><img src="png/stereo.png" alt="Sample stereo">
</div>
<hr>
<a name="stfa-sample"></a>
<div class="header">
<p>
Next: <a href="#style-sample" accesskey="n" rel="next">style sample</a>, Previous: <a href="#stereo-sample" accesskey="p" rel="prev">stereo sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-stfa"></a>
<h3 class="section">10.110 Sample &lsquo;<samp>stfa</samp>&rsquo;</h3>


<p>Example of <a href="#stfa">stfa</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new a 2000:new b 2000
fill a 'cos(50*pi*x)*(x&lt;-.5)+cos(100*pi*x)*(x&lt;0)*(x&gt;-.5)+\
cos(200*pi*x)*(x&lt;.5)*(x&gt;0)+cos(400*pi*x)*(x&gt;.5)'
subplot 1 2 0 '&lt;_':title 'Initial signal':plot a:axis:xlabel '\i t'
subplot 1 2 1 '&lt;_':title 'STFA plot':stfa a b 64:axis:ylabel '\omega' 0:xlabel '\i t'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_stfa(mglGraph *gr)	// STFA sample
{
	mglData a(2000), b(2000);
	gr-&gt;Fill(a,&quot;cos(50*pi*x)*(x&lt;-.5)+cos(100*pi*x)*(x&lt;0)*(x&gt;-.5)+\
	cos(200*pi*x)*(x&lt;.5)*(x&gt;0)+cos(400*pi*x)*(x&gt;.5)&quot;);
	gr-&gt;SubPlot(1, 2, 0,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;Initial signal&quot;);
	gr-&gt;Plot(a);
	gr-&gt;Axis();
	gr-&gt;Label('x', &quot;\\i t&quot;);

	gr-&gt;SubPlot(1, 2, 1,&quot;&lt;_&quot;);	gr-&gt;Title(&quot;STFA plot&quot;);
	gr-&gt;STFA(a, b, 64);
	gr-&gt;Axis();
	gr-&gt;Label('x', &quot;\\i t&quot;);
	gr-&gt;Label('y', &quot;\\omega&quot;, 0);
}
</pre><div align="center"><img src="png/stfa.png" alt="Sample stfa">
</div>
<hr>
<a name="style-sample"></a>
<div class="header">
<p>
Next: <a href="#surf-sample" accesskey="n" rel="next">surf sample</a>, Previous: <a href="#stfa-sample" accesskey="p" rel="prev">stfa sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-style"></a>
<h3 class="section">10.111 Sample &lsquo;<samp>style</samp>&rsquo;</h3>


<p>Example of colors and styles for plots.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_style(mglGraph *gr)	// pen styles
{
	gr-&gt;SubPlot(2,2,0);
	double d,x1,x2,x0,y=1.1, y1=1.15;
	d=0.3, x0=0.2, x1=0.5, x2=0.6;
	gr-&gt;Line(mglPoint(x0,y1-0*d),mglPoint(x1,y1-0*d),&quot;k-&quot;);	gr-&gt;Puts(mglPoint(x2,y-0*d),&quot;Solid '-'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-1*d),mglPoint(x1,y1-1*d),&quot;k|&quot;);	gr-&gt;Puts(mglPoint(x2,y-1*d),&quot;Long Dash '|'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-2*d),mglPoint(x1,y1-2*d),&quot;k;&quot;);	gr-&gt;Puts(mglPoint(x2,y-2*d),&quot;Dash ';'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-3*d),mglPoint(x1,y1-3*d),&quot;k=&quot;);	gr-&gt;Puts(mglPoint(x2,y-3*d),&quot;Small dash '='&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-4*d),mglPoint(x1,y1-4*d),&quot;kj&quot;);	gr-&gt;Puts(mglPoint(x2,y-4*d),&quot;Dash-dot 'j'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-5*d),mglPoint(x1,y1-5*d),&quot;ki&quot;);	gr-&gt;Puts(mglPoint(x2,y-5*d),&quot;Small dash-dot 'i'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-6*d),mglPoint(x1,y1-6*d),&quot;k:&quot;);	gr-&gt;Puts(mglPoint(x2,y-6*d),&quot;Dots ':'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-7*d),mglPoint(x1,y1-7*d),&quot;k &quot;);	gr-&gt;Puts(mglPoint(x2,y-7*d),&quot;None ' '&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(x0,y1-8*d),mglPoint(x1,y1-8*d),&quot;k{df090}&quot;);	gr-&gt;Puts(mglPoint(x2,y-8*d),&quot;Manual '{df090}'&quot;,&quot;:rL&quot;);

	d=0.25; x1=-1; x0=-0.8;	y = -0.05;
	gr-&gt;Mark(mglPoint(x1,5*d),&quot;k.&quot;);		gr-&gt;Puts(mglPoint(x0,y+5*d),&quot;'.'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,4*d),&quot;k+&quot;);		gr-&gt;Puts(mglPoint(x0,y+4*d),&quot;'+'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,3*d),&quot;kx&quot;);		gr-&gt;Puts(mglPoint(x0,y+3*d),&quot;'x'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,2*d),&quot;k*&quot;);		gr-&gt;Puts(mglPoint(x0,y+2*d),&quot;'*'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,d),&quot;ks&quot;);		gr-&gt;Puts(mglPoint(x0,y+d),&quot;'s'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,0),&quot;kd&quot;);		gr-&gt;Puts(mglPoint(x0,y),&quot;'d'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-d,0),&quot;ko&quot;);	gr-&gt;Puts(mglPoint(x0,y-d),&quot;'o'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-2*d,0),&quot;k^&quot;);	gr-&gt;Puts(mglPoint(x0,y-2*d),&quot;'\\^'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-3*d,0),&quot;kv&quot;);	gr-&gt;Puts(mglPoint(x0,y-3*d),&quot;'v'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-4*d,0),&quot;k&lt;&quot;);	gr-&gt;Puts(mglPoint(x0,y-4*d),&quot;'&lt;'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-5*d,0),&quot;k&gt;&quot;);	gr-&gt;Puts(mglPoint(x0,y-5*d),&quot;'&gt;'&quot;,&quot;:rL&quot;);

	d=0.25; x1=-0.5; x0=-0.3;	y = -0.05;
	gr-&gt;Mark(mglPoint(x1,5*d),&quot;k#.&quot;);	gr-&gt;Puts(mglPoint(x0,y+5*d),&quot;'\\#.'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,4*d),&quot;k#+&quot;);	gr-&gt;Puts(mglPoint(x0,y+4*d),&quot;'\\#+'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,3*d),&quot;k#x&quot;);	gr-&gt;Puts(mglPoint(x0,y+3*d),&quot;'\\#x'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,2*d),&quot;k#*&quot;);	gr-&gt;Puts(mglPoint(x0,y+2*d),&quot;'\\#*'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,d),&quot;k#s&quot;);		gr-&gt;Puts(mglPoint(x0,y+d),&quot;'\\#s'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,0),&quot;k#d&quot;);		gr-&gt;Puts(mglPoint(x0,y),&quot;'\\#d'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-d,0),&quot;k#o&quot;);	gr-&gt;Puts(mglPoint(x0,y-d),&quot;'\\#o'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-2*d,0),&quot;k#^&quot;);	gr-&gt;Puts(mglPoint(x0,y-2*d),&quot;'\\#\\^'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-3*d,0),&quot;k#v&quot;);	gr-&gt;Puts(mglPoint(x0,y-3*d),&quot;'\\#v'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-4*d,0),&quot;k#&lt;&quot;);	gr-&gt;Puts(mglPoint(x0,y-4*d),&quot;'\\#&lt;'&quot;,&quot;:rL&quot;);
	gr-&gt;Mark(mglPoint(x1,-5*d,0),&quot;k#&gt;&quot;);	gr-&gt;Puts(mglPoint(x0,y-5*d),&quot;'\\#&gt;'&quot;,&quot;:rL&quot;);

	gr-&gt;SubPlot(2,2,1);
	double a=0.1,b=0.4,c=0.5;
	gr-&gt;Line(mglPoint(a,1),mglPoint(b,1),&quot;k-A&quot;);		gr-&gt;Puts(mglPoint(c,1),&quot;Style 'A' or 'A\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.8),mglPoint(b,0.8),&quot;k-V&quot;);	gr-&gt;Puts(mglPoint(c,0.8),&quot;Style 'V' or 'V\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.6),mglPoint(b,0.6),&quot;k-K&quot;);	gr-&gt;Puts(mglPoint(c,0.6),&quot;Style 'K' or 'K\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.4),mglPoint(b,0.4),&quot;k-I&quot;);	gr-&gt;Puts(mglPoint(c,0.4),&quot;Style 'I' or 'I\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.2),mglPoint(b,0.2),&quot;k-D&quot;);	gr-&gt;Puts(mglPoint(c,0.2),&quot;Style 'D' or 'D\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0),mglPoint(b,0),&quot;k-S&quot;);		gr-&gt;Puts(mglPoint(c,0),&quot;Style 'S' or 'S\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.2),mglPoint(b,-0.2),&quot;k-O&quot;);	gr-&gt;Puts(mglPoint(c,-0.2),&quot;Style 'O' or 'O\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.4),mglPoint(b,-0.4),&quot;k-T&quot;);	gr-&gt;Puts(mglPoint(c,-0.4),&quot;Style 'T' or 'T\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.6),mglPoint(b,-0.6),&quot;k-X&quot;);	gr-&gt;Puts(mglPoint(c,-0.6),&quot;Style 'X' or 'X\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.8),mglPoint(b,-0.8),&quot;k-_&quot;);	gr-&gt;Puts(mglPoint(c,-0.8),&quot;Style '\\_' or none&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-1),mglPoint(b,-1),&quot;k-AS&quot;);		gr-&gt;Puts(mglPoint(c,-1),&quot;Style 'AS'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-1.2),mglPoint(b,-1.2),&quot;k-_A&quot;);	gr-&gt;Puts(mglPoint(c,-1.2),&quot;Style '\\_A'&quot;,&quot;:rL&quot;);

	a=-1;	b=-0.7;	c=-0.6;
	gr-&gt;Line(mglPoint(a,1),mglPoint(b,1),&quot;kAA&quot;);		gr-&gt;Puts(mglPoint(c,1),&quot;Style 'AA'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.8),mglPoint(b,0.8),&quot;kVV&quot;);	gr-&gt;Puts(mglPoint(c,0.8),&quot;Style 'VV'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.6),mglPoint(b,0.6),&quot;kKK&quot;);	gr-&gt;Puts(mglPoint(c,0.6),&quot;Style 'KK'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.4),mglPoint(b,0.4),&quot;kII&quot;);	gr-&gt;Puts(mglPoint(c,0.4),&quot;Style 'II'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0.2),mglPoint(b,0.2),&quot;kDD&quot;);	gr-&gt;Puts(mglPoint(c,0.2),&quot;Style 'DD'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,0),mglPoint(b,0),&quot;kSS&quot;);		gr-&gt;Puts(mglPoint(c,0),&quot;Style 'SS'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.2),mglPoint(b,-0.2),&quot;kOO&quot;);	gr-&gt;Puts(mglPoint(c,-0.2),&quot;Style 'OO'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.4),mglPoint(b,-0.4),&quot;kTT&quot;);	gr-&gt;Puts(mglPoint(c,-0.4),&quot;Style 'TT'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.6),mglPoint(b,-0.6),&quot;kXX&quot;);	gr-&gt;Puts(mglPoint(c,-0.6),&quot;Style 'XX'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-0.8),mglPoint(b,-0.8),&quot;k-__&quot;);	gr-&gt;Puts(mglPoint(c,-0.8),&quot;Style '\\_\\_'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-1),mglPoint(b,-1),&quot;k-VA&quot;);		gr-&gt;Puts(mglPoint(c,-1),&quot;Style 'VA'&quot;,&quot;:rL&quot;);
	gr-&gt;Line(mglPoint(a,-1.2),mglPoint(b,-1.2),&quot;k-AV&quot;);	gr-&gt;Puts(mglPoint(c,-1.2),&quot;Style 'AV'&quot;,&quot;:rL&quot;);

	gr-&gt;SubPlot(2,2,2);
	//#LENUQ
	gr-&gt;FaceZ(mglPoint(-1,	-1), 0.4, 0.3, &quot;L#&quot;);	gr-&gt;Puts(mglPoint(-0.8,-0.9), &quot;L&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,-1), 0.4, 0.3, &quot;E#&quot;);	gr-&gt;Puts(mglPoint(-0.4,-0.9), &quot;E&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,-1), 0.4, 0.3, &quot;N#&quot;);	gr-&gt;Puts(mglPoint(0,  -0.9), &quot;N&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	-1), 0.4, 0.3, &quot;U#&quot;);	gr-&gt;Puts(mglPoint(0.4,-0.9), &quot;U&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	-1), 0.4, 0.3, &quot;Q#&quot;);	gr-&gt;Puts(mglPoint(0.8,-0.9), &quot;Q&quot;, &quot;w:C&quot;, -1.4);
	//#lenuq
	gr-&gt;FaceZ(mglPoint(-1,	-0.7), 0.4, 0.3, &quot;l#&quot;);	gr-&gt;Puts(mglPoint(-0.8,-0.6), &quot;l&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,-0.7), 0.4, 0.3, &quot;e#&quot;);	gr-&gt;Puts(mglPoint(-0.4,-0.6), &quot;e&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,-0.7), 0.4, 0.3, &quot;n#&quot;);	gr-&gt;Puts(mglPoint(0,  -0.6), &quot;n&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	-0.7), 0.4, 0.3, &quot;u#&quot;);	gr-&gt;Puts(mglPoint(0.4,-0.6), &quot;u&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	-0.7), 0.4, 0.3, &quot;q#&quot;);	gr-&gt;Puts(mglPoint(0.8,-0.6), &quot;q&quot;, &quot;k:C&quot;, -1.4);
	//#CMYkP
	gr-&gt;FaceZ(mglPoint(-1,	-0.4), 0.4, 0.3, &quot;C#&quot;);	gr-&gt;Puts(mglPoint(-0.8,-0.3), &quot;C&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,-0.4), 0.4, 0.3, &quot;M#&quot;);	gr-&gt;Puts(mglPoint(-0.4,-0.3), &quot;M&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,-0.4), 0.4, 0.3, &quot;Y#&quot;);	gr-&gt;Puts(mglPoint(0,  -0.3), &quot;Y&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	-0.4), 0.4, 0.3, &quot;k#&quot;);	gr-&gt;Puts(mglPoint(0.4,-0.3), &quot;k&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	-0.4), 0.4, 0.3, &quot;P#&quot;);	gr-&gt;Puts(mglPoint(0.8,-0.3), &quot;P&quot;, &quot;w:C&quot;, -1.4);
	//#cmywp
	gr-&gt;FaceZ(mglPoint(-1,	-0.1), 0.4, 0.3, &quot;c#&quot;);	gr-&gt;Puts(mglPoint(-0.8, 0), &quot;c&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,-0.1), 0.4, 0.3, &quot;m#&quot;);	gr-&gt;Puts(mglPoint(-0.4, 0), &quot;m&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,-0.1), 0.4, 0.3, &quot;y#&quot;);	gr-&gt;Puts(mglPoint(0,   0), &quot;y&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	-0.1), 0.4, 0.3, &quot;w#&quot;);	gr-&gt;Puts(mglPoint(0.4, 0), &quot;w&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	-0.1), 0.4, 0.3, &quot;p#&quot;);	gr-&gt;Puts(mglPoint(0.8, 0), &quot;p&quot;, &quot;k:C&quot;, -1.4);
	//#BGRHW
	gr-&gt;FaceZ(mglPoint(-1,	0.2), 0.4, 0.3, &quot;B#&quot;);	gr-&gt;Puts(mglPoint(-0.8, 0.3), &quot;B&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,0.2), 0.4, 0.3, &quot;G#&quot;);	gr-&gt;Puts(mglPoint(-0.4, 0.3), &quot;G&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,0.2), 0.4, 0.3, &quot;R#&quot;);	gr-&gt;Puts(mglPoint(0,   0.3), &quot;R&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	0.2), 0.4, 0.3, &quot;H#&quot;);	gr-&gt;Puts(mglPoint(0.4, 0.3), &quot;H&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	0.2), 0.4, 0.3, &quot;W#&quot;);	gr-&gt;Puts(mglPoint(0.8, 0.3), &quot;W&quot;, &quot;w:C&quot;, -1.4);
	//#bgrhw
	gr-&gt;FaceZ(mglPoint(-1,	0.5), 0.4, 0.3, &quot;b#&quot;);	gr-&gt;Puts(mglPoint(-0.8, 0.6), &quot;b&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,0.5), 0.4, 0.3, &quot;g#&quot;);	gr-&gt;Puts(mglPoint(-0.4, 0.6), &quot;g&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,0.5), 0.4, 0.3, &quot;r#&quot;);	gr-&gt;Puts(mglPoint(0,   0.6), &quot;r&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	0.5), 0.4, 0.3, &quot;h#&quot;);	gr-&gt;Puts(mglPoint(0.4, 0.6), &quot;h&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	0.5), 0.4, 0.3, &quot;w#&quot;);	gr-&gt;Puts(mglPoint(0.8, 0.6), &quot;w&quot;, &quot;k:C&quot;, -1.4);
	//#brighted
	gr-&gt;FaceZ(mglPoint(-1,	0.8), 0.4, 0.3, &quot;{r1}#&quot;);	gr-&gt;Puts(mglPoint(-0.8, 0.9), &quot;\\{r1\\}&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.6,0.8), 0.4, 0.3, &quot;{r3}#&quot;);	gr-&gt;Puts(mglPoint(-0.4, 0.9), &quot;\\{r3\\}&quot;, &quot;w:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(-0.2,0.8), 0.4, 0.3, &quot;{r5}#&quot;);	gr-&gt;Puts(mglPoint(0,   0.9), &quot;\\{r5\\}&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.2,	0.8), 0.4, 0.3, &quot;{r7}#&quot;);	gr-&gt;Puts(mglPoint(0.4, 0.9), &quot;\\{r7\\}&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0.6,	0.8), 0.4, 0.3, &quot;{r9}#&quot;);	gr-&gt;Puts(mglPoint(0.8, 0.9), &quot;\\{r9\\}&quot;, &quot;k:C&quot;, -1.4);
	// HEX
	gr-&gt;FaceZ(mglPoint(-1, -1.3), 1, 0.3, &quot;{xff9966}#&quot;);	gr-&gt;Puts(mglPoint(-0.5,-1.2), &quot;\\{xff9966\\}&quot;, &quot;k:C&quot;, -1.4);
	gr-&gt;FaceZ(mglPoint(0,  -1.3), 1, 0.3, &quot;{x83CAFF}#&quot;);	gr-&gt;Puts(mglPoint( 0.5,-1.2), &quot;\\{x83CAFF\\}&quot;, &quot;k:C&quot;, -1.4);

	gr-&gt;SubPlot(2,2,3);
	char stl[3]=&quot;r1&quot;, txt[4]=&quot;'1'&quot;;
	for(int i=0;i&lt;10;i++)
	{
		txt[1]=stl[1]='0'+i;
		gr-&gt;Line(mglPoint(-1,0.2*i-1),mglPoint(1,0.2*i-1),stl);
		gr-&gt;Puts(mglPoint(1.05,0.2*i-1),txt,&quot;:L&quot;);
	}
}
</pre><div align="center"><img src="png/style.png" alt="Sample style">
</div>
<hr>
<a name="surf-sample"></a>
<div class="header">
<p>
Next: <a href="#surf3-sample" accesskey="n" rel="next">surf3 sample</a>, Previous: <a href="#style-sample" accesskey="p" rel="prev">style sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surf"></a>
<h3 class="section">10.112 Sample &lsquo;<samp>surf</samp>&rsquo;</h3>


<p>Function <a href="#surf">surf</a> is most standard way to visualize 2D data array. <code>Surf</code> use color scheme for coloring (see <a href="#Color-scheme">Color scheme</a>). You can use &lsquo;<samp>#</samp>&rsquo; style for drawing black meshes on the surface.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
subplot 2 2 0:title 'Surf plot (default)':rotate 50 60:light on:box:surf a
subplot 2 2 1:title '&quot;\#&quot; style; meshnum 10':rotate 50 60:box:surf a '#'; meshnum 10
subplot 2 2 2:title '&quot;.&quot; style':rotate 50 60:box:surf a '.'
new x 50 40 '0.8*sin(pi*x)*sin(pi*(y+1)/2)'
new y 50 40 '0.8*cos(pi*x)*sin(pi*(y+1)/2)'
new z 50 40 '0.8*cos(pi*(y+1)/2)'
subplot 2 2 3:title 'parametric form':rotate 50 60:box:surf x y z 'BbwrR'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surf3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Surf3 plot (default)&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Surf3(c);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'\\#' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Surf3(c,&quot;#&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'.' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Surf3(c,&quot;.&quot;);
}
</pre><div align="center"><img src="png/surf.png" alt="Sample surf">
</div>
<hr>
<a name="surf3-sample"></a>
<div class="header">
<p>
Next: <a href="#surf3a-sample" accesskey="n" rel="next">surf3a sample</a>, Previous: <a href="#surf-sample" accesskey="p" rel="prev">surf sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surf3"></a>
<h3 class="section">10.113 Sample &lsquo;<samp>surf3</samp>&rsquo;</h3>


<p>Function <a href="#surf3">surf3</a> is one of most suitable (for my opinion) functions to visualize 3D data. It draw the isosurface(s) &ndash; surface(s) of constant amplitude (3D analogue of contour lines). You can draw wired isosurfaces if specify &lsquo;<samp>#</samp>&rsquo; style.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
light on:alpha on
subplot 2 2 0:title 'Surf3 plot (default)'
rotate 50 60:box:surf3 c
subplot 2 2 1:title '&quot;\#&quot; style'
rotate 50 60:box:surf3 c '#'
subplot 2 2 2:title '&quot;.&quot; style'
rotate 50 60:box:surf3 c '.'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surf3(mglGraph *gr)
{
	mglData c;	mgls_prepare3d(&amp;c);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Surf3 plot (default)&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Surf3(c);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'\\#' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Surf3(c,&quot;#&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'.' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Surf3(c,&quot;.&quot;);
}
</pre><div align="center"><img src="png/surf3.png" alt="Sample surf3">
</div>
<hr>
<a name="surf3a-sample"></a>
<div class="header">
<p>
Next: <a href="#surf3c-sample" accesskey="n" rel="next">surf3c sample</a>, Previous: <a href="#surf3-sample" accesskey="p" rel="prev">surf3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surf3a"></a>
<h3 class="section">10.114 Sample &lsquo;<samp>surf3a</samp>&rsquo;</h3>


<p>Function <a href="#surf3c">surf3c</a> is similar to <a href="#surf3">surf3</a> but its transparency is determined by another data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Surf3A plot':rotate 50 60:light on:alpha on:box:surf3a c d
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surf3a(mglGraph *gr)
{
	mglData c,d;	mgls_prepare3d(&amp;c,&amp;d);
	if(big!=3)	gr-&gt;Title(&quot;Surf3A plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Surf3A(c,d);
}
</pre><div align="center"><img src="png/surf3a.png" alt="Sample surf3a">
</div>
<hr>
<a name="surf3c-sample"></a>
<div class="header">
<p>
Next: <a href="#surf3ca-sample" accesskey="n" rel="next">surf3ca sample</a>, Previous: <a href="#surf3a-sample" accesskey="p" rel="prev">surf3a sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surf3c"></a>
<h3 class="section">10.115 Sample &lsquo;<samp>surf3c</samp>&rsquo;</h3>


<p>Function <a href="#surf3c">surf3c</a> is similar to <a href="#surf3">surf3</a> but its coloring is determined by another data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Surf3C plot':rotate 50 60:light on:alpha on:box:surf3c c d
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surf3c(mglGraph *gr)
{
	mglData c,d;	mgls_prepare3d(&amp;c,&amp;d);
	if(big!=3)	gr-&gt;Title(&quot;Surf3C plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Surf3C(c,d);
}
</pre><div align="center"><img src="png/surf3c.png" alt="Sample surf3c">
</div>
<hr>
<a name="surf3ca-sample"></a>
<div class="header">
<p>
Next: <a href="#surfa-sample" accesskey="n" rel="next">surfa sample</a>, Previous: <a href="#surf3c-sample" accesskey="p" rel="prev">surf3c sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surf3ca"></a>
<h3 class="section">10.116 Sample &lsquo;<samp>surf3ca</samp>&rsquo;</h3>


<p>Function <a href="#surf3c">surf3c</a> is similar to <a href="#surf3">surf3</a> but its coloring and transparency is determined by another data arrays.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3d'
title 'Surf3CA plot':rotate 50 60:light on:alpha on:box:surf3ca c d c
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surf3ca(mglGraph *gr)
{
	mglData c,d;	mgls_prepare3d(&amp;c,&amp;d);
	if(big!=3)	gr-&gt;Title(&quot;Surf3CA plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Alpha(true);
	gr-&gt;Box();	gr-&gt;Surf3CA(c,d,c);
}
</pre><div align="center"><img src="png/surf3ca.png" alt="Sample surf3ca">
</div>
<hr>
<a name="surfa-sample"></a>
<div class="header">
<p>
Next: <a href="#surfc-sample" accesskey="n" rel="next">surfc sample</a>, Previous: <a href="#surf3ca-sample" accesskey="p" rel="prev">surf3ca sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surfa"></a>
<h3 class="section">10.117 Sample &lsquo;<samp>surfa</samp>&rsquo;</h3>


<p>Function <a href="#surfa">surfa</a> is similar to <a href="#surf">surf</a> but its transparency is determined by another data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'SurfA plot':rotate 50 60:light on:alpha on:box:surfa a b
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surfa(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2d(&amp;a,&amp;b);
	if(big!=3)	gr-&gt;Title(&quot;SurfA plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Alpha(true);	gr-&gt;Light(true);	gr-&gt;Box();
	gr-&gt;SurfA(a,b);
}
</pre><div align="center"><img src="png/surfa.png" alt="Sample surfa">
</div>
<hr>
<a name="surfc-sample"></a>
<div class="header">
<p>
Next: <a href="#surfca-sample" accesskey="n" rel="next">surfca sample</a>, Previous: <a href="#surfa-sample" accesskey="p" rel="prev">surfa sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surfc"></a>
<h3 class="section">10.118 Sample &lsquo;<samp>surfc</samp>&rsquo;</h3>


<p>Function <a href="#surfc">surfc</a> is similar to <a href="#surf">surf</a> but its coloring is determined by another data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'SurfC plot':rotate 50 60:light on:box:surfc a b
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surfc(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2d(&amp;a,&amp;b);
	if(big!=3)	gr-&gt;Title(&quot;SurfC plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);	gr-&gt;Box();	gr-&gt;SurfC(a,b);
}
</pre><div align="center"><img src="png/surfc.png" alt="Sample surfc">
</div>
<hr>
<a name="surfca-sample"></a>
<div class="header">
<p>
Next: <a href="#table-sample" accesskey="n" rel="next">table sample</a>, Previous: <a href="#surfc-sample" accesskey="p" rel="prev">surfc sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-surfca"></a>
<h3 class="section">10.119 Sample &lsquo;<samp>surfca</samp>&rsquo;</h3>


<p>Function <a href="#surfca">surfca</a> is similar to <a href="#surf">surf</a> but its coloring and transparency is determined by another data arrays.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'SurfCA plot':rotate 50 60:light on:alpha on:box:surfca a b a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_surfca(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2d(&amp;a,&amp;b);
	if(big!=3)	gr-&gt;Title(&quot;SurfCA plot&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;Alpha(true);	gr-&gt;Light(true);	gr-&gt;Box();
	gr-&gt;SurfCA(a,b,a);
}
</pre><div align="center"><img src="png/surfca.png" alt="Sample surfca">
</div>
<hr>
<a name="table-sample"></a>
<div class="header">
<p>
Next: <a href="#tape-sample" accesskey="n" rel="next">tape sample</a>, Previous: <a href="#surfca-sample" accesskey="p" rel="prev">surfca sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-table"></a>
<h3 class="section">10.120 Sample &lsquo;<samp>table</samp>&rsquo;</h3>


<p>Function <a href="#table">table</a> draw table with data values.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new ys 10 3 '0.8*sin(pi*(x+y/4+1.25))+0.2*rnd'
subplot 2 2 0:title 'Table sample':box
table ys 'y_1\n{}y_2\n{}y_3'

subplot 2 2 1:title 'no borders, colored'
table ys 'y_1\n{}y_2\n{}y_3' 'r|'

subplot 2 2 2:title 'no font decrease'
table ys 'y_1\n{}y_2\n{}y_3' '#'

subplot 2 2 3:title 'manual width and position':box
table 0.5 0.95 ys 'y_1\n{}y_2\n{}y_3' '#';value 0.7
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_table(mglGraph *gr)
{
	mglData ys(10,3);	ys.Modify(&quot;0.8*sin(pi*(2*x+y/2))+0.2*rnd&quot;);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Table plot&quot;);	}
	gr-&gt;Table(ys,&quot;y_1\ny_2\ny_3&quot;);	gr-&gt;Box();
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;no borders, colored&quot;);
	gr-&gt;Table(ys,&quot;y_1\ny_2\ny_3&quot;,&quot;r|&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;no font decrease&quot;);
	gr-&gt;Table(ys,&quot;y_1\ny_2\ny_3&quot;,&quot;#&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;manual width, position&quot;);
	gr-&gt;Table(0.5, 0.95, ys,&quot;y_1\ny_2\ny_3&quot;,&quot;#&quot;, &quot;value 0.7&quot;);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/table.png" alt="Sample table">
</div>
<hr>
<a name="tape-sample"></a>
<div class="header">
<p>
Next: <a href="#tens-sample" accesskey="n" rel="next">tens sample</a>, Previous: <a href="#table-sample" accesskey="p" rel="prev">table sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-tape"></a>
<h3 class="section">10.121 Sample &lsquo;<samp>tape</samp>&rsquo;</h3>


<p>Function <a href="#tape">tape</a> draw tapes which rotate around the curve as transverse orts of accompanied coordinates.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
new yc 50 'sin(pi*x)':new xc 50 'cos(pi*x)':new z 50 'x'
subplot 2 2 0 '':title 'Tape plot (default)':box:tape y:plot y 'k'
subplot 2 2 1:title '3d variant, 2 colors':rotate 50 60:light on
box:plot xc yc z 'k':tape xc yc z 'rg'
subplot 2 2 2:title '3d variant, x only':rotate 50 60
box:plot xc yc z 'k':tape xc yc z 'xr':tape xc yc z 'xr#'
subplot 2 2 3:title '3d variant, z only':rotate 50 60
box:plot xc yc z 'k':tape xc yc z 'zg':tape xc yc z 'zg#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_tape(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);
	mglData xc(50), yc(50), z(50);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);
	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);	z.Fill(-1,1);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Tape plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Tape(y);	gr-&gt;Plot(y,&quot;k&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;3d variant, 2 colors&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Light(true);
	gr-&gt;Box();	gr-&gt;Plot(xc,yc,z,&quot;k&quot;);	gr-&gt;Tape(xc,yc,z,&quot;rg&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;3d variant, x only&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Plot(xc,yc,z,&quot;k&quot;);	gr-&gt;Tape(xc,yc,z,&quot;xr&quot;);	gr-&gt;Tape(xc,yc,z,&quot;xr#&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;3d variant, z only&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;Box();	gr-&gt;Plot(xc,yc,z,&quot;k&quot;);	gr-&gt;Tape(xc,yc,z,&quot;zg&quot;);	gr-&gt;Tape(xc,yc,z,&quot;zg#&quot;);
}
</pre><div align="center"><img src="png/tape.png" alt="Sample tape">
</div>
<hr>
<a name="tens-sample"></a>
<div class="header">
<p>
Next: <a href="#ternary-sample" accesskey="n" rel="next">ternary sample</a>, Previous: <a href="#tape-sample" accesskey="p" rel="prev">tape sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-tens"></a>
<h3 class="section">10.122 Sample &lsquo;<samp>tens</samp>&rsquo;</h3>


<p>Function <a href="#tens">tens</a> is variant of <a href="#plot">plot</a> with smooth coloring along the curves. At this, color is determined as for surfaces (see <a href="#Color-scheme">Color scheme</a>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 2 2 0 '':title 'Tens plot (default)':box:tens y(:,0) y(:,1)
subplot 2 2 2 '':title '&quot; &quot; style':box:tens y(:,0) y(:,1) 'o '
new yc 30 'sin(pi*x)':new xc 30 'cos(pi*x)':new z 30 'x'
subplot 2 2 1:title '3d variant':rotate 50 60:box:tens xc yc z z 's'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_tens(mglGraph *gr)
{
	mglData y;	mgls_prepare1d(&amp;y);	gr-&gt;SetOrigin(0,0,0);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Tens plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;Tens(y.SubData(-1,0), y.SubData(-1,1));
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;' ' style&quot;);	gr-&gt;Box();	gr-&gt;Tens(y.SubData(-1,0), y.SubData(-1,1),&quot;o &quot;);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();
	mglData yc(30), xc(30), z(30);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	gr-&gt;Tens(xc,yc,z,z,&quot;s&quot;);
}
</pre><div align="center"><img src="png/tens.png" alt="Sample tens">
</div>
<hr>
<a name="ternary-sample"></a>
<div class="header">
<p>
Next: <a href="#text-sample" accesskey="n" rel="next">text sample</a>, Previous: <a href="#tens-sample" accesskey="p" rel="prev">tens sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ternary"></a>
<h3 class="section">10.123 Sample &lsquo;<samp>ternary</samp>&rsquo;</h3>


<p>Example of <a href="#ternary">ternary</a> coordinates.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">ranges 0 1 0 1 0 1
new x 50 '0.25*(1+cos(2*pi*x))'
new y 50 '0.25*(1+sin(2*pi*x))'
new z 50 'x'
new a 20 30 '30*x*y*(1-x-y)^2*(x+y&lt;1)'
new rx 10 'rnd':new ry 10:fill ry '(1-v)*rnd' rx
light on

subplot 2 2 0:title 'Ordinary axis 3D':rotate 50 60
box:axis:grid
plot x y z 'r2':surf a '#'
xlabel 'B':ylabel 'C':zlabel 'Z'

subplot 2 2 1:title 'Ternary axis (x+y+t=1)':ternary 1
box:axis:grid 'xyz' 'B;'
plot x y 'r2':plot rx ry 'q^ ':cont a:line 0.5 0 0 0.75 'g2'
xlabel 'B':ylabel 'C':tlabel 'A'

subplot 2 2 2:title 'Quaternary axis 3D':rotate 50 60:ternary 2
box:axis:grid 'xyz' 'B;'
plot x y z 'r2':surf a '#'
xlabel 'B':ylabel 'C':tlabel 'A':zlabel 'D'

subplot 2 2 3:title 'Ternary axis 3D':rotate 50 60:ternary 1
box:axis:grid 'xyz' 'B;'
plot x y z 'r2':surf a '#'
xlabel 'B':ylabel 'C':tlabel 'A':zlabel 'Z'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ternary(mglGraph *gr)	// flag #
{
	gr-&gt;SetRanges(0,1,0,1,0,1);
	mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
	a.Modify(&quot;30*x*y*(1-x-y)^2*(x+y&lt;1)&quot;);
	x.Modify(&quot;0.25*(1+cos(2*pi*x))&quot;);
	y.Modify(&quot;0.25*(1+sin(2*pi*x))&quot;);
	rx.Modify(&quot;rnd&quot;); ry.Modify(&quot;(1-v)*rnd&quot;,rx);
	z.Modify(&quot;x&quot;);

	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Ordinary axis 3D&quot;);
	gr-&gt;Rotate(50,60);		gr-&gt;Light(true);
	gr-&gt;Plot(x,y,z,&quot;r2&quot;);	gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();	gr-&gt;Box();
	gr-&gt;Label('x',&quot;B&quot;,1);	gr-&gt;Label('y',&quot;C&quot;,1);	gr-&gt;Label('z',&quot;Z&quot;,1);

	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;Ternary axis (x+y+t=1)&quot;);
	gr-&gt;Ternary(1);
	gr-&gt;Plot(x,y,&quot;r2&quot;);	gr-&gt;Plot(rx,ry,&quot;q^ &quot;);	gr-&gt;Cont(a);
	gr-&gt;Line(mglPoint(0.5,0), mglPoint(0,0.75), &quot;g2&quot;);
	gr-&gt;Axis(); gr-&gt;Grid(&quot;xyz&quot;,&quot;B;&quot;);
	gr-&gt;Label('x',&quot;B&quot;);	gr-&gt;Label('y',&quot;C&quot;);	gr-&gt;Label('t',&quot;A&quot;);

	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;Quaternary axis 3D&quot;);
	gr-&gt;Rotate(50,60);		gr-&gt;Light(true);
	gr-&gt;Ternary(2);
	gr-&gt;Plot(x,y,z,&quot;r2&quot;);	gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();	gr-&gt;Box();
	gr-&gt;Label('t',&quot;A&quot;,1);	gr-&gt;Label('x',&quot;B&quot;,1);
	gr-&gt;Label('y',&quot;C&quot;,1);	gr-&gt;Label('z',&quot;D&quot;,1);

	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;Ternary axis 3D&quot;);
	gr-&gt;Rotate(50,60);		gr-&gt;Light(true);
	gr-&gt;Ternary(1);
	gr-&gt;Plot(x,y,z,&quot;r2&quot;);	gr-&gt;Surf(a,&quot;BbcyrR#&quot;);
	gr-&gt;Axis(); gr-&gt;Grid();	gr-&gt;Box();
	gr-&gt;Label('t',&quot;A&quot;,1);	gr-&gt;Label('x',&quot;B&quot;,1);
	gr-&gt;Label('y',&quot;C&quot;,1);	gr-&gt;Label('z',&quot;Z&quot;,1);
}
</pre><div align="center"><img src="png/ternary.png" alt="Sample ternary">
</div>
<hr>
<a name="text-sample"></a>
<div class="header">
<p>
Next: <a href="#text2-sample" accesskey="n" rel="next">text2 sample</a>, Previous: <a href="#ternary-sample" accesskey="p" rel="prev">ternary sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-text"></a>
<h3 class="section">10.124 Sample &lsquo;<samp>text</samp>&rsquo;</h3>


<p>Example of <a href="#text">text</a> possibilities.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 2 2 0 ''
text 0 1 'Text can be in ASCII and in Unicode'
text 0 0.6 'It can be \wire{wire}, \big{big} or #r{colored}'
text 0 0.2 'One can change style in string: \b{bold}, \i{italic, \b{both}}'
text 0 -0.2 'Easy to \a{overline} or \u{underline}'
text 0 -0.6 'Easy to change indexes ^{up} _{down} @{center}'
text 0 -1 'It parse TeX: \int \alpha \cdot \
\sqrt3{sin(\pi x)^2 + \gamma_{i_k}} dx'
subplot 2 2 1 ''
 text 0 0.5 '\sqrt{\frac{\alpha^{\gamma^2}+\overset 1{\big\infty}}{\sqrt3{2+b}}}' '@' -2
text 0 -0.1 'More text position: \frac{a}{b}, \dfrac{a}{b}, [\stack{a}{bbb}], [\stackl{a}{bbb}], [\stackr{a}{bbb}], \sup{a}{sup}, \sub{a}{sub}'text 0 -0.5 'Text can be printed\n{}on several lines'
text 0 -0.9 'or with color gradient' 'BbcyrR'
subplot 2 2 2 '':box:plot y(:,0)
text y 'This is very very long string drawn along a curve' 'k'
text y 'Another string drawn above a curve' 'Tr'
subplot 2 2 3 '':line -1 -1 1 -1 'rA':text 0 -1 1 -1 'Horizontal'
line -1 -1 1 1 'rA':text 0 0 1 1 'At angle' '@'
line -1 -1 -1 1 'rA':text -1 0 -1 1 'Vertical'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_text(mglGraph *gr)	// text drawing
{
	if(big!=3)	gr-&gt;SubPlot(2,2,0,&quot;&quot;);
	gr-&gt;Putsw(mglPoint(0,1),L&quot;Text can be in ASCII and in Unicode&quot;);
	gr-&gt;Puts(mglPoint(0,0.6),&quot;It can be \\wire{wire}, \\big{big} or #r{colored}&quot;);
	gr-&gt;Puts(mglPoint(0,0.2),&quot;One can change style in string: &quot;
	&quot;\\b{bold}, \\i{italic, \\b{both}}&quot;);
	gr-&gt;Puts(mglPoint(0,-0.2),&quot;Easy to \\a{overline} or &quot;
	&quot;\\u{underline}&quot;);
	gr-&gt;Puts(mglPoint(0,-0.6),&quot;Easy to change indexes ^{up} _{down} @{center}&quot;);
	gr-&gt;Puts(mglPoint(0,-1),&quot;It parse TeX: \\int \\alpha \\cdot &quot;
	&quot;\\sqrt3{sin(\\pi x)^2 + \\gamma_{i_k}} dx&quot;);
	if(big==3)	return;

	gr-&gt;SubPlot(2,2,1,&quot;&quot;);
	gr-&gt;Puts(mglPoint(0,0.5), &quot;\\sqrt{\\frac{\\alpha^{\\gamma^2}+\\overset 1{\\big\\infty}}{\\sqrt3{2+b}}}&quot;, &quot;@&quot;, -2);
	gr-&gt;Puts(mglPoint(0,-0.1),&quot;More text position: \\frac{a}{b}, \\dfrac{a}{b}, [\\stack{a}{bbb}], [\\stackl{a}{bbb}], [\\stackr{a}{bbb}], \\sup{a}{sup}, \\sub{a}{sub}&quot;);
	gr-&gt;Puts(mglPoint(0,-0.5),&quot;Text can be printed\non several lines&quot;);
	gr-&gt;Puts(mglPoint(0,-0.9),&quot;or with col\bor gradient&quot;,&quot;BbcyrR&quot;);

	gr-&gt;SubPlot(2,2,2,&quot;&quot;);
	mglData y;	mgls_prepare1d(&amp;y);
	gr-&gt;Box();	gr-&gt;Plot(y.SubData(-1,0));
	gr-&gt;Text(y,&quot;This is very very long string drawn along a curve&quot;,&quot;k&quot;);
	gr-&gt;Text(y,&quot;Another string drawn under a curve&quot;,&quot;Tr&quot;);

	gr-&gt;SubPlot(2,2,3,&quot;&quot;);
	gr-&gt;Line(mglPoint(-1,-1),mglPoint(1,-1),&quot;rA&quot;);	gr-&gt;Puts(mglPoint(0,-1),mglPoint(1,-1),&quot;Horizontal&quot;);
	gr-&gt;Line(mglPoint(-1,-1),mglPoint(1,1),&quot;rA&quot;);	gr-&gt;Puts(mglPoint(0,0),mglPoint(1,1),&quot;At angle&quot;,&quot;@&quot;);
	gr-&gt;Line(mglPoint(-1,-1),mglPoint(-1,1),&quot;rA&quot;);	gr-&gt;Puts(mglPoint(-1,0),mglPoint(-1,1),&quot;Vertical&quot;);
}
</pre><div align="center"><img src="png/text.png" alt="Sample text">
</div>
<hr>
<a name="text2-sample"></a>
<div class="header">
<p>
Next: <a href="#textmark-sample" accesskey="n" rel="next">textmark sample</a>, Previous: <a href="#text-sample" accesskey="p" rel="prev">text sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-text2"></a>
<h3 class="section">10.125 Sample &lsquo;<samp>text2</samp>&rsquo;</h3>


<p>Example of <a href="#text">text</a> along curve.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 1 3 0 '':box:plot y(:,0)
text y 'This is very very long string drawn along a curve' 'k'
text y 'Another string drawn under a curve' 'Tr'
subplot 1 3 1 '':box:plot y(:,0)
text y 'This is very very long string drawn along a curve' 'k:C'
text y 'Another string drawn under a curve' 'Tr:C'
subplot 1 3 2 '':box:plot y(:,0)
text y 'This is very very long string drawn along a curve' 'k:R'
text y 'Another string drawn under a curve' 'Tr:R'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_text2(mglGraph *gr)	// text drawing
{
	mglData y;	mgls_prepare1d(&amp;y);
	if(big!=3)	gr-&gt;SubPlot(1,3,0,&quot;&quot;);
	gr-&gt;Box();	gr-&gt;Plot(y.SubData(-1,0));
	gr-&gt;Text(y,&quot;This is very very long string drawn along a curve&quot;,&quot;k&quot;);
	gr-&gt;Text(y,&quot;Another string drawn under a curve&quot;,&quot;Tr&quot;);
	if(big==3)	return;

	gr-&gt;SubPlot(1,3,1,&quot;&quot;);
	gr-&gt;Box();	gr-&gt;Plot(y.SubData(-1,0));
	gr-&gt;Text(y,&quot;This is very very long string drawn along a curve&quot;,&quot;k:C&quot;);
	gr-&gt;Text(y,&quot;Another string drawn under a curve&quot;,&quot;Tr:C&quot;);

	gr-&gt;SubPlot(1,3,2,&quot;&quot;);
	gr-&gt;Box();	gr-&gt;Plot(y.SubData(-1,0));
	gr-&gt;Text(y,&quot;This is very very long string drawn along a curve&quot;,&quot;k:R&quot;);
	gr-&gt;Text(y,&quot;Another string drawn under a curve&quot;,&quot;Tr:R&quot;);
}
</pre><div align="center"><img src="png/text2.png" alt="Sample text2">
</div>
<hr>
<a name="textmark-sample"></a>
<div class="header">
<p>
Next: <a href="#ticks-sample" accesskey="n" rel="next">ticks sample</a>, Previous: <a href="#text2-sample" accesskey="p" rel="prev">text2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-textmark"></a>
<h3 class="section">10.126 Sample &lsquo;<samp>textmark</samp>&rsquo;</h3>


<p>Function <a href="#textmark">textmark</a> is similar to <a href="#mark">mark</a> but draw text instead of markers.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 1 1 0 '':title 'TextMark plot (default)':box:textmark y y1 '\gamma' 'r'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_textmark(mglGraph *gr)
{
	mglData y,y1;	mgls_prepare1d(&amp;y,&amp;y1);
	if(big!=3)	{	gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;TextMark plot (default)&quot;);	}
	gr-&gt;Box();	gr-&gt;TextMark(y,y1,&quot;\\gamma&quot;,&quot;r&quot;);
}
</pre><div align="center"><img src="png/textmark.png" alt="Sample textmark">
</div>
<hr>
<a name="ticks-sample"></a>
<div class="header">
<p>
Next: <a href="#tile-sample" accesskey="n" rel="next">tile sample</a>, Previous: <a href="#textmark-sample" accesskey="p" rel="prev">textmark sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-ticks"></a>
<h3 class="section">10.127 Sample &lsquo;<samp>ticks</samp>&rsquo;</h3>


<p>Example of <a href="#axis">axis</a> ticks.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">subplot 3 3 0:title 'Usual axis with &quot;:&quot; style'
axis ':'

subplot 3 3 1:title 'Too big/small range'
ranges -1000 1000 0 0.001:axis

subplot 3 3 2:title 'LaTeX-like labels'
axis 'F!'

subplot 3 3 3:title 'Too narrow range'
ranges 100 100.1 10 10.01:axis

subplot 3 3 4:title 'No tuning, manual &quot;+&quot;'
axis '+!'
# for version &lt;2.3 you can use
#tuneticks off:axis

subplot 3 3 5:title 'Template for ticks'
xtick 'xxx:%g':ytick 'y:%g'
axis

xtick '':ytick '' # switch it off for other plots

subplot 3 3 6:title 'No tuning, higher precision'
axis '!4'

subplot 3 3 7:title 'Manual ticks'
ranges -pi pi 0 2
xtick pi 3 '\pi'
xtick 0.886 'x^*' on # note this will disable subticks drawing
# or you can use
#xtick -pi '\pi' -pi/2 '-\pi/2' 0 '0' 0.886 'x^*' pi/2 '\pi/2' pi 'pi'
list v 0 0.5 1 2:ytick v '0
0.5
1
2'
axis:grid:fplot '2*cos(x^2)^2' 'r2'

subplot 3 3 8:title 'Time ticks'
xrange 0 3e5:ticktime 'x':axis
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_ticks(mglGraph *gr)
{
	gr-&gt;SubPlot(3,3,0);	gr-&gt;Title(&quot;Usual axis with ':' style&quot;);	gr-&gt;Axis(&quot;:&quot;);
	gr-&gt;SubPlot(3,3,1);	gr-&gt;Title(&quot;Too big/small range&quot;);
	gr-&gt;SetRanges(-1000,1000,0,0.001);	gr-&gt;Axis();
	gr-&gt;SubPlot(3,3,2);	gr-&gt;Title(&quot;LaTeX-like labels&quot;);
	gr-&gt;Axis(&quot;F!&quot;);
	gr-&gt;SubPlot(3,3,3);	gr-&gt;Title(&quot;Too narrow range&quot;);
	gr-&gt;SetRanges(100,100.1,10,10.01);	gr-&gt;Axis();
	gr-&gt;SubPlot(3,3,4);	gr-&gt;Title(&quot;No tuning, manual '+'&quot;);
	// for version&lt;2.3 you need first call gr-&gt;SetTuneTicks(0);
	gr-&gt;Axis(&quot;+!&quot;);
	gr-&gt;SubPlot(3,3,5);	gr-&gt;Title(&quot;Template for ticks&quot;);
	gr-&gt;SetTickTempl('x',&quot;xxx:%g&quot;);	gr-&gt;SetTickTempl('y',&quot;y:%g&quot;);
	gr-&gt;Axis();
	// now switch it off for other plots
	gr-&gt;SetTickTempl('x',&quot;&quot;);	gr-&gt;SetTickTempl('y',&quot;&quot;);
	gr-&gt;SubPlot(3,3,6);	gr-&gt;Title(&quot;No tuning, higher precision&quot;);
	gr-&gt;Axis(&quot;!4&quot;);
	gr-&gt;SubPlot(3,3,7);	gr-&gt;Title(&quot;Manual ticks&quot;);	gr-&gt;SetRanges(-M_PI,M_PI, 0, 2);
	gr-&gt;SetTicks('x',M_PI,0,0,&quot;\\pi&quot;);	gr-&gt;AddTick('x',0.886,&quot;x^*&quot;);
	// alternatively you can use following lines
	double val[]={0, 0.5, 1, 2};
	gr-&gt;SetTicksVal('y', mglData(4,val), &quot;0\n0.5\n1\n2&quot;);
	gr-&gt;Axis();	gr-&gt;Grid();	gr-&gt;FPlot(&quot;2*cos(x^2)^2&quot;, &quot;r2&quot;);
	gr-&gt;SubPlot(3,3,8);	gr-&gt;Title(&quot;Time ticks&quot;);	gr-&gt;SetRange('x',0,3e5);
	gr-&gt;SetTicksTime('x',0);	gr-&gt;Axis();
}
</pre><div align="center"><img src="png/ticks.png" alt="Sample ticks">
</div>
<hr>
<a name="tile-sample"></a>
<div class="header">
<p>
Next: <a href="#tiles-sample" accesskey="n" rel="next">tiles sample</a>, Previous: <a href="#ticks-sample" accesskey="p" rel="prev">ticks sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-tile"></a>
<h3 class="section">10.128 Sample &lsquo;<samp>tile</samp>&rsquo;</h3>


<p>Function <a href="#tile">tile</a> draw surface by tiles.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
title 'Tile plot':rotate 50 60:box:tile a
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_tile(mglGraph *gr)
{
	mglData a;	mgls_prepare2d(&amp;a);
	if(big!=3)	gr-&gt;Title(&quot;Tile plot&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Tile(a);
}
</pre><div align="center"><img src="png/tile.png" alt="Sample tile">
</div>
<hr>
<a name="tiles-sample"></a>
<div class="header">
<p>
Next: <a href="#torus-sample" accesskey="n" rel="next">torus sample</a>, Previous: <a href="#tile-sample" accesskey="p" rel="prev">tile sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-tiles"></a>
<h3 class="section">10.129 Sample &lsquo;<samp>tiles</samp>&rsquo;</h3>


<p>Function <a href="#tiles">tiles</a> is similar to <a href="#tile">tile</a> but tile sizes is determined by another data. This allows one to simulate transparency of the plot.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
subplot 1 1 0 '':title 'Tiles plot':box:tiles a b
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_tiles(mglGraph *gr)
{
	mglData a,b;	mgls_prepare2d(&amp;a,&amp;b);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;TileS plot&quot;);}
	gr-&gt;Box();	gr-&gt;TileS(a,b);
}
</pre><div align="center"><img src="png/tiles.png" alt="Sample tiles">
</div>
<hr>
<a name="torus-sample"></a>
<div class="header">
<p>
Next: <a href="#traj-sample" accesskey="n" rel="next">traj sample</a>, Previous: <a href="#tiles-sample" accesskey="p" rel="prev">tiles sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-torus"></a>
<h3 class="section">10.130 Sample &lsquo;<samp>torus</samp>&rsquo;</h3>


<p>Function <a href="#torus">torus</a> draw surface of the curve rotation.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 2 2 0:title 'Torus plot (default)':light on:rotate 50 60:box:torus y1 y2
subplot 2 2 1:title '&quot;x&quot; style':light on:rotate 50 60:box:torus y1 y2 'x'
subplot 2 2 2:title '&quot;z&quot; style':light on:rotate 50 60:box:torus y1 y2 'z'
subplot 2 2 3:title '&quot;\#&quot; style':light on:rotate 50 60:box:torus y1 y2 '#'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_torus(mglGraph *gr)
{
	mglData y1,y2;	mgls_prepare1d(0,&amp;y1,&amp;y2);
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;Torus plot (default)&quot;);	}
	gr-&gt;Light(true);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Torus(y1,y2);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;'x' style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Torus(y1,y2,&quot;x&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;'z' style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Torus(y1,y2,&quot;z&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;'\\#' style&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Torus(y1,y2,&quot;#&quot;);
}
</pre><div align="center"><img src="png/torus.png" alt="Sample torus">
</div>
<hr>
<a name="traj-sample"></a>
<div class="header">
<p>
Next: <a href="#triangulation-sample" accesskey="n" rel="next">triangulation sample</a>, Previous: <a href="#torus-sample" accesskey="p" rel="prev">torus sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-traj"></a>
<h3 class="section">10.131 Sample &lsquo;<samp>traj</samp>&rsquo;</h3>


<p>Function <a href="#traj">traj</a> is 1D analogue of <a href="#vect">vect</a>. It draw vectors from specified points.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
subplot 1 1 0 '':title 'Traj plot':box:plot x1 y:traj x1 y y1 y2
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_traj(mglGraph *gr)
{
	mglData x,y,y1,y2;	mgls_prepare1d(&amp;y,&amp;y1,&amp;y2,&amp;x);
	if(big!=3)	{gr-&gt;SubPlot(1,1,0,&quot;&quot;);	gr-&gt;Title(&quot;Traj plot&quot;);}
	gr-&gt;Box();	gr-&gt;Plot(x,y);	gr-&gt;Traj(x,y,y1,y2);
}
</pre><div align="center"><img src="png/traj.png" alt="Sample traj">
</div>
<hr>
<a name="triangulation-sample"></a>
<div class="header">
<p>
Next: <a href="#triplot-sample" accesskey="n" rel="next">triplot sample</a>, Previous: <a href="#traj-sample" accesskey="p" rel="prev">traj sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-triangulation"></a>
<h3 class="section">10.132 Sample &lsquo;<samp>triangulation</samp>&rsquo;</h3>


<p>Example of use <a href="#triangulate">triangulate</a> for arbitrary placed points.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">new x 100 '2*rnd-1':new y 100 '2*rnd-1':copy z x^2-y^2
new g 30 30:triangulate d x y
title 'Triangulation'
rotate 50 60:box:light on
triplot d x y z:triplot d x y z '#k'
datagrid g x y z:mesh g 'm'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_triangulation(mglGraph *gr)	// surface triangulation
{
	mglData x(100), y(100), z(100);
	gr-&gt;Fill(x,&quot;2*rnd-1&quot;);	gr-&gt;Fill(y,&quot;2*rnd-1&quot;);	gr-&gt;Fill(z,&quot;v^2-w^2&quot;,x,y);
	mglData d = mglTriangulation(x,y), g(30,30);

	if(big!=3)	gr-&gt;Title(&quot;Triangulation&quot;);
	gr-&gt;Rotate(40,60);	gr-&gt;Box();	gr-&gt;Light(true);
	gr-&gt;TriPlot(d,x,y,z);	gr-&gt;TriPlot(d,x,y,z,&quot;#k&quot;);

	gr-&gt;DataGrid(g,x,y,z);	gr-&gt;Mesh(g,&quot;m&quot;);
}
</pre><div align="center"><img src="png/triangulation.png" alt="Sample triangulation">
</div>
<hr>
<a name="triplot-sample"></a>
<div class="header">
<p>
Next: <a href="#tube-sample" accesskey="n" rel="next">tube sample</a>, Previous: <a href="#triangulation-sample" accesskey="p" rel="prev">triangulation sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-triplot"></a>
<h3 class="section">10.133 Sample &lsquo;<samp>triplot</samp>&rsquo;</h3>


<p>Functions <a href="#triplot">triplot</a> and <a href="#quadplot">quadplot</a> draw set of triangles (or quadrangles, correspondingly) for irregular data arrays. Note, that you have to provide not only vertexes, but also the indexes of triangles or quadrangles. I.e. perform triangulation by some other library. See also <a href="#triangulate">triangulate</a>.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">list q 0 1 2 3 | 4 5 6 7 | 0 2 4 6 | 1 3 5 7 | 0 4 1 5 | 2 6 3 7
list xq -1 1 -1 1 -1 1 -1 1
list yq -1 -1 1 1 -1 -1 1 1
list zq -1 -1 -1 -1 1 1 1 1
light on
subplot 2 2 0:title 'QuadPlot sample':rotate 50 60
quadplot q xq yq zq 'yr'
quadplot q xq yq zq '#k'
subplot 2 2 2:title 'QuadPlot coloring':rotate 50 60
quadplot q xq yq zq yq 'yr'
quadplot q xq yq zq '#k'
list t 0 1 2 | 0 1 3 | 0 2 3 | 1 2 3
list xt -1 1 0 0
list yt -1 -1 1 0
list zt -1 -1 -1 1
subplot 2 2 1:title 'TriPlot sample':rotate 50 60
triplot t xt yt zt 'b'
triplot t xt yt zt '#k'
subplot 2 2 3:title 'TriPlot coloring':rotate 50 60
triplot t xt yt zt yt 'cb'
triplot t xt yt zt '#k'
tricont t xt yt zt 'B'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_triplot(mglGraph *gr)
{
	double q[] = {0,1,2,3, 4,5,6,7, 0,2,4,6, 1,3,5,7, 0,4,1,5, 2,6,3,7};
	double xc[] = {-1,1,-1,1,-1,1,-1,1}, yc[] = {-1,-1,1,1,-1,-1,1,1}, zc[] = {-1,-1,-1,-1,1,1,1,1};
	mglData qq(6,4,q), xx(8,xc), yy(8,yc), zz(8,zc);
	gr-&gt;Light(true);	//gr-&gt;Alpha(true);
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Title(&quot;QuadPlot sample&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;QuadPlot(qq,xx,yy,zz,&quot;yr&quot;);
	gr-&gt;QuadPlot(qq,xx,yy,zz,&quot;k#&quot;);
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Title(&quot;QuadPlot coloring&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;QuadPlot(qq,xx,yy,zz,yy,&quot;yr&quot;);
	gr-&gt;QuadPlot(qq,xx,yy,zz,&quot;k#&quot;);

	double t[] = {0,1,2, 0,1,3, 0,2,3, 1,2,3};
	double xt[] = {-1,1,0,0}, yt[] = {-1,-1,1,0}, zt[] = {-1,-1,-1,1};
	mglData tt(4,3,t), uu(4,xt), vv(4,yt), ww(4,zt);
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Title(&quot;TriPlot sample&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;TriPlot(tt,uu,vv,ww,&quot;b&quot;);
	gr-&gt;TriPlot(tt,uu,vv,ww,&quot;k#&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;TriPlot coloring&quot;);	gr-&gt;Rotate(50,60);
	gr-&gt;TriPlot(tt,uu,vv,ww,vv,&quot;cb&quot;);
	gr-&gt;TriPlot(tt,uu,vv,ww,&quot;k#&quot;);
	gr-&gt;TriCont(tt,uu,vv,ww,&quot;B&quot;);
}
</pre><div align="center"><img src="png/triplot.png" alt="Sample triplot">
</div>
<hr>
<a name="tube-sample"></a>
<div class="header">
<p>
Next: <a href="#type0-sample" accesskey="n" rel="next">type0 sample</a>, Previous: <a href="#triplot-sample" accesskey="p" rel="prev">triplot sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-tube"></a>
<h3 class="section">10.134 Sample &lsquo;<samp>tube</samp>&rsquo;</h3>


<p>Function <a href="#tube">tube</a> draw tube with variable radius.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare1d'
light on
new yc 50 'sin(pi*x)':new xc 50 'cos(pi*x)':new z 50 'x':divto y1 20
subplot 2 2 0 '':title 'Tube plot (default)':box:tube y 0.05
subplot 2 2 1 '':title 'variable radius':box:tube y y1
subplot 2 2 2 '':title '&quot;\#&quot; style':box:tube y 0.05 '#'
subplot 2 2 3:title '3d variant':rotate 50 60:box:tube xc yc z y2 'r'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_tube(mglGraph *gr)
{
	mglData y,y1,y2;	mgls_prepare1d(&amp;y,&amp;y1,&amp;y2);	y1/=20;
	if(big!=3)	{	gr-&gt;SubPlot(2,2,0,&quot;&quot;);	gr-&gt;Title(&quot;Tube plot (default)&quot;);	}
	gr-&gt;Light(true);	gr-&gt;Box();	gr-&gt;Tube(y,0.05);
	if(big==3)	return;
	gr-&gt;SubPlot(2,2,1,&quot;&quot;);	gr-&gt;Title(&quot;variable radius&quot;);	gr-&gt;Box();	gr-&gt;Tube(y,y1);
	gr-&gt;SubPlot(2,2,2,&quot;&quot;);	gr-&gt;Title(&quot;'\\#' style&quot;);	gr-&gt;Box();	gr-&gt;Tube(y,0.05,&quot;#&quot;);
	mglData yc(50), xc(50), z(50);	z.Modify(&quot;2*x-1&quot;);
	yc.Modify(&quot;sin(pi*(2*x-1))&quot;);	xc.Modify(&quot;cos(pi*2*x-pi)&quot;);
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Title(&quot;3d variant&quot;);	gr-&gt;Rotate(50,60);	gr-&gt;Box();	gr-&gt;Tube(xc,yc,z,y2,&quot;r&quot;);
}
</pre><div align="center"><img src="png/tube.png" alt="Sample tube">
</div>
<hr>
<a name="type0-sample"></a>
<div class="header">
<p>
Next: <a href="#type1-sample" accesskey="n" rel="next">type1 sample</a>, Previous: <a href="#tube-sample" accesskey="p" rel="prev">tube sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-type0"></a>
<h3 class="section">10.135 Sample &lsquo;<samp>type0</samp>&rsquo;</h3>


<p>Example of ordinary transparency (<a href="#transptype">transptype</a>=0).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
alpha on:light on:transptype 0:clf
subplot 2 2 0:rotate 50 60:surf a:box
subplot 2 2 1:rotate 50 60:dens a:box
subplot 2 2 2:rotate 50 60:cont a:box
subplot 2 2 3:rotate 50 60:axial a:box
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_type0(mglGraph *gr)	// TranspType = 0
{
	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;SetTranspType(0);	gr-&gt;Clf();
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Rotate(50,60);	gr-&gt;Surf(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Rotate(50,60);	gr-&gt;Dens(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(50,60);	gr-&gt;Cont(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(50,60);	gr-&gt;Axial(a);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/type0.png" alt="Sample type0">
</div>
<hr>
<a name="type1-sample"></a>
<div class="header">
<p>
Next: <a href="#type2-sample" accesskey="n" rel="next">type2 sample</a>, Previous: <a href="#type0-sample" accesskey="p" rel="prev">type0 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-type1"></a>
<h3 class="section">10.136 Sample &lsquo;<samp>type1</samp>&rsquo;</h3>


<p>Example of glass-like transparency (<a href="#transptype">transptype</a>=1).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
alpha on:light on:transptype 1:clf
subplot 2 2 0:rotate 50 60:surf a:box
subplot 2 2 1:rotate 50 60:dens a:box
subplot 2 2 2:rotate 50 60:cont a:box
subplot 2 2 3:rotate 50 60:axial a:box
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_type1(mglGraph *gr)	// TranspType = 1
{
	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;SetTranspType(1);	gr-&gt;Clf();
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Rotate(50,60);	gr-&gt;Surf(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Rotate(50,60);	gr-&gt;Dens(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(50,60);	gr-&gt;Cont(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(50,60);	gr-&gt;Axial(a);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/type1.png" alt="Sample type1">
</div>
<hr>
<a name="type2-sample"></a>
<div class="header">
<p>
Next: <a href="#vect-sample" accesskey="n" rel="next">vect sample</a>, Previous: <a href="#type1-sample" accesskey="p" rel="prev">type1 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-type2"></a>
<h3 class="section">10.137 Sample &lsquo;<samp>type2</samp>&rsquo;</h3>


<p>Example of lamp-like transparency (<a href="#transptype">transptype</a>=2).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2d'
alpha on:light on:transptype 2:clf
subplot 2 2 0:rotate 50 60:surf a:box
subplot 2 2 1:rotate 50 60:dens a:box
subplot 2 2 2:rotate 50 60:cont a:box
subplot 2 2 3:rotate 50 60:axial a:box
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_type2(mglGraph *gr)	// TranspType = 2
{
	gr-&gt;Alpha(true);	gr-&gt;Light(true);
	mglData a;	mgls_prepare2d(&amp;a);
	gr-&gt;SetTranspType(2);	gr-&gt;Clf();
	gr-&gt;SubPlot(2,2,0);	gr-&gt;Rotate(50,60);	gr-&gt;Surf(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,1);	gr-&gt;Rotate(50,60);	gr-&gt;Dens(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,2);	gr-&gt;Rotate(50,60);	gr-&gt;Cont(a);	gr-&gt;Box();
	gr-&gt;SubPlot(2,2,3);	gr-&gt;Rotate(50,60);	gr-&gt;Axial(a);	gr-&gt;Box();
}
</pre><div align="center"><img src="png/type2.png" alt="Sample type2">
</div>
<hr>
<a name="vect-sample"></a>
<div class="header">
<p>
Next: <a href="#vect3-sample" accesskey="n" rel="next">vect3 sample</a>, Previous: <a href="#type2-sample" accesskey="p" rel="prev">type2 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-vect"></a>
<h3 class="section">10.138 Sample &lsquo;<samp>vect</samp>&rsquo;</h3>


<p>Function <a href="#vect">vect</a> is most standard way to visualize vector fields &ndash; it draw a lot of arrows or hachures for each data cell. It have a lot of options which can be seen on the figure (and in the sample code), and use color scheme for coloring (see <a href="#Color-scheme">Color scheme</a>).
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare2v'
call 'prepare3v'
subplot 3 2 0 '':title 'Vect plot (default)':box:vect a b
subplot 3 2 1 '':title '&quot;.&quot; style; &quot;=&quot; style':box:vect a b '.='
subplot 3 2 2 '':title '&quot;f&quot; style':box:vect a b 'f'
subplot 3 2 3 '':title '&quot;&gt;&quot; style':box:vect a b '&gt;'
subplot 3 2 4 '':title '&quot;&lt;&quot; style':box:vect a b '&lt;'
subplot 3 2 5:title '3d variant':rotate 50 60:box:vect ex ey ez
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_vect3(mglGraph *gr)
{
	mglData ex,ey,ez;	mgls_prepare3v(&amp;ex,&amp;ey,&amp;ez);
	if(big!=3)	{	gr-&gt;SubPlot(2,1,0);	gr-&gt;Title(&quot;Vect3 sample&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Vect3(ex,ey,ez,&quot;x&quot;);	gr-&gt;Vect3(ex,ey,ez);	gr-&gt;Vect3(ex,ey,ez,&quot;z&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,1,1);	gr-&gt;Title(&quot;'f' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Vect3(ex,ey,ez,&quot;fx&quot;);	gr-&gt;Vect3(ex,ey,ez,&quot;f&quot;);	gr-&gt;Vect3(ex,ey,ez,&quot;fz&quot;);
	gr-&gt;Grid3(ex,&quot;Wx&quot;);	gr-&gt;Grid3(ex,&quot;W&quot;);	gr-&gt;Grid3(ex,&quot;Wz&quot;);
}
</pre><div align="center"><img src="png/vect.png" alt="Sample vect">
</div>
<hr>
<a name="vect3-sample"></a>
<div class="header">
<p>
Next: <a href="#venn-sample" accesskey="n" rel="next">venn sample</a>, Previous: <a href="#vect-sample" accesskey="p" rel="prev">vect sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-vect3"></a>
<h3 class="section">10.139 Sample &lsquo;<samp>vect3</samp>&rsquo;</h3>


<p>Function <a href="#vect3">vect3</a> draw ordinary vector field plot but at slices of 3D data.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">call 'prepare3v'
subplot 2 1 0:title 'Vect3 sample':rotate 50 60
origin 0 0 0:box:axis '_xyz'
vect3 ex ey ez 'x':vect3 ex ey ez:vect3 ex ey ez 'z'
subplot 2 1 1:title '&quot;f&quot; style':rotate 50 60
origin 0 0 0:box:axis '_xyz'
vect3 ex ey ez 'fx':vect3 ex ey ez 'f':vect3 ex ey ez 'fz'
grid3 ex 'Wx':grid3 ex 'W':grid3 ex 'Wz'
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_vect3(mglGraph *gr)
{
	mglData ex,ey,ez;	mgls_prepare3v(&amp;ex,&amp;ey,&amp;ez);
	if(big!=3)	{	gr-&gt;SubPlot(2,1,0);	gr-&gt;Title(&quot;Vect3 sample&quot;);	}
	gr-&gt;Rotate(50,60);	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Vect3(ex,ey,ez,&quot;x&quot;);	gr-&gt;Vect3(ex,ey,ez);	gr-&gt;Vect3(ex,ey,ez,&quot;z&quot;);
	if(big==3)	return;
	gr-&gt;SubPlot(2,1,1);	gr-&gt;Title(&quot;'f' style&quot;);
	gr-&gt;Rotate(50,60);	gr-&gt;SetOrigin(0,0,0);	gr-&gt;Axis(&quot;_xyz&quot;);	gr-&gt;Box();
	gr-&gt;Vect3(ex,ey,ez,&quot;fx&quot;);	gr-&gt;Vect3(ex,ey,ez,&quot;f&quot;);	gr-&gt;Vect3(ex,ey,ez,&quot;fz&quot;);
	gr-&gt;Grid3(ex,&quot;Wx&quot;);	gr-&gt;Grid3(ex,&quot;W&quot;);	gr-&gt;Grid3(ex,&quot;Wz&quot;);
}
</pre><div align="center"><img src="png/vect3.png" alt="Sample vect3">
</div>
<hr>
<a name="venn-sample"></a>
<div class="header">
<p>
Previous: <a href="#vect3-sample" accesskey="p" rel="prev">vect3 sample</a>, Up: <a href="#All-samples" accesskey="u" rel="up">All samples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sample-_0027venn_0027"></a>
<h3 class="section">10.140 Sample &rsquo;venn&rsquo;</h3>


<p>Example of venn-like diagram.
</p>
<p><strong>MGL code:</strong>
</p><pre class="verbatim">list x -0.3 0 0.3:list y 0.3 -0.3 0.3:list e 0.7 0.7 0.7
subplot 1 1 0:title 'Venn-like diagram'
transptype 1:alpha on:error x y e e '!rgb@#o';alpha 0.1
</pre>
<p><strong>C++ code:</strong>
</p><pre class="verbatim">void smgl_venn(mglGraph *gr)
{
	double xx[3]={-0.3,0,0.3}, yy[3]={0.3,-0.3,0.3}, ee[3]={0.7,0.7,0.7};
	mglData x(3,xx), y(3,yy), e(3,ee);
	gr-&gt;SubPlot(1,1,0);	gr-&gt;Title(&quot;Venn-like diagram&quot;);
	gr-&gt;SetTranspType(1);	gr-&gt;Alpha(true);	gr-&gt;Error(x,y,e,e,&quot;!rgb@#o&quot;,&quot;alpha 0.1&quot;);
}
</pre><div align="center"><img src="png/venn.png" alt="Sample venn">
</div>

<hr>
<a name="Symbols-and-hot_002dkeys"></a>
<div class="header">
<p>
Next: <a href="#File-formats" accesskey="n" rel="next">File formats</a>, Previous: <a href="#All-samples" accesskey="p" rel="prev">All samples</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Symbols-and-hot_002dkeys-1"></a>
<h2 class="appendix">Appendix A Symbols and hot-keys</h2>


<p>This appendix contain the full list of symbols (characters) used by MathGL for setting up plot. Also it contain sections for full list of hot-keys supported by mglview tool and by UDAV program.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Symbols-for-styles" accesskey="1">Symbols for styles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hot_002dkeys-for-mglview" accesskey="2">Hot-keys for mglview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hot_002dkeys-for-UDAV" accesskey="3">Hot-keys for UDAV</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Symbols-for-styles"></a>
<div class="header">
<p>
Next: <a href="#Hot_002dkeys-for-mglview" accesskey="n" rel="next">Hot-keys for mglview</a>, Up: <a href="#Symbols-and-hot_002dkeys" accesskey="u" rel="up">Symbols and hot-keys</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Symbols-for-styles-1"></a>
<h3 class="section">A.1 Symbols for styles</h3>


<p>Below is full list of all characters (symbols) which MathGL use for setting up the plot.
</p>
<dl compact="compact">
<dt>&lsquo;<samp>space ' '</samp>&rsquo;</dt>
<dd><p>empty line style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>empty color in <a href="#chart">chart</a>.
</p>
</dd>
<dt>&lsquo;<samp>!</samp>&rsquo;</dt>
<dd><p>set to use new color from palette for each point (not for each curve, as default) in <a href="#g_t1D-plotting">1D plotting</a>;
</p>
<p>set to disable ticks tuning in <a href="#axis">axis</a> and <a href="#colorbar">colorbar</a>;
</p>
<p>set to draw <a href="#grid">grid</a> lines at subticks coordinates too;
</p>
<p>define complex variable/expression in MGL script if placed at beginning.
</p>
</dd>
<dt>&lsquo;<samp>#</samp>&rsquo;</dt>
<dd><p>set to use solid marks (see <a href="#Line-styles">Line styles</a>) or solid <a href="#error">error</a> boxes;
</p>
<p>set to draw wired plot for <a href="#axial">axial</a>, <a href="#surf3">surf3</a>, <a href="#surf3a">surf3a</a>, <a href="#surf3c">surf3c</a>, <a href="#triplot">triplot</a>, <a href="#quadplot">quadplot</a>, <a href="#area">area</a>, <a href="#region">region</a>, <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#tube">tube</a>, <a href="#tape">tape</a>, <a href="#cone">cone</a>, <a href="#boxs">boxs</a> and draw boundary only for <a href="#circle">circle</a>, <a href="#ellipse">ellipse</a>, <a href="#rhomb">rhomb</a>;
</p>
<p>set to draw also mesh lines for <a href="#surf">surf</a>, <a href="#surfc">surfc</a>, <a href="#surfa">surfa</a>, <a href="#dens">dens</a>, <a href="#densx">densx</a>, <a href="#densy">densy</a>, <a href="#densz">densz</a>, <a href="#dens3">dens3</a>, or boundary for <a href="#chart">chart</a>, <a href="#facex">facex</a>, <a href="#facey">facey</a>, <a href="#facez">facez</a>, <a href="#rect">rect</a>;
</p>
<p>set to draw boundary and box for <a href="#legend">legend</a>, <a href="#title">title</a>, or grid lines for <a href="#table">table</a>;
</p>
<p>set to draw grid for <a href="#radar">radar</a>;
</p>
<p>set to start flow threads and pipes from edges only for <a href="#flow">flow</a>, <a href="#pipe">pipe</a>;
</p>
<p>set to use whole are for axis range in <a href="#subplot">subplot</a>, <a href="#inplot">inplot</a>;
</p>
<p>change text color inside a string (see <a href="#Font-styles">Font styles</a>);
</p>
<p>start comment in <a href="#MGL-scripts">MGL scripts</a> or in <a href="#Command-options">Command options</a>.
</p>
</dd>
<dt>&lsquo;<samp>$</samp>&rsquo;</dt>
<dd><p>denote parameter of <a href="#MGL-scripts">MGL scripts</a>.
</p>
</dd>
<dt>&lsquo;<samp>%</samp>&rsquo;</dt>
<dd><p>set color scheme along 2 coordinates <a href="#Color-scheme">Color scheme</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>&amp;</samp>&rsquo;</dt>
<dd>
<p>set to pass long integer number in tick template <a href="#xtick">xtick</a>, <a href="#ytick">ytick</a>, <a href="#ztick">ztick</a>, <a href="#ctick">ctick</a>;
</p>
<p>specifier of drawing user-defined symbols as mark (see <a href="#Line-styles">Line styles</a>);
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>&rsquo;</samp>&rsquo;</dt>
<dd><p>denote string in <a href="#MGL-scripts">MGL scripts</a> or in <a href="#Command-options">Command options</a>.
</p>
</dd>
<dt>&lsquo;<samp>*</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>set to start flow threads from 2d array inside data (see <a href="#flow">flow</a>);
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>+</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>set to print &lsquo;<samp>+</samp>&rsquo; for positive numbers in <a href="#axis">axis</a>, <a href="#label">label</a>, <a href="#table">table</a>;
</p>
<p>operation of increasing last character value in MGL strings;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>,</samp>&rsquo;</dt>
<dd><p>separator for color positions (see <a href="#Color-styles">Color styles</a>) or items in a list
</p>
<p>concatenation of MGL string with another string or numerical value.
</p>
</dd>
<dt>&lsquo;<samp>-</samp>&rsquo;</dt>
<dd><p>solid line style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>place entries horizontally in <a href="#legend">legend</a>;
</p>
<p>set to use usual &lsquo;<samp>-</samp>&rsquo; for negative numbers in <a href="#axis">axis</a>, <a href="#label">label</a>, <a href="#table">table</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>.</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>set to draw hachures instead of arrows for <a href="#vect">vect</a>, <a href="#vect3">vect3</a>;
</p>
<p>set to use dots instead of faces for <a href="#cloud">cloud</a>, <a href="#torus">torus</a>, <a href="#axial">axial</a>, <a href="#surf3">surf3</a>, <a href="#surf3a">surf3a</a>, <a href="#surf3c">surf3c</a>, <a href="#surf">surf</a>, <a href="#surfa">surfa</a>, <a href="#surfc">surfc</a>, <a href="#dens">dens</a>, <a href="#map">map</a>;
</p>
<p>delimiter of fractional parts for numbers.
</p>
</dd>
<dt>&lsquo;<samp>/</samp>&rsquo;</dt>
<dd><p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>:</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>stop color scheme parsing (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>range operation in <a href="#MGL-scripts">MGL scripts</a>;
</p>
<p>style for <a href="#axis">axis</a>;
</p>
<p>separator of commands in <a href="#MGL-scripts">MGL scripts</a>.
</p>
</dd>
<dt>&lsquo;<samp>;</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>start of an option in <a href="#MGL-scripts">MGL scripts</a> or in <a href="#Command-options">Command options</a>;
</p>
<p>separator of equations in <a href="#ode">ode</a>;
</p>
<p>separator of labels in <a href="#iris">iris</a>.
</p>
</dd>
<dt>&lsquo;<samp>&lt;</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>style of <a href="#subplot">subplot</a> and <a href="#inplot">inplot</a>;
</p>
<p>set position of <a href="#colorbar">colorbar</a>;
</p>
<p>style of <a href="#vect">vect</a>, <a href="#vect3">vect3</a>;
</p>
<p>align left in <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#boxplot">boxplot</a>, <a href="#cones">cones</a>, <a href="#candle">candle</a>, <a href="#ohlc">ohlc</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>

</dd>
<dt>&lsquo;<samp>&gt;</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>style of <a href="#subplot">subplot</a> and <a href="#inplot">inplot</a>;
</p>
<p>set position of <a href="#colorbar">colorbar</a>;
</p>
<p>style of <a href="#vect">vect</a>, <a href="#vect3">vect3</a>;
</p>
<p>align right in <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#boxplot">boxplot</a>, <a href="#cones">cones</a>, <a href="#candle">candle</a>, <a href="#ohlc">ohlc</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>=</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>set to use equidistant columns for <a href="#table">table</a>;
</p>
<p>set to use color gradient for <a href="#vect">vect</a>, <a href="#vect3">vect3</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>@</samp>&rsquo;</dt>
<dd><p>set to draw box around text for <a href="#text">text</a> and similar functions;
</p>
<p>set to draw boundary and fill it for <a href="#circle">circle</a>, <a href="#ellipse">ellipse</a>, <a href="#rhomb">rhomb</a>;
</p>
<p>set to fill faces for <a href="#box">box</a>;
</p>
<p>set to draw large semitransparent mark instead of error box for <a href="#error">error</a>;
</p>
<p>set to draw edges for <a href="#cone">cone</a>;
</p>
<p>set to draw filled boxes for <a href="#boxs">boxs</a>;
</p>
<p>reduce text size inside a string (see <a href="#Font-styles">Font styles</a>);
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>^</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>style of <a href="#subplot">subplot</a> and <a href="#inplot">inplot</a>;
</p>
<p>set position of <a href="#colorbar">colorbar</a>;
</p>
<p>set outer position for <a href="#legend">legend</a>;
</p>
<p>inverse default position for <a href="#axis">axis</a>;
</p>
<p>switch to upper index inside a string (see <a href="#Font-styles">Font styles</a>);
</p>
<p>align center in <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#boxplot">boxplot</a>, <a href="#cones">cones</a>, <a href="#candle">candle</a>, <a href="#ohlc">ohlc</a>;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>_</samp>&rsquo;</dt>
<dd><p>empty arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>disable drawing of tick labels for <a href="#axis">axis</a>;
</p>
<p>style of <a href="#subplot">subplot</a> and <a href="#inplot">inplot</a>;
</p>
<p>set position of <a href="#colorbar">colorbar</a>;
</p>
<p>set to draw contours at bottom for <a href="#cont">cont</a>, <a href="#contf">contf</a>, <a href="#contd">contd</a>, <a href="#contv">contv</a>, <a href="#tricont">tricont</a>;
</p>
<p>switch to lower index inside a string (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>[]</samp>&rsquo;</dt>
<dd><p>contain symbols excluded from color scheme parsing (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>operation of getting n-th character from MGL string.
</p>
</dd>
<dt>&lsquo;<samp>{}</samp>&rsquo;</dt>
<dd><p>contain extended specification of color (see <a href="#Color-styles">Color styles</a>), dashing (see <a href="#Line-styles">Line styles</a>) or mask (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>denote special operation in <a href="#MGL-scripts">MGL scripts</a>;
</p>
<p>denote &rsquo;meta-symbol&rsquo; for LaTeX like string parsing (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>|</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>set to use sharp color scheme (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>set to limit width by subplot width for <a href="#table">table</a>;
</p>
<p>delimiter in <a href="#list">list</a> command;
</p>
<p>operation in <a href="#Textual-formulas">Textual formulas</a>.
</p>
</dd>
<dt>&lsquo;<samp>\</samp>&rsquo;</dt>
<dd><p>string continuation symbol on next line for <a href="#MGL-scripts">MGL scripts</a>.
</p>
</dd>
<dt>&lsquo;<samp>~</samp>&rsquo;</dt>
<dd><p>disable drawing of tick labels for <a href="#axis">axis</a> and <a href="#colorbar">colorbar</a>;
</p>
<p>disable first segment in <a href="#lamerey">lamerey</a>;
</p>
<p>reduce number of segments in <a href="#plot">plot</a> and <a href="#tens">tens</a>;
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>).
</p>
</dd>
<dt>&lsquo;<samp>0,1,2,3,4,5,6,7,8,9</samp>&rsquo;</dt>
<dd><p>line width (see <a href="#Line-styles">Line styles</a>);
</p>
<p>brightness of a color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>precision of numbers in <a href="#axis">axis</a>, <a href="#label">label</a>, <a href="#table">table</a>;
</p>
<p>kind of smoothing (for digits 1,3,5) in <a href="#smooth">smooth</a>;
</p>
<p>digits for a value.
</p>
</dd>
<dt>&lsquo;<samp>4,6,8</samp>&rsquo;</dt>
<dd><p>set to draw square, hex- or octo-pyramids instead of cones in <a href="#cone">cone</a>, <a href="#cones">cones</a>.
</p>
</dd>
<dt>&lsquo;<samp>A,B,C,D,E,F,a,b,c,d,e,f</samp>&rsquo;</dt>
<dd><p>can be hex-digit for color specification if placed inside {} (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>A</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>set to use absolute position in whole picture for <a href="#text">text</a>, <a href="#colorbar">colorbar</a>, <a href="#legend">legend</a>.
</p>
</dd>
<dt>&lsquo;<samp>a</samp>&rsquo;</dt>
<dd><p>set to use absolute position in subplot for <a href="#text">text</a>;
</p>
<p>style of <a href="#plot">plot</a>, <a href="#radar">radar</a>, <a href="#tens">tens</a>, <a href="#area">area</a>, <a href="#region">region</a> to draw segments between points outside of axis range;
</p>
<p>style of <a href="#bars">bars</a>, <a href="#barh">barh</a>, <a href="#cones">cones</a>.
</p>
</dd>
<dt>&lsquo;<samp>B</samp>&rsquo;</dt>
<dd><p>dark blue color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>b</samp>&rsquo;</dt>
<dd><p>blue color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>bold font face if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>C</samp>&rsquo;</dt>
<dd><p>dark cyan color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>align text to center if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>c</samp>&rsquo;</dt>
<dd><p>cyan color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>name of color axis;
</p>
<p>cosine transform for <a href="#transform">transform</a>.
</p>
</dd>
<dt>&lsquo;<samp>D</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>).
</p>
</dd>
<dt>&lsquo;<samp>d</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>start hex-dash description if placed inside {} (see <a href="#Line-styles">Line styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>E</samp>&rsquo;</dt>
<dd><p>dark green-yellow color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>e</samp>&rsquo;</dt>
<dd><p>green-yellow color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>F</samp>&rsquo;</dt>
<dd>
<p>set fixed bar widths in <a href="#bars">bars</a>, <a href="#barh">barh</a>;
</p>
<p>set LaTeX-like format for numbers in <a href="#axis">axis</a>, <a href="#label">label</a>, <a href="#table">table</a>.
</p>
</dd>
<dt>&lsquo;<samp>f</samp>&rsquo;</dt>
<dd><p>style of <a href="#bars">bars</a>, <a href="#barh">barh</a>;
</p>
<p>style of <a href="#vect">vect</a>, <a href="#vect3">vect3</a>;
</p>
<p>set fixed format for numbers in <a href="#axis">axis</a>, <a href="#label">label</a>, <a href="#table">table</a>;
</p>
<p>Fourier transform for <a href="#transform">transform</a>.
</p>
</dd>
<dt>&lsquo;<samp>G</samp>&rsquo;</dt>
<dd><p>dark green color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>g</samp>&rsquo;</dt>
<dd><p>green color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>H</samp>&rsquo;</dt>
<dd><p>dark gray color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>h</samp>&rsquo;</dt>
<dd><p>gray color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>Hankel transform for <a href="#transform">transform</a>.
</p>
</dd>
<dt>&lsquo;<samp>I</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>set <a href="#colorbar">colorbar</a> position near boundary.
</p>
</dd>
<dt>&lsquo;<samp>i</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>italic font face if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
<p>set to use inverse values for <a href="#cloud">cloud</a>, <a href="#pipe">pipe</a>, <a href="#dew">dew</a>;
</p>
<p>set to fill only area with y1&lt;y&lt;y2 for <a href="#region">region</a>;
</p>
<p>inverse Fourier transform for <a href="#transform">transform</a>, <a href="#transforma">transforma</a>, <a href="#fourier">fourier</a>.
</p>
</dd>
<dt>&lsquo;<samp>j</samp>&rsquo;</dt>
<dd><p>line dashing style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>).
</p>
</dd>
<dt>&lsquo;<samp>K</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>k</samp>&rsquo;</dt>
<dd><p>black color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>L</samp>&rsquo;</dt>
<dd><p>dark green-blue color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>align text to left if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>l</samp>&rsquo;</dt>
<dd><p>green-blue color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>M</samp>&rsquo;</dt>
<dd><p>dark magenta color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>m</samp>&rsquo;</dt>
<dd><p>magenta color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>N</samp>&rsquo;</dt>
<dd><p>dark sky-blue color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>n</samp>&rsquo;</dt>
<dd><p>sky-blue color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>O</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>).
</p>
</dd>
<dt>&lsquo;<samp>o</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>over-line text if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>P</samp>&rsquo;</dt>
<dd><p>dark purple color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>p</samp>&rsquo;</dt>
<dd><p>purple color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>Q</samp>&rsquo;</dt>
<dd><p>dark orange or brown color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>q</samp>&rsquo;</dt>
<dd><p>orange color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>R</samp>&rsquo;</dt>
<dd><p>dark red color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>align text to right if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>r</samp>&rsquo;</dt>
<dd><p>red color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>S</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>).
</p>
</dd>
<dt>&lsquo;<samp>s</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>one of mask for face filling (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>start hex-mask description if placed inside {} (see <a href="#Color-scheme">Color scheme</a>);
</p>
<p>sine transform for <a href="#transform">transform</a>.
</p>
</dd>
<dt>&lsquo;<samp>t</samp>&rsquo;</dt>
<dd><p>draw tubes instead of cones in <a href="#cone">cone</a>, <a href="#cones">cones</a>;
</p>
</dd>
<dt>&lsquo;<samp>T</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>place text under the curve for <a href="#text">text</a>, <a href="#cont">cont</a>, <a href="#cont3">cont3</a>.
</p>
</dd>
<dt>&lsquo;<samp>t</samp>&rsquo;</dt>
<dd><p>set to draw text labels for <a href="#cont">cont</a>, <a href="#cont3">cont3</a>;
</p>
<p>name of t-axis (one of ternary axis);
</p>
<p>variable in <a href="#Textual-formulas">Textual formulas</a>, which usually is varied in range [0,1].
</p>
</dd>
<dt>&lsquo;<samp>U</samp>&rsquo;</dt>
<dd><p>dark blue-violet color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>disable rotation of tick labels for <a href="#axis">axis</a>.
</p>
</dd>
<dt>&lsquo;<samp>u</samp>&rsquo;</dt>
<dd><p>blue-violet color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>under-line text if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>);
</p>
<p>name of u-axis (one of ternary axis);
</p>
<p>variable in <a href="#Textual-formulas">Textual formulas</a>, which usually denote array itself.
</p>
</dd>
<dt>&lsquo;<samp>V</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>);
</p>
<p>place text centering on vertical direction for <a href="#text">text</a>.
</p>
</dd>
<dt>&lsquo;<samp>v</samp>&rsquo;</dt>
<dd><p>one of marks (see <a href="#Line-styles">Line styles</a>);
</p>
<p>set to draw vectors on flow threads for <a href="#flow">flow</a> and on segments for <a href="#lamerey">lamerey</a>.
</p>
</dd>
<dt>&lsquo;<samp>W</samp>&rsquo;</dt>
<dd><p>bright gray color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>w</samp>&rsquo;</dt>
<dd><p>white color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>wired text if placed after &lsquo;<samp>:</samp>&rsquo; (see <a href="#Font-styles">Font styles</a>);
</p>
<p>name of w-axis (one of ternary axis);
</p>
</dd>
<dt>&lsquo;<samp>X</samp>&rsquo;</dt>
<dd><p>arrow style (see <a href="#Line-styles">Line styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>x</samp>&rsquo;</dt>
<dd>
<p>name of x-axis or x-direction or 1st dimension of a data array;
</p>
<p>start hex-color description if placed inside {} (see <a href="#Color-styles">Color styles</a>);
</p>
<p>one of marks (see <a href="#Line-styles">Line styles</a>) or kind of <a href="#error">error</a> boxes;
</p>
<p>tiles orientation perpendicular to x-axis in <a href="#tile">tile</a>, <a href="#tiles">tiles</a>;
</p>
<p>style of <a href="#tape">tape</a>.
</p>
</dd>
<dt>&lsquo;<samp>Y</samp>&rsquo;</dt>
<dd><p>dark yellow or gold color (see <a href="#Color-styles">Color styles</a>).
</p>
</dd>
<dt>&lsquo;<samp>y</samp>&rsquo;</dt>
<dd><p>yellow color (see <a href="#Color-styles">Color styles</a>);
</p>
<p>name of y-axis or y-direction or 2nd dimension of a data array;
</p>
<p>tiles orientation perpendicular to y-axis in <a href="#tile">tile</a>, <a href="#tiles">tiles</a>.
</p>
</dd>
<dt>&lsquo;<samp>z</samp>&rsquo;</dt>
<dd>
<p>name of z-axis or z-direction or 3d dimension of a data array;
</p>
<p>style of <a href="#tape">tape</a>.
</p>
</dd>
</dl>



<hr>
<a name="Hot_002dkeys-for-mglview"></a>
<div class="header">
<p>
Next: <a href="#Hot_002dkeys-for-UDAV" accesskey="n" rel="next">Hot-keys for UDAV</a>, Previous: <a href="#Symbols-for-styles" accesskey="p" rel="prev">Symbols for styles</a>, Up: <a href="#Symbols-and-hot_002dkeys" accesskey="u" rel="up">Symbols and hot-keys</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Hot_002dkeys-for-mglview-1"></a>
<h3 class="section">A.2 Hot-keys for mglview</h3>


<table>
<thead><tr><th width="30%">Key</th><th width="70%">Description</th></tr></thead>
<tr><td width="30%"><tt class="key">Ctrl-P</tt></td><td width="70%">Open printer dialog and print graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-W</tt></td><td width="70%">Close window.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-T</tt></td><td width="70%">Switch on/off transparency for the graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-L</tt></td><td width="70%">Switch on/off additional lightning for the graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Space</tt></td><td width="70%">Restore default graphics rotation, zoom and perspective.</td></tr>
<tr><td width="30%"><tt class="key">F5</tt></td><td width="70%">Execute script and redraw graphics.</td></tr>
<tr><td width="30%"><tt class="key">F6</tt></td><td width="70%">Change canvas size to fill whole region.</td></tr>
<tr><td width="30%"><tt class="key">F7</tt></td><td width="70%">Stop drawing and script execution.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-F5</tt></td><td width="70%">Run slideshow. If no parameter specified then the dialog with slideshow options will appear.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Comma</tt>, <tt class="key">Ctrl-Period</tt></td><td width="70%">Show next/previous slide. If no parameter specified then the dialog with slideshow options will appear.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-G</tt></td><td width="70%">Copy graphics to clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Alt-P</tt></td><td width="70%">Export as semitransparent PNG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-F</tt></td><td width="70%">Export as solid PNG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-J</tt></td><td width="70%">Export as JPEG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-E</tt></td><td width="70%">Export as vector EPS.</td></tr>
<tr><td width="30%"><tt class="key">Alt-S</tt></td><td width="70%">Export as vector SVG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-L</tt></td><td width="70%">Export as LaTeX/Tikz image.</td></tr>
<tr><td width="30%"><tt class="key">Alt-M</tt></td><td width="70%">Export as MGLD.</td></tr>
<tr><td width="30%"><tt class="key">Alt-D</tt></td><td width="70%">Export as PRC/PDF.</td></tr>
<tr><td width="30%"><tt class="key">Alt-O</tt></td><td width="70%">Export as OBJ.</td></tr>
</table>


<hr>
<a name="Hot_002dkeys-for-UDAV"></a>
<div class="header">
<p>
Previous: <a href="#Hot_002dkeys-for-mglview" accesskey="p" rel="prev">Hot-keys for mglview</a>, Up: <a href="#Symbols-and-hot_002dkeys" accesskey="u" rel="up">Symbols and hot-keys</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Hot_002dkeys-for-UDAV-1"></a>
<h3 class="section">A.3 Hot-keys for UDAV</h3>


<table>
<thead><tr><th width="30%">Key</th><th width="70%">Description</th></tr></thead>
<tr><td width="30%"><tt class="key">Ctrl-N</tt></td><td width="70%">Create new window with empty script. Note, all scripts share variables. So, second window can be used to see some additional information of existed variables.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-O</tt></td><td width="70%">Open and execute/show script or data from file. You may switch off automatic exection in UDAV properties</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-S</tt></td><td width="70%">Save script to a file.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-P</tt></td><td width="70%">Open printer dialog and print graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Z</tt></td><td width="70%">Undo changes in script editor.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-Z</tt></td><td width="70%">Redo changes in script editor.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-X</tt></td><td width="70%">Cut selected text into clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-C</tt></td><td width="70%">Copy selected text into clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-V</tt></td><td width="70%">Paste selected text from clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-A</tt></td><td width="70%">Select all text in editor.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-F</tt></td><td width="70%">Show dialog for text finding.</td></tr>
<tr><td width="30%"><tt class="key">F3</tt></td><td width="70%">Find next occurrence of the text.</td></tr>
<tr><td width="30%"><tt class="key">Win-C</tt> or <tt class="key">Meta-C</tt></td><td width="70%">Show dialog for new command and put it into the script.</td></tr>
<tr><td width="30%"><tt class="key">Win-F</tt> or <tt class="key">Meta-F</tt></td><td width="70%">Insert last fitted formula with found coefficients.</td></tr>
<tr><td width="30%"><tt class="key">Win-S</tt> or <tt class="key">Meta-S</tt></td><td width="70%">Show dialog for styles and put it into the script. Styles define the plot view (color scheme, marks, dashing and so on).</td></tr>
<tr><td width="30%"><tt class="key">Win-O</tt> or <tt class="key">Meta-O</tt></td><td width="70%">Show dialog for options and put it into the script. Options are used for additional setup the plot.</td></tr>
<tr><td width="30%"><tt class="key">Win-N</tt> or <tt class="key">Meta-N</tt></td><td width="70%">Replace selected expression by its numerical value.</td></tr>
<tr><td width="30%"><tt class="key">Win-P</tt> or <tt class="key">Meta-P</tt></td><td width="70%">Select file and insert its file name into the script.</td></tr>
<tr><td width="30%"><tt class="key">Win-G</tt> or <tt class="key">Meta-G</tt></td><td width="70%">Show dialog for plot setup and put resulting code into the script. This dialog setup axis, labels, lighting and other general things.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-O</tt></td><td width="70%">Load data from file. Data will be deleted only at exit but UDAV will not ask to save it.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-S</tt></td><td width="70%">Save data to a file.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-C</tt></td><td width="70%">Copy range of numbers to clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-V</tt></td><td width="70%">Paste range of numbers from clipboard.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-N</tt></td><td width="70%">Recreate the data with new sizes and fill it by zeros.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-R</tt></td><td width="70%">Resize (interpolate) the data to specified sizes.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-T</tt></td><td width="70%">Transform data along dimension(s).</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-M</tt></td><td width="70%">Make another data.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-H</tt></td><td width="70%">Find histogram of data.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-T</tt></td><td width="70%">Switch on/off transparency for the graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-L</tt></td><td width="70%">Switch on/off additional lightning for the graphics.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-G</tt></td><td width="70%">Switch on/off grid of absolute coordinates.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Space</tt></td><td width="70%">Restore default graphics rotation, zoom and perspective.</td></tr>
<tr><td width="30%"><tt class="key">F5</tt></td><td width="70%">Execute script and redraw graphics.</td></tr>
<tr><td width="30%"><tt class="key">F6</tt></td><td width="70%">Change canvas size to fill whole region.</td></tr>
<tr><td width="30%"><tt class="key">F7</tt></td><td width="70%">Stop script execution and drawing.</td></tr>
<tr><td width="30%"><tt class="key">F8</tt></td><td width="70%">Show/hide tool window with list of hidden plots.</td></tr>
<tr><td width="30%"><tt class="key">F9</tt></td><td width="70%">Restore status for &rsquo;once&rsquo; command and reload data.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-F5</tt></td><td width="70%">Run slideshow. If no parameter specified then the dialog with slideshow options will appear.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Comma</tt>, <tt class="key">Ctrl-Period</tt></td><td width="70%">Show next/previous slide. If no parameter specified then the dialog with slideshow options will appear.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-W</tt></td><td width="70%">Open dialog with slideshow options.</td></tr>
<tr><td width="30%"><tt class="key">Ctrl-Shift-G</tt></td><td width="70%">Copy graphics to clipboard.</td></tr>
<tr><td width="30%"><tt class="key">F1</tt></td><td width="70%">Show help on MGL commands</td></tr>
<tr><td width="30%"><tt class="key">F2</tt></td><td width="70%">Show/hide tool window with messages and information.</td></tr>
<tr><td width="30%"><tt class="key">F4</tt></td><td width="70%">Show/hide calculator which evaluate and help to type textual formulas. Textual formulas may contain data variables too.</td></tr>
<tr><td width="30%"><tt class="key">Meta-Shift-Up</tt>, <tt class="key">Meta-Shift-Down</tt></td><td width="70%">Change view angle <em>\theta</em>.</td></tr>
<tr><td width="30%"><tt class="key">Meta-Shift-Left</tt>, <tt class="key">Meta-Shift-Right</tt></td><td width="70%">Change view angle <em>\phi</em>.</td></tr>
<tr><td width="30%"><tt class="key">Alt-Minus</tt>, <tt class="key">Alt-Equal</tt></td><td width="70%">Zoom in/out whole image.</td></tr>
<tr><td width="30%"><tt class="key">Alt-Up</tt>, <tt class="key">Alt-Down</tt>, <tt class="key">Alt-Right</tt>, <tt class="key">Alt-Left</tt></td><td width="70%">Shift whole image.</td></tr>
<tr><td width="30%"><tt class="key">Alt-P</tt></td><td width="70%">Export as semitransparent PNG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-F</tt></td><td width="70%">Export as solid PNG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-J</tt></td><td width="70%">Export as JPEG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-E</tt></td><td width="70%">Export as vector EPS.</td></tr>
<tr><td width="30%"><tt class="key">Alt-S</tt></td><td width="70%">Export as vector SVG.</td></tr>
<tr><td width="30%"><tt class="key">Alt-L</tt></td><td width="70%">Export as LaTeX/Tikz image.</td></tr>
<tr><td width="30%"><tt class="key">Alt-M</tt></td><td width="70%">Export as MGLD.</td></tr>
<tr><td width="30%"><tt class="key">Alt-D</tt></td><td width="70%">Export as PRC/PDF.</td></tr>
<tr><td width="30%"><tt class="key">Alt-O</tt></td><td width="70%">Export as OBJ.</td></tr>
</table>



<hr>
<a name="File-formats"></a>
<div class="header">
<p>
Next: <a href="#Plotting-time" accesskey="n" rel="next">Plotting time</a>, Previous: <a href="#Symbols-and-hot_002dkeys" accesskey="p" rel="prev">Symbols and hot-keys</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="File-formats-1"></a>
<h2 class="appendix">Appendix B File formats</h2>


<p>This appendix contain description of file formats used by MathGL.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Font-files" accesskey="1">Font files</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MGLD-format" accesskey="2">MGLD format</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#JSON-format" accesskey="3">JSON format</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#IFS-format" accesskey="4">IFS format</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Font-files"></a>
<div class="header">
<p>
Next: <a href="#MGLD-format" accesskey="n" rel="next">MGLD format</a>, Up: <a href="#File-formats" accesskey="u" rel="up">File formats</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Font-files-1"></a>
<h3 class="section">B.1 Font files</h3>


<p>Starting from v.1.6 the MathGL library uses new font files. The font is defined in 4 files with suffixes &lsquo;<samp>*.vfm</samp>&rsquo;, &lsquo;<samp>*_b.vfm</samp>&rsquo;, &lsquo;<samp>*_i.vfm</samp>&rsquo;, &lsquo;<samp>*_bi.vfm</samp>&rsquo;. These files are text files containing the data for roman font, bold font, italic font and bold italic font. The files (or some symbols in the files) for bold, italic or bold italic fonts can be absent. In this case the roman glyph will be used for them. By analogy, if the bold italic font is absent but the bold font is present then bold glyph will be used for bold italic. You may create these font files by yourself from *.ttf, *.otf files with the help of program <code>font_tools</code>. This program can be found at MathGL home site.
</p>
<p>The format of font files (*.vfm &ndash; vector font for MathGL) is the following.
</p><ol>
<li> First string contains human readable comment and is always ignored.
</li><li> Second string contains 3 numbers, delimited by space or tabulation. The order of numbers is the following: <var>numg</var> &ndash; the number of glyphs in the file (integer), <var>fact</var> &ndash; the factor for glyph sizing (mreal), <var>size</var> &ndash; the size of buffer for glyph description (integer).
</li><li> After it <var>numg</var>-th strings with glyphs description are placed. Each string contains 6 positive numbers, delimited by space of tabulation. The order of numbers is the following: Unicode glyph ID, glyph width, number of lines in glyph, position of lines coordinates in the buffer (length is 2*number of lines), number of triangles in glyph, position of triangles coordinates in the buffer (length is 6*number of triangles).
</li><li> The end of file contains the buffer with point coordinates at lines or triangles vertexes. The size of buffer (the number of integer) is <var>size</var>.
</li></ol>

<p>Each font file can be compressed by gzip.
</p>
<p>Note: the closing contour line  is done automatically (so the last segment may be absent). For starting new contour use a point with coordinates <code>{0x3fff, 0x3fff}</code>.
</p>


<hr>
<a name="MGLD-format"></a>
<div class="header">
<p>
Next: <a href="#JSON-format" accesskey="n" rel="next">JSON format</a>, Previous: <a href="#Font-files" accesskey="p" rel="prev">Font files</a>, Up: <a href="#File-formats" accesskey="u" rel="up">File formats</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="MGLD-format-1"></a>
<h3 class="section">B.2 MGLD format</h3>


<p>MGLD is textual file, which contain all required information for drawing 3D image, i.e. it contain vertexes with colors and normales, primitives with all properties, textures, and glyph descriptions. MGLD file can be imported or viewed separately, without parsing data files itself.
</p>
<p>MGLD file start from string
</p><pre class="verbatim">MGLD npnts nprim ntxtr nglfs # optional description
</pre><p>which contain signature &lsquo;<samp>MGLD</samp>&rsquo; and number of points <var>npnts</var>, number of primitives <var>nprim</var>, number of textures <var>ntxtr</var>, number of glyph descriptions <var>nglfs</var>, and optional description. Empty strings and string with &lsquo;<samp>#</samp>&rsquo; are ignored.
</p>
<p>Next, file contain <var>npnts</var> strings with points coordinates and colors. The format of each string is
</p><pre class="verbatim">x y z c t ta u v w r g b a
</pre><p>Here <var>x</var>, <var>y</var>, <var>z</var> are coordinates, <var>c</var>, <var>t</var> are color indexes in texture, <var>ta</var> is normalized <var>t</var> according to current alpha setting, <var>u</var>, <var>v</var>, <var>w</var> are coordinates of normal vector (can be <code>NAN</code> if disabled), <var>r</var>, <var>g</var>, <var>b</var>, <var>a</var> are RGBA color values.
</p>
<p>Next, file contain <var>nprim</var> strings with properties of primitives. The format of each string is
</p><pre class="verbatim">type n1 n2 n3 n4 id s w p
</pre><p>Here <var>type</var> is kind of primitive (0 - mark, 1 - line, 2 - triangle, 3 - quadrangle, 4 - glyph), <var>n1</var>...<var>n4</var> is index of point for vertexes,  <var>id</var> is primitive identification number, <var>s</var> and <var>w</var> are size and width if applicable, <var>p</var> is scaling factor for glyphs.
</p>
<p>Next, file contain <var>ntxtr</var> strings with descriptions of textures. The format of each string is
</p><pre class="verbatim">smooth alpha colors
</pre><p>Here <var>smooth</var> set to enable smoothing between colors, <var>alpha</var> set to use half-transparent texture, <var>colors</var> contain color scheme itself as it described in <a href="#Color-scheme">Color scheme</a>.
</p>
<p>Finally, file contain <var>nglfs</var> entries with description of each glyph used in the figure. The format of entries are
</p><pre class="verbatim">nT nL
xA yA xB yB xC yC ...
xP yP ...
</pre><p>Here nT is the number of triangles; nL is the number of line vertexes; xA, yA, xB, yB, xC, yC are coordinates of triangles; and xP, yP, xQ, yQ are coordinates of lines. Line coordinate xP=0x3fff, yP=0x3fff denote line breaking.
</p>

<hr>
<a name="JSON-format"></a>
<div class="header">
<p>
Next: <a href="#IFS-format" accesskey="n" rel="next">IFS format</a>, Previous: <a href="#MGLD-format" accesskey="p" rel="prev">MGLD format</a>, Up: <a href="#File-formats" accesskey="u" rel="up">File formats</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="JSON-format-1"></a>
<h3 class="section">B.3 JSON format</h3>


<p>MathGL can save points and primitives of 3D object. It contain a set of variables listed below.
</p>
<dl compact="compact">
<dt>&lsquo;<samp>width</samp>&rsquo;</dt>
<dd><p>width of the image;
</p></dd>
<dt>&lsquo;<samp>height</samp>&rsquo;</dt>
<dd><p>height of the image
</p></dd>
<dt>&lsquo;<samp>depth</samp>&rsquo;</dt>
<dd><p>depth of the image, usually =sqrt(width*height);
</p>
</dd>
<dt>&lsquo;<samp>npnts</samp>&rsquo;</dt>
<dd><p>number of points (vertexes);
</p></dd>
<dt>&lsquo;<samp>pnts</samp>&rsquo;</dt>
<dd><p>array of coordinates of points (vertexes), each element is array in form [x, y, z];
</p>
</dd>
<dt>&lsquo;<samp>nprim</samp>&rsquo;</dt>
<dd><p>number of primitives;
</p></dd>
<dt>&lsquo;<samp>prim</samp>&rsquo;</dt>
<dd><p>array of primitives, each element is array in form [type, n1, n2, n3, n4, id, s, w, p, z, color].
</p>
<p>Here <var>type</var> is kind of primitive (0 - mark, 1 - line, 2 - triangle, 3 - quadrangle, 4 - glyph), <var>n1</var>...<var>n4</var> is index of point for vertexes and <var>n2</var> can be index of glyph coordinate, <var>s</var> and <var>w</var> are size and width if applicable, <var>z</var> is average z-coordinate, <var>id</var> is primitive identification number, <var>p</var> is scaling factor for glyphs.
</p>
</dd>
<dt>&lsquo;<samp>ncoor</samp>&rsquo;</dt>
<dd><p>number of glyph positions
</p></dd>
<dt>&lsquo;<samp>coor</samp>&rsquo;</dt>
<dd><p>array of glyph positions, each element is array in form [dx,dy]
</p>
</dd>
<dt>&lsquo;<samp>nglfs</samp>&rsquo;</dt>
<dd><p>number of glyph descriptions
</p></dd>
<dt>&lsquo;<samp>glfs</samp>&rsquo;</dt>
<dd><p>array of glyph descriptions, each element is array in form <code>[nL, [xP0, yP0, xP1, yP1 ...]]</code>. Here <code>nL</code> is the number of line vertexes; and <code>xP, yP, xQ, yQ</code> are coordinates of lines. Line coordinate xP=0x3fff, yP=0x3fff denote line breaking.
</p>
</dd>
</dl>


<hr>
<a name="IFS-format"></a>
<div class="header">
<p>
Previous: <a href="#JSON-format" accesskey="p" rel="prev">JSON format</a>, Up: <a href="#File-formats" accesskey="u" rel="up">File formats</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="IFS-format-1"></a>
<h3 class="section">B.4 IFS format</h3>


<p>MathGL can read IFS fractal parameters (see <a href="#ifsfile">ifsfile</a>) from a IFS file. Let remind IFS file format. File may contain several records. Each record contain the name of fractal (&lsquo;<samp>binary</samp>&rsquo; in the example below) and the body of fractal, which is enclosed in curly braces {}. Symbol &lsquo;<samp>;</samp>&rsquo; start the comment. If the name of fractal contain &lsquo;<samp>(3D)</samp>&rsquo; or &lsquo;<samp>(3d)</samp>&rsquo; then the 3d IFS fractal is specified. The sample below contain two fractals: &lsquo;<samp>binary</samp>&rsquo; &ndash; usual 2d fractal, and &lsquo;<samp>3dfern (3D)</samp>&rsquo; &ndash; 3d fractal.
</p>
<pre class="verbatim"> binary
 { ; comment allowed here
  ; and here
  .5  .0 .0 .5 -2.563477 -0.000003 .333333   ; also comment allowed here
  .5  .0 .0 .5  2.436544 -0.000003 .333333
  .0 -.5 .5 .0  4.873085  7.563492 .333333
  }

 3dfern (3D) {
   .00  .00 0 .0 .18 .0 0  0.0 0.00 0 0.0 0 .01
   .85  .00 0 .0 .85 .1 0 -0.1 0.85 0 1.6 0 .85
   .20 -.20 0 .2 .20 .0 0  0.0 0.30 0 0.8 0 .07
  -.20  .20 0 .2 .20 .0 0  0.0 0.30 0 0.8 0 .07
  }
</pre>

<hr>
<a name="Plotting-time"></a>
<div class="header">
<p>
Next: <a href="#TeX_002dlike-symbols" accesskey="n" rel="next">TeX-like symbols</a>, Previous: <a href="#File-formats" accesskey="p" rel="prev">File formats</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Vremya-otrisovki"></a>
<h2 class="appendix">Appendix C Время отрисовки</h2>

<p>В таблице показаны времена создания графика для всех примеров из файла <a href="http://sourceforge.net/p/mathgl/code/HEAD/tree/mathgl-2x/examples/samples.cpp">examples/samples.cpp</a>. Тест выполнен на моем ноутбуке (i5-2430M) с 64-bit Debian.
</p>
<p>Несколько слов о скорости. Во-первых, прямое рисование в память (Quality=4,5,6) быстрее буферизованного (Quality=0,1,2), но иногда результат некоректен (см. <a href="#cloud">cloud</a>) и пропадает возможность экспорта в векторные и 3d форматы (например, EPS, SVG, PDF, ...). Во-вторых, обычно картинка худшего качества рисуется быстрее, т.е. Quality=1 быстрее Quality=2, и Quality=0 быстрее Quality=1. Однако, если график содержит множество граней (например <a href="#cloud">cloud</a>, <a href="#surf3">surf3</a>, <a href="#pipe">pipe</a>, <a href="#dew">dew</a>), то Quality=0 может быть достаточно медленным, особенно для маленьких картинок. Наконец, картинки меньшего размера рисуются быстрее.
</p>
<p>Результаты для изображения размером 800*600 (по умолчанию).
</p><table>
<thead><tr><th width="16%">Name</th><th width="12%">q=0</th><th width="12%">q=1</th><th width="12%">q=2</th><th width="12%">q=4</th><th width="12%">q=5</th><th width="12%">q=6</th><th width="12%">q=8</th></tr></thead>
<tr><td width="16%">3wave</td><td width="12%">0.0322</td><td width="12%">0.0627</td><td width="12%">0.0721</td><td width="12%">0.0425</td><td width="12%">0.11</td><td width="12%">0.136</td><td width="12%">0.0271</td></tr>
<tr><td width="16%">alpha</td><td width="12%">0.0892</td><td width="12%">0.108</td><td width="12%">0.113</td><td width="12%">0.0473</td><td width="12%">0.124</td><td width="12%">0.145</td><td width="12%">0.0297</td></tr>
<tr><td width="16%">apde</td><td width="12%">48.2</td><td width="12%">47.4</td><td width="12%">47.6</td><td width="12%">47.4</td><td width="12%">47.8</td><td width="12%">48.4</td><td width="12%">47.9</td></tr>
<tr><td width="16%">area</td><td width="12%">0.0376</td><td width="12%">0.0728</td><td width="12%">0.0752</td><td width="12%">0.033</td><td width="12%">0.141</td><td width="12%">0.165</td><td width="12%">0.0186</td></tr>
<tr><td width="16%">aspect</td><td width="12%">0.0442</td><td width="12%">0.0572</td><td width="12%">0.0551</td><td width="12%">0.031</td><td width="12%">0.0999</td><td width="12%">0.103</td><td width="12%">0.0146</td></tr>
<tr><td width="16%">axial</td><td width="12%">0.639</td><td width="12%">0.917</td><td width="12%">0.926</td><td width="12%">0.195</td><td width="12%">0.525</td><td width="12%">0.552</td><td width="12%">0.119</td></tr>
<tr><td width="16%">axis</td><td width="12%">0.0683</td><td width="12%">0.107</td><td width="12%">0.108</td><td width="12%">0.0466</td><td width="12%">0.196</td><td width="12%">0.202</td><td width="12%">0.0169</td></tr>
<tr><td width="16%">barh</td><td width="12%">0.0285</td><td width="12%">0.0547</td><td width="12%">0.0603</td><td width="12%">0.0292</td><td width="12%">0.101</td><td width="12%">0.115</td><td width="12%">0.0114</td></tr>
<tr><td width="16%">bars</td><td width="12%">0.0414</td><td width="12%">0.0703</td><td width="12%">0.0843</td><td width="12%">0.1</td><td width="12%">0.185</td><td width="12%">0.184</td><td width="12%">0.0295</td></tr>
<tr><td width="16%">belt</td><td width="12%">0.0286</td><td width="12%">0.0532</td><td width="12%">0.0577</td><td width="12%">0.0384</td><td width="12%">0.0735</td><td width="12%">0.1</td><td width="12%">0.0131</td></tr>
<tr><td width="16%">bifurcation</td><td width="12%">0.589</td><td width="12%">0.635</td><td width="12%">0.609</td><td width="12%">0.531</td><td width="12%">0.572</td><td width="12%">0.579</td><td width="12%">0.512</td></tr>
<tr><td width="16%">box</td><td width="12%">0.0682</td><td width="12%">0.0805</td><td width="12%">0.0828</td><td width="12%">0.0314</td><td width="12%">0.124</td><td width="12%">0.121</td><td width="12%">0.0169</td></tr>
<tr><td width="16%">boxplot</td><td width="12%">0.0102</td><td width="12%">0.0317</td><td width="12%">0.0347</td><td width="12%">0.02</td><td width="12%">0.0499</td><td width="12%">0.0554</td><td width="12%">0.0167</td></tr>
<tr><td width="16%">boxs</td><td width="12%">0.239</td><td width="12%">0.363</td><td width="12%">0.4</td><td width="12%">0.0798</td><td width="12%">0.216</td><td width="12%">0.234</td><td width="12%">0.0721</td></tr>
<tr><td width="16%">candle</td><td width="12%">0.0286</td><td width="12%">0.0549</td><td width="12%">0.053</td><td width="12%">0.0263</td><td width="12%">0.0483</td><td width="12%">0.0564</td><td width="12%">0.0109</td></tr>
<tr><td width="16%">chart</td><td width="12%">0.416</td><td width="12%">0.613</td><td width="12%">0.707</td><td width="12%">0.26</td><td width="12%">1.07</td><td width="12%">1.59</td><td width="12%">0.191</td></tr>
<tr><td width="16%">cloud</td><td width="12%">0.0312</td><td width="12%">4.15</td><td width="12%">4.11</td><td width="12%">0.0306</td><td width="12%">0.715</td><td width="12%">0.924</td><td width="12%">0.0168</td></tr>
<tr><td width="16%">colorbar</td><td width="12%">0.108</td><td width="12%">0.172</td><td width="12%">0.177</td><td width="12%">0.0787</td><td width="12%">0.258</td><td width="12%">0.266</td><td width="12%">0.0452</td></tr>
<tr><td width="16%">combined</td><td width="12%">0.36</td><td width="12%">0.336</td><td width="12%">0.332</td><td width="12%">0.198</td><td width="12%">0.316</td><td width="12%">0.33</td><td width="12%">0.196</td></tr>
<tr><td width="16%">cones</td><td width="12%">0.145</td><td width="12%">0.139</td><td width="12%">0.14</td><td width="12%">0.0937</td><td width="12%">0.248</td><td width="12%">0.276</td><td width="12%">0.0363</td></tr>
<tr><td width="16%">cont</td><td width="12%">0.0987</td><td width="12%">0.141</td><td width="12%">0.141</td><td width="12%">0.0585</td><td width="12%">0.207</td><td width="12%">0.194</td><td width="12%">0.0455</td></tr>
<tr><td width="16%">cont3</td><td width="12%">0.0323</td><td width="12%">0.058</td><td width="12%">0.0587</td><td width="12%">0.0304</td><td width="12%">0.0726</td><td width="12%">0.0837</td><td width="12%">0.0162</td></tr>
<tr><td width="16%">cont_xyz</td><td width="12%">0.0417</td><td width="12%">0.0585</td><td width="12%">0.0612</td><td width="12%">0.0417</td><td width="12%">0.0833</td><td width="12%">0.0845</td><td width="12%">0.0294</td></tr>
<tr><td width="16%">contd</td><td width="12%">0.191</td><td width="12%">0.245</td><td width="12%">0.236</td><td width="12%">0.104</td><td width="12%">0.189</td><td width="12%">0.201</td><td width="12%">0.0902</td></tr>
<tr><td width="16%">contf</td><td width="12%">0.162</td><td width="12%">0.179</td><td width="12%">0.182</td><td width="12%">0.0789</td><td width="12%">0.166</td><td width="12%">0.177</td><td width="12%">0.067</td></tr>
<tr><td width="16%">contf3</td><td width="12%">0.123</td><td width="12%">0.12</td><td width="12%">0.134</td><td width="12%">0.065</td><td width="12%">0.123</td><td width="12%">0.155</td><td width="12%">0.0538</td></tr>
<tr><td width="16%">contf_xyz</td><td width="12%">0.0751</td><td width="12%">0.0922</td><td width="12%">0.111</td><td width="12%">0.0756</td><td width="12%">0.0879</td><td width="12%">0.0956</td><td width="12%">0.0462</td></tr>
<tr><td width="16%">contv</td><td width="12%">0.0947</td><td width="12%">0.123</td><td width="12%">0.136</td><td width="12%">0.0757</td><td width="12%">0.163</td><td width="12%">0.18</td><td width="12%">0.0469</td></tr>
<tr><td width="16%">correl</td><td width="12%">0.0339</td><td width="12%">0.0629</td><td width="12%">0.0599</td><td width="12%">0.0288</td><td width="12%">0.115</td><td width="12%">0.138</td><td width="12%">0.0165</td></tr>
<tr><td width="16%">curvcoor</td><td width="12%">0.112</td><td width="12%">0.164</td><td width="12%">0.171</td><td width="12%">0.0864</td><td width="12%">0.296</td><td width="12%">0.298</td><td width="12%">0.0739</td></tr>
<tr><td width="16%">cut</td><td width="12%">0.695</td><td width="12%">0.465</td><td width="12%">0.484</td><td width="12%">0.303</td><td width="12%">0.385</td><td width="12%">0.371</td><td width="12%">0.316</td></tr>
<tr><td width="16%">dat_diff</td><td width="12%">0.0457</td><td width="12%">0.079</td><td width="12%">0.0825</td><td width="12%">0.0346</td><td width="12%">0.136</td><td width="12%">0.158</td><td width="12%">0.0186</td></tr>
<tr><td width="16%">dat_extra</td><td width="12%">0.175</td><td width="12%">0.181</td><td width="12%">0.173</td><td width="12%">0.0877</td><td width="12%">0.163</td><td width="12%">0.173</td><td width="12%">0.0463</td></tr>
<tr><td width="16%">data1</td><td width="12%">2.39</td><td width="12%">1.76</td><td width="12%">1.75</td><td width="12%">1.33</td><td width="12%">1.38</td><td width="12%">1.37</td><td width="12%">1.4</td></tr>
<tr><td width="16%">data2</td><td width="12%">1.42</td><td width="12%">1.26</td><td width="12%">1.28</td><td width="12%">1.17</td><td width="12%">1.24</td><td width="12%">1.29</td><td width="12%">1.14</td></tr>
<tr><td width="16%">dens</td><td width="12%">0.0867</td><td width="12%">0.122</td><td width="12%">0.131</td><td width="12%">0.0615</td><td width="12%">0.145</td><td width="12%">0.168</td><td width="12%">0.032</td></tr>
<tr><td width="16%">dens3</td><td width="12%">0.0722</td><td width="12%">0.0769</td><td width="12%">0.0937</td><td width="12%">0.0437</td><td width="12%">0.0947</td><td width="12%">0.151</td><td width="12%">0.0797</td></tr>
<tr><td width="16%">dens_xyz</td><td width="12%">0.0599</td><td width="12%">0.0875</td><td width="12%">0.0961</td><td width="12%">0.0463</td><td width="12%">0.089</td><td width="12%">0.0897</td><td width="12%">0.0315</td></tr>
<tr><td width="16%">detect</td><td width="12%">0.133</td><td width="12%">0.151</td><td width="12%">0.176</td><td width="12%">0.0861</td><td width="12%">0.116</td><td width="12%">0.138</td><td width="12%">0.0721</td></tr>
<tr><td width="16%">dew</td><td width="12%">1.48</td><td width="12%">1.07</td><td width="12%">0.971</td><td width="12%">0.473</td><td width="12%">0.537</td><td width="12%">0.416</td><td width="12%">0.195</td></tr>
<tr><td width="16%">diffract</td><td width="12%">0.0878</td><td width="12%">0.127</td><td width="12%">0.139</td><td width="12%">0.0607</td><td width="12%">0.219</td><td width="12%">0.237</td><td width="12%">0.0274</td></tr>
<tr><td width="16%">dilate</td><td width="12%">0.0778</td><td width="12%">0.128</td><td width="12%">0.138</td><td width="12%">0.0592</td><td width="12%">0.242</td><td width="12%">0.232</td><td width="12%">0.0298</td></tr>
<tr><td width="16%">dots</td><td width="12%">0.0685</td><td width="12%">0.1</td><td width="12%">0.101</td><td width="12%">0.0694</td><td width="12%">0.134</td><td width="12%">0.129</td><td width="12%">0.0261</td></tr>
<tr><td width="16%">earth</td><td width="12%">0.0147</td><td width="12%">0.033</td><td width="12%">0.0218</td><td width="12%">0.0168</td><td width="12%">0.0168</td><td width="12%">0.0191</td><td width="12%">0.00177</td></tr>
<tr><td width="16%">error</td><td width="12%">0.0312</td><td width="12%">0.0707</td><td width="12%">0.0709</td><td width="12%">0.0288</td><td width="12%">0.135</td><td width="12%">0.137</td><td width="12%">0.016</td></tr>
<tr><td width="16%">error2</td><td width="12%">0.0581</td><td width="12%">0.0964</td><td width="12%">0.0958</td><td width="12%">0.0595</td><td width="12%">0.173</td><td width="12%">0.187</td><td width="12%">0.0444</td></tr>
<tr><td width="16%">export</td><td width="12%">0.116</td><td width="12%">0.158</td><td width="12%">0.167</td><td width="12%">0.0799</td><td width="12%">0.132</td><td width="12%">0.133</td><td width="12%">0.0685</td></tr>
<tr><td width="16%">fall</td><td width="12%">0.035</td><td width="12%">0.051</td><td width="12%">0.0577</td><td width="12%">0.018</td><td width="12%">0.0585</td><td width="12%">0.0709</td><td width="12%">0.0142</td></tr>
<tr><td width="16%">fexport</td><td width="12%">1.52</td><td width="12%">1.76</td><td width="12%">1.78</td><td width="12%">0.278</td><td width="12%">0.604</td><td width="12%">0.606</td><td width="12%">1.35</td></tr>
<tr><td width="16%">fit</td><td width="12%">0.0371</td><td width="12%">0.0653</td><td width="12%">0.0666</td><td width="12%">0.0277</td><td width="12%">0.081</td><td width="12%">0.0837</td><td width="12%">0.014</td></tr>
<tr><td width="16%">flame2d</td><td width="12%">5.37</td><td width="12%">5.54</td><td width="12%">5.5</td><td width="12%">3.04</td><td width="12%">3.21</td><td width="12%">3.09</td><td width="12%">1.13</td></tr>
<tr><td width="16%">flow</td><td width="12%">0.368</td><td width="12%">0.451</td><td width="12%">0.444</td><td width="12%">0.36</td><td width="12%">0.5</td><td width="12%">0.48</td><td width="12%">0.352</td></tr>
<tr><td width="16%">fog</td><td width="12%">0.0406</td><td width="12%">0.0645</td><td width="12%">0.0688</td><td width="12%">0.0379</td><td width="12%">0.0793</td><td width="12%">0.0894</td><td width="12%">0.0156</td></tr>
<tr><td width="16%">fonts</td><td width="12%">0.0477</td><td width="12%">0.0926</td><td width="12%">0.112</td><td width="12%">0.0347</td><td width="12%">0.0518</td><td width="12%">0.0519</td><td width="12%">0.0413</td></tr>
<tr><td width="16%">grad</td><td width="12%">0.0607</td><td width="12%">0.104</td><td width="12%">0.129</td><td width="12%">0.0715</td><td width="12%">0.103</td><td width="12%">0.12</td><td width="12%">0.0633</td></tr>
<tr><td width="16%">hist</td><td width="12%">0.125</td><td width="12%">0.148</td><td width="12%">0.159</td><td width="12%">0.0919</td><td width="12%">0.116</td><td width="12%">0.129</td><td width="12%">0.0372</td></tr>
<tr><td width="16%">ifs2d</td><td width="12%">0.594</td><td width="12%">0.623</td><td width="12%">0.62</td><td width="12%">0.315</td><td width="12%">0.349</td><td width="12%">0.33</td><td width="12%">0.109</td></tr>
<tr><td width="16%">ifs3d</td><td width="12%">0.787</td><td width="12%">0.777</td><td width="12%">0.784</td><td width="12%">0.294</td><td width="12%">0.353</td><td width="12%">0.366</td><td width="12%">0.117</td></tr>
<tr><td width="16%">indirect</td><td width="12%">0.0286</td><td width="12%">0.0517</td><td width="12%">0.0543</td><td width="12%">0.031</td><td width="12%">0.0612</td><td width="12%">0.104</td><td width="12%">0.0144</td></tr>
<tr><td width="16%">inplot</td><td width="12%">0.0687</td><td width="12%">0.0979</td><td width="12%">0.0993</td><td width="12%">0.0622</td><td width="12%">0.181</td><td width="12%">0.195</td><td width="12%">0.0444</td></tr>
<tr><td width="16%">iris</td><td width="12%">0.00846</td><td width="12%">0.025</td><td width="12%">0.0198</td><td width="12%">0.00349</td><td width="12%">0.0172</td><td width="12%">0.0182</td><td width="12%">0.0018</td></tr>
<tr><td width="16%">label</td><td width="12%">0.0285</td><td width="12%">0.045</td><td width="12%">0.058</td><td width="12%">0.0267</td><td width="12%">0.0525</td><td width="12%">0.0618</td><td width="12%">0.014</td></tr>
<tr><td width="16%">lamerey</td><td width="12%">0.0305</td><td width="12%">0.0372</td><td width="12%">0.0455</td><td width="12%">0.019</td><td width="12%">0.0604</td><td width="12%">0.0633</td><td width="12%">0.0024</td></tr>
<tr><td width="16%">legend</td><td width="12%">0.0764</td><td width="12%">0.202</td><td width="12%">0.207</td><td width="12%">0.0455</td><td width="12%">0.138</td><td width="12%">0.148</td><td width="12%">0.0162</td></tr>
<tr><td width="16%">light</td><td width="12%">0.0903</td><td width="12%">0.129</td><td width="12%">0.122</td><td width="12%">0.0573</td><td width="12%">0.132</td><td width="12%">0.144</td><td width="12%">0.021</td></tr>
<tr><td width="16%">loglog</td><td width="12%">0.103</td><td width="12%">0.168</td><td width="12%">0.16</td><td width="12%">0.0806</td><td width="12%">0.228</td><td width="12%">0.235</td><td width="12%">0.0802</td></tr>
<tr><td width="16%">map</td><td width="12%">0.0303</td><td width="12%">0.0653</td><td width="12%">0.0721</td><td width="12%">0.0337</td><td width="12%">0.0821</td><td width="12%">0.0866</td><td width="12%">0.015</td></tr>
<tr><td width="16%">mark</td><td width="12%">0.0191</td><td width="12%">0.0324</td><td width="12%">0.0368</td><td width="12%">0.0261</td><td width="12%">0.0533</td><td width="12%">0.045</td><td width="12%">0.0072</td></tr>
<tr><td width="16%">mask</td><td width="12%">0.0442</td><td width="12%">0.0964</td><td width="12%">0.101</td><td width="12%">0.0343</td><td width="12%">0.205</td><td width="12%">0.211</td><td width="12%">0.0115</td></tr>
<tr><td width="16%">mesh</td><td width="12%">0.034</td><td width="12%">0.0774</td><td width="12%">0.0682</td><td width="12%">0.0192</td><td width="12%">0.0765</td><td width="12%">0.0742</td><td width="12%">0.0145</td></tr>
<tr><td width="16%">mirror</td><td width="12%">0.092</td><td width="12%">0.128</td><td width="12%">0.142</td><td width="12%">0.0607</td><td width="12%">0.174</td><td width="12%">0.176</td><td width="12%">0.0312</td></tr>
<tr><td width="16%">molecule</td><td width="12%">0.0827</td><td width="12%">0.0842</td><td width="12%">0.0859</td><td width="12%">0.0443</td><td width="12%">0.0997</td><td width="12%">0.146</td><td width="12%">0.0115</td></tr>
<tr><td width="16%">ode</td><td width="12%">0.149</td><td width="12%">0.202</td><td width="12%">0.202</td><td width="12%">0.147</td><td width="12%">0.282</td><td width="12%">0.316</td><td width="12%">0.133</td></tr>
<tr><td width="16%">ohlc</td><td width="12%">0.0059</td><td width="12%">0.0278</td><td width="12%">0.0271</td><td width="12%">0.0152</td><td width="12%">0.0517</td><td width="12%">0.045</td><td width="12%">0.0152</td></tr>
<tr><td width="16%">param1</td><td width="12%">0.161</td><td width="12%">0.252</td><td width="12%">0.26</td><td width="12%">0.0941</td><td width="12%">0.301</td><td width="12%">0.341</td><td width="12%">0.0466</td></tr>
<tr><td width="16%">param2</td><td width="12%">0.535</td><td width="12%">0.58</td><td width="12%">0.539</td><td width="12%">0.26</td><td width="12%">0.452</td><td width="12%">0.475</td><td width="12%">0.189</td></tr>
<tr><td width="16%">param3</td><td width="12%">1.75</td><td width="12%">2.37</td><td width="12%">2.32</td><td width="12%">0.677</td><td width="12%">0.899</td><td width="12%">0.907</td><td width="12%">0.758</td></tr>
<tr><td width="16%">paramv</td><td width="12%">1.21</td><td width="12%">1.39</td><td width="12%">1.36</td><td width="12%">0.788</td><td width="12%">0.974</td><td width="12%">0.968</td><td width="12%">0.69</td></tr>
<tr><td width="16%">parser</td><td width="12%">0.0346</td><td width="12%">0.0582</td><td width="12%">0.0687</td><td width="12%">0.0317</td><td width="12%">0.108</td><td width="12%">0.11</td><td width="12%">0.0275</td></tr>
<tr><td width="16%">pde</td><td width="12%">0.329</td><td width="12%">0.358</td><td width="12%">0.373</td><td width="12%">0.272</td><td width="12%">0.311</td><td width="12%">0.364</td><td width="12%">0.264</td></tr>
<tr><td width="16%">pendelta</td><td width="12%">0.0653</td><td width="12%">0.0525</td><td width="12%">0.0648</td><td width="12%">0.0517</td><td width="12%">0.0531</td><td width="12%">0.0522</td><td width="12%">0.0653</td></tr>
<tr><td width="16%">pipe</td><td width="12%">0.598</td><td width="12%">0.737</td><td width="12%">0.738</td><td width="12%">0.382</td><td width="12%">0.493</td><td width="12%">0.505</td><td width="12%">0.34</td></tr>
<tr><td width="16%">plot</td><td width="12%">0.0397</td><td width="12%">0.0642</td><td width="12%">0.114</td><td width="12%">0.0444</td><td width="12%">0.123</td><td width="12%">0.118</td><td width="12%">0.0194</td></tr>
<tr><td width="16%">pmap</td><td width="12%">0.0913</td><td width="12%">0.115</td><td width="12%">0.125</td><td width="12%">0.0572</td><td width="12%">0.0999</td><td width="12%">0.113</td><td width="12%">0.0469</td></tr>
<tr><td width="16%">primitives</td><td width="12%">0.0581</td><td width="12%">0.108</td><td width="12%">0.128</td><td width="12%">0.0649</td><td width="12%">0.181</td><td width="12%">0.21</td><td width="12%">0.00928</td></tr>
<tr><td width="16%">projection</td><td width="12%">0.13</td><td width="12%">0.264</td><td width="12%">0.286</td><td width="12%">0.0704</td><td width="12%">0.351</td><td width="12%">0.349</td><td width="12%">0.0683</td></tr>
<tr><td width="16%">projection5</td><td width="12%">0.117</td><td width="12%">0.207</td><td width="12%">0.215</td><td width="12%">0.0717</td><td width="12%">0.3</td><td width="12%">0.312</td><td width="12%">0.0437</td></tr>
<tr><td width="16%">pulse</td><td width="12%">0.0273</td><td width="12%">0.0395</td><td width="12%">0.0413</td><td width="12%">0.0183</td><td width="12%">0.0576</td><td width="12%">0.0635</td><td width="12%">0.0023</td></tr>
<tr><td width="16%">qo2d</td><td width="12%">0.218</td><td width="12%">0.246</td><td width="12%">0.274</td><td width="12%">0.198</td><td width="12%">0.243</td><td width="12%">0.255</td><td width="12%">0.177</td></tr>
<tr><td width="16%">quality0</td><td width="12%">0.0859</td><td width="12%">0.0902</td><td width="12%">0.087</td><td width="12%">0.0808</td><td width="12%">0.0808</td><td width="12%">0.0823</td><td width="12%">0.0796</td></tr>
<tr><td width="16%">quality1</td><td width="12%">0.189</td><td width="12%">0.166</td><td width="12%">0.171</td><td width="12%">0.175</td><td width="12%">0.17</td><td width="12%">0.173</td><td width="12%">0.166</td></tr>
<tr><td width="16%">quality2</td><td width="12%">0.183</td><td width="12%">0.183</td><td width="12%">0.175</td><td width="12%">0.172</td><td width="12%">0.171</td><td width="12%">0.183</td><td width="12%">0.184</td></tr>
<tr><td width="16%">quality4</td><td width="12%">0.082</td><td width="12%">0.0713</td><td width="12%">0.0728</td><td width="12%">0.0636</td><td width="12%">0.0843</td><td width="12%">0.0651</td><td width="12%">0.0592</td></tr>
<tr><td width="16%">quality5</td><td width="12%">0.366</td><td width="12%">0.359</td><td width="12%">0.363</td><td width="12%">0.366</td><td width="12%">0.354</td><td width="12%">0.356</td><td width="12%">0.357</td></tr>
<tr><td width="16%">quality6</td><td width="12%">0.373</td><td width="12%">0.367</td><td width="12%">0.365</td><td width="12%">0.366</td><td width="12%">0.368</td><td width="12%">0.383</td><td width="12%">0.366</td></tr>
<tr><td width="16%">quality8</td><td width="12%">0.0193</td><td width="12%">0.019</td><td width="12%">0.0289</td><td width="12%">0.0298</td><td width="12%">0.0165</td><td width="12%">0.0244</td><td width="12%">0.0229</td></tr>
<tr><td width="16%">radar</td><td width="12%">0.0193</td><td width="12%">0.0369</td><td width="12%">0.0545</td><td width="12%">0.0158</td><td width="12%">0.0525</td><td width="12%">0.0532</td><td width="12%">0.0115</td></tr>
<tr><td width="16%">refill</td><td width="12%">0.153</td><td width="12%">0.168</td><td width="12%">0.166</td><td width="12%">0.0746</td><td width="12%">0.239</td><td width="12%">0.258</td><td width="12%">0.0467</td></tr>
<tr><td width="16%">region</td><td width="12%">0.0396</td><td width="12%">0.0723</td><td width="12%">0.0859</td><td width="12%">0.0342</td><td width="12%">0.133</td><td width="12%">0.159</td><td width="12%">0.017</td></tr>
<tr><td width="16%">scanfile</td><td width="12%">0.0315</td><td width="12%">0.036</td><td width="12%">0.0497</td><td width="12%">0.0169</td><td width="12%">0.0486</td><td width="12%">0.053</td><td width="12%">0.014</td></tr>
<tr><td width="16%">schemes</td><td width="12%">0.0703</td><td width="12%">0.114</td><td width="12%">0.117</td><td width="12%">0.062</td><td width="12%">0.204</td><td width="12%">0.21</td><td width="12%">0.019</td></tr>
<tr><td width="16%">section</td><td width="12%">0.0294</td><td width="12%">0.0483</td><td width="12%">0.054</td><td width="12%">0.0221</td><td width="12%">0.0804</td><td width="12%">0.0821</td><td width="12%">0.00568</td></tr>
<tr><td width="16%">several_light</td><td width="12%">0.0441</td><td width="12%">0.0541</td><td width="12%">0.0701</td><td width="12%">0.0299</td><td width="12%">0.0602</td><td width="12%">0.0815</td><td width="12%">0.0117</td></tr>
<tr><td width="16%">solve</td><td width="12%">0.0461</td><td width="12%">0.109</td><td width="12%">0.105</td><td width="12%">0.0462</td><td width="12%">0.18</td><td width="12%">0.191</td><td width="12%">0.0184</td></tr>
<tr><td width="16%">stem</td><td width="12%">0.0418</td><td width="12%">0.0599</td><td width="12%">0.0591</td><td width="12%">0.0308</td><td width="12%">0.126</td><td width="12%">0.139</td><td width="12%">0.015</td></tr>
<tr><td width="16%">step</td><td width="12%">0.0399</td><td width="12%">0.0614</td><td width="12%">0.0554</td><td width="12%">0.0315</td><td width="12%">0.0958</td><td width="12%">0.113</td><td width="12%">0.0145</td></tr>
<tr><td width="16%">stereo</td><td width="12%">0.0569</td><td width="12%">0.0652</td><td width="12%">0.0811</td><td width="12%">0.031</td><td width="12%">0.0807</td><td width="12%">0.093</td><td width="12%">0.0163</td></tr>
<tr><td width="16%">stfa</td><td width="12%">0.0425</td><td width="12%">0.117</td><td width="12%">0.111</td><td width="12%">0.0416</td><td width="12%">0.115</td><td width="12%">0.121</td><td width="12%">0.0157</td></tr>
<tr><td width="16%">style</td><td width="12%">0.0892</td><td width="12%">0.197</td><td width="12%">0.204</td><td width="12%">0.0596</td><td width="12%">0.349</td><td width="12%">0.369</td><td width="12%">0.0158</td></tr>
<tr><td width="16%">surf</td><td width="12%">0.109</td><td width="12%">0.133</td><td width="12%">0.157</td><td width="12%">0.0657</td><td width="12%">0.16</td><td width="12%">0.158</td><td width="12%">0.0315</td></tr>
<tr><td width="16%">surf3</td><td width="12%">1.79</td><td width="12%">2.6</td><td width="12%">2.57</td><td width="12%">0.949</td><td width="12%">2.36</td><td width="12%">2.44</td><td width="12%">0.625</td></tr>
<tr><td width="16%">surf3a</td><td width="12%">0.431</td><td width="12%">0.281</td><td width="12%">0.297</td><td width="12%">0.176</td><td width="12%">0.235</td><td width="12%">0.252</td><td width="12%">0.178</td></tr>
<tr><td width="16%">surf3c</td><td width="12%">0.423</td><td width="12%">0.285</td><td width="12%">0.301</td><td width="12%">0.175</td><td width="12%">0.202</td><td width="12%">0.265</td><td width="12%">0.177</td></tr>
<tr><td width="16%">surf3ca</td><td width="12%">0.428</td><td width="12%">0.303</td><td width="12%">0.31</td><td width="12%">0.176</td><td width="12%">0.203</td><td width="12%">0.265</td><td width="12%">0.19</td></tr>
<tr><td width="16%">surfa</td><td width="12%">0.0409</td><td width="12%">0.0577</td><td width="12%">0.0714</td><td width="12%">0.0265</td><td width="12%">0.062</td><td width="12%">0.0725</td><td width="12%">0.0154</td></tr>
<tr><td width="16%">surfc</td><td width="12%">0.0422</td><td width="12%">0.0453</td><td width="12%">0.058</td><td width="12%">0.0282</td><td width="12%">0.0628</td><td width="12%">0.0749</td><td width="12%">0.0161</td></tr>
<tr><td width="16%">surfca</td><td width="12%">0.0416</td><td width="12%">0.0598</td><td width="12%">0.058</td><td width="12%">0.0254</td><td width="12%">0.0541</td><td width="12%">0.0671</td><td width="12%">0.015</td></tr>
<tr><td width="16%">table</td><td width="12%">0.103</td><td width="12%">0.213</td><td width="12%">0.214</td><td width="12%">0.0484</td><td width="12%">0.112</td><td width="12%">0.117</td><td width="12%">0.0156</td></tr>
<tr><td width="16%">tape</td><td width="12%">0.0409</td><td width="12%">0.0784</td><td width="12%">0.0836</td><td width="12%">0.0347</td><td width="12%">0.124</td><td width="12%">0.138</td><td width="12%">0.0164</td></tr>
<tr><td width="16%">tens</td><td width="12%">0.0329</td><td width="12%">0.0485</td><td width="12%">0.0441</td><td width="12%">0.0279</td><td width="12%">0.0805</td><td width="12%">0.0757</td><td width="12%">0.00561</td></tr>
<tr><td width="16%">ternary</td><td width="12%">0.104</td><td width="12%">0.218</td><td width="12%">0.214</td><td width="12%">0.0634</td><td width="12%">0.393</td><td width="12%">0.425</td><td width="12%">0.0352</td></tr>
<tr><td width="16%">text</td><td width="12%">0.0827</td><td width="12%">0.156</td><td width="12%">0.15</td><td width="12%">0.0261</td><td width="12%">0.114</td><td width="12%">0.127</td><td width="12%">0.015</td></tr>
<tr><td width="16%">text2</td><td width="12%">0.0719</td><td width="12%">0.12</td><td width="12%">0.131</td><td width="12%">0.115</td><td width="12%">0.129</td><td width="12%">0.137</td><td width="12%">0.016</td></tr>
<tr><td width="16%">textmark</td><td width="12%">0.0403</td><td width="12%">0.0749</td><td width="12%">0.0788</td><td width="12%">0.0223</td><td width="12%">0.0607</td><td width="12%">0.0653</td><td width="12%">0.014</td></tr>
<tr><td width="16%">ticks</td><td width="12%">0.0868</td><td width="12%">0.193</td><td width="12%">0.195</td><td width="12%">0.0611</td><td width="12%">0.259</td><td width="12%">0.249</td><td width="12%">0.0275</td></tr>
<tr><td width="16%">tile</td><td width="12%">0.0349</td><td width="12%">0.0444</td><td width="12%">0.0597</td><td width="12%">0.0308</td><td width="12%">0.0546</td><td width="12%">0.0547</td><td width="12%">0.0111</td></tr>
<tr><td width="16%">tiles</td><td width="12%">0.0393</td><td width="12%">0.0585</td><td width="12%">0.0534</td><td width="12%">0.0205</td><td width="12%">0.0648</td><td width="12%">0.0597</td><td width="12%">0.0174</td></tr>
<tr><td width="16%">torus</td><td width="12%">0.114</td><td width="12%">0.197</td><td width="12%">0.193</td><td width="12%">0.0713</td><td width="12%">0.394</td><td width="12%">0.457</td><td width="12%">0.0306</td></tr>
<tr><td width="16%">traj</td><td width="12%">0.0251</td><td width="12%">0.0413</td><td width="12%">0.043</td><td width="12%">0.0178</td><td width="12%">0.0628</td><td width="12%">0.0968</td><td width="12%">0.0129</td></tr>
<tr><td width="16%">triangulation</td><td width="12%">0.0328</td><td width="12%">0.0659</td><td width="12%">0.0792</td><td width="12%">0.0319</td><td width="12%">0.0966</td><td width="12%">0.0888</td><td width="12%">0.0155</td></tr>
<tr><td width="16%">triplot</td><td width="12%">0.0302</td><td width="12%">0.0705</td><td width="12%">0.102</td><td width="12%">0.0198</td><td width="12%">0.0973</td><td width="12%">0.127</td><td width="12%">0.0143</td></tr>
<tr><td width="16%">tube</td><td width="12%">0.077</td><td width="12%">0.143</td><td width="12%">0.192</td><td width="12%">0.0593</td><td width="12%">0.191</td><td width="12%">0.21</td><td width="12%">0.0197</td></tr>
<tr><td width="16%">type0</td><td width="12%">0.177</td><td width="12%">0.172</td><td width="12%">0.198</td><td width="12%">0.0673</td><td width="12%">0.141</td><td width="12%">0.2</td><td width="12%">0.0576</td></tr>
<tr><td width="16%">type1</td><td width="12%">0.174</td><td width="12%">0.173</td><td width="12%">0.2</td><td width="12%">0.0648</td><td width="12%">0.153</td><td width="12%">0.17</td><td width="12%">0.0571</td></tr>
<tr><td width="16%">type2</td><td width="12%">0.188</td><td width="12%">0.198</td><td width="12%">0.197</td><td width="12%">0.0773</td><td width="12%">0.186</td><td width="12%">0.193</td><td width="12%">0.0647</td></tr>
<tr><td width="16%">vect</td><td width="12%">0.129</td><td width="12%">0.336</td><td width="12%">0.194</td><td width="12%">0.0608</td><td width="12%">0.174</td><td width="12%">0.177</td><td width="12%">0.043</td></tr>
<tr><td width="16%">vect3</td><td width="12%">0.0317</td><td width="12%">0.0781</td><td width="12%">0.0869</td><td width="12%">0.0366</td><td width="12%">0.155</td><td width="12%">0.159</td><td width="12%">0.0174</td></tr>
<tr><td width="16%">venn</td><td width="12%">0.0153</td><td width="12%">0.0503</td><td width="12%">0.0787</td><td width="12%">0.0115</td><td width="12%">0.0665</td><td width="12%">0.075</td><td width="12%">0.00249</td></tr>
</table>

<p>Результаты для изображения размером 1920*1440 (для печати)
</p><table>
<thead><tr><th width="16%">Name</th><th width="12%">q=0</th><th width="12%">q=1</th><th width="12%">q=2</th><th width="12%">q=4</th><th width="12%">q=5</th><th width="12%">q=6</th><th width="12%">q=8</th></tr></thead>
<tr><td width="16%">3wave</td><td width="12%">0.0763</td><td width="12%">0.134</td><td width="12%">0.157</td><td width="12%">0.0764</td><td width="12%">0.198</td><td width="12%">0.207</td><td width="12%">0.0598</td></tr>
<tr><td width="16%">alpha</td><td width="12%">0.111</td><td width="12%">0.176</td><td width="12%">0.254</td><td width="12%">0.104</td><td width="12%">0.244</td><td width="12%">0.272</td><td width="12%">0.0591</td></tr>
<tr><td width="16%">apde</td><td width="12%">48</td><td width="12%">47.6</td><td width="12%">47.5</td><td width="12%">47.1</td><td width="12%">47.2</td><td width="12%">47.7</td><td width="12%">47</td></tr>
<tr><td width="16%">area</td><td width="12%">0.0783</td><td width="12%">0.169</td><td width="12%">0.245</td><td width="12%">0.107</td><td width="12%">0.277</td><td width="12%">0.335</td><td width="12%">0.0408</td></tr>
<tr><td width="16%">aspect</td><td width="12%">0.0622</td><td width="12%">0.105</td><td width="12%">0.129</td><td width="12%">0.0638</td><td width="12%">0.185</td><td width="12%">0.234</td><td width="12%">0.0478</td></tr>
<tr><td width="16%">axial</td><td width="12%">0.681</td><td width="12%">1.38</td><td width="12%">1.61</td><td width="12%">0.297</td><td width="12%">0.878</td><td width="12%">1.12</td><td width="12%">0.141</td></tr>
<tr><td width="16%">axis</td><td width="12%">0.0863</td><td width="12%">0.153</td><td width="12%">0.17</td><td width="12%">0.0773</td><td width="12%">0.274</td><td width="12%">0.297</td><td width="12%">0.0479</td></tr>
<tr><td width="16%">barh</td><td width="12%">0.0631</td><td width="12%">0.118</td><td width="12%">0.134</td><td width="12%">0.0661</td><td width="12%">0.218</td><td width="12%">0.259</td><td width="12%">0.049</td></tr>
<tr><td width="16%">bars</td><td width="12%">0.0654</td><td width="12%">0.126</td><td width="12%">0.153</td><td width="12%">0.0803</td><td width="12%">0.28</td><td width="12%">0.318</td><td width="12%">0.0479</td></tr>
<tr><td width="16%">belt</td><td width="12%">0.0624</td><td width="12%">0.11</td><td width="12%">0.133</td><td width="12%">0.0614</td><td width="12%">0.228</td><td width="12%">0.354</td><td width="12%">0.0454</td></tr>
<tr><td width="16%">bifurcation</td><td width="12%">0.604</td><td width="12%">0.696</td><td width="12%">0.758</td><td width="12%">0.602</td><td width="12%">0.656</td><td width="12%">0.692</td><td width="12%">0.572</td></tr>
<tr><td width="16%">box</td><td width="12%">0.081</td><td width="12%">0.152</td><td width="12%">0.211</td><td width="12%">0.0754</td><td width="12%">0.204</td><td width="12%">0.238</td><td width="12%">0.0516</td></tr>
<tr><td width="16%">boxplot</td><td width="12%">0.0458</td><td width="12%">0.072</td><td width="12%">0.108</td><td width="12%">0.0493</td><td width="12%">0.106</td><td width="12%">0.12</td><td width="12%">0.0329</td></tr>
<tr><td width="16%">boxs</td><td width="12%">0.276</td><td width="12%">0.623</td><td width="12%">0.823</td><td width="12%">0.131</td><td width="12%">0.387</td><td width="12%">0.52</td><td width="12%">0.0935</td></tr>
<tr><td width="16%">candle</td><td width="12%">0.0566</td><td width="12%">0.1</td><td width="12%">0.113</td><td width="12%">0.059</td><td width="12%">0.126</td><td width="12%">0.154</td><td width="12%">0.0435</td></tr>
<tr><td width="16%">chart</td><td width="12%">0.46</td><td width="12%">1.08</td><td width="12%">1.78</td><td width="12%">0.377</td><td width="12%">2.57</td><td width="12%">3.84</td><td width="12%">0.19</td></tr>
<tr><td width="16%">cloud</td><td width="12%">0.0618</td><td width="12%">5.78</td><td width="12%">6.76</td><td width="12%">0.061</td><td width="12%">1.49</td><td width="12%">2.72</td><td width="12%">0.0441</td></tr>
<tr><td width="16%">colorbar</td><td width="12%">0.144</td><td width="12%">0.259</td><td width="12%">0.297</td><td width="12%">0.142</td><td width="12%">0.383</td><td width="12%">0.455</td><td width="12%">0.075</td></tr>
<tr><td width="16%">combined</td><td width="12%">0.429</td><td width="12%">0.457</td><td width="12%">0.556</td><td width="12%">0.286</td><td width="12%">0.474</td><td width="12%">0.564</td><td width="12%">0.245</td></tr>
<tr><td width="16%">cones</td><td width="12%">0.17</td><td width="12%">0.226</td><td width="12%">0.272</td><td width="12%">0.157</td><td width="12%">0.521</td><td width="12%">0.667</td><td width="12%">0.0624</td></tr>
<tr><td width="16%">cont</td><td width="12%">0.0989</td><td width="12%">0.193</td><td width="12%">0.235</td><td width="12%">0.0952</td><td width="12%">0.285</td><td width="12%">0.304</td><td width="12%">0.0637</td></tr>
<tr><td width="16%">cont3</td><td width="12%">0.0645</td><td width="12%">0.11</td><td width="12%">0.122</td><td width="12%">0.0629</td><td width="12%">0.13</td><td width="12%">0.152</td><td width="12%">0.0479</td></tr>
<tr><td width="16%">cont_xyz</td><td width="12%">0.0676</td><td width="12%">0.105</td><td width="12%">0.129</td><td width="12%">0.0628</td><td width="12%">0.134</td><td width="12%">0.148</td><td width="12%">0.0523</td></tr>
<tr><td width="16%">contd</td><td width="12%">0.237</td><td width="12%">0.307</td><td width="12%">0.368</td><td width="12%">0.151</td><td width="12%">0.294</td><td width="12%">0.346</td><td width="12%">0.106</td></tr>
<tr><td width="16%">contf</td><td width="12%">0.193</td><td width="12%">0.262</td><td width="12%">0.305</td><td width="12%">0.136</td><td width="12%">0.274</td><td width="12%">0.322</td><td width="12%">0.0921</td></tr>
<tr><td width="16%">contf3</td><td width="12%">0.169</td><td width="12%">0.206</td><td width="12%">0.3</td><td width="12%">0.117</td><td width="12%">0.232</td><td width="12%">0.353</td><td width="12%">0.0796</td></tr>
<tr><td width="16%">contf_xyz</td><td width="12%">0.118</td><td width="12%">0.18</td><td width="12%">0.206</td><td width="12%">0.103</td><td width="12%">0.177</td><td width="12%">0.231</td><td width="12%">0.0661</td></tr>
<tr><td width="16%">contv</td><td width="12%">0.131</td><td width="12%">0.226</td><td width="12%">0.259</td><td width="12%">0.114</td><td width="12%">0.282</td><td width="12%">0.334</td><td width="12%">0.0753</td></tr>
<tr><td width="16%">correl</td><td width="12%">0.0578</td><td width="12%">0.108</td><td width="12%">0.115</td><td width="12%">0.0616</td><td width="12%">0.193</td><td width="12%">0.216</td><td width="12%">0.0463</td></tr>
<tr><td width="16%">curvcoor</td><td width="12%">0.125</td><td width="12%">0.203</td><td width="12%">0.219</td><td width="12%">0.12</td><td width="12%">0.454</td><td width="12%">0.504</td><td width="12%">0.0933</td></tr>
<tr><td width="16%">cut</td><td width="12%">0.768</td><td width="12%">0.661</td><td width="12%">0.73</td><td width="12%">0.43</td><td width="12%">0.53</td><td width="12%">0.669</td><td width="12%">0.431</td></tr>
<tr><td width="16%">dat_diff</td><td width="12%">0.0922</td><td width="12%">0.151</td><td width="12%">0.193</td><td width="12%">0.092</td><td width="12%">0.235</td><td width="12%">0.274</td><td width="12%">0.0439</td></tr>
<tr><td width="16%">dat_extra</td><td width="12%">0.202</td><td width="12%">0.236</td><td width="12%">0.263</td><td width="12%">0.132</td><td width="12%">0.254</td><td width="12%">0.292</td><td width="12%">0.0747</td></tr>
<tr><td width="16%">data1</td><td width="12%">2.62</td><td width="12%">2.07</td><td width="12%">2.14</td><td width="12%">1.43</td><td width="12%">1.69</td><td width="12%">1.83</td><td width="12%">1.56</td></tr>
<tr><td width="16%">data2</td><td width="12%">1.51</td><td width="12%">1.41</td><td width="12%">1.49</td><td width="12%">1.22</td><td width="12%">1.43</td><td width="12%">1.44</td><td width="12%">1.24</td></tr>
<tr><td width="16%">dens</td><td width="12%">0.115</td><td width="12%">0.236</td><td width="12%">0.32</td><td width="12%">0.134</td><td width="12%">0.271</td><td width="12%">0.327</td><td width="12%">0.0746</td></tr>
<tr><td width="16%">dens3</td><td width="12%">0.101</td><td width="12%">0.154</td><td width="12%">0.214</td><td width="12%">0.0981</td><td width="12%">0.173</td><td width="12%">0.244</td><td width="12%">0.0429</td></tr>
<tr><td width="16%">dens_xyz</td><td width="12%">0.102</td><td width="12%">0.179</td><td width="12%">0.242</td><td width="12%">0.119</td><td width="12%">0.164</td><td width="12%">0.22</td><td width="12%">0.0495</td></tr>
<tr><td width="16%">detect</td><td width="12%">0.17</td><td width="12%">0.283</td><td width="12%">0.357</td><td width="12%">0.129</td><td width="12%">0.217</td><td width="12%">0.293</td><td width="12%">0.0927</td></tr>
<tr><td width="16%">dew</td><td width="12%">1.63</td><td width="12%">1.1</td><td width="12%">1.19</td><td width="12%">0.557</td><td width="12%">0.797</td><td width="12%">0.881</td><td width="12%">0.288</td></tr>
<tr><td width="16%">diffract</td><td width="12%">0.0961</td><td width="12%">0.253</td><td width="12%">0.346</td><td width="12%">0.114</td><td width="12%">0.382</td><td width="12%">0.43</td><td width="12%">0.0508</td></tr>
<tr><td width="16%">dilate</td><td width="12%">0.098</td><td width="12%">0.231</td><td width="12%">0.259</td><td width="12%">0.101</td><td width="12%">0.347</td><td width="12%">0.404</td><td width="12%">0.0539</td></tr>
<tr><td width="16%">dots</td><td width="12%">0.0986</td><td width="12%">0.139</td><td width="12%">0.167</td><td width="12%">0.106</td><td width="12%">0.24</td><td width="12%">0.221</td><td width="12%">0.223</td></tr>
<tr><td width="16%">earth</td><td width="12%">0.0455</td><td width="12%">0.0532</td><td width="12%">0.0659</td><td width="12%">0.0448</td><td width="12%">0.0404</td><td width="12%">0.0592</td><td width="12%">0.0294</td></tr>
<tr><td width="16%">error</td><td width="12%">0.0764</td><td width="12%">0.128</td><td width="12%">0.134</td><td width="12%">0.0758</td><td width="12%">0.203</td><td width="12%">0.227</td><td width="12%">0.076</td></tr>
<tr><td width="16%">error2</td><td width="12%">0.0739</td><td width="12%">0.166</td><td width="12%">0.188</td><td width="12%">0.0934</td><td width="12%">0.374</td><td width="12%">0.416</td><td width="12%">0.0608</td></tr>
<tr><td width="16%">export</td><td width="12%">0.177</td><td width="12%">0.273</td><td width="12%">0.382</td><td width="12%">0.131</td><td width="12%">0.244</td><td width="12%">0.312</td><td width="12%">0.0968</td></tr>
<tr><td width="16%">fall</td><td width="12%">0.0481</td><td width="12%">0.127</td><td width="12%">0.114</td><td width="12%">0.051</td><td width="12%">0.115</td><td width="12%">0.125</td><td width="12%">0.0442</td></tr>
<tr><td width="16%">fexport</td><td width="12%">2.33</td><td width="12%">2.69</td><td width="12%">2.81</td><td width="12%">1.12</td><td width="12%">1.43</td><td width="12%">1.52</td><td width="12%">2.19</td></tr>
<tr><td width="16%">fit</td><td width="12%">0.072</td><td width="12%">0.112</td><td width="12%">0.121</td><td width="12%">0.0657</td><td width="12%">0.154</td><td width="12%">0.166</td><td width="12%">0.0442</td></tr>
<tr><td width="16%">flame2d</td><td width="12%">6.16</td><td width="12%">6.34</td><td width="12%">6.31</td><td width="12%">3.71</td><td width="12%">3.91</td><td width="12%">3.75</td><td width="12%">1.26</td></tr>
<tr><td width="16%">flow</td><td width="12%">0.43</td><td width="12%">0.529</td><td width="12%">0.557</td><td width="12%">0.403</td><td width="12%">0.582</td><td width="12%">0.599</td><td width="12%">0.372</td></tr>
<tr><td width="16%">fog</td><td width="12%">0.0651</td><td width="12%">0.146</td><td width="12%">0.209</td><td width="12%">0.07</td><td width="12%">0.172</td><td width="12%">0.242</td><td width="12%">0.0466</td></tr>
<tr><td width="16%">fonts</td><td width="12%">0.0842</td><td width="12%">0.13</td><td width="12%">0.135</td><td width="12%">0.0669</td><td width="12%">0.0969</td><td width="12%">0.0965</td><td width="12%">0.0696</td></tr>
<tr><td width="16%">grad</td><td width="12%">0.111</td><td width="12%">0.223</td><td width="12%">0.318</td><td width="12%">0.133</td><td width="12%">0.216</td><td width="12%">0.284</td><td width="12%">0.0783</td></tr>
<tr><td width="16%">hist</td><td width="12%">0.185</td><td width="12%">0.227</td><td width="12%">0.25</td><td width="12%">0.136</td><td width="12%">0.234</td><td width="12%">0.253</td><td width="12%">0.0632</td></tr>
<tr><td width="16%">ifs2d</td><td width="12%">0.7</td><td width="12%">0.777</td><td width="12%">0.762</td><td width="12%">0.396</td><td width="12%">0.457</td><td width="12%">0.443</td><td width="12%">0.133</td></tr>
<tr><td width="16%">ifs3d</td><td width="12%">0.827</td><td width="12%">0.835</td><td width="12%">0.893</td><td width="12%">0.369</td><td width="12%">0.45</td><td width="12%">0.484</td><td width="12%">0.127</td></tr>
<tr><td width="16%">indirect</td><td width="12%">0.0579</td><td width="12%">0.0904</td><td width="12%">0.116</td><td width="12%">0.0599</td><td width="12%">0.128</td><td width="12%">0.152</td><td width="12%">0.0316</td></tr>
<tr><td width="16%">inplot</td><td width="12%">0.0931</td><td width="12%">0.151</td><td width="12%">0.19</td><td width="12%">0.107</td><td width="12%">0.32</td><td width="12%">0.329</td><td width="12%">0.0601</td></tr>
<tr><td width="16%">iris</td><td width="12%">0.0446</td><td width="12%">0.0544</td><td width="12%">0.0751</td><td width="12%">0.0468</td><td width="12%">0.0457</td><td width="12%">0.0578</td><td width="12%">0.0371</td></tr>
<tr><td width="16%">label</td><td width="12%">0.0484</td><td width="12%">0.0879</td><td width="12%">0.105</td><td width="12%">0.0601</td><td width="12%">0.112</td><td width="12%">0.164</td><td width="12%">0.078</td></tr>
<tr><td width="16%">lamerey</td><td width="12%">0.0723</td><td width="12%">0.0728</td><td width="12%">0.0978</td><td width="12%">0.0611</td><td width="12%">0.104</td><td width="12%">0.154</td><td width="12%">0.0522</td></tr>
<tr><td width="16%">legend</td><td width="12%">0.123</td><td width="12%">0.282</td><td width="12%">0.3</td><td width="12%">0.0796</td><td width="12%">0.232</td><td width="12%">0.311</td><td width="12%">0.041</td></tr>
<tr><td width="16%">light</td><td width="12%">0.12</td><td width="12%">0.186</td><td width="12%">0.448</td><td width="12%">0.104</td><td width="12%">0.22</td><td width="12%">0.417</td><td width="12%">0.0528</td></tr>
<tr><td width="16%">loglog</td><td width="12%">0.136</td><td width="12%">0.252</td><td width="12%">0.252</td><td width="12%">0.125</td><td width="12%">0.405</td><td width="12%">0.481</td><td width="12%">0.0956</td></tr>
<tr><td width="16%">map</td><td width="12%">0.0768</td><td width="12%">0.157</td><td width="12%">0.195</td><td width="12%">0.0734</td><td width="12%">0.168</td><td width="12%">0.232</td><td width="12%">0.0471</td></tr>
<tr><td width="16%">mark</td><td width="12%">0.0659</td><td width="12%">0.0909</td><td width="12%">0.0881</td><td width="12%">0.0718</td><td width="12%">0.239</td><td width="12%">0.151</td><td width="12%">0.0372</td></tr>
<tr><td width="16%">mask</td><td width="12%">0.0878</td><td width="12%">0.207</td><td width="12%">0.326</td><td width="12%">0.0944</td><td width="12%">0.279</td><td width="12%">0.347</td><td width="12%">0.0511</td></tr>
<tr><td width="16%">mesh</td><td width="12%">0.0719</td><td width="12%">0.131</td><td width="12%">0.163</td><td width="12%">0.0683</td><td width="12%">0.147</td><td width="12%">0.181</td><td width="12%">0.0418</td></tr>
<tr><td width="16%">mirror</td><td width="12%">0.135</td><td width="12%">0.217</td><td width="12%">0.259</td><td width="12%">0.105</td><td width="12%">0.296</td><td width="12%">0.308</td><td width="12%">0.0548</td></tr>
<tr><td width="16%">molecule</td><td width="12%">0.0979</td><td width="12%">0.146</td><td width="12%">0.237</td><td width="12%">0.0953</td><td width="12%">0.241</td><td width="12%">0.361</td><td width="12%">0.044</td></tr>
<tr><td width="16%">ode</td><td width="12%">0.193</td><td width="12%">0.28</td><td width="12%">0.29</td><td width="12%">0.191</td><td width="12%">0.419</td><td width="12%">0.436</td><td width="12%">0.163</td></tr>
<tr><td width="16%">ohlc</td><td width="12%">0.0482</td><td width="12%">0.071</td><td width="12%">0.0936</td><td width="12%">0.0574</td><td width="12%">0.109</td><td width="12%">0.121</td><td width="12%">0.0447</td></tr>
<tr><td width="16%">param1</td><td width="12%">0.186</td><td width="12%">0.348</td><td width="12%">0.424</td><td width="12%">0.15</td><td width="12%">0.545</td><td width="12%">0.845</td><td width="12%">0.0861</td></tr>
<tr><td width="16%">param2</td><td width="12%">0.57</td><td width="12%">0.732</td><td width="12%">0.806</td><td width="12%">0.313</td><td width="12%">0.698</td><td width="12%">0.827</td><td width="12%">0.23</td></tr>
<tr><td width="16%">param3</td><td width="12%">1.91</td><td width="12%">2.56</td><td width="12%">2.93</td><td width="12%">0.767</td><td width="12%">1.17</td><td width="12%">1.58</td><td width="12%">0.844</td></tr>
<tr><td width="16%">paramv</td><td width="12%">1.29</td><td width="12%">1.55</td><td width="12%">1.5</td><td width="12%">0.816</td><td width="12%">1.12</td><td width="12%">1.11</td><td width="12%">0.718</td></tr>
<tr><td width="16%">parser</td><td width="12%">0.0631</td><td width="12%">0.112</td><td width="12%">0.14</td><td width="12%">0.0643</td><td width="12%">0.209</td><td width="12%">0.232</td><td width="12%">0.0467</td></tr>
<tr><td width="16%">pde</td><td width="12%">0.37</td><td width="12%">0.511</td><td width="12%">0.554</td><td width="12%">0.318</td><td width="12%">0.429</td><td width="12%">0.455</td><td width="12%">0.284</td></tr>
<tr><td width="16%">pendelta</td><td width="12%">0.108</td><td width="12%">0.115</td><td width="12%">0.102</td><td width="12%">0.108</td><td width="12%">0.115</td><td width="12%">0.104</td><td width="12%">0.105</td></tr>
<tr><td width="16%">pipe</td><td width="12%">0.661</td><td width="12%">0.922</td><td width="12%">1.04</td><td width="12%">0.414</td><td width="12%">0.669</td><td width="12%">0.828</td><td width="12%">0.36</td></tr>
<tr><td width="16%">plot</td><td width="12%">0.0961</td><td width="12%">0.116</td><td width="12%">0.142</td><td width="12%">0.0932</td><td width="12%">0.22</td><td width="12%">0.237</td><td width="12%">0.0457</td></tr>
<tr><td width="16%">pmap</td><td width="12%">0.137</td><td width="12%">0.184</td><td width="12%">0.216</td><td width="12%">0.0994</td><td width="12%">0.165</td><td width="12%">0.21</td><td width="12%">0.0737</td></tr>
<tr><td width="16%">primitives</td><td width="12%">0.0978</td><td width="12%">0.191</td><td width="12%">0.289</td><td width="12%">0.0971</td><td width="12%">0.304</td><td width="12%">0.353</td><td width="12%">0.0386</td></tr>
<tr><td width="16%">projection</td><td width="12%">0.166</td><td width="12%">0.403</td><td width="12%">0.484</td><td width="12%">0.124</td><td width="12%">0.578</td><td width="12%">0.626</td><td width="12%">0.078</td></tr>
<tr><td width="16%">projection5</td><td width="12%">0.149</td><td width="12%">0.323</td><td width="12%">0.36</td><td width="12%">0.117</td><td width="12%">0.496</td><td width="12%">0.546</td><td width="12%">0.0722</td></tr>
<tr><td width="16%">pulse</td><td width="12%">0.0488</td><td width="12%">0.0751</td><td width="12%">0.0911</td><td width="12%">0.0503</td><td width="12%">0.112</td><td width="12%">0.13</td><td width="12%">0.0347</td></tr>
<tr><td width="16%">qo2d</td><td width="12%">0.252</td><td width="12%">0.389</td><td width="12%">0.455</td><td width="12%">0.244</td><td width="12%">0.354</td><td width="12%">0.414</td><td width="12%">0.208</td></tr>
<tr><td width="16%">quality0</td><td width="12%">0.112</td><td width="12%">0.112</td><td width="12%">0.119</td><td width="12%">0.119</td><td width="12%">0.11</td><td width="12%">0.123</td><td width="12%">0.114</td></tr>
<tr><td width="16%">quality1</td><td width="12%">0.239</td><td width="12%">0.254</td><td width="12%">0.24</td><td width="12%">0.24</td><td width="12%">0.252</td><td width="12%">0.26</td><td width="12%">0.232</td></tr>
<tr><td width="16%">quality2</td><td width="12%">0.276</td><td width="12%">0.273</td><td width="12%">0.272</td><td width="12%">0.277</td><td width="12%">0.275</td><td width="12%">0.274</td><td width="12%">0.278</td></tr>
<tr><td width="16%">quality4</td><td width="12%">0.107</td><td width="12%">0.104</td><td width="12%">0.103</td><td width="12%">0.104</td><td width="12%">0.104</td><td width="12%">0.112</td><td width="12%">0.107</td></tr>
<tr><td width="16%">quality5</td><td width="12%">0.455</td><td width="12%">0.448</td><td width="12%">0.46</td><td width="12%">0.466</td><td width="12%">0.45</td><td width="12%">0.45</td><td width="12%">0.456</td></tr>
<tr><td width="16%">quality6</td><td width="12%">0.489</td><td width="12%">0.478</td><td width="12%">0.48</td><td width="12%">0.489</td><td width="12%">0.48</td><td width="12%">0.479</td><td width="12%">0.492</td></tr>
<tr><td width="16%">quality8</td><td width="12%">0.0575</td><td width="12%">0.0467</td><td width="12%">0.0453</td><td width="12%">0.0439</td><td width="12%">0.047</td><td width="12%">0.0462</td><td width="12%">0.0486</td></tr>
<tr><td width="16%">radar</td><td width="12%">0.058</td><td width="12%">0.0675</td><td width="12%">0.0872</td><td width="12%">0.07</td><td width="12%">0.0969</td><td width="12%">0.123</td><td width="12%">0.0284</td></tr>
<tr><td width="16%">refill</td><td width="12%">0.186</td><td width="12%">0.232</td><td width="12%">0.278</td><td width="12%">0.129</td><td width="12%">0.356</td><td width="12%">0.389</td><td width="12%">0.07</td></tr>
<tr><td width="16%">region</td><td width="12%">0.0706</td><td width="12%">0.166</td><td width="12%">0.21</td><td width="12%">0.0803</td><td width="12%">0.274</td><td width="12%">0.3</td><td width="12%">0.0442</td></tr>
<tr><td width="16%">scanfile</td><td width="12%">0.0563</td><td width="12%">0.0769</td><td width="12%">0.0884</td><td width="12%">0.0469</td><td width="12%">0.0891</td><td width="12%">0.106</td><td width="12%">0.0341</td></tr>
<tr><td width="16%">schemes</td><td width="12%">0.121</td><td width="12%">0.227</td><td width="12%">0.283</td><td width="12%">0.189</td><td width="12%">0.284</td><td width="12%">0.338</td><td width="12%">0.0454</td></tr>
<tr><td width="16%">section</td><td width="12%">0.0593</td><td width="12%">0.0948</td><td width="12%">0.0974</td><td width="12%">0.0622</td><td width="12%">0.159</td><td width="12%">0.175</td><td width="12%">0.0417</td></tr>
<tr><td width="16%">several_light</td><td width="12%">0.076</td><td width="12%">0.109</td><td width="12%">0.244</td><td width="12%">0.0697</td><td width="12%">0.123</td><td width="12%">0.246</td><td width="12%">0.0442</td></tr>
<tr><td width="16%">solve</td><td width="12%">0.0925</td><td width="12%">0.188</td><td width="12%">0.195</td><td width="12%">0.108</td><td width="12%">0.344</td><td width="12%">0.334</td><td width="12%">0.0485</td></tr>
<tr><td width="16%">stem</td><td width="12%">0.0633</td><td width="12%">0.129</td><td width="12%">0.145</td><td width="12%">0.0827</td><td width="12%">0.203</td><td width="12%">0.212</td><td width="12%">0.0407</td></tr>
<tr><td width="16%">step</td><td width="12%">0.0632</td><td width="12%">0.102</td><td width="12%">0.114</td><td width="12%">0.112</td><td width="12%">0.183</td><td width="12%">0.194</td><td width="12%">0.0447</td></tr>
<tr><td width="16%">stereo</td><td width="12%">0.0901</td><td width="12%">0.126</td><td width="12%">0.206</td><td width="12%">0.0807</td><td width="12%">0.151</td><td width="12%">0.237</td><td width="12%">0.0441</td></tr>
<tr><td width="16%">stfa</td><td width="12%">0.0925</td><td width="12%">0.245</td><td width="12%">0.291</td><td width="12%">0.0801</td><td width="12%">0.214</td><td width="12%">0.299</td><td width="12%">0.0438</td></tr>
<tr><td width="16%">style</td><td width="12%">0.114</td><td width="12%">0.271</td><td width="12%">0.321</td><td width="12%">0.102</td><td width="12%">0.44</td><td width="12%">0.468</td><td width="12%">0.0451</td></tr>
<tr><td width="16%">surf</td><td width="12%">0.149</td><td width="12%">0.241</td><td width="12%">0.303</td><td width="12%">0.12</td><td width="12%">0.24</td><td width="12%">0.319</td><td width="12%">0.0498</td></tr>
<tr><td width="16%">surf3</td><td width="12%">2.01</td><td width="12%">3.41</td><td width="12%">3.44</td><td width="12%">1.41</td><td width="12%">3.34</td><td width="12%">3.33</td><td width="12%">0.667</td></tr>
<tr><td width="16%">surf3a</td><td width="12%">0.514</td><td width="12%">0.397</td><td width="12%">0.537</td><td width="12%">0.24</td><td width="12%">0.397</td><td width="12%">0.74</td><td width="12%">0.205</td></tr>
<tr><td width="16%">surf3c</td><td width="12%">0.482</td><td width="12%">0.4</td><td width="12%">0.533</td><td width="12%">0.235</td><td width="12%">0.423</td><td width="12%">0.728</td><td width="12%">0.208</td></tr>
<tr><td width="16%">surf3ca</td><td width="12%">0.494</td><td width="12%">0.401</td><td width="12%">0.536</td><td width="12%">0.26</td><td width="12%">0.402</td><td width="12%">0.709</td><td width="12%">0.243</td></tr>
<tr><td width="16%">surfa</td><td width="12%">0.0643</td><td width="12%">0.105</td><td width="12%">0.181</td><td width="12%">0.0572</td><td width="12%">0.122</td><td width="12%">0.192</td><td width="12%">0.0456</td></tr>
<tr><td width="16%">surfc</td><td width="12%">0.0644</td><td width="12%">0.111</td><td width="12%">0.184</td><td width="12%">0.0609</td><td width="12%">0.128</td><td width="12%">0.199</td><td width="12%">0.0399</td></tr>
<tr><td width="16%">surfca</td><td width="12%">0.0645</td><td width="12%">0.106</td><td width="12%">0.181</td><td width="12%">0.0696</td><td width="12%">0.128</td><td width="12%">0.201</td><td width="12%">0.044</td></tr>
<tr><td width="16%">table</td><td width="12%">0.128</td><td width="12%">0.263</td><td width="12%">0.29</td><td width="12%">0.0813</td><td width="12%">0.176</td><td width="12%">0.197</td><td width="12%">0.0481</td></tr>
<tr><td width="16%">tape</td><td width="12%">0.0779</td><td width="12%">0.143</td><td width="12%">0.167</td><td width="12%">0.0788</td><td width="12%">0.224</td><td width="12%">0.242</td><td width="12%">0.0463</td></tr>
<tr><td width="16%">tens</td><td width="12%">0.0605</td><td width="12%">0.0956</td><td width="12%">0.0935</td><td width="12%">0.0699</td><td width="12%">0.146</td><td width="12%">0.162</td><td width="12%">0.046</td></tr>
<tr><td width="16%">ternary</td><td width="12%">0.13</td><td width="12%">0.334</td><td width="12%">0.357</td><td width="12%">0.116</td><td width="12%">0.589</td><td width="12%">0.65</td><td width="12%">0.061</td></tr>
<tr><td width="16%">text</td><td width="12%">0.11</td><td width="12%">0.214</td><td width="12%">0.225</td><td width="12%">0.0678</td><td width="12%">0.172</td><td width="12%">0.19</td><td width="12%">0.0438</td></tr>
<tr><td width="16%">text2</td><td width="12%">0.0809</td><td width="12%">0.175</td><td width="12%">0.189</td><td width="12%">0.0797</td><td width="12%">0.22</td><td width="12%">0.235</td><td width="12%">0.0425</td></tr>
<tr><td width="16%">textmark</td><td width="12%">0.0742</td><td width="12%">0.129</td><td width="12%">0.14</td><td width="12%">0.0574</td><td width="12%">0.126</td><td width="12%">0.143</td><td width="12%">0.0438</td></tr>
<tr><td width="16%">ticks</td><td width="12%">0.126</td><td width="12%">0.252</td><td width="12%">0.274</td><td width="12%">0.111</td><td width="12%">0.329</td><td width="12%">0.359</td><td width="12%">0.0488</td></tr>
<tr><td width="16%">tile</td><td width="12%">0.062</td><td width="12%">0.091</td><td width="12%">0.135</td><td width="12%">0.0605</td><td width="12%">0.11</td><td width="12%">0.156</td><td width="12%">0.0613</td></tr>
<tr><td width="16%">tiles</td><td width="12%">0.06</td><td width="12%">0.119</td><td width="12%">0.158</td><td width="12%">0.0604</td><td width="12%">0.129</td><td width="12%">0.163</td><td width="12%">0.0466</td></tr>
<tr><td width="16%">torus</td><td width="12%">0.148</td><td width="12%">0.277</td><td width="12%">0.391</td><td width="12%">0.121</td><td width="12%">0.817</td><td width="12%">1.19</td><td width="12%">0.0653</td></tr>
<tr><td width="16%">traj</td><td width="12%">0.0476</td><td width="12%">0.0899</td><td width="12%">0.108</td><td width="12%">0.0559</td><td width="12%">0.153</td><td width="12%">0.162</td><td width="12%">0.0336</td></tr>
<tr><td width="16%">triangulation</td><td width="12%">0.0622</td><td width="12%">0.159</td><td width="12%">0.218</td><td width="12%">0.0667</td><td width="12%">0.173</td><td width="12%">0.244</td><td width="12%">0.0451</td></tr>
<tr><td width="16%">triplot</td><td width="12%">0.0494</td><td width="12%">0.181</td><td width="12%">0.371</td><td width="12%">0.0608</td><td width="12%">0.181</td><td width="12%">0.32</td><td width="12%">0.0308</td></tr>
<tr><td width="16%">tube</td><td width="12%">0.108</td><td width="12%">0.286</td><td width="12%">0.373</td><td width="12%">0.104</td><td width="12%">0.311</td><td width="12%">0.379</td><td width="12%">0.0493</td></tr>
<tr><td width="16%">type0</td><td width="12%">0.238</td><td width="12%">0.326</td><td width="12%">0.5</td><td width="12%">0.144</td><td width="12%">0.314</td><td width="12%">0.479</td><td width="12%">0.108</td></tr>
<tr><td width="16%">type1</td><td width="12%">0.237</td><td width="12%">0.34</td><td width="12%">0.531</td><td width="12%">0.137</td><td width="12%">0.317</td><td width="12%">0.5</td><td width="12%">0.102</td></tr>
<tr><td width="16%">type2</td><td width="12%">0.243</td><td width="12%">0.335</td><td width="12%">0.509</td><td width="12%">0.148</td><td width="12%">0.317</td><td width="12%">0.484</td><td width="12%">0.115</td></tr>
<tr><td width="16%">vect</td><td width="12%">0.11</td><td width="12%">0.248</td><td width="12%">0.328</td><td width="12%">0.127</td><td width="12%">0.354</td><td width="12%">0.325</td><td width="12%">0.0732</td></tr>
<tr><td width="16%">vect3</td><td width="12%">0.0692</td><td width="12%">0.153</td><td width="12%">0.173</td><td width="12%">0.0884</td><td width="12%">0.526</td><td width="12%">0.366</td><td width="12%">0.0356</td></tr>
<tr><td width="16%">venn</td><td width="12%">0.0494</td><td width="12%">0.194</td><td width="12%">0.289</td><td width="12%">0.0664</td><td width="12%">0.158</td><td width="12%">0.236</td><td width="12%">0.044</td></tr>
</table>

<hr>
<a name="TeX_002dlike-symbols"></a>
<div class="header">
<p>
Next: <a href="#Copying-This-Manual" accesskey="n" rel="next">Copying This Manual</a>, Previous: <a href="#Plotting-time" accesskey="p" rel="prev">Plotting time</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Simvoly-TeX"></a>
<h2 class="appendix">Appendix D Символы TeX</h2>


<p>The full list of TeX-like commands recognizable by MathGL is shown below. If command is not recognized then it will be printed as is by ommitting &lsquo;<samp>\</samp>&rsquo; symbol. For example, &lsquo;<samp>\#</samp>&rsquo; produce &ldquo;#&rdquo;, &lsquo;<samp>\\</samp>&rsquo; produce &ldquo;\&rdquo;, &lsquo;<samp>\qq</samp>&rsquo; produce &ldquo;qq&rdquo;.
</p>
<p><strong>Change case</strong>: _, ^, @.
</p>
<p><strong>Text style</strong>: \big, \b, \textbf, \i, \textit, \bi, \r, \textrm, \a, \overline, \u, \underline, \w, \wire, #, \color[wkrgbcymhRGBCYMHWlenupqLENUPQ]
</p>
<p><strong>Roots</strong>: \sqrt, \sqrt3, \sqrt4
</p>
<p><strong>Fractions</strong>: \frac, \dfrac, \stack, \overset, \underset, \stackr, \stackl
</p>
<p><strong>Accents</strong>: \hat, \tilde, \dot, \ddot, \dddot, \ddddot, \acute, \check, \grave, \vec, \bar, \breve
</p>
<p><strong>Special symbols</strong>:
</p>
<p>\# (#), \% (%), \&amp; (&amp;), \^ (^).
</p>
<p>\AA (Å), \AE (Æ), \APLboxquestion (⍰), \APLboxupcaret (⍓), \APLnotbackslash (⍀), \APLnotslash (⌿), \Alpha (Α), \And (&amp;), \Angstrom (Å), \Barv (⫧), \BbbC (ℂ), \BbbGamma (ℾ), \BbbH (ℍ), \BbbN (ℕ), \BbbP (ℙ), \BbbPi (ℿ), \BbbQ (ℚ), \BbbR (ℝ), \BbbZ (ℤ), \Bbbgamma (ℽ), \Bbbpi (ℼ), \Bbbsum (⅀), \Beta (Β), \Bumpeq (≎), \Cap (⋒), \Chi (Χ), \Colon (∷), \Coloneq (⩴), \Cup (⋓), \DDownarrow (⟱), \DH (Ð), \DJ (Đ), \DashV (⫥), \DashVDash (⟚), \Dashv (⫤), \Ddownarrow (⤋), \Delta (Δ), \Digamma (Ϝ), \Doteq (≑), \Downarrow (⇓), \Epsilon (Ε), \Equiv (≣), \Eta (Η), \Eulerconst (ℇ), \Exclam (‼), \Finv (Ⅎ), \Game (⅁), \Gamma (Γ), \Gt (⪢), \Hermaphrodite (⚥), \Im (ℑ), \Iota (Ι), \Kappa (Κ), \Koppa (Ϟ), \L (Ł), \LLeftarrow (⭅), \Lambda (Λ), \Lbrbrak (⟬), \Ldsh (↲), \Leftarrow (⇐), \Leftrightarrow (⇔), \Lleftarrow (⇚), \Longleftarrow (⟸), \Longleftrightarrow (⟺), \Longmapsfrom (⟽), \Longmapsto (⟾), \Longrightarrow (⟹), \Lparengtr (⦕), \Lsh (↰), \Lt (⪡), \Lvzigzag (⧚), \Mapsfrom (⤆), \Mapsto (⤇), \Mu (Μ), \NG (Ŋ), \Nearrow (⇗), \Not (⫬), \Nu (Ν), \Nwarrow (⇖), \O (Ø), \OE (Œ), \Ohorn (Ơ), \Omega (Ω), \Omicron (Ο), \Otimes (⨷), \P (¶), \Phi (Φ), \Pi (Π), \Planckconst (ℎ), \Prec (⪻), \PropertyLine (⅊), \Psi (Ψ), \QED (∎), \Question (⁇), \RRightarrow (⭆), \Rbrbrak (⟭), \Rdsh (↳), \Re (ℜ), \Rho (Ρ), \Rightarrow (⇒), \Rparenless (⦖), \Rrightarrow (⇛), \Rsh (↱), \Rvzigzag (⧛), \S (§), \Sc (⪼), \Searrow (⇘), \Sigma (Σ), \Sqcap (⩎), \Sqcup (⩏), \Stigma (Ϛ), \Subset (⋐), \Supset (⋑), \Swarrow (⇙), \TH (Þ), \Tau (Τ), \Theta (Θ), \UUparrow (⟰), \Uhorn (Ư), \Uparrow (⇑), \Updownarrow (⇕), \Uuparrow (⤊), \VDash (⊫), \Vbar (⫫), \Vdash (⊩), \Vee (⩔), \Vert (‖), \Vvdash (⊪), \Vvert (⦀), \Wedge (⩓), \XBox (☒), \Xi (Ξ), \Yup (⅄), \Zbar (Ƶ), \Zeta (Ζ).
</p>
<p>\aa (å), \ac (∾), \accurrent (⏦), \acidfree (♾), \acwcirclearrow (⥀), \acwgapcirclearrow (⟲), \acwleftarcarrow (⤹), \acwopencirclearrow (↺), \acwoverarcarrow (⤺), \acwundercurvearrow (⤻), \adots (⋰), \ae (æ), \aleph (ℵ), \alpha (α), \amalg (⨿), \angdnr (⦟), \angle (∠), \angles (⦞), \angleubar (⦤), \approx (≈), \approxeq (≊), \approxeqq (⩰), \approxident (≋), \arceq (≘), \aries (♈), \assert (⊦), \ast (∗), \asteq (⩮), \astrosun (☉), \asymp (≍), \awint (⨑).
</p>
<p>\bNot (⫭), \backcong (≌), \backdprime (‶), \backepsilon (϶), \backprime (‵), \backsim (∽), \backsimeq (⋍), \backslash (\), \backtrprime (‷), \bagmember (⋿), \barV (⫪), \barcap (⩃), \barcup (⩂), \bardownharpoonleft (⥡), \bardownharpoonright (⥝), \barleftarrow (⇤), \barleftarrowrightarrowbar (↹), \barleftharpoondown (⥖), \barleftharpoonup (⥒), \barovernorthwestarrow (↸), \barrightarrowdiamond (⤠), \barrightharpoondown (⥟), \barrightharpoonup (⥛), \baruparrow (⤒), \barupharpoonleft (⥘), \barupharpoonright (⥔), \barvee (⊽), \barwedge (⊼), \bbrktbrk (⎶), \bdHrule (═), \bdVrule (║), \bdbVbH (╬), \bdbVbh (╫), \bdbVlH (╣), \bdbVlh (╢), \bdbVrH (╠), \bdbVrh (╟), \bdbvbH (╪), \bdbvbh (┼), \bdbvlH (╡), \bdbvlh (┤), \bdbvrH (╞), \bdbvrh (├), \bddVbH (╦), \bddVbh (╥), \bddVlH (╗), \bddVlh (╖), \bddVrH (╔), \bddVrh (╓), \bddvbH (╤), \bddvbh (┬), \bddvlH (╕), \bddvlh (┐), \bddvrH (╒), \bddvrh (┌), \bdhrule (─), \bdnesw (╱), \bdnwse (╲), \bdquadhdash (┈), \bdquadvdash (┊), \bdtriplevdash (┆), \bduVbH (╩), \bduVbh (╨), \bduVlH (╝), \bduVlh (╜), \bduVrH (╚), \bduVrh (╙), \bduvbH (╧), \bduvbh (┴), \bduvlH (╛), \bduvlh (┘), \bduvrH (╘), \bduvrh (└), \bdvrule (│), \because (∵), \benzenr (⏣), \beta (β), \beth (ℶ), \between (≬), \bigblacktriangledown (▼), \bigblacktriangleup (▲), \bigbot (⟘), \bigcap (⋂), \bigcup (⋃), \bigslopedvee (⩗), \bigslopedwedge (⩘), \bigstar (★), \bigtop (⟙), \bigtriangledown (▽), \bigtriangleup (△), \bigvee (⋁), \bigwedge (⋀), \bigwhitestar (☆), \blackcircledownarrow (⧭), \blackcircledrightdot (⚈), \blackcircledsanseight (➑), \blackcircledsansfive (➎), \blackcircledsansfour (➍), \blackcircledsansnine (➒), \blackcircledsansone (➊), \blackcircledsansseven (➐), \blackcircledsanssix (➏), \blackcircledsansten (➓), \blackcircledsansthree (➌), \blackcircledsanstwo (➋), \blackcircledtwodots (⚉), \blackcircleulquadwhite (◕), \blackdiamonddownarrow (⧪), \blackhourglass (⧗), \blackinwhitediamond (◈), \blackinwhitesquare (▣), \blacklefthalfcircle (◖), \blackpointerleft (◄), \blackpointerright (►), \blackrighthalfcircle (◗), \blacksmiley (☻), \blacktriangle (▴), \blacktriangledown (▾), \blacktriangleleft (◀), \blacktriangleright (▶), \blkhorzoval (⬬), \blkvertoval (⬮), \blockfull (█), \blockhalfshaded (▒), \blocklefthalf (▌), \blocklowhalf (▄), \blockqtrshaded (░), \blockrighthalf (▐), \blockthreeqtrshaded (▓), \blockuphalf (▀), \bot (⊥), \botsemicircle (◡), \bowtie (⋈), \box (◻), \boxast (⧆), \boxbar (◫), \boxbox (⧈), \boxbslash (⧅), \boxcircle (⧇), \boxdiag (⧄), \boxdot (⊡), \boxminus (⊟), \boxonbox (⧉), \boxplus (⊞), \boxtimes (⊠), \bsimilarleftarrow (⭁), \bsimilarrightarrow (⭇), \bsolhsub (⟈), \btimes (⨲), \bullet (∙), \bullseye (◎), \bumpeq (≏), \bumpeqq (⪮).
</p>
<p>\calB (ℬ), \calE (ℰ), \calF (ℱ), \calH (ℋ), \calM (ℳ), \calR (ℛ), \cap (∩), \capdot (⩀), \capwedge (⩄), \caretinsert (‸), \carreturn (⏎), \carriagereturn (↵), \ccwundercurvearrow (⤿), \cdot (⋅), \cdotp (·), \cdots (⋯), \cdprime (ʺ), \checkmark (✓), \chi (χ), \cirE (⧃), \cirbot (⟟), \circ (∘), \circeq (≗), \circfint (⨐), \circlebottomhalfblack (◒), \circledA (Ⓐ), \circledB (Ⓑ), \circledC (Ⓒ), \circledD (Ⓓ), \circledE (Ⓔ), \circledF (Ⓕ), \circledG (Ⓖ), \circledH (Ⓗ), \circledI (Ⓘ), \circledJ (Ⓙ), \circledK (Ⓚ), \circledL (Ⓛ), \circledM (Ⓜ), \circledN (Ⓝ), \circledO (Ⓞ), \circledP (Ⓟ), \circledQ (Ⓠ), \circledR (Ⓡ), \circledS (Ⓢ), \circledT (Ⓣ), \circledU (Ⓤ), \circledV (Ⓥ), \circledW (Ⓦ), \circledX (Ⓧ), \circledY (Ⓨ), \circledZ (Ⓩ), \circleda (ⓐ), \circledast (⊛), \circledb (ⓑ), \circledbullet (⦿), \circledc (ⓒ), \circledcirc (⊚), \circledd (ⓓ), \circleddash (⊝), \circlede (ⓔ), \circledeight (⑧), \circledequal (⊜), \circledf (ⓕ), \circledfive (⑤), \circledfour (④), \circledg (ⓖ), \circledh (ⓗ), \circledi (ⓘ), \circledj (ⓙ), \circledk (ⓚ), \circledl (ⓛ), \circledm (ⓜ), \circledn (ⓝ), \circlednine (⑨), \circledo (ⓞ), \circledone (①), \circledownarrow (⧬), \circledp (ⓟ), \circledparallel (⦷), \circledq (ⓠ), \circledr (ⓡ), \circledrightdot (⚆), \circleds (ⓢ), \circledsanseight (➇), \circledsansfive (➄), \circledsansfour (➃), \circledsansnine (➈), \circledsansone (➀), \circledsansseven (➆), \circledsanssix (➅), \circledsansten (➉), \circledsansthree (➂), \circledsanstwo (➁), \circledseven (⑦), \circledsix (⑥), \circledstar (✪), \circledt (ⓣ), \circledthree (③), \circledtwo (②), \circledtwodots (⚇), \circledu (ⓤ), \circledv (ⓥ), \circledvert (⦶), \circledw (ⓦ), \circledwhitebullet (⦾), \circledx (ⓧ), \circledy (ⓨ), \circledz (ⓩ), \circledzero (⓪), \circlehbar (⦵), \circlelefthalfblack (◐), \circlellquad (◵), \circlelrquad (◶), \circleonleftarrow (⬰), \circleonrightarrow (⇴), \circlerighthalfblack (◑), \circletophalfblack (◓), \circleulquad (◴), \circleurquad (◷), \circleurquadblack (◔), \circlevertfill (◍), \cirmid (⫯), \cirscir (⧂), \clangle (〈), \closedvarcap (⩍), \closedvarcup (⩌), \closedvarcupsmashprod (⩐), \closure (⁐), \cloverleaf (⌘), \clubsuit (♣), \colon (:), \colon (∶), \coloneq (≔), \commaminus (⨩), \complement (∁), \concavediamond (⟡), \concavediamondtickleft (⟢), \concavediamondtickright (⟣), \cong (≅), \congdot (⩭), \conictaper (⌲), \conjunction (☌), \coprod (∐), \cprime (ʹ), \crangle (〉), \csub (⫏), \csube (⫑), \csup (⫐), \csupe (⫒), \cuberoot (∛), \cup (∪), \cupdot (⊍), \cupleftarrow (⊌), \cupvee (⩅), \curlyeqprec (⋞), \curlyeqsucc (⋟), \curlyvee (⋎), \curlywedge (⋏), \curvearrowleft (↶), \curvearrowleftplus (⤽), \curvearrowright (↷), \curvearrowrightminus (⤼), \cwcirclearrow (⥁), \cwgapcirclearrow (⟳), \cwopencirclearrow (↻), \cwrightarcarrow (⤸), \cwundercurvearrow (⤾), \cylcty (⌭).
</p>
<p>\dag (†), \dagger (†), \daleth (ℸ), \danger (☡), \dashV (⫣), \dashVdash (⟛), \dashcolon (∹), \dashleftharpoondown (⥫), \dashrightharpoondown (⥭), \dashv (⊣), \dbkarow (⤏), \ddag (‡), \ddagger (‡), \ddots (⋱), \ddotseq (⩷), \delta (δ), \dh (ð), \diameter (⌀), \diamond (◇), \diamondbotblack (⬙), \diamondcdot (⟐), \diamondleftarrow (⤝), \diamondleftarrowbar (⤟), \diamondleftblack (⬖), \diamondrightblack (⬗), \diamondsuit (♢), \diamondtopblack (⬘), \dicei (⚀), \diceii (⚁), \diceiii (⚂), \diceiv (⚃), \dicev (⚄), \dicevi (⚅), \digamma (ϝ), \dingasterisk (✽), \dircurrent (⎓), \disin (⋲), \div (÷), \divideontimes (⋇), \dj (đ), \dlcrop (⌍), \doteq (≐), \dotequiv (⩧), \dotminus (∸), \dotplus (∔), \dots (…), \dotsim (⩪), \dotsminusdots (∺), \dottedcircle (◌), \dottedsquare (⬚), \dottimes (⨰), \doublebarvee (⩢), \doublebarwedge (⩞), \doubleplus (⧺), \downarrow (↓), \downarrowbar (⤓), \downarrowbarred (⤈), \downdasharrow (⇣), \downdownarrows (⇊), \downfishtail (⥿), \downharpoonleft (⇃), \downharpoonleftbar (⥙), \downharpoonright (⇂), \downharpoonrightbar (⥕), \downharpoonsleftright (⥥), \downrightcurvedarrow (⤵), \downtriangleleftblack (⧨), \downtrianglerightblack (⧩), \downuparrows (⇵), \downupharpoonsleftright (⥯), \downwhitearrow (⇩), \downzigzagarrow (↯), \dprime (″), \draftingarrow (➛), \drbkarow (⤐), \drcrop (⌌), \dsol (⧶), \dsub (⩤), \dualmap (⧟).
</p>
<p>\earth (♁), \egsdot (⪘), \eighthnote (♪), \elinters (⏧), \ell (ℓ), \elsdot (⪗), \emdash (—), \emptyset (∅), \emptysetoarr (⦳), \emptysetoarrl (⦴), \emptysetobar (⦱), \emptysetocirc (⦲), \endash (–), \enleadertwodots (‥), \envelope (✉), \eparsl (⧣), \epsilon (ϵ), \eqcirc (≖), \eqcolon (≕), \eqdef (≝), \eqdot (⩦), \eqeq (⩵), \eqeqeq (⩶), \eqgtr (⋝), \eqless (⋜), \eqqgtr (⪚), \eqqless (⪙), \eqqplus (⩱), \eqqsim (⩳), \eqqslantgtr (⪜), \eqqslantless (⪛), \eqsim (≂), \eqslantgtr (⪖), \eqslantless (⪕), \equalleftarrow (⭀), \equalparallel (⋕), \equalrightarrow (⥱), \equiv (≡), \equivDD (⩸), \equivVert (⩨), \equivVvert (⩩), \eqvparsl (⧥), \errbarblackcircle (⧳), \errbarblackdiamond (⧱), \errbarblacksquare (⧯), \errbarcircle (⧲), \errbardiamond (⧰), \errbarsquare (⧮), \eta (η), \euro (€), \exists (∃).
</p>
<p>\fallingdotseq (≒), \fbowtie (⧓), \fcmp (⨾), \fdiagovnearrow (⤯), \fdiagovrdiag (⤬), \female (♀), \figdash (‒), \fint (⨏), \fisheye (◉), \flat (♭), \fltns (⏥), \forall (∀), \forks (⫝̸), \forksnot (⫝), \forkv (⫙), \fourthroot (∜), \fourvdots (⦙), \fracfiveeighths (⅝), \fracfivesixths (⅚), \fracfourfifths (⅘), \fraconeeighth (⅛), \fraconefifth (⅕), \fraconesixth (⅙), \fraconethird (⅓), \fracseveneights (⅞), \fracslash (⁄), \fracthreeeighths (⅜), \fracthreefifths (⅗), \fractwofifths (⅖), \fractwothirds (⅔), \frakC (ℭ), \frakH (ℌ), \frakZ (ℨ), \frown (⌢), \frownie (☹), \fullouterjoin (⟗).
</p>
<p>\gamma (γ), \ge (≥), \geq (≥), \geqq (≧), \geqslant (⩾), \gescc (⪩), \gesdot (⪀), \gesdoto (⪂), \gesdotol (⪄), \gesles (⪔), \gets (←), \gg (≫), \ggg (⋙), \gggnest (⫸), \gimel (ℷ), \glE (⪒), \gla (⪥), \gleichstark (⧦), \glj (⪤), \gnapprox (⪊), \gneq (⪈), \gneqq (≩), \gnsim (⋧), \greater (&gt;), \gsime (⪎), \gsiml (⪐), \gtcc (⪧), \gtcir (⩺), \gtlpar (⦠), \gtquest (⩼), \gtrapprox (⪆), \gtrarr (⥸), \gtrdot (⋗), \gtreqless (⋛), \gtreqqless (⪌), \gtrless (≷), \gtrsim (≳), \guillemotleft («), \guillemotright (»), \guilsinglleft (‹), \guilsinglright (›).
</p>
<p>\harrowextender (⎯), \hatapprox (⩯), \hbar (ℏ), \heartsuit (♡), \hermitmatrix (⊹), \hexagon (⎔), \hexagonblack (⬣), \hiraganano (の), \hknearrow (⤤), \hknwarrow (⤣), \hksearow (⤥), \hkswarow (⤦), \hookleftarrow (↩), \hookrightarrow (↪), \horizbar (―), \hourglass (⧖), \house (⌂), \hrectangle (▭), \hrectangleblack (▬), \hslash (ℏ), \hyphenbullet (⁃), \hzigzag (〰).
</p>
<p>\iiiint (⨌), \iiint (∭), \iinfin (⧜), \iint (∬), \imageof (⊷), \in (∈), \incare (℅), \increment (∆), \infty (∞), \int (∫), \intBar (⨎), \intbar (⨍), \intbottom (⌡), \intcap (⨙), \intclockwise (∱), \intcup (⨚), \intercal (⊺), \interleave (⫴), \intextender (⎮), \intlharhk (⨗), \intprod (⨼), \intprodr (⨽), \inttop (⌠), \intx (⨘), \inversebullet (◘), \inversewhitecircle (◙), \invnot (⌐), \invwhitelowerhalfcircle (◛), \invwhiteupperhalfcircle (◚), \iota (ι), \ipasupgamma (ˠ), \ipasupl (ˡ), \ipasuprerglotstpp (ˤ), \ipasups (ˢ), \ipasupx (ˣ), \ipaunaspirated (˭), \ipavoicing (ˬ), \isinE (⋹), \isindot (⋵), \isinobar (⋷), \isins (⋴), \isinvb (⋸), \itBbbD (ⅅ), \itBbbd (ⅆ), \itBbbe (ⅇ), \itBbbi (ⅈ), \itBbbj (ⅉ).
</p>
<p>\jupiter (♃), \kappa (κ), \kernelcontraction (∻), \koppa (ϟ).
</p>
<p>\l (ł), \lAngle (⟪), \lBrace (⦃), \lBrack (⟦), \lParen (⦅), \lambda (λ), \lambdabar (ƛ), \langle (⟨), \langledot (⦑), \laplac (⧠), \lasp (ʽ), \lat (⪫), \late (⪭), \lbag (⟅), \lblkbrbrak (⦗), \lbrace ({), \lbracelend (⎩), \lbracemid (⎨), \lbraceuend (⎧), \lbrack ([), \lbrackextender (⎢), \lbracklend (⎣), \lbracklltick (⦏), \lbrackubar (⦋), \lbrackuend (⎡), \lbrackultick (⦍), \lbrbrak (❲), \lceil (⌈), \lcurvyangle (⧼), \ldasharrhead (⇠), \le (≤), \leadsto (↝), \leftarrow (←), \leftarrowapprox (⭊), \leftarrowbackapprox (⭂), \leftarrowbsimilar (⭋), \leftarrowless (⥷), \leftarrowonoplus (⬲), \leftarrowplus (⥆), \leftarrowshortrightarrow (⥃), \leftarrowsimilar (⥳), \leftarrowsubset (⥺), \leftarrowtail (↢), \leftarrowtriangle (⇽), \leftarrowx (⬾), \leftbkarrow (⤌), \leftcurvedarrow (⬿), \leftdasharrow (⇠), \leftdasharrowhead (⇡), \leftdbkarrow (⤎), \leftdbltail (⤛), \leftdotarrow (⬸), \leftdowncurvedarrow (⤶), \leftfishtail (⥼), \leftharpoondown (↽), \leftharpoondownbar (⥞), \leftharpoonsupdown (⥢), \leftharpoonup (↼), \leftharpoonupbar (⥚), \leftharpoonupdash (⥪), \leftleftarrows (⇇), \leftmoon (☾), \leftouterjoin (⟕), \leftrightarrow (↔), \leftrightarrowcircle (⥈), \leftrightarrows (⇆), \leftrightarrowtriangle (⇿), \leftrightharpoondowndown (⥐), \leftrightharpoondownup (⥋), \leftrightharpoons (⇋), \leftrightharpoonsdown (⥧), \leftrightharpoonsup (⥦), \leftrightharpoonupdown (⥊), \leftrightharpoonupup (⥎), \leftrightsquigarrow (↭), \leftsquigarrow (↜), \leftsquigarrow (⇜), \lefttail (⤙), \leftthreearrows (⬱), \leftthreetimes (⋋), \leftwhitearrow (⇦), \leq (≤), \leqq (≦), \leqqslant (⫹), \leqqslant (⫺), \leqslant (⩽), \lescc (⪨), \lesdot (⩿), \lesdoto (⪁), \lesdotor (⪃), \lesges (⪓), \less (&lt;), \lessapprox (⪅), \lessdot (⋖), \lesseqgtr (⋚), \lesseqqgtr (⪋), \lessgtr (≶), \lesssim (≲), \lfbowtie (⧑), \lfloor (⌊), \lftimes (⧔), \lgE (⪑), \lgblkcircle (⬤), \lgblksquare (⬛), \lgwhtcircle (◯), \lgwhtsquare (⬜), \lhd (⊲), \linefeed (↴), \ll (≪), \llangle (⦉), \llarc (◟), \llblacktriangle (◣), \llcorner (⌞), \lll (⋘), \lllnest (⫷), \llparenthesis (⦇), \lltriangle (◺), \lmoustache (⎰), \lnapprox (⪉), \lneq (⪇), \lneqq (≨), \lnsim (⋦), \longdashv (⟞), \longdivision (⟌), \longleftarrow (⟵), \longleftrightarrow (⟷), \longleftsquigarrow (⬳), \longmapsfrom (⟻), \longmapsto (⟼), \longrightarrow (⟶), \longrightsquigarrow (⟿), \looparrowleft (↫), \looparrowright (↬), \lowint (⨜), \lozenge (◊), \lozengeminus (⟠), \lparenextender (⎜), \lparenlend (⎝), \lparenless (⦓), \lparenuend (⎛), \lq (‘), \lrarc (◞), \lrblacktriangle (◢), \lrcorner (⌟), \lrtriangle (◿), \lrtriangleeq (⧡), \lsime (⪍), \lsimg (⪏), \lsqhook (⫍), \ltcc (⪦), \ltcir (⩹), \ltimes (⋉), \ltlarr (⥶), \ltquest (⩻), \ltrivb (⧏), \lvboxline (⎸), \lvzigzag (⧘).
</p>
<p>\male (♂), \maltese (✠), \mapsdown (↧), \mapsfrom (↤), \mapsto (↦), \mapsup (↥), \mdblkdiamond (⬥), \mdblklozenge (⬧), \mdblkrcl (⚫), \mdblksquare (◼), \mdlgblkcircle (●), \mdlgblkdiamond (◆), \mdlgblklozenge (⧫), \mdlgblksquare (■), \mdlgwhtcircle (○), \mdlgwhtdiamond (◇), \mdlgwhtsquare (□), \mdsmblkcircle (⦁), \mdsmblksquare (◾), \mdsmwhtcircl (⚬), \mdsmwhtsquare (◽), \mdwhtcircl (⚪), \mdwhtdiamond (⬦), \mdwhtlozenge (⬨), \mdwhtsquare (◻), \measangledltosw (⦯), \measangledrtose (⦮), \measangleldtosw (⦫), \measanglelutonw (⦩), \measanglerdtose (⦪), \measanglerutone (⦨), \measangleultonw (⦭), \measangleurtone (⦬), \measeq (≞), \measuredangle (∡), \measuredangleleft (⦛), \measuredrightangle (⊾), \medblackstar (⭑), \medmathspace ( ), \medwhitestar (⭐), \mercury (☿), \mho (℧), \mid (∣), \midbarvee (⩝), \midbarwedge (⩜), \midcir (⫰), \minus (−), \minusdot (⨪), \minusfdots (⨫), \minusrdots (⨬), \mlcp (⫛), \models (⊧), \mp (∓), \mu (μ), \multimap (⊸), \multimapinv (⟜).
</p>
<p>\nHdownarrow (⇟), \nHuparrow (⇞), \nLeftarrow (⇍), \nLeftrightarrow (⇎), \nRightarrow (⇏), \nVDash (⊯), \nVdash (⊮), \nVleftarrow (⇺), \nVleftarrowtail (⬺), \nVleftrightarrow (⇼), \nVrightarrow (⇻), \nVrightarrowtail (⤕), \nVtwoheadleftarrow (⬵), \nVtwoheadleftarrowtail (⬽), \nVtwoheadrightarrow (⤁), \nVtwoheadrightarrowtail (⤘), \nabla (∇), \napprox (≉), \nasymp (≭), \natural (♮), \ncong (≇), \ne (≠), \nearrow (↗), \neg (¬), \neovnwarrow (⤱), \neovsearrow (⤮), \neptune (♆), \neq (≠), \nequiv (≢), \neswarrow (⤢), \neuter (⚲), \nexists (∄), \ng (ŋ), \ngeq (≱), \ngtr (≯), \ngtrless (≹), \ngtrsim (≵), \nhVvert (⫵), \nhpar (⫲), \ni (∋), \niobar (⋾), \nis (⋼), \nisd (⋺), \nleftarrow (↚), \nleftrightarrow (↮), \nleq (≰), \nless (≮), \nlessgtr (≸), \nlesssim (≴), \nmid (∤), \nni (∌), \nobreakhyphen (‑), \notin (∉), \nparallel (∦), \npolint (⨔), \nprec (⊀), \npreccurlyeq (⋠), \nrightarrow (↛), \nsim (≁), \nsime (≄), \nsqsubseteq (⋢), \nsqsupseteq (⋣), \nsubset (⊄), \nsubseteq (⊈), \nsucc (⊁), \nsucccurlyeq (⋡), \nsupset (⊅), \nsupseteq (⊉), \ntriangleleft (⋪), \ntrianglelefteq (⋬), \ntriangleright (⋫), \ntrianglerighteq (⋭), \nu (ν), \nvDash (⊭), \nvLeftarrow (⤂), \nvLeftrightarrow (⤄), \nvRightarrow (⤃), \nvdash (⊬), \nvinfty (⧞), \nvleftarrow (⇷), \nvleftarrowtail (⬹), \nvleftrightarrow (⇹), \nvrightarrow (⇸), \nvrightarrowtail (⤔), \nvtwoheadleftarrow (⬴), \nvtwoheadleftarrowtail (⬼), \nvtwoheadrightarrow (⤀), \nvtwoheadrightarrowtail (⤗), \nwarrow (↖), \nwovnearrow (⤲), \nwsearrow (⤡).
</p>
<p>\o (ø), \obar (⌽), \obot (⦺), \obrbrak (⏠), \obslash (⦸), \odiv (⨸), \odot (⊙), \odotslashdot (⦼), \oe (œ), \ogreaterthan (⧁), \ohorn (ơ), \oiiint (∰), \oiint (∯), \oint (∮), \ointctrclockwise (∳), \olcross (⦻), \oldKoppa (Ϙ), \oldkoppa (ϙ), \olessthan (⧀), \omega (ω), \omicron (ο), \ominus (⊖), \operp (⦹), \oplus (⊕), \opluslhrim (⨭), \oplusrhrim (⨮), \origof (⊶), \oslash (⊘), \otimes (⊗), \otimeshat (⨶), \otimeslhrim (⨴), \otimesrhrim (⨵), \overbrace (⏞), \overbracket (⎴), \overline (‾), \overparen (⏜), \owns (∋).
</p>
<p>\parallel (∥), \parallelogram (▱), \parallelogramblack (▰), \parsim (⫳), \partial (∂), \partialmeetcontraction (⪣), \pentagon (⬠), \pentagonblack (⬟), \perp (⟂), \perps (⫡), \phi (ϕ), \phone (☎), \pi (π), \pitchfork (⋔), \plusdot (⨥), \pluseqq (⩲), \plushat (⨣), \plussim (⨦), \plussubtwo (⨧), \plustrif (⨨), \pluto (♇), \pm (±), \pointnt (⨕), \postalmark (〒), \prec (≺), \precapprox (⪷), \preccurlyeq (≼), \preceq (⪯), \preceqq (⪳), \precnapprox (⪹), \precneq (⪱), \precneqq (⪵), \precnsim (⋨), \precsim (≾), \prime (′), \prod (∏), \profalar (⌮), \profline (⌒), \profsurf (⌓), \propto (∝), \prurel (⊰), \psi (ψ), \pullback (⟓), \pushout (⟔).
</p>
<p>\qprime (⁗), \quarternote (♩), \questeq (≟), \quotdblbase („), \quotdblright (‟), \quotsinglbase (‚), \quotsinglright (‛).
</p>
<p>\rAngle (⟫), \rBrace (⦄), \rBrack (⟧), \rParen (⦆), \rangle (⟩), \rangledot (⦒), \rangledownzigzagarrow (⍼), \rasp (ʼ), \rbag (⟆), \rblkbrbrak (⦘), \rbrace (}), \rbracelend (⎭), \rbracemid (⎬), \rbraceuend (⎫), \rbrack (]), \rbrackextender (⎥), \rbracklend (⎦), \rbracklrtick (⦎), \rbrackubar (⦌), \rbrackuend (⎤), \rbrackurtick (⦐), \rbrbrak (❳), \rceil (⌉), \rcurvyangle (⧽), \rdiagovfdiag (⤫), \rdiagovsearrow (⤰), \recorder (⌕), \revangle (⦣), \revangleubar (⦥), \revemptyset (⦰), \revnmid (⫮), \rfbowtie (⧒), \rfloor (⌋), \rftimes (⧕), \rhd (⊳), \rho (ρ), \righarrowbsimilar (⭌), \rightangle (∟), \rightanglemdot (⦝), \rightanglesqr (⦜), \rightarrow (→), \rightarrowapprox (⥵), \rightarrowbackapprox (⭈), \rightarrowbar (⇥), \rightarrowdiamond (⤞), \rightarrowgtr (⭃), \rightarrowonoplus (⟴), \rightarrowplus (⥅), \rightarrowshortleftarrow (⥂), \rightarrowsimilar (⥴), \rightarrowsupset (⭄), \rightarrowtail (↣), \rightarrowtriangle (⇾), \rightarrowx (⥇), \rightbkarrow (⤍), \rightcurvedarrow (⤳), \rightdasharrow (⇢), \rightdbltail (⤜), \rightdotarrow (⤑), \rightdowncurvedarrow (⤷), \rightfishtail (⥽), \rightharpoondown (⇁), \rightharpoondownbar (⥗), \rightharpoonsupdown (⥤), \rightharpoonup (⇀), \rightharpoonupbar (⥓), \rightharpoonupdash (⥬), \rightimply (⥰), \rightleftarrows (⇄), \rightleftharpoons (⇌), \rightleftharpoonsdown (⥩), \rightleftharpoonsup (⥨), \rightmoon (☽), \rightouterjoin (⟖), \rightpentagon (⭔), \rightpentagonblack (⭓), \rightrightarrows (⇉), \rightsquigarrow (↝), \rightsquigarrow (⇝), \righttail (⤚), \rightthreearrows (⇶), \rightthreetimes (⋌), \rightwhitearrow (⇨), \ringplus (⨢), \risingdotseq (≓), \rmoustache (⎱), \rparenextender (⎟), \rparengtr (⦔), \rparenlend (⎠), \rparenuend (⎞), \rppolint (⨒), \rq (’), \rrangle (⦊), \rrparenthesis (⦈), \rsolbar (⧷), \rsqhook (⫎), \rsub (⩥), \rtimes (⋊), \rtriltri (⧎), \ruledelayed (⧴), \rvboxline (⎹), \rvzigzag (⧙).
</p>
<p>\sampi (ϡ), \sansLmirrored (⅃), \sansLturned (⅂), \saturn (♄), \scissors (✂), \scpolint (⨓), \scrB (ℬ), \scrE (ℰ), \scrF (ℱ), \scrH (ℋ), \scrI (ℐ), \scrL (ℒ), \scrM (ℳ), \scrR (ℛ), \scre (ℯ), \scrg (ℊ), \scro (ℴ), \scurel (⊱), \searrow (↘), \seovnearrow (⤭), \setminus (∖), \setminus (⧵), \sharp (♯), \shortdowntack (⫟), \shortleftarrow (←), \shortlefttack (⫞), \shortrightarrow (→), \shortrightarrowleftarrow (⥄), \shortuptack (⫠), \shuffle (⧢), \sigma (σ), \silon (υ), \silon (ϒ), \sim (∼), \simeq (≃), \simgE (⪠), \simgtr (⪞), \similarleftarrow (⭉), \similarrightarrow (⥲), \simlE (⪟), \simless (⪝), \simminussim (⩬), \simneqq (≆), \simplus (⨤), \simrdots (⩫), \sinewave (∿), \slash (∕), \smallblacktriangleleft (◂), \smallblacktriangleright (▸), \smalldiamond (⋄), \smallin (∊), \smallint (∫), \smallni (∍), \smallsetminus (∖), \smalltriangleleft (◃), \smalltriangleright (▹), \smashtimes (⨳), \smblkdiamond (⬩), \smblklozenge (⬪), \smblksquare (▪), \smeparsl (⧤), \smile (⌣), \smiley (☺), \smt (⪪), \smte (⪬), \smwhitestar (⭒), \smwhtcircle (◦), \smwhtlozenge (⬫), \smwhtsquare (▫), \spadesuit (♠), \sphericalangle (∢), \sphericalangleup (⦡), \sqcap (⊓), \sqcup (⊔), \sqint (⨖), \sqlozenge (⌑), \sqrt (√), \sqrt3 (∛), \sqrt4 (∜), \sqrtbottom (⎷), \sqsubset (⊏), \sqsubseteq (⊑), \sqsubsetneq (⋤), \sqsupset (⊐), \sqsupseteq (⊒), \sqsupsetneq (⋥), \squarecrossfill (▩), \squaregrayfill (▩), \squarehfill (▤), \squarehvfill (▦), \squareleftblack (◧), \squareleftblack (◨), \squarellblack (⬕), \squarellquad (◱), \squarelrblack (◪), \squarelrquad (◲), \squareneswfill (▨), \squarenwsefill (▧), \squareulblack (◩), \squareulquad (◰), \squareurblack (⬔), \squareurquad (◳), \squarevfill (▥), \squoval (▢), \ss (ß), \star (⋆), \stareq (≛), \sterling (£), \stigma (ϛ), \strns (⏤), \subedot (⫃), \submult (⫁), \subrarr (⥹), \subset (⊂), \subsetapprox (⫉), \subsetcirc (⟃), \subsetdot (⪽), \subseteq (⊆), \subseteqq (⫅), \subsetneq (⊊), \subsetneqq (⫋), \subsetplus (⪿), \subsim (⫇), \subsub (⫕), \subsup (⫓), \succ (≻), \succapprox (⪸), \succcurlyeq (≽), \succeq (⪰), \succeqq (⪴), \succnapprox (⪺), \succneq (⪲), \succneqq (⪶), \succnsim (⋩), \succsim (≿), \sum (∑), \sumbottom (⎳), \sumint (⨋), \sumtop (⎲), \sun (☼), \supdsub (⫘), \supedot (⫄), \suphsol (⟉), \suphsub (⫗), \suplarr (⥻), \supmult (⫂), \supn (ⁿ), \supset (⊃), \supsetapprox (⫊), \supsetcirc (⟄), \supsetdot (⪾), \supseteq (⊇), \supseteqq (⫆), \supsetneq (⊋), \supsetneqq (⫌), \supsetplus (⫀), \supsim (⫈), \supsub (⫔), \supsup (⫖), \surd (√), \swarrow (↙).
</p>
<p>\talloblong (⫾), \target (⌖), \tau (τ), \taurus (♉), \testhookx (ᶍ), \textAsterisks (⁑), \textacute (ˊ), \textadvanced (˖), \textain (ʿ), \textasciiacute (´), \textasciicircum (^), \textasciidieresis (¨), \textasciigrave (&lsquo;), \textasciimacron (¯), \textasciitilde (~), \textasterisklow (⁎), \textbackdprime (‶), \textbackprime (‵), \textbacktrprime (‷), \textbardotlessj (ɟ), \textbardotlessjvar (ʄ), \textbarglotstop (ʡ), \textbari (ɨ), \textbarl (ƚ), \textbaro (ɵ), \textbarrevglotstop (ʢ), \textbaru (ʉ), \textbeltl (ɬ), \textbenttailyogh (ƺ), \textbreve (˘), \textbrokenbar (¦), \textbullet (•), \textbullseye (ʘ), \textcent (¢), \textcircledP (℗), \textcloseepsilon (ʚ), \textcloseomega (ɷ), \textcloserevepsilon (ɞ), \textcopyright (©), \textcrb (ƀ), \textcrh (ħ), \textcrinvglotstop (ƾ), \textcrlambda (ƛ), \textcrtwo (ƻ), \textctc (ɕ), \textctd (ȡ), \textctesh (ʆ), \textctj (ʝ), \textctl (ȴ), \textctn (ȵ), \textctt (ȶ), \textctyogh (ʓ), \textctz (ʑ), \textcurrency (¤), \textdctzlig (ʥ), \textdegree (°), \textdiscount (⁒), \textdollar ($), \textdotaccent (˙), \textdotlessj (ȷ), \textdoubleacute (˝), \textdoublebarpipe (ǂ), \textdoublepipe (ǁ), \textdprime (″), \textdptr (˅), \textdyoghlig (ʤ), \textdzlig (ʣ), \textepsilon (ɛ), \textesh (ʃ), \textestimated (℮), \textexclam (ǃ), \textexclamdown (¡), \textfishhookr (ɾ), \textflorin (ƒ), \textfranc (₣), \textgamma (ɣ), \textglotstop (ʔ), \textgrave (ˋ), \texthalflength (ˑ), \texthamza (ʾ), \texthen (ꜧ), \textheng (ꜧ), \texthooks (ᶊ), \texthookz (ᶎ), \texthtb (ɓ), \texthtc (ƈ), \texthtd (ɗ), \texthtg (ɠ), \texthth (ɦ), \texththeng (ɧ), \texthtk (ƙ), \texthtp (ƥ), \texthtq (ʠ), \texthtscg (ʛ), \texthtt (ƭ), \texthvlig (ƕ), \texthyphen (‐), \textinvglotstop (ʖ), \textinvscr (ʁ), \textiota (ɩ), \textlengthmark (ː), \textlhalfring (˓), \textlhookd (ᶁ), \textlhookk (ᶄ), \textlhookl (ᶅ), \textlhookt (ƫ), \textlhti (ɿ), \textlira (₤), \textlonglegr (ɼ), \textlongy (ʮ), \textlongy (ʯ), \textlooptoprevesh (ƪ), \textlowacute (ˏ), \textlowered (˕), \textlowgrave (ˎ), \textlowmacron (ˍ), \textlptr (˂), \textltailm (ɱ), \textltailn (ɲ), \textltilde (ɫ), \textlyoghlig (ɮ), \textmacron (ˉ), \textmu (µ), \textnumero (№), \textogonek (˛), \textohm (Ω), \textonehalf (½), \textonequarter (¼), \textonesuperior (¹), \textopeno (ɔ), \textordfeminine (ª), \textordmasculine (º), \textovercross (˟), \textoz (℥), \textpertenthousand (‱), \textperthousand (‰), \textpesetas (₧), \textphi (ɸ), \textpipe (ǀ), \textprime (′), \textprimstress (ˈ), \textqprime (⁗), \textquestiondown (¿), \textquotedbl (&quot;), \textquotedblleft (“), \textquotedblright (”), \textraised (˔), \textraiseglotstop (ˀ), \textraiserevglotstop (ˁ), \textramshorns (ɤ), \textrecipe (℞), \textreferencemark (※), \textregistered (®), \textretracted (˗), \textreve (ɘ), \textrevepsilon (ɜ), \textrevglotstop (ʕ), \textrhalfring (˒), \textrhookrevepsilon (ɝ), \textrhookschwa (ɚ), \textrhoticity (˞), \textringaccent (˚), \textrptr (˃), \textrtaild (ɖ), \textrtaill (ɭ), \textrtailn (ɳ), \textrtailr (ɽ), \textrtails (ʂ), \textrtailt (ʈ), \textrtailz (ʐ), \textsca (ᴀ), \textscb (ʙ), \textsce (ᴇ), \textscg (ɢ), \textsch (ʜ), \textschwa (ə), \textsci (ɪ), \textscl (ʟ), \textscn (ɴ), \textscoelig (ɶ), \textscr (ʀ), \textscripta (ɑ), \textscriptg (ɡ), \textscriptv (ʋ), \textscu (ᴜ), \textscy (ʏ), \textsecstress (ˌ), \textsemicolonreversed (⁏), \textsilon (Υ), \textsmalltilde (˜), \textstretchcvar (ʗ), \textsubw (w), \textsuph (ʰ), \textsuphth (ʱ), \textsupinvscr (ʶ), \textsupj (ʲ), \textsupr (ʳ), \textsupturnr (ʴ), \textsupturnrrtail (ʵ), \textsupw (ʷ), \textsupy (ʸ), \texttctctlig (ʧ), \texttctctlig (ʨ), \textthreequarters (¾), \textthreesuperior (³), \texttrademark (™), \texttrprime (‴), \texttslig (ʦ), \textturna (ɐ), \textturncomma (ʻ), \textturnh (ɥ), \textturnk (ʞ), \textturnlonglegr (ɺ), \textturnm (ɯ), \textturnmrleg (ɰ), \textturnr (ɹ), \textturnrrtail (ɻ), \textturnscripta (ɒ), \textturnt (ʇ), \textturnv (ʌ), \textturnw (ʍ), \textturny (ʎ), \texttwosuperior (²), \textupsilon (ʊ), \textuptr (˄), \textvibyi (ʅ), \textvisiblespace (␣), \textyogh (ʒ), \th (þ), \therefore (∴), \thermod (⧧), \theta (θ), \thickapprox (≈), \thicksim (∼), \threedangle (⟀), \threedotcolon (⫶), \tieconcat (⁀), \tieinfty (⧝), \times (×), \timesbar (⨱), \tminus (⧿), \to (→), \toea (⤨), \tona (⤧), \tonebarextrahigh (˥), \tonebarextralow (˩), \tonebarhigh (˦), \tonebarlow (˨), \tonebarmid (˧), \top (⊤), \topbot (⌶), \topcir (⫱), \topfork (⫚), \topsemicircle (◠), \tosa (⤩), \towa (⤪), \tplus (⧾), \trapezium (⏢), \trianglecdot (◬), \triangledown (▿), \triangleexclam (⚠), \triangleleft (◁), \triangleleftblack (◭), \trianglelefteq (⊴), \triangleminus (⨺), \triangleodot (⧊), \triangleplus (⨹), \triangleq (≜), \triangleright (▷), \trianglerightblack (◮), \trianglerighteq (⊵), \triangles (⧌), \triangleserifs (⧍), \triangletimes (⨻), \triangleubar (⧋), \tripleplus (⧻), \trprime (‴), \turnangle (⦢), \turnediota (℩), \turnednot (⌙), \twocaps (⩋), \twocups (⩊), \twoheaddownarrow (↡), \twoheadleftarrow (↞), \twoheadleftarrowtail (⬻), \twoheadleftdbkarrow (⬷), \twoheadmapsfrom (⬶), \twoheadmapsto (⤅), \twoheadrightarrow (↠), \twoheadrightarrowtail (⤖), \twoheaduparrow (↟), \twoheaduparrowcircle (⥉), \twolowline (‗), \twonotes (♫), \typecolon (⦂).
</p>
<p>\ubrbrak (⏡), \uhorn (ư), \ularc (◜), \ulblacktriangle (◤), \ulcorner (⌜), \ulcrop (⌏), \ultriangle (◸), \uminus (⩁), \underbrace (⏟), \underbracket (⎵), \underparen (⏝), \unlhd (⊴), \unrhd (⊵), \upand (⅋), \uparrow (↑), \uparrowbarred (⤉), \uparrowoncircle (⦽), \updasharrow (⇢), \updownarrow (↕), \updownarrowbar (↨), \updownarrows (⇅), \updownharpoonleftleft (⥑), \updownharpoonleftright (⥍), \updownharpoonrightleft (⥌), \updownharpoonrightright (⥏), \updownharpoonsleftright (⥮), \upfishtail (⥾), \upharpoonleft (↿), \upharpoonleftbar (⥠), \upharpoonright (↾), \upharpoonrightbar (⥜), \upharpoonsleftright (⥣), \upin (⟒), \upint (⨛), \uplus (⊎), \uprightcurvearrow (⤴), \upuparrows (⇈), \upwhitearrow (⇧), \urarc (◝), \urblacktriangle (◥), \urcorner (⌝), \urcrop (⌎), \urtriangle (◹).
</p>
<p>\v (ˇ), \vBar (⫨), \vBarv (⫩), \vDash (⊨), \vDdash (⫢), \varTheta (ϴ), \varVdash (⫦), \varbarwedge (⌅), \varbeta (ϐ), \varclubsuit (♧), \vardiamondsuit (♦), \vardoublebarwedge (⌆), \varepsilon (ε), \varheartsuit (♥), \varhexagon (⬡), \varhexagonblack (⬢), \varhexagonlrbonds (⌬), \varin (∈), \varisinobar (⋶), \varisins (⋳), \varkappa (ϰ), \varlrtriangle (⊿), \varni (∋), \varniobar (⋽), \varnis (⋻), \varnothing (∅), \varointclockwise (∲), \varphi (φ), \varpi (ϖ), \varpropto (∝), \varrho (ϱ), \varrowextender (⏐), \varsigma (ς), \varspadesuit (♤), \varstar (✶), \vartheta (ϑ), \vartriangle (▵), \vartriangleleft (⊲), \vartriangleright (⊳), \varveebar (⩡), \vbraceextender (⎪), \vbrtri (⧐), \vdash (⊢), \vdots (⋮), \vectimes (⨯), \vee (∨), \veebar (⊻), \veedot (⟇), \veedoublebar (⩣), \veeeq (≚), \veemidvert (⩛), \veeodot (⩒), \veeonvee (⩖), \veeonwedge (⩙), \vert (|), \viewdata (⌗), \vlongdash (⟝), \vrectangle (▯), \vrectangleblack (▮), \vysmlblksquare (⬝), \vysmlwhtsquare (⬞), \vzigzag (⦚).
</p>
<p>\watchicon (⌚), \wedge (∧), \wedgebar (⩟), \wedgedot (⟑), \wedgedoublebar (⩠), \wedgemidvert (⩚), \wedgeodot (⩑), \wedgeonwedge (⩕), \wedgeq (≙), \whitearrowupfrombar (⇪), \whiteinwhitetriangle (⟁), \whitepointerleft (◅), \whitepointerright (▻), \whitesquaretickleft (⟤), \whitesquaretickright (⟥), \whthorzoval (⬭), \whtvertoval (⬯), \wideangledown (⦦), \wideangleup (⦧), \wp (℘), \wr (≀).
</p>
<p>\xbsol (⧹), \xi (ξ), \xsol (⧸), \yen (¥), \zeta (ζ), \zpipe (⨠), 
</p>
<p>IF ANYBODY WILL CHECK WHETHER ALL NAMES CORRESPOND TO RIGHT TEX SYMBOLS I SHALL APPRECIATE IT GREATLY. 
</p>
<hr>
<a name="Copying-This-Manual"></a>
<div class="header">
<p>
Next: <a href="#Index" accesskey="n" rel="next">Index</a>, Previous: <a href="#TeX_002dlike-symbols" accesskey="p" rel="prev">TeX-like symbols</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="GNU-Free-Documentation-License"></a>
<h2 class="appendix">Appendix E GNU Free Documentation License</h2>
<div align="center">Version 1.2, November 2002
</div>

<div class="display">
<pre class="display">Copyright &copy; 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol start="0">
<li> PREAMBLE

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <em>free</em> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</p>
</li><li> APPLICABILITY AND DEFINITIONS

<p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&rsquo;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.
</p>
<p>Examples of suitable formats for Transparent copies include plain
<small>ASCII</small> without markup, Texinfo input format, LaTeX input
format, <acronym>SGML</acronym> or <acronym>XML</acronym> using a publicly available
<acronym>DTD</acronym>, and standard-conforming simple <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> designed for human modification.  Examples
of transparent image formats include <acronym>PNG</acronym>, <acronym>XCF</acronym> and
<acronym>JPG</acronym>.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, <acronym>SGML</acronym> or
<acronym>XML</acronym> for which the <acronym>DTD</acronym> and/or processing tools are
not generally available, and the machine-generated <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> produced by some word processors for
output purposes only.
</p>
<p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work&rsquo;s title,
preceding the beginning of the body of the text.
</p>
<p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
</li><li> VERBATIM COPYING

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</p>
</li><li> COPYING IN QUANTITY

<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&rsquo;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
</li><li> MODIFICATIONS

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</p>
<ol type="A" start="1">
<li> Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

</li><li> List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

</li><li> State on the Title page the name of the publisher of the
Modified Version, as the publisher.

</li><li> Preserve all the copyright notices of the Document.

</li><li> Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

</li><li> Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

</li><li> Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&rsquo;s license notice.

</li><li> Include an unaltered copy of this License.

</li><li> Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

</li><li> Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

</li><li> For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

</li><li> Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

</li><li> Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

</li><li> Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

</li><li> Preserve any Warranty Disclaimers.
</li></ol>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&rsquo;s license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
</li><li> COMBINING DOCUMENTS

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;
</p>
</li><li> COLLECTIONS OF DOCUMENTS

<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
</li><li> AGGREGATION WITH INDEPENDENT WORKS

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&rsquo;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&rsquo;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
</li><li> TRANSLATION

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
</li><li> TERMINATION

<p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
</p>
</li><li> FUTURE REVISIONS OF THIS LICENSE

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.
</p>
<p>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</p></li></ol>

<a name="ADDENDUM_003a-How-to-use-this-License-for-your-documents"></a>
<h3 class="heading">ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</p>
<div class="smallexample">
<pre class="smallexample">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with&hellip;Texts.&rdquo; line with this:
</p>
<div class="smallexample">
<pre class="smallexample">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</p>
<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</p>


<hr>
<a name="Index"></a>
<div class="header">
<p>
Previous: <a href="#Copying-This-Manual" accesskey="p" rel="prev">Copying This Manual</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Indeks"></a>
<h2 class="unnumbered">Индекс</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Н"><b>Н</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-О"><b>О</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-С"><b>С</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Т"><b>Т</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Ц"><b>Ц</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-AddLegend">AddLegend</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legend">Legend</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AddLight">AddLight</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lighting">Lighting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AddTick">AddTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Adjust">Adjust</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alpha">alpha</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Alpha">Alpha</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Transparency">Transparency</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alphadef">alphadef</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AlphaDef">AlphaDef</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Transparency">Transparency</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ambient">Ambient</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lighting">Lighting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Area">Area</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ArrowSize">ArrowSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ask">ask</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Aspect">Aspect</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AutoCorrel">AutoCorrel</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Axial">Axial</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Axis">Axis</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curved-coordinates">Curved coordinates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Axis-1">Axis</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Axis-and-Colorbar">Axis and Colorbar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AxisStl">AxisStl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ball">Ball</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Barh">Barh</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bars">Bars</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BarWidth">BarWidth</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Beam">Beam</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Belt">Belt</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Box">Box</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Axis-and-Colorbar">Axis and Colorbar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BoxPlot">BoxPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Boxs">Boxs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-call">call</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Candle">Candle</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Chart">Chart</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chdir">chdir</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Clean">Clean</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ClearLegend">ClearLegend</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legend">Legend</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Clf">Clf</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Background">Background</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CloseGIF">CloseGIF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cloud">Cloud</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Colorbar">Colorbar</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Axis-and-Colorbar">Axis and Colorbar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Column">Column</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ColumnPlot">ColumnPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Combine">Combine</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parallelization">Parallelization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Combine-1">Combine</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cone">Cone</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cones">Cones</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cont">Cont</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cont3">Cont3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ContD">ContD</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ContF">ContF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ContF3">ContF3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ContFXYZ">ContFXYZ</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ContXYZ">ContXYZ</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CopyFont">CopyFont</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Correl">Correl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CosFFT">CosFFT</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CRange">CRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Create">Create</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Crop">Crop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Crust">Crust</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTick">CTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CumSum">CumSum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Curve">Curve</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cut">cut</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cut">Cut</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cutting">Cutting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CutOff">CutOff</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cutting">Cutting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-DataGrid">DataGrid</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-manipulation">Data manipulation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defchr">defchr</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define">define</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defnum">defnum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Delete">Delete</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dens">Dens</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dens3">Dens3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DensXYZ">DensXYZ</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dew">Dew</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Diff">Diff</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Diff2">Diff2</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do">do</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dots">Dots</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Drop">Drop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-else">else</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elseif">elseif</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EndFrame">EndFrame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endif">endif</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Envelop">Envelop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Error">Error</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Error-1">Error</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Evaluate">Evaluate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Export">Export</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Extend">Extend</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Face">Face</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FaceX">FaceX</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FaceY">FaceY</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FaceZ">FaceZ</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fall">Fall</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fgets">fgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-printing">Text printing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fill">Fill</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-manipulation">Data manipulation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fill-1">Fill</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Find">Find</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FindAny">FindAny</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fit">Fit</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fit2">Fit2</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fit3">Fit3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FitS">FitS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Flow">Flow</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FlowP">FlowP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fl_005fMathGL">Fl_MathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fl_005fMathGL-1">Fl_MathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fl_005fMathGL-class">Fl_MathGL class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fog">Fog</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fog">Fog</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Font">Font</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fontsize">fontsize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for">for</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FPlot">FPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FSurf">FSurf</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-func">func</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-GetNumFrame">GetNumFrame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GetNx">GetNx</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GetNy">GetNy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GetNz">GetNz</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GetWarn">GetWarn</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Error-handling">Error handling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Glyph">Glyph</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Grad">Grad</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Grid">Grid</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Axis-and-Colorbar">Axis and Colorbar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Grid-1">Grid</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Grid3">Grid3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hankel">Hankel</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hist">Hist</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-manipulation">Data manipulation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hist-1">Hist</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-if">if</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Import">Import</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-InPlot">InPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Insert">Insert</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Integral">Integral</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-J">J</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Join">Join</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Label">Label</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Axis-and-Colorbar">Axis and Colorbar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Label-1">Label</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Last">Last</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-legend">legend</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Legend">Legend</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legend">Legend</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Light">Light</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lighting">Lighting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Line">Line</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linear">Linear</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linear1">Linear1</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linear1-1">Linear1</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-List">List</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load">load</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LoadBackground">LoadBackground</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Background">Background</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LoadFont">LoadFont</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Map">Map</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mark">Mark</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mark-1">Mark</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MarkSize">MarkSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Max">Max</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Maximal">Maximal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mesh">Mesh</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-meshnum">meshnum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MeshNum">MeshNum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Message">Message</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Error-handling">Error handling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglColor">mglColor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglColor-class">mglColor class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglData">mglData</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-constructor">Data constructor</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglDraw">mglDraw</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglDraw-class">mglDraw class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglFitPnts">mglFitPnts</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglGLUT">mglGLUT</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglGraph">mglGraph</a>:</td><td>&nbsp;</td><td valign="top"><a href="#MathGL-core">MathGL core</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglParse">mglParse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglParse-class">mglParse class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglPoint">mglPoint</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglPoint-class">mglPoint class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglWnd">mglWnd</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mglWnd-1">mglWnd</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglWnd-class">mglWnd class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Min">Min</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Minimal">Minimal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mirror">Mirror</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Modify">Modify</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Momentum">Momentum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Momentum-1">Momentum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPI_005fRecv">MPI_Recv</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parallelization">Parallelization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPI_005fSend">MPI_Send</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parallelization">Parallelization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MultiPlot">MultiPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-NeedStop">NeedStop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stop-drawing">Stop drawing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NewFrame">NewFrame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next">next</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Norm">Norm</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NormSl">NormSl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-once">once</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Origin">Origin</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Palette">Palette</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Palette-and-colors">Palette and colors</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Perspective">Perspective</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pipe">Pipe</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Plot">Plot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pop">Pop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PrintInfo">PrintInfo</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-information">Data information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Push">Push</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Puts">Puts</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-printing">Text printing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PutsFit">PutsFit</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-fitting">Nonlinear fitting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Putsw">Putsw</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-printing">Text printing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-QMathGL">QMathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QMathGL-1">QMathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#QMathGL-class">QMathGL class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QuadPlot">QuadPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Radar">Radar</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ranges">Ranges</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rasterize">Rasterize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Background">Background</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Read">Read</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ReadAll">ReadAll</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ReadHDF">ReadHDF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ReadMat">ReadMat</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ReadRange">ReadRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rearrange">Rearrange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Refill">Refill</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Region">Region</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ResetFrames">ResetFrames</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Resize">Resize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RestoreFont">RestoreFont</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return">return</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rkstep">rkstep</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Roll">Roll</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Roots">Roots</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rotate">Rotate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RotateN">RotateN</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RotateText">RotateText</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Save">Save</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SaveHDF">SaveHDF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#File-I_002fO">File I/O</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Set">Set</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetAlphaDef">SetAlphaDef</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Transparency">Transparency</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetAmbient">SetAmbient</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lighting">Lighting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetArrowSize">SetArrowSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetAxisStl">SetAxisStl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetBarWidth">SetBarWidth</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetCoor">SetCoor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curved-coordinates">Curved coordinates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetCut">SetCut</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cutting">Cutting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetCutBox">SetCutBox</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cutting">Cutting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetEventFunc">SetEventFunc</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stop-drawing">Stop drawing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFontDef">SetFontDef</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFontSize">SetFontSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFontSizeCM">SetFontSizeCM</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFontSizeIN">SetFontSizeIN</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFontSizePT">SetFontSizePT</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetFunc">SetFunc</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curved-coordinates">Curved coordinates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetLegendBox">SetLegendBox</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legend">Legend</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetLegendMarks">SetLegendMarks</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Legend">Legend</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetMarkSize">SetMarkSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetMask">SetMask</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Masks">Masks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetMaskAngle">SetMaskAngle</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Masks">Masks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetMeshNum">SetMeshNum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetOrigin">SetOrigin</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetOriginTick">SetOriginTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetPalette">SetPalette</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Palette-and-colors">Palette and colors</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetPlotId">SetPlotId</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Default-sizes">Default sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetRange">SetRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetRanges">SetRanges</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetRotatedText">SetRotatedText</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-settings">Font settings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetSize">SetSize</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-picture">Export picture</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTickLen">SetTickLen</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTickRotate">SetTickRotate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTicks">SetTicks</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTickSkip">SetTickSkip</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTicksVal">SetTicksVal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTickTempl">SetTickTempl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTickTime">SetTickTime</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTranspType">SetTranspType</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Transparency">Transparency</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetTuneTicks">SetTuneTicks</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SetWarn">SetWarn</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Error-handling">Error handling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sew">Sew</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ShowImage">ShowImage</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SinFFT">SinFFT</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Smooth">Smooth</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sort">Sort</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sphere">Sphere</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Primitives">Primitives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spline">Spline</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spline1">Spline1</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spline1-1">Spline1</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interpolation">Interpolation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Squeeze">Squeeze</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-StartGIF">StartGIF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Frames_002fAnimation">Frames/Animation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stem">Stem</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Step">Step</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-STFA">STFA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-StickPlot">StickPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stop">Stop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stop-drawing">Stop drawing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stop">stop</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SubData">SubData</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SubPlot">SubPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sum">Sum</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Surf">Surf</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Surf3">Surf3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t3D-plotting">3D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Surf3A">Surf3A</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Surf3C">Surf3C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SurfA">SurfA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SurfC">SurfC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Swap">Swap</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-changing">Data changing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tape">Tape</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tens">Tens</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ternary">Ternary</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Curved-coordinates">Curved coordinates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Text">Text</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-printing">Text printing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TextMark">TextMark</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TickLen">TickLen</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tile">Tile</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t2D-plotting">2D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TileS">TileS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dual-plotting">Dual plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Title">Title</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Torus">Torus</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trace">Trace</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Make-another-data">Make another data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Traj">Traj</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Transpose">Transpose</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-resizing">Data resizing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TranspType">TranspType</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Transparency">Transparency</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TriCont">TriCont</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TriPlot">TriPlot</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-plotting">Other plotting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tube">Tube</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t1D-plotting">1D plotting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-value">value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Var">Var</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-filling">Data filling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variant">variant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Vect">Vect</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Vector-fields">Vector fields</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-View">View</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Subplots-and-rotation">Subplots and rotation</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-while">while</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Program-flow-commands">Program flow commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-widgets">widgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-MathGL-window">Using MathGL window</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-widgets-1">widgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-widgets-2">widgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fl_005fMathGL-class">Fl_MathGL class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-widgets-3">widgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#QMathGL-class">QMathGL class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-widgets-4">widgets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#wxMathGL-class">wxMathGL class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-window">window</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-MathGL-window">Using MathGL window</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-window-1">window</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Widget-classes">Widget classes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-window-2">window</a>:</td><td>&nbsp;</td><td valign="top"><a href="#mglWnd-class">mglWnd class</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Write">Write</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteBMP">WriteBMP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteBPS">WriteBPS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteEPS">WriteEPS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteFrame">WriteFrame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteGIF">WriteGIF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteJPEG">WriteJPEG</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteOBJ">WriteOBJ</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WritePNG">WritePNG</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WritePRC">WritePRC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteSVG">WriteSVG</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteTEX">WriteTEX</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteTGA">WriteTGA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-WriteWGL">WriteWGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Export-to-file">Export to file</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wxMathGL">wxMathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#wxMathGL-class">wxMathGL class</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-X">X</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-xrange">xrange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-XRange">XRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-XTick">XTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Y">Y</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-yrange">yrange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-YRange">YRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-YTick">YTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Z">Z</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-zrange">zrange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Command-options">Command options</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ZRange">ZRange</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ranges-_0028bounding-box_0029">Ranges (bounding box)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ZTick">ZTick</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ticks">Ticks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Н">Н</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Nastroika-MathGL">Настройка MathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Graphics-setup">Graphics setup</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-О">О</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Obzor-MathGL">Обзор MathGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overview">Overview</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-С">С</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stilx-linii">Стиль линий</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Line-styles">Line styles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stilx-markerov">Стиль маркеров</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Line-styles">Line styles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stilx-strelok">Стиль стрелок</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Line-styles">Line styles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stilx-teksta">Стиль текста</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Font-styles">Font styles</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Т">Т</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tekstovye-formuly">Текстовые формулы</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Textual-formulas">Textual formulas</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index_cp_letter-Ц">Ц</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cvetovaya-skhema">Цветовая схема</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Color-scheme">Color scheme</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Н"><b>Н</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-О"><b>О</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-С"><b>С</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Т"><b>Т</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Ц"><b>Ц</b></a>
 &nbsp; 
</td></tr></table>

<hr>



</div><script type="text/javascript" src="accordion.js"></script></body>
</html>
